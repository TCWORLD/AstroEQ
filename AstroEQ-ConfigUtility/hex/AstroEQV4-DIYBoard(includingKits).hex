/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ.cpp"
/*
  Code written by Thomas Carpenter 2012-2017
  
  With thanks Chris over at the EQMOD Yahoo group for assisting decoding the Skywatcher protocol
  
  
  Equatorial mount tracking system for integration with EQMOD using the Skywatcher/Synta
  communication protocol.
 
  Works with EQ5, HEQ5, and EQ6 mounts, and also a great many custom mount configurations.
 
  Current Verison: 8.0.2
*/

//Only works with ATmega162, and Arduino Mega boards (1280 and 2560)
#if defined(__AVR_ATmega162__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)


/*
 * Include headers
 */
 
#include "AstroEQ.h" //AstroEQ header

#include "EEPROMReader.h" //Read config file
#include "SerialLink.h" //Serial Port
#include "UnionHelpers.h" //Union prototypes
#include "synta.h" //Synta Communications Protocol.
#include <util/delay.h>    
#include <util/delay_basic.h>
#include <avr/wdt.h>

// Watchdog disable on boot.
void wdt_init(void) __attribute__((naked)) __attribute__((section(".init3")));
void wdt_init(void)
{
    wdt_disable();
    return;
}

/*
 * Defines
 */
//Define the version number
#define ASTROEQ_VER 802

/*
 * Global Variables
 */
byte stepIncrement[2];
byte readyToGo[2] = {0,0};
unsigned long gotoPosn[2] = {0UL,0UL}; //where to slew to
bool encodeDirection[2];
byte progMode = RUNMODE; //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
byte microstepConf;
byte driverVersion;
bool standaloneMode = false; //Initially not in standalone mode (EQMOD mode)
bool syntaMode = true; //And synta processing is enabled.

#define timerCountRate 8000000

#define DecimalDistnWidth 32
unsigned int timerOVF[2][DecimalDistnWidth];
bool canJumpToHighspeed = false;
bool defaultSpeedState = SPEEDNORM;
bool disableGearChange = false;
bool allowAdvancedHCDetection = false;
unsigned int gotoDecelerationLength[2];
byte accelTableRepeatsLeft[2] = {0,0};
byte accelTableIndex[2] = {0,0};

/*
 * Helper Macros
 */
#define distributionSegment(m)      (m ? GPIOR1     : GPIOR2    )
#define currentMotorSpeed(m)        (m ? OCR3A      : OCR3B     )
#define irqToNextStep(m)            (m ? OCR1A      : OCR1B     )
#define interruptOVFCount(m)        (m ? ICR3       : ICR1      )
#define interruptControlRegister(m) (m ? TIMSK3     : TIMSK1    )
#define interruptControlBitMask(m)  (m ? _BV(ICIE3) : _BV(ICIE1))
#define timerCountRegister(m)       (m ? TCNT3      : TCNT1     )
#define timerPrescalarRegister(m)   (m ? TCCR3B     : TCCR1B    )
#define gotoDeceleratingBitMask(m)  (m ? _BV(3)     : _BV(2)    )
#define gotoRunningBitMask(m)       (m ? _BV(1)     : _BV(0)    )
#define gotoControlRegister GPIOR0




/*
 * Inline functions
 */
inline bool gotoRunning(const byte axis) {
    return (gotoControlRegister & gotoRunningBitMask(axis));
}
inline bool gotoDecelerating(const byte axis) {
    return (gotoControlRegister & gotoDeceleratingBitMask(axis));
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
}
inline void clearGotoDecelerating(const byte axis) {
    gotoControlRegister &= ~gotoDeceleratingBitMask(axis);
}



/*
 * Generate Mode Mappings
 */

#define MODE0 0
#define MODE1 1
#define MODE2 2
#define MODE0DIR 3
#define MODE1DIR 4
#define MODE2DIR 5
byte modeState[2] = {((LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0)), (( LOW << MODE2) | ( LOW << MODE1) | (LOW << MODE0))}; //Default to 1/8th stepping as that is the same for all

void buildModeMapping(byte microsteps, byte driverVersion){
    //For microstep modes less than 8, we cannot jump to high speed, so we use the SPEEDFAST mode maps. Given that the SPEEDFAST maps are generated for the microstepping modes >=8
    //anyway, we can simply multiply the number of microsteps by 8 if it is less than 8 and thus reduce the number of cases in the mode generation switch statement below 
    if (microsteps < 8){
        microsteps *= 8;
    }
    //Generate the mode mapping for the current driver version and microstepping modes.
    switch (microsteps) {
        case 8:
            // 1/8
            modeState[SPEEDNORM] =                                                                                       (( LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/1
            modeState[SPEEDFAST] =                                                                                       (( LOW << MODE2) | ( LOW << MODE1) | ( LOW << MODE0));
            break;
        case 32:
            // 1/32
            modeState[SPEEDNORM] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | (HIGH << MODE1) | ( LOW << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/4
            modeState[SPEEDFAST] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | (HIGH << MODE1) | ( LOW << MODE0));
            break;
        case 16:
        default:  //Unknown. Default to half/sixteenth stepping
            // 1/16
            modeState[SPEEDNORM] = (driverVersion == DRV882x) ? ((  LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/2
            modeState[SPEEDFAST] = (driverVersion == DRV882x) ? (( HIGH << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0));
            break;
    }
}




/*
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
}

void calculateRate(byte axis){
  
    unsigned long rate;
    unsigned long remainder;
    float floatRemainder;
    unsigned long divisor = cmd.bVal[axis];
    byte distWidth = DecimalDistnWidth;
    
    //When dividing a very large number by a much smaller on, float accuracy is abismal. So firstly we use integer math to split the division into quotient and remainder
    rate = timerCountRate / divisor; //Calculate the quotient
    remainder = timerCountRate % divisor; //Calculate the remainder
    
    //Then convert the remainder into a decimal number (division of a small number by a larger one, improving accuracy)
    floatRemainder = (float)remainder/(float)divisor; //Convert the remainder to a decimal.
    
    //Multiply the remainder by distributionWidth to work out an approximate number of extra clocks needed per full step (each step is 'distributionWidth' microsteps)
    floatRemainder *= (float)distWidth; 
    //This many extra cycles are needed:
    remainder = (unsigned long)(floatRemainder+0.5f); 
    
    //Now truncate to an unsigned int with a sensible max value (the int is to avoid register issues with the 16 bit timer)
    if((unsigned int)(rate >> 16)){
        rate = 65535UL;
    } else if (rate < 128UL) {
        rate = 128UL;
    }
#if defined(__AVR_ATmega162__)
    rate--;
#endif
  
    for (byte i = 0; i < distWidth; i++){
#if defined(__AVR_ATmega162__)
        timerOVF[axis][i] = rate; //Subtract 1 as timer is 0 indexed.
#else
        timerOVF[axis][i] = rate; //Hmm, for some reason this one doesn't need 1 subtracting???
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
        distn *= (float)distWidth;
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    }
    
}

void systemInitialiser(){    
    
    encodeDirection[RA] = EEPROM_readByte(RAReverse_Address) ? CMD_REVERSE : CMD_FORWARD;  //reverse the right ascension if 1
    encodeDirection[DC] = EEPROM_readByte(DECReverse_Address) ? CMD_REVERSE : CMD_FORWARD; //reverse the declination if 1
    
    driverVersion = EEPROM_readByte(Driver_Address);
    microstepConf = EEPROM_readByte(Microstep_Address);

    allowAdvancedHCDetection = !EEPROM_readByte(AdvHCEnable_Address);
    
    defaultSpeedState = (microstepConf >= 8) ? SPEEDNORM : SPEEDFAST;
    disableGearChange = !EEPROM_readByte(GearEnable_Address);
    canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
        
    synta_initialise(ASTROEQ_VER,(canJumpToHighspeed ? 8 : 1)); //initialise mount instance, specify version!
    
    buildModeMapping(microstepConf, driverVersion);
    
    if(!checkEEPROM()){
        progMode = PROGMODE; //prevent AstroEQ startup if EEPROM is blank.
    }

    calculateRate(RA); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateDecelerationLength(RA);
    calculateDecelerationLength(DC);
    
    //Status pin to output low
    setPinDir  (statusPin,OUTPUT);
    setPinValue(statusPin,   LOW);

    //Standalone Speed/IRQ pin to input no-pullup
    setPinDir  (standalonePin[  STANDALONE_IRQ], INPUT);
    setPinValue(standalonePin[  STANDALONE_IRQ],  HIGH); //enable pull-up to pull IRQ high.

    //Standalone Pullup/Pulldown pin to output high
    setPinDir  (standalonePin[ STANDALONE_PULL],OUTPUT);
    setPinValue(standalonePin[ STANDALONE_PULL],  HIGH);
    
    //ST4 pins to input with pullup
    setPinDir  (st4Pins[RA][ST4P],INPUT);
    setPinValue(st4Pins[RA][ST4P],HIGH );
    setPinDir  (st4Pins[RA][ST4N],INPUT);
    setPinValue(st4Pins[RA][ST4N],HIGH );
    setPinDir  (st4Pins[DC][ST4P],INPUT);
    setPinValue(st4Pins[DC][ST4P],HIGH );
    setPinDir  (st4Pins[DC][ST4N],INPUT);
    setPinValue(st4Pins[DC][ST4N],HIGH );
    
    //Reset pins to output
    setPinDir  (resetPin[RA],OUTPUT);
    setPinValue(resetPin[RA],   LOW);  //Motor driver in Reset
    setPinDir  (resetPin[DC],OUTPUT);
    setPinValue(resetPin[DC],   LOW);  //Motor driver in Reset 
    
    //Enable pins to output
    setPinDir  (enablePin[RA],OUTPUT);
    setPinValue(enablePin[RA],  HIGH); //Motor Driver Disabled
    setPinDir  (enablePin[DC],OUTPUT);
    setPinValue(enablePin[DC],  HIGH); //Motor Driver Disabled
    
    //Step pins to output
    setPinDir  (stepPin[RA],OUTPUT);
    setPinValue(stepPin[RA],   LOW);
    setPinDir  (stepPin[DC],OUTPUT);
    setPinValue(stepPin[DC],   LOW);
    
    //Direction pins to output
    setPinDir  (dirPin[RA],OUTPUT);
    setPinValue(dirPin[RA],   LOW);
    setPinDir  (dirPin[DC],OUTPUT);
    setPinValue(dirPin[DC],   LOW);
    
    //Load the correct mode
    byte state = modeState[defaultSpeedState]; //Extract the default mode - If the microstep mode is >= then we start in NORMAL mode, otherwise we use FAST mode

    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    setPinDir  (modePins[RA][MODE0],  OUTPUT                      ); 
    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    setPinDir  (modePins[DC][MODE0],  OUTPUT                      );
    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    setPinDir  (modePins[RA][MODE1],  OUTPUT                      );
    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    setPinDir  (modePins[DC][MODE1],  OUTPUT                      );
    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    setPinDir  (modePins[RA][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    setPinDir  (modePins[DC][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.

    //Give some time for the Motor Drivers to reset.
    _delay_ms(1);

    //Then bring them out of reset.
    setPinValue(resetPin[RA],HIGH);
    setPinValue(resetPin[DC],HIGH);
    
#if defined(__AVR_ATmega162__)
    //Disable Timer 0
    //Timer 0 registers are being used as general purpose data storage for high efficency
    //interrupt routines. So timer must be fully disabled. The ATMegaxxx0 has three of these
    //registers, but the ATMega162 doesn't, so I've had to improvise and use other registers
    //instead. See PinMappings.h for the ATMega162 to see which registers have been #defined
    //as GPIORx.
    TIMSK &= ~(_BV(TOIE0) | _BV(OCIE0));
    TCCR0 = 0;
#endif

    //Ensure SPI is disabled
    SPI_disable();
    
    //Initialise the Serial port:
    Serial_initialise(BAUD_RATE); //SyncScan runs at 9600Baud, use a serial port of your choice as defined in SerialLink.h
      
}




/*
 * EEPROM Validation and Programming Routines
 */

bool checkEEPROM(){
    char temp[9] = {0};
    EEPROM_readString(temp,8,AstroEQID_Address);
    if(strncmp(temp,"AstroEQ",8)){
        return false;
    }
    if (driverVersion > DRV8834){
        return false; //invalid value.
    }
    if ((driverVersion == A498x) && microstepConf > 16){
        return false; //invalid value.
    } else if (microstepConf > 32){
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[RA] > 1200) || (cmd.siderealIVal[RA] < MIN_IVAL)) {
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[DC] > 1200) || (cmd.siderealIVal[DC] < MIN_IVAL)) {
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[RA] == 0){
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[DC] == 0){
        return false; //invalid value.
    }
    if((cmd.st4SpeedFactor < 1) || (cmd.st4SpeedFactor > 19)){
        return false; //invalid value
    }
    return true;
}

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
}

void storeEEPROM(){
    EEPROM_writeLong(cmd.aVal[RA],aVal1_Address);
    EEPROM_writeLong(cmd.aVal[DC],aVal2_Address);
    EEPROM_writeLong(cmd.bVal[RA],bVal1_Address);
    EEPROM_writeLong(cmd.bVal[DC],bVal2_Address);
    EEPROM_writeLong(cmd.sVal[RA],sVal1_Address);
    EEPROM_writeLong(cmd.sVal[DC],sVal2_Address);
    EEPROM_writeByte(encodeDirection[RA],RAReverse_Address);
    EEPROM_writeByte(encodeDirection[DC],DECReverse_Address);
    EEPROM_writeByte(driverVersion,Driver_Address);
    EEPROM_writeByte(microstepConf,Microstep_Address);
    EEPROM_writeByte(cmd.normalGotoSpeed[RA],RAGoto_Address);
    EEPROM_writeByte(cmd.normalGotoSpeed[DC],DECGoto_Address);
    EEPROM_writeInt(cmd.siderealIVal[RA],IVal1_Address);
    EEPROM_writeInt(cmd.siderealIVal[DC],IVal2_Address);
    EEPROM_writeByte(!disableGearChange, GearEnable_Address);
    EEPROM_writeByte(!allowAdvancedHCDetection, AdvHCEnable_Address);
    EEPROM_writeInt(cmd.st4DecBacklash, DecBacklash_Address);
    EEPROM_writeByte(cmd.st4SpeedFactor, SpeedFactor_Address);
    EEPROM_writeAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address);
    EEPROM_writeAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address);
}









/*
 * Standalone Helpers
 */

byte standaloneModeTest() {
    //We need to test what sort of controller is attached.
    //The IRQ pin on the ST4 connector is used to determine this. It has the following
    //states:
    //   FLOAT      | No handcontroller
    //   DRIVE LOW  | Basic handcontroller
    //   DRIVE HIGH | Advanced handcontroller
    //We can test for each of these states by virtue of having a controllable pull up/down
    //resistor on that pin.
    //If we pull down and the pin stays high, then pin must be driven high (DRIVE HIGH)
    //If we pull up and the pin stays low, then pin must be driven low (DRIVE LOW)
    //Otherwise if pin follows us then it must be floating.

    //To start we check for an advanced controller
    setPinValue(standalonePin[STANDALONE_PULL],LOW); //Pull low
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(allowAdvancedHCDetection && getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Note: Must be an advanced controller as pin stayed high and we are allowing HC detection. (If HC detection is disallowed its because we have no external pull down available)
        return ADVANCED_HC_MODE;
    }
    //Otherwise we check for a basic controller
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Convert to external pull-up of IRQ
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Must be a basic controller as pin stayed low.
        return BASIC_HC_MODE;
    }


    //If we get this far then it is floating, so we assume EQMOD mode
    return EQMOD_MODE;
}


byte checkBasicHCSpeed() {
    //Here we check what the speed is for the basic hand controller.
    //
    //By using both external and internal pull-ups, the following three speeds are possible:
    // +-----------+-----+-----+
    // |  Pull-Up: | Ext | Int |
    // +-----------+-----+-----+
    // | ST-4 Rate |  0  |  0  |
    // |   2x Rate |  1  |  0  |
    // | GoTo Rate |  1  |  1  |
    // +-----------+-----+-----+
    //
    //Note: if we don't have an external pull-up resistor, this function will return either ST-4 Rate (0,0) or GoTo Rate (1,1)
    //
    byte speed;
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Must be a ST-4 rate as IRQ pin is low when external pull-up enabled
        speed = CMD_ST4_DEFAULT;
    } else {
        //Otherwise check which high-speed mode it is
        setPinDir  (standalonePin[STANDALONE_PULL],INPUT); //Disable external resistor by switching to input
        setPinValue(standalonePin[STANDALONE_PULL],LOW);   //with no internal pull-up (we are using the IRQ pin internal pull-up)
        nop(); // Input synchroniser takes a couple of cycles
        nop();
        nop();
        nop();
        
        if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
            //Must be a 2x rate as IRQ pin goes low when external pull-up disabled
            speed = CMD_ST4_STANDALONE;
        } else {
            speed = CMD_ST4_HIGHSPEED;
        }
    }
    setPinDir  (standalonePin[STANDALONE_PULL],OUTPUT); //Ensure we leave an external pull-up of IRQ.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH);
    //And return the new speed
    return speed;
}



/*
 * AstroEQ firmware main() function
 */

int main(void) {
    //Enable global interrupt flag
    sei();
    //Initialise global variables from the EEPROM
    systemInitialiser();
    
    bool mcuReset = false; //Not resetting the MCU after programming command
    
    bool isST4Move[2] = {false, false};
    
    unsigned int loopCount = 0;
    char recievedChar = 0; //last character we received
    int8_t decoded = 0; //Whether we have decoded the packet
    char decodedPacket[11]; //temporary store for completed command ready to be processed
    
    for(;;){ //Run loop

        loopCount++; //Counter used to time events based on number of loops.

        if (!standaloneMode && (loopCount == 0)) { 
            //If we are not in standalone mode, periodically check if we have just entered it
            byte mode = standaloneModeTest();
            if (mode != EQMOD_MODE) {
                //If we have just entered stand-alone mode, then we enable the motors and configure the mount
                motorStop(RA, true); //Ensure both motors are stopped
                motorStop(DC, true);
                
                //This next bit needs to be atomic
                byte oldSREG = SREG; 
                cli();  
                cmd_setjVal(RA, 0x800000); //set the current position to the middle
                cmd_setjVal(DC, 0x800000); //set the current position to the middle
                SREG = oldSREG;
                //End atomic
                //Disable Serial
                Serial_disable();
    
                //We are now in standalone mode.
                standaloneMode = true; 
                
                //Next check what type of hand controller we have
                if (mode == ADVANCED_HC_MODE) {
                    //We pulled low, but pin stayed high
                    //This means we must have an advanced controller actively pulling the line high
                    syntaMode = true; 
                    
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
                    Serial_writeStr(welcome); //Send error packet to trigger controller state machine.
                    
                } else {
                    //Pin either is being pulled low by us or by something else
                    //This means we might have a basic controller actively pulling the line low
                    //Even if we don't we would default to basic mode.
                    syntaMode = false;
                    
                    //High speed not supported in Basic HC
                    canJumpToHighspeed = false;
                    
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
                    
                    Commands_configureST4Speed(CMD_ST4_DEFAULT); //Change the ST4 speeds to default
                    
                    motorEnable(RA); //Ensure the motors are enabled
                    motorEnable(DC);
                    
                    cmd_setGVal      (RA, 1); //Set both axes to slew mode.
                    cmd_setGVal      (DC, 1);
                    cmd_setDir       (RA, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA ,1);
                    cmd_setDir       (DC, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA,1);
                    cmd_setIVal      (RA, cmd.siderealIVal[RA]); //Set RA speed to sidereal
                    
                    readyToGo[RA] = 1; //Signal we are ready to go on the RA axis to start sideral tracking
                }
            }
            //If we end up in standalone mode, we don't exit until a reset.
        }

        /////////////
        if (syntaMode) {
        //
        // EQMOD or Advanced Hand Controller Synta Mode
        //
            //Check if we need to run the command parser
            
            if ((decoded == -2) || Serial_available()) { //is there a byte in buffer or we still need to process the previous byte?
                //Toggle on the LED to indicate activity.
                togglePin(statusPin);
                //See what character we need to parse
                if (decoded != -2) {
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
                //Once full command packet recieved, synta_recieveCommand populates either an error packet (and returns -1), or data packet (returns 1). If incomplete, decodedPacket is unchanged and 0 is returned
                if (decoded != 0){ //Send a response
                    if (decoded > 0){ //Valid Packet, current command is in decoded variable.
                        mcuReset = !decodeCommand(decoded,decodedPacket); //decode the valid packet and populate response.
                    }
                    Serial_writeStr(decodedPacket); //send the response packet (recieveCommand() generated the error packet, or decodeCommand() a valid response)
                } //otherwise command not yet fully recieved, so wait for next byte
                
                if (mcuReset) {
                    //Special case. We were asked to reset the MCU.
                    Serial_flush(); //Flush out last response.
                    wdt_enable(WDTO_120MS); //WDT has been set to reset MCU.
                    exit(0); //Done
                }
            }
            if (loopCount == 0) {
                setPinValue(statusPin, 0);
            }
            
            //
            //ST4 button handling
            //
            if (!standaloneMode && ((loopCount & 0xFF) == 0)){
                //We only check the ST-4 buttons in EQMOD mode when not doing Go-To, and only every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //In Synta mode, we only allow the ST-4 port to move forward, and only if EQMOD has configured us previously to be in tracking mode
                    if ((cmd.dir[RA] == CMD_FORWARD) && (readyToGo[RA] == 2)) {
                        //Determine which ST4 pin if any
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                        //Update target speed.
                        if (st4Pin != ST4O) {
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
                            isST4Move[RA] = true; //Now doing ST4 movement
                        }
                        else if (isST4Move[RA]) { 
                            //Only return to sidereal speed if we are in an ST4 move.
                            cmd_setIVal(RA,cmd.siderealIVal[RA]);
                            motorStartRA();
                            isST4Move[RA] = false; //No longer ST4 movement
                        }
                    }
                }//End RA
                
                if (!cmd.gotoEn[DC]) {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir)) {
                        //If we are currently moving in the wrong direction
                        motorStopDC(false); //Stop the Dec motor
                        readyToGo[DC]=0;    //No longer ready to go as we have now deleted any pre-running EQMOD movement.
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
                            isST4Move[DC] = true; //Now doing ST4 movement
                        } else if (isST4Move[DC]) {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
                            isST4Move[DC] = false; //No longer ST4 movement
                        }
                    }
                }//End DEC
            }
            
            //Check both axes - loop unravelled for speed efficiency - lots of Flash available.
            if(readyToGo[RA]==1){
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[RA] == CMD_STOPPED){
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[RA];
                    if (canJumpToHighspeed){
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
                            cmd_updateStepDir(RA,1);
                            cmd.highSpeedMode[RA] = false;
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
                            cmd_updateStepDir(RA,cmd.gVal[RA]);
                            cmd.highSpeedMode[RA] = true;
                        }
                        setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0)));
                        setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1)));
                        setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2)));
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(RA,1); //Just move along at one step per step
                        cmd.highSpeedMode[RA] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(RA); //Slew type
                        readyToGo[RA] = 2;
                    } else {
                        //This is the function for goto mode. You may need to customise it for a different motor driver
                        gotoMode(RA); //Goto Mode
                        readyToGo[RA] = 0;
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
            if(readyToGo[DC]==1){
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[DC] == CMD_STOPPED){
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[DC];
                    if (canJumpToHighspeed){
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
                            cmd_updateStepDir(DC,1);
                            cmd.highSpeedMode[DC] = false;
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
                            cmd_updateStepDir(DC,cmd.gVal[DC]);
                            cmd.highSpeedMode[DC] = true;
                        }
                        setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0)));
                        setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1)));
                        setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2)));
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(DC,1); //Just move along at one step per step
                        cmd.highSpeedMode[DC] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(DC); //Slew type
                        readyToGo[DC] = 2; //We are now in a running mode which speed can be changed without stopping motor (unless a command changes the direction)
                    } else {
                        //This is the function for goto mode.
                        gotoMode(DC); //Goto Mode
                        readyToGo[DC] = 0; //We are now in a mode where no further changes can be made to the motor (apart from requesting a stop) until the go-to movement is done.
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
        //////////
        } else {
        //
        // ST4 Basic Hand Controller Mode
        //
            if (loopCount == 0) {
                //we run these checks every so often, not all the time.
                
                //Update status LED
                togglePin(statusPin); //Toggle status pin at roughly constant rate in basic mode as indicator
                
                //Check the speed
                byte newBasicHCSpeed = checkBasicHCSpeed();
                if (newBasicHCSpeed != cmd.st4Mode) {
                    //Only update speed if changed.
                    Commands_configureST4Speed(newBasicHCSpeed); //Change the ST4 speeds
                }
            }
            
            //
            //NESW button handling - uses ST4 pins
            //
            if ((loopCount & 0xFF) == 0){
                //We only check the buttons every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
                    if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] != dir) && (currentMotorSpeed(RA) < cmd.minSpeed[RA])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
                        cmd_setDir(RA,dir);
                        cmd_updateStepDir(RA,1);
                        if ((st4Pin == ST4O) && (cmd.st4Mode == CMD_ST4_HIGHSPEED)) {
                            motorStopRA(false); //If no buttons pressed and in high speed mode, we stop entirely rather than going to tracking
                                                //This ensures that the motors stop if the handcontroller is subsequently unplugged.
                        } else {
                            motorStartRA(); //If the motor is currently stopped at this point, this will automatically start them.
                        }
                    }
                    SREG = oldSREG; //End atomic
                }//End RA
                
                {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopDC(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
                        } else {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
                        }
                    }
                    SREG = oldSREG; //End atomic
                }//End DEC
            }
        ///////////
        }
        
        
    }//End of run loop
}

/*
#ifdef ALTERNATE_ST4
ISR(PCINT2_vect)
#else
ISR(PCINT0_vect)
#endif
{
    //ST4 Pin Change Interrupt Handler.
    if(!cmd.gotoEn[RA] && !cmd.gotoEn[DC]){
        //Only allow when not it goto mode.
        {//Start RA
            //Determine which if any ST4 Pin
            char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
            if (syntaMode) {
                //In Synta mode, we only allow the ST-4 port to move forward, and not to automatically start moving
                if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] == CMD_FORWARD)) {
                    //If we are not stopped and we are moving in the correct direction, update speed.
                    cmd.currentIVal[RA] = (st4Pin != ST4O) ? cmd.st4RAIVal[st4Pin] :  cmd.siderealIVal[RA];
                    //Ensure that if the new speed is slower than the stopping speed that we don't stop
                    cmd.stopSpeed[RA] = (cmd.currentIVal[RA] < cmd.minSpeed[RA]) ? cmd.minSpeed[RA] : cmd.currentIVal[RA];
                }
            } 
        }//End RA

        {//Start DEC
            //Determine which if any ST4 Pin
            char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
            //Determine the new direction
            byte dir = CMD_FORWARD;
            char stepDir = 1;
            if (st4Pin == ST4N) {
                //If requested reverse, switch direction
                dir = CMD_REVERSE;
                stepDir = -1;
            }
            if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//make our target >stopSpeed so that ISRs bring us to a halt.
            } else {
                //Otherwise we are now free to change to the new required speed.
                //Set to correct direction
                cmd.stepDir[DC] = stepDir; //set step direction
                cmd.dir[DC] = dir; //set direction
                //Then update speed
                if (st4Pin != ST4O) {
                    //If an ST4 Dec pin is pressed
                    if (cmd.stopped[DC] != CMD_STOPPED) {
                        //If running, update to new required speed directly
                        cmd.currentIVal[DC] = cmd.st4DecIVal;
                        //Ensure that if the new speed is slower than the stopping speed that we don't stop
                        cmd.stopSpeed[DC] = (cmd.currentIVal[DC] < cmd.minSpeed[DC]) ? cmd.minSpeed[DC] : cmd.currentIVal[DC];
                    } else  {
                        //Otherwise we are stopped when we should be moving.
                        //First lets update global IVal
                        cmd.IVal[DC] = cmd.st4DecIVal;
                        //Then trigger main() loop to start us moving
                        readyToGo[DC]=1;
                    }
                } else {
                    //Otherwise stop
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;
                }
                //If the motor is currently stopped at this point when it should be moving, the main() function will automatically start it at the IVal.
            }
        }//End DEC
    }
}
*/

/*
 * Decode and Perform the Command
 */

bool decodeCommand(char command, char* buffer){ //each command is axis specific. The axis being modified can be retrieved by calling synta_axis()
    unsigned long responseData = 0; //data for response
    bool success = true;
    byte axis = synta_axis();
    unsigned int correction;
    byte oldSREG;
    switch(command) {
        case 'e': //readonly, return the eVal (version number)
            responseData = cmd.eVal[axis]; //response to the e command is stored in the eVal function for that axis.
            break;
        case 'a': //readonly, return the aVal (steps per axis)
            responseData = cmd.aVal[axis]; //response to the a command is stored in the aVal function for that axis.
            break;
        case 'b': //readonly, return the bVal (sidereal step rate)
            responseData = cmd.bVal[axis]; //response to the b command is stored in the bVal function for that axis.
            if (!progMode) {
                //If not in programming mode, we need to apply a correction factor to ensure that calculations in EQMOD round correctly
                correction = (cmd.siderealIVal[axis] << 1);
                responseData = (responseData * (correction+1))/correction; //account for rounding inside Skywatcher DLL.
            }
            break;
        case 'g': //readonly, return the gVal (high speed multiplier)
            responseData = cmd.gVal[axis]; //response to the g command is stored in the gVal function for that axis.
            break;
        case 's': //readonly, return the sVal (steps per worm rotation)
            responseData = cmd.sVal[axis]; //response to the s command is stored in the sVal function for that axis.
            break;
        case 'f': //readonly, return the fVal (axis status)
            responseData = cmd_fVal(axis); //response to the f command is stored in the fVal function for that axis.
            break;
        case 'j': //readonly, return the jVal (current position)
            oldSREG = SREG; 
            cli();  //The next bit needs to be atomic, just in case the motors are running
            responseData = cmd.jVal[axis]; //response to the j command is stored in the jVal function for that axis.
            SREG = oldSREG;
            break;
        case 'K': //stop the motor, return empty response
            motorStop(axis,0); //normal ISR based decelleration trigger.
            readyToGo[axis] = 0;
            break;
        case 'L':
            motorStop(axis,1); //emergency axis stop.
            motorDisable(axis); //shutdown driver power.
            break;
        case 'G': //set mode and direction, return empty response
            /*if (packetIn[0] == '0'){
              packetIn[0] = '2'; //don't allow a high torque goto. But do allow a high torque slew.
            }*/
            cmd_setGVal(axis, (buffer[0] - '0')); //Store the current mode for the axis
            cmd_setDir(axis, (buffer[1] != '0') ? CMD_REVERSE : CMD_FORWARD); //Store the current direction for that axis
            readyToGo[axis] = 0;
            break;
        case 'H': //set goto position, return empty response (this sets the number of steps to move from cuurent position if in goto mode)
            cmd_setHVal(axis, synta_hexToLong(buffer)); //set the goto position container (convert string to long first)
            readyToGo[axis] = 0;
            break;
        case 'I': //set slew speed, return empty response (this sets the speed to move at if in slew mode)
            responseData = synta_hexToLong(buffer); //convert string to long first
            if (responseData < cmd.accelTable[axis][AccelTableLength-1].speed) {
                //Limit the IVal to the largest speed in the acceleration table to prevent sudden rapid acceleration at the end.
                responseData = cmd.accelTable[axis][AccelTableLength-1].speed; 
            }
            cmd_setIVal(axis, responseData); //set the speed container
            responseData = 0;
            if (readyToGo[axis] == 2) {
                //If we are in a running mode which allows speed update without motor reconfiguration
                motorStart(axis); //Simply update the speed.
            } else {
                //Otherwise we are no longer ready to go until the next :J command is received
                readyToGo[axis] = 0;
            }
            break;
        case 'E': //set the current position, return empty response
            oldSREG = SREG; 
            cli();  //The next bit needs to be atomic, just in case the motors are running
            cmd_setjVal(axis, synta_hexToLong(buffer)); //set the current position (used to sync to what EQMOD thinks is the current position at startup
            SREG = oldSREG;
            break;
        case 'F': //Enable the motor driver, return empty response
            if (progMode == 0) { //only allow motors to be enabled outside of programming mode.
                motorEnable(axis); //This enables the motors - gives the motor driver board power
            } else {
                command = 0; //force sending of error packet!.
            }
            break;
            
        //Command required for entering programming mode. All other programming commands cannot be used when progMode = 0 (normal ops)
        case 'O': //set the programming mode.
            progMode = buffer[0] - '0';              //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
            if (progMode != 0) {
                motorStop(RA,1); //emergency axis stop.
                motorDisable(RA); //shutdown driver power.
                motorStop(DC,1); //emergency axis stop.
                motorDisable(DC); //shutdown driver power.
                readyToGo[RA] = 0;
                readyToGo[DC] = 0;
            } else { //reset the uC to return to normal ops mode.
                success = false;
            }
            break;

        default:
            //Prevent any chance of accidentally running configuration commands when not in programming mode.
            if (progMode != 0) {
                //The following are used for configuration ----------
                switch(command) {
                    case 'A': //store the aVal (steps per axis)
                        cmd_setaVal(axis, synta_hexToLong(buffer)); //store aVal for that axis.
                        break;
                    case 'B': //store the bVal (sidereal rate)
                        cmd_setbVal(axis, synta_hexToLong(buffer)); //store bVal for that axis.
                        break;
                    case 'S': //store the sVal (steps per worm rotation)
                        cmd_setsVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
                        break;
                    case 'n': //return the IVal (EQMOD Speed at sidereal)
                        responseData = cmd.siderealIVal[axis];
                        break;
                    case 'N': //store the IVal (EQMOD Speed at sidereal)
                        cmd_setsideIVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
                        break;
                    case 'd': //return the driver version or step mode
                        if (axis) {
                            responseData = microstepConf; 
                        } else {
                            responseData = driverVersion;
                        }
                        break;
                    case 'D': //store the driver verison and step modes
                        if (axis) {
                            microstepConf = synta_hexToByte(buffer); //store step mode.
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
                        } else {
                            driverVersion = synta_hexToByte(buffer); //store driver version.
                        }
                        break;
                    case 'r': //return the dec backlash or st4 speed factor
                        if (axis) {
                            responseData = cmd.st4DecBacklash; 
                        } else {
                            responseData = cmd.st4SpeedFactor;
                        }
                        break;
                    case 'R': //store the dec backlash or st4 speed factor
                        if (axis) {
                            unsigned long dataIn = synta_hexToLong(buffer); //store step mode.
                            if (dataIn > 65535) {
                                command = '\0'; //If the step rate is out of range, force an error response packet.
                            } else {
                                cmd_setst4DecBacklash(dataIn); //store st4 speed factor
                            }
                        } else {
                            byte factor = synta_hexToByte(buffer);
                            if ((factor > 19) || (factor < 1)) {
                                command = '\0'; //If the factor is out of range, force an error response packet.
                            } else {
                                cmd_setst4SpeedFactor(factor); //store st4 speed factor
                            }
                        }
                        break;
                    case 'z': //return the Goto speed
                        responseData = cmd.normalGotoSpeed[axis];
                        break;
                    case 'Z': //return the Goto speed factor
                        cmd.normalGotoSpeed[axis] = synta_hexToByte(buffer); //store the goto speed factor
                        break;
                    case 'c': //return the axisDirectionReverse
                        responseData = encodeDirection[axis];
                        break;
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
                            responseData = disableGearChange; 
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
                        } else {
                            responseData = allowAdvancedHCDetection;
                        }
                        break;
                    case 'Q': //store the disableGearChange/allowAdvancedHCDetection setting
                        if (axis) {
                            disableGearChange = synta_hexToByte(buffer); //store whether we can change gear
                        } else {
                            allowAdvancedHCDetection = synta_hexToByte(buffer); //store whether to allow advanced hand controller detection
                        }
                        break;
                    case 'x': {  //return the accelTable
                        Inter responsePack = InterMaker(0);
                        responsePack.lowByter.integer = cmd.accelTable[axis][accelTableIndex[axis]].speed;
                        responsePack.highByter.low = cmd.accelTable[axis][accelTableIndex[axis]].repeats; 
                        responseData = responsePack.integer;
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if reading sequentially.
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            accelTableIndex[axis] = 0; //Wrap around
                        }
                        break;
                    }
                    case 'X': { //store the accelTable value for address set by 'Y', or next address after last 'X'
                        unsigned long dataIn = synta_hexToLong(buffer);
                        cmd.accelTable[axis][accelTableIndex[axis]].speed = (unsigned int)dataIn; //lower two bytes is speed
                        cmd.accelTable[axis][accelTableIndex[axis]].repeats = (byte)(dataIn>>16); //upper byte is repeats.
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if programming sequentially.
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            accelTableIndex[axis] = 0; //Wrap around
                        }
                        break;
                    }
                    case 'Y': //store the accelTableIndex value
                        //Use axis=0 to set which address we are accessing (we'll repurpose accelTableIndex[RA] in prog mode for this)
                        accelTableIndex[axis] = synta_hexToByte(buffer);
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            command = '\0'; //If the address out of range, force an error response packet.
                        }
                        break;
                    case 'T': //set mode, return empty response
                        if (progMode & 2) {
                        //proceed with eeprom write
                            if (progMode & 1) {
                                buildEEPROM();
                            } else {
                                storeEEPROM();
                            }
                        } else if (progMode & 1) {
                            if (!checkEEPROM()) { //check if EEPROM contains valid data.
                                command = 0; //force sending of an error packet.
                            }
                        }
                        break;
                    //---------------------------------------------------
                    default: //Return empty response (deals with commands that don't do anything before the response sent (i.e 'J', 'R'), or do nothing at all (e.g. 'M') )
                        break;
                }
            }
            break;
    }
  
    synta_assembleResponse(buffer, command, responseData); //generate correct response (this is required as is)
    
    if ((command == 'J') && (progMode == 0)) { //J tells us we are ready to begin the requested movement.
        readyToGo[axis] = 1; //So signal we are ready to go and when the last movement complets this one will execute.
        if (!(cmd.GVal[axis] & 1)){
            //If go-to mode requested
            cmd_setGotoEn(axis,CMD_ENABLED);
        }
    }
    return success;
}










void motorEnable(byte axis){
    if (axis == RA){
        setPinValue(enablePin[RA],LOW); //IC enabled
        cmd_setFVal(RA,CMD_ENABLED);
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
        cmd_setFVal(DC,CMD_ENABLED);
    }
    configureTimer(); //setup the motor pulse timers.
}

void motorDisable(byte axis){
    if (axis == RA){
        setPinValue(enablePin[RA],HIGH); //IC enabled
        cmd_setFVal(RA,CMD_DISABLED);
    } else {
        setPinValue(enablePin[DC],HIGH); //IC enabled
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
}

void gotoMode(byte axis){
    unsigned int decelerationLength = gotoDecelerationLength[axis];
    
    if (cmd.highSpeedMode[axis]) {
        //Additionally in order to maintain the same speed profile in high-speed mode, we actually increase the profile repeats by a factor of sqrt(8)
        //compared with running in normal-speed mode. See Atmel AVR466 app note for calculation.
        decelerationLength = decelerationLength * 3; //multiply by 3 as it is approx sqrt(8)
    }
    
    byte dirMagnitude = abs(cmd.stepDir[axis]);
    byte dir = cmd.dir[axis];

    if (cmd.HVal[axis] < 2*dirMagnitude){
        cmd_setHVal(axis,2*dirMagnitude);
    }

    decelerationLength = decelerationLength * dirMagnitude;
    //decelleration length is here a multiple of stepDir.
    unsigned long HVal = cmd.HVal[axis];
    unsigned long halfHVal = (HVal >> 1);
    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    if(dirMagnitude == 8){
        HVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
    }
    if(dirMagnitude == 8){
        halfHVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
    }
    //HVal and halfHVal are here a multiple of stepDir
    if (halfHVal < decelerationLength) {
        decelerationLength = halfHVal;
    }
    HVal -= decelerationLength;
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
    
    cmd_setIVal(axis, gotoSpeed);
    clearGotoDecelerating(axis);
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStart functions (one for RA and one for DEC)
void motorStart(byte motor){
    if (motor == RA) {
        motorStartRA();
    } else {
        motorStartDC();
    }
}

void motorStartRA(){
    unsigned int IVal = cmd.IVal[RA];
    unsigned int currentIVal;
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
    currentIVal = currentMotorSpeed(RA);
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    
    if (IVal > cmd.minSpeed[RA]){
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[RA];
    }
    if(cmd.stopped[RA]) {
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[RA]) {
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
    cmd.currentIVal[RA] = cmd.IVal[RA];
    currentMotorSpeed(RA) = startSpeed;
    cmd.stopSpeed[RA] = stoppingSpeed;
    setPinValue(dirPin[RA],(encodeDirection[RA] != cmd.dir[RA]));
    
    if(cmd.stopped[RA]) { //if stopped, configure timers
        irqToNextStep(RA) = 1;
        accelTableRepeatsLeft[RA] = cmd.accelTable[RA][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
        accelTableIndex[RA] = 0;
        distributionSegment(RA) = 0;
        timerCountRegister(RA) = 0;
        interruptOVFCount(RA) = timerOVF[RA][0];
        timerEnable(RA);
        cmd_setStopped(RA, CMD_RUNNING);
    }
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
}

void motorStartDC(){
    unsigned int IVal = cmd.IVal[DC];
    unsigned int currentIVal;
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
    currentIVal = currentMotorSpeed(DC);
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
    
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    if (IVal > cmd.minSpeed[DC]){
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[DC];
    }
    if(cmd.stopped[DC]) {
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[DC]) {
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
    cmd.currentIVal[DC] = cmd.IVal[DC];
    currentMotorSpeed(DC) = startSpeed;
    cmd.stopSpeed[DC] = stoppingSpeed;
    setPinValue(dirPin[DC],(encodeDirection[DC] != cmd.dir[DC]));
    
    if(cmd.stopped[DC]) { //if stopped, configure timers
        irqToNextStep(DC) = 1;
        accelTableRepeatsLeft[DC] = cmd.accelTable[DC][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
        accelTableIndex[DC] = 0;
        distributionSegment(DC) = 0;
        timerCountRegister(DC) = 0;
        interruptOVFCount(DC) = timerOVF[DC][0];
        timerEnable(DC);
        cmd_setStopped(DC, CMD_RUNNING);
    }
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStop functions (one for RA and one for DEC)
void motorStop(byte motor, byte emergency){
    if (motor == RA) {
        motorStopRA(emergency);
    } else {
        motorStopDC(emergency);
    }
}

void motorStopRA(bool emergency){
    if (emergency) {
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(RA);
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
        clearGotoRunning(RA);
    } else if (!cmd.stopped[RA]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
        //trigger ISR based decelleration
        //readyToGo[RA] = 0;
        byte oldSREG = SREG;
        cli();
        cmd_setGotoEn(RA,CMD_DISABLED); //No longer in goto mode.
        clearGotoRunning(RA);
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        //interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
        if(cmd.currentIVal[RA] < cmd.minSpeed[RA]){
            if(cmd.stopSpeed[RA] > cmd.minSpeed[RA]){
                cmd.stopSpeed[RA] = cmd.minSpeed[RA];
            }
        }/* else {
            stopSpeed[RA] = cmd.currentIVal[RA];
        }*/
        cmd.currentIVal[RA] = cmd.stopSpeed[RA] + 1;//cmd.stepIncrement[motor];
        SREG = oldSREG;
        //interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    }
}

void motorStopDC(bool emergency){
    if (emergency) {
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(DC);
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
        clearGotoRunning(DC);
    } else if (!cmd.stopped[DC]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
        //trigger ISR based decelleration
        //readyToGo[motor] = 0;
        byte oldSREG = SREG;
        cli();
        cmd_setGotoEn(DC,CMD_DISABLED); //No longer in goto mode.
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        clearGotoRunning(DC);
        //interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
        if(cmd.currentIVal[DC] < cmd.minSpeed[DC]){
            if(cmd.stopSpeed[DC] > cmd.minSpeed[DC]){
                cmd.stopSpeed[DC] = cmd.minSpeed[DC];
            }
        }/* else {
        stopSpeed[DC] = cmd.currentIVal[DC];
        }*/
        cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//cmd.stepIncrement[motor];
        SREG = oldSREG;
        //interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
    }
}

//Timer Interrupt-----------------------------------------------------------------------------
void configureTimer(){
    interruptControlRegister(DC) = 0; //disable all timer interrupts.
#if defined(__AVR_ATmega162__)
    interruptControlRegister(RA) &= 0b00000011; //for 162, the lower 2 bits of the declination register control another timer, so leave them alone.
#else
    interruptControlRegister(RA) = 0;
#endif
    //set to ctc mode (0100)
    TCCR1A = 0;//~((1<<WGM11) | (1<<WGM10));
    TCCR1B = ((1<<WGM12) | (1<<WGM13));
    TCCR3A = 0;//~((1<<WGM31) | (1<<WGM30));
    TCCR3B = ((1<<WGM32) | (1<<WGM33));
}



/*Timer Interrupt Vector*/
ISR(TIMER3_CAPT_vect) {
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(DC)-1;
    //Check if we are ready to step
    if (irqToNext == 0) {
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(DC); //Get the current time segement
        
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(DC) = timerOVF[DC][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(DC) = *(int*)((byte*)timerOVF[DC] + index); //Update interrupt base rate.
        
        distributionSegment(DC) = timeSegment + 1; //Increment time segement for next time.

        unsigned int currentSpeed = currentMotorSpeed(DC); //Get the current motor speed
        irqToNextStep(DC) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
        
        if (getPinValue(stepPin[DC])){
            //If the step pin is currently high...
            
            setPinValue(stepPin[DC],LOW); //set step pin low to complete step
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[DC]; 
            jVal = jVal + cmd.stepDir[DC];
            cmd.jVal[DC] = jVal;
            
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(DC); //Mark that we have started decelleration.
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
                    accelTableRepeatsLeft[DC] = 0;
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[DC]) {
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(DC)){ 
                    //if we are currently running a goto... 
                    cmd_setGotoEn(DC,CMD_DISABLED); //Switch back to slew mode 
                    clearGotoRunning(DC); //And mark goto status as complete
                } //otherwise don't as it cancels a 'goto ready' state 
                
                cmd_setStopped(DC,CMD_STOPPED); //mark as stopped 
                timerDisable(DC);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[DC],HIGH); //Set it high to start next step.
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[DC]; //load the number of repeats left for this accel table entry
            if (repeatsReqd == 0) { 
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[DC]; //Get the target speed
                if (currentSpeed > targetSpeed) {
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
                    if (accelIndex >= AccelTableLength-1) {
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
                        accelTableIndex[DC] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed <= targetSpeed) {
                            //If the new value is too fast
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
                    if (accelIndex == 0) {
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
                        accelTableIndex[DC] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed >= targetSpeed) {
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                }
                currentMotorSpeed(DC) = currentSpeed; //Update the current speed in case it has changed.
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[DC] = repeatsReqd - 1;
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(DC) = irqToNext; //Update the number of IRQs remaining until the next step.
    }   


}






/*Timer Interrupt Vector*/
ISR(TIMER1_CAPT_vect) {
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(RA)-1;
    //Check if we are ready to step
    if (irqToNext == 0) {
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(RA); //Get the current time segement
        
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(RA) = timerOVF[RA][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(RA) = *(int*)((byte*)timerOVF[RA] + index); //Update interrupt base rate.
        
        distributionSegment(RA) = timeSegment + 1; //Increment time segement for next time.

        unsigned int currentSpeed = currentMotorSpeed(RA); //Get the current motor speed
        irqToNextStep(RA) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
        
        if (getPinValue(stepPin[RA])){
            //If the step pin is currently high...
            
            setPinValue(stepPin[RA],LOW); //set step pin low to complete step
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[RA]; 
            jVal = jVal + cmd.stepDir[RA];
            cmd.jVal[RA] = jVal;
            
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(RA); //Mark that we have started decelleration.
                    cmd.currentIVal[RA] = cmd.stopSpeed[RA]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
                    accelTableRepeatsLeft[RA] = 0;
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[RA]) {
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(RA)){ 
                    //if we are currently running a goto... 
                    cmd_setGotoEn(RA,CMD_DISABLED); //Switch back to slew mode 
                    clearGotoRunning(RA); //And mark goto status as complete
                } //otherwise don't as it cancels a 'goto ready' state 
                
                cmd_setStopped(RA,CMD_STOPPED); //mark as stopped 
                timerDisable(RA);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[RA],HIGH); //Set it high to start next step.
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[RA]; //load the number of repeats left for this accel table entry
            if (repeatsReqd == 0) { 
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[RA]; //Get the target speed
                if (currentSpeed > targetSpeed) {
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
                    if (accelIndex >= AccelTableLength-1) {
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
                        accelTableIndex[RA] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed <= targetSpeed) {
                            //If the new value is too fast
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
                    if (accelIndex == 0) {
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
                        accelTableIndex[RA] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed >= targetSpeed) {
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                }
                currentMotorSpeed(RA) = currentSpeed; //Update the current speed in case it has changed.
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[RA] = repeatsReqd - 1;
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(RA) = irqToNext; //Update the number of IRQs remaining until the next step.
    }   


}

#else
#error Unsupported Part! Please use an Arduino Mega, or ATMega162
#endif

ELF          S            H     4     ( [ X AstroEQ %RU   :;I  $ >  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  .?:;<   I4   I  .?:;<   I  :;  I  ! I/  5 I  .:;    :;I  .?:;   /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ.h"
/*
  Code written by Thomas Carpenter 2012
  
  With thanks Chris over at the EQMOD Yahoo group for explaining the Skywatcher protocol
  
  
  Equatorial mount tracking system for integration with EQMOD using the Skywatcher/Synta
  communication protocol.
 
  Works with EQ5, HEQ5, and EQ6 mounts, and also a great many custom mount configurations.
 
  Current Verison: 7.5
*/

//Only works with ATmega162, and Arduino Mega boards (1280 and 2560)
#if defined(__AVR_ATmega162__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)

#ifndef __ASTROEQ_H__
#define __ASTROEQ_H__

#ifdef __cplusplus
extern "C"{
#endif

/*
 * File Includes
 */
 
#include "PinMappings.h" //Read Pin Mappings
#include "EEPROMAddresses.h" //Config file addresses
#include "UnionHelpers.h"

#include <string.h>
#include <stdlib.h>
#include <math.h>

#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/interrupt.h>

#include <inttypes.h>

/*
 * Useful Defines
 */
 
#ifndef sbi
  #define sbi(r,b) r |= _BV(b)
#endif
#ifndef cbi
  #define cbi(r,b) r &= ~_BV(b)
#endif

#define FLOAT (1<<3)
#define HIGH 1
#define LOW 0

#define OUTPUT 1
#define INPUT 0

#define A498x 0
#define DRV882x 1
#define DRV8834 2

#define SPEEDNORM 0
#define SPEEDFAST 1

#define REBUILDMODE 3
#define STOREMODE 2
#define PROGMODE 1
#define RUNMODE 0

#ifdef abs
#undef abs
#endif

#define abs(x) ((x)>0?(x):-(x))

#ifndef max
#define max(a,b) ((a > b) ? a : b)
#endif

typedef uint8_t byte;

#define RA 0 //Right Ascension is AstroEQ axis 0 (Synta axis '1')
#define DC 1 //Declination is AstroEQ axis 1 (Synta axis '2')

#define ST4P (0)  //Positive ST4 Pin
#define ST4N (1)  //Negative ST4 Pin
#define ST4O (-1) //Neither ST4 Pin

#define MIN_IVAL 50

#define BAUD_RATE 9600

#define nop() __asm__ __volatile__ ("nop \n\t")


/*
 * Standalone Pin Names
 */

#define STANDALONE_IRQ   0
#define STANDALONE_PULL  1

#define EQMOD_MODE 0
#define BASIC_HC_MODE 1
#define ADVANCED_HC_MODE 2

typedef struct {
    unsigned int speed;
    byte repeats;
} AccelTableStruct;

/*
 * Declare constant arrays of pin numbers
 */
 
const byte standalonePin[2] = {gpioPin_0_Define,gpioPin_2_Define};
const byte statusPin = statusPin_Define;
const byte resetPin[2] = {resetPin_0_Define,resetPin_1_Define};
const byte dirPin[2] = {dirPin_0_Define,dirPin_1_Define};
const byte enablePin[2] = {enablePin_0_Define,enablePin_1_Define};
const byte stepPin[2] = {stepPin_0_Define,stepPin_1_Define};
const byte st4Pins[2][2] = {{ST4AddPin_0_Define,ST4SubPin_0_Define},{ST4AddPin_1_Define,ST4SubPin_1_Define}};
const byte modePins[2][3] = {{modePins0_0_Define,modePins1_0_Define,modePins2_0_Define},{modePins0_1_Define,modePins1_1_Define,modePins2_1_Define}};


/*
 * Function Prototypes
 */
 
bool checkEEPROM();
void buildEEPROM();
void storeEEPROM();
void systemInitialiser();
byte standaloneModeTest();
int main(void);
bool decodeCommand(char command, char* packetIn);
void calculateRate(byte axis);
void calculateDecelerationLength (byte axis);
void motorEnable(byte axis);
void motorDisable(byte axis);
void slewMode(byte axis);
void gotoMode(byte axis);
void motorStart(byte motor);
void motorStartRA();
void motorStartDC();
void motorStop(byte motor, byte emergency);
void motorStopRA(bool emergency);
void motorStopDC(bool emergency);
void configureTimer();
void buildModeMapping(byte microsteps, byte driverVersion);


#ifdef __cplusplus
} // extern "C"
#endif


#endif


#else
#error Unsupported Part! Please use an Arduino Mega, or ATMega162
#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE INO OR *
 * PDE FILE THIS FILE IS GENERATED FROM!!!         *
 ***************************************************/

#include <Raw.h>
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ6.ino"
ELF          S            @     4     (  
 %  $ >  $ >  $ >   \                                int                                  
                           C:\Users\Thomas\AppData\Local\Temp\build-257f0514-347c-4697-aed5-e6694d4cdfa1\AstroEQ6.cpp unsigned int long unsigned int GNU C++ 4.3.2 signed char long long unsigned int unsigned char long int long long int  .symtab .strtab .shstrtab .text .data .bss .debug_abbrev .rela.debug_info .rela.debug_line .debug_str                                                         4                      !             4                      '             4                      ,              4   1                  ?              e   `                  :                               P                 A                  K              \                 \      0                                          g                                H                	              X  h                                                                                           ?            >             =         )   4         1             =                                                                   	 J              Y               AstroEQ6.cpp __SREG__ __SP_H__ __SP_L__ __CCP__ __tmp_reg__ __zero_reg__ __do_copy_data __do_clear_bss               z                                       $     [   2        9        @        G     h   N        U                 :00000001FF
ELF          S        4        4    (                 +  +           :100000000C9472000C9495000C9495000C9495003F
:100010000C9495000C9495000C9458030C94950046
:100020000C9495000C9495000C9495000C949500FC
:100030000C9448040C9495000C9495000C94950035
:100040000C9495000C9495000C9495000C94C2119E
:100050000C9495000C94E2110C9495000C9495006E
:100060000C9495000C9495000C9495000C949500BC
:10007000E707F70792083708450945094509450983
:100080004509450945094509450923084509450923
:10009000B308590807082F09450945094509F80813
:1000A00024097E08450945094509450945094509C9
:1000B000450945098A082F084509450945094509A3
:1000C00045094509450945094509170845094509EF
:1000D0009E084F0845094509450945094509CD08C8
:1000E0004509770811241FBECFEFD4E0DEBFCDBF96
:1000F00088E10FB6F89481BD11BC0FBE11E0A0E0FD
:10010000B1E0E6E8FBE202C005900D92AA37B10724
:10011000D9F714E0AAE7B1E001C01D92A135B107FB
:10012000E1F70E943D0B0C94C1150C940000FB01FB
:10013000DC014150504030F08D910190801919F44C
:100140000020B9F7881B990B0895883018F4880FA0
:10015000880F880F883019F08032A1F406C083E040
:100160008093090110920A010895623011F087E02E
:1001700001C082E280930901623011F082E00EC07A
:1001800080E20CC0613011F087E001C081E0809313
:100190000901613011F081E001C084E080930A011F
:1001A00008953898000000000000000080910D02C2
:1001B000882321F0829B02C082E00895389A0000D3
:1001C00000000000000080B38695869580958170C0
:1001D0000895829902C080E00BC0309838980000E2
:1001E000000000000000829B02C082E001C081E0AC
:1001F000309A389A0895882329F4969881E080935C
:10020000340204C0C09881E08093350210927D00D2
:1002100089B7837089BF1FBC88E18EBD10928B00A7
:1002200080938A000895882321F4969A10923402CC
:100230000895C09A10923502089540911E0250917F
:100240001F0289B7877F89BFE0918400F091850004
:1002500089B7886089BF2091710230917202C9010B
:10026000722F692F2417350718F4CA01742F692FCC
:10027000A0913802AA2329F4E217F30710F49F0192
:1002800003C0872F962F9C0189B7877F89BF509322
:100290006E0240936D02309385002093840070932A
:1002A000790260937A0290918401809132029817CA
:1002B00011F0939A01C09398AA23D9F081E090E0BD
:1002C00099BD88BD80917F02809312021092140222
:1002D00012BE1DBC1CBC80918A0190918B0195BD02
:1002E00084BD8EB5897F8EBD8EB581608EBD109226
:1002F000380289B7886089BF0895409120025091E3
:10030000210280917D008F7D80937D00E0918600A9
:10031000F091870080917D00806280937D00209124
:10032000730230917402C901722F692F24173507A7
:1003300018F4CA01742F692FA0913902AA2329F455
:10034000E217F30710F49F0103C0872F962F9C013B
:1003500080917D008F7D80937D005093700240934B
:100360006F02309387002093860070937B02609326
:100370007C029091850180913302981711F0979A31
:1003800001C09798AA2319F181E090E09BBD8ABD36
:1003900080913F03809313021092150211BE1092B8
:1003A0008900109288008091CA019091CB019093AE
:1003B00081008093800080918A00897F80938A00E9
:1003C00080918A00816080938A0010923902809126
:1003D0007D00806280937D000895882319F40E9437
:1003E0001D0108950E947D0108959F92AF92BF92D2
:1003F000CF92DF92EF92FF920F931F93CF93DF93F1
:10040000C82EC82FD0E0FE01EE0FFF1FE25FFD4FA8
:1004100000811181FE01EA5EFD4F84A1882329F04D
:10042000C801880F991F080F191FFE01EA5EFD4FD2
:10043000828D181614F4D28C02C0D28CD194FE0195
:10044000EA5EFD4F948C8D2D90E0880F991F9C01E2
:10045000442737FD4095542FFE01EE0FFF1FEE0F8E
:10046000FF1FEA5EFD4F82899389A489B5898217AF
:100470009307A407B50720F4228B338B448B558B4D
:100480008D2D90E0809FB001819F700D909F700D29
:100490001124FE01EE0FFF1FEE0FFF1FEA5EFD4F5E
:1004A000E288F38804891589A80197015695479534
:1004B00037952795FE01EE0FFF1FEB58FD4FA080EB
:1004C000B18088E0D81649F488EF9FEFAFEFBFEF17
:1004D000E822F9220A231B23287FCB01A0E0B0E009
:1004E000281739074A075B0708F4B901CB01A0E0D8
:1004F000B0E0A8019701281B390B4A0B5B0BDA010E
:10050000C901FE01EE0FFF1FEE0FFF1FEA5EFD4F58
:100510002081318142815381992039F0B095A09595
:10052000909581959F4FAF4FBF4FFE01EE0FFF1F7C
:10053000EE0FFF1FE458FE4F820F931FA41FB51F3D
:1005400080839183A283B383CC0FDD1FC25EDD4F16
:10055000B982A88295B3CC2011F48BEF01C087EF4C
:10056000892385BB95B3CC2011F481E001C082E0E2
:10057000892B85BB8C2D0E94ED01DF91CF911F91BE
:100580000F91FF90EF90DF90CF90BF90AF909F9032
:100590000895882389F089B7877F89BF8EB5887FC2
:1005A0008EBD1092360281E08093380210922602AE
:1005B00010927A01A898089580913802882339F51D
:1005C0004FB7F89410923602A89810922602209104
:1005D00071023091720280916D0290916E028217C9
:1005E000930758F48091790290917A02281739077D
:1005F00020F430937A0220937902809179029091CD
:100600007A02019690936E0280936D024FBF089517
:100610008823A9F080917D008F7D80937D0080915B
:100620008A00887F80938A001092370281E080934D
:1006300039021092270210927B01A99808958091A7
:100640003902882339F54FB7F89410923702109287
:100650002702A998209173023091740280916F0251
:10066000909170028217930758F480917B029091C9
:100670007C022817390720F430937C0220937B02F8
:1006800080917B0290917C020196909370028093FE
:100690006F024FBF0895882329F4611181E00E9401
:1006A000C902089580E0611181E00E940803089565
:1006B0001F920F920FB60F9211242F933F934F93D7
:1006C0005F936F937F938F939F93AF93BF93EF93BA
:1006D000FF938AB59BB5019709F0C7C081B7E82F92
:1006E000EE73F0E0E653FE4F2081318130938100BC
:1006F000209380008F5F81BF60918600709187009A
:100700007BBD6ABD2A9B54C03A9880911A02909191
:100710001B02A0911C02B0911D02209131023327CF
:1007200027FD3095432F532F280F391F4A1F5B1F7A
:1007300020931A0230931B0240931C0250931D0217
:10074000A99B1BC0AB9919C0809180019091810138
:10075000A0918201B091830182179307A407B50786
:1007600061F4AB9A80917B0290917C020196909308
:10077000700280936F021092130280917B0290911D
:100780007C028617970708F072C0A99B03C01092DD
:100790003702A99881E08093390280917D008F7D96
:1007A00080937D0080918A00887F80938A005FC05B
:1007B0003A9A80911302882309F053C020916F0266
:1007C0003091700226173707D0F4809115028F33CD
:1007D00008F041C08F5F8093150290E0FC01EE0F9E
:1007E000FF1FE80FF91FEA5EFD4FE95DFE4F6081D4
:1007F0007181E752F14026173707E0F02CC06217ED
:10080000730750F580911502882329F18150809358
:10081000150290E0FC01EE0FFF1FE80FF91FEA5EE2
:10082000FD4FE95DFE4F60817181E752F140621733
:10083000730788F480913B02E75DFE4F882339F00F
:10084000808123E0829FC00111248E5F01C08081DE
:100850008093130201C0B9017093870060938600F2
:1008600006C081508093130202C09BBD8ABDFF91D8
:10087000EF91BF91AF919F918F917F916F915F9118
:100880004F913F912F910F900FBE0F901F90189591
:100890001F920F920FB60F9211242F933F934F93F5
:1008A0005F936F937F938F939F93AF93BF93EF93D8
:1008B000FF9388B599B5019709F0C1C082B7E82FB9
:1008C000EE73F0E0E657FE4F2081318135BD24BD47
:1008D0008F5F82BF609184007091850079BD68BD93
:1008E000849B50C094988091160290911702A09119
:1008F0001802B091190220913002332727FD30955C
:10090000432F532F280F391F4A1F5B1F20931602B6
:10091000309317024093180250931902A89B1BC0F2
:10092000AA9919C080917C0190917D01A0917E01CE
:10093000B0917F0182179307A407B50761F4AA9AC3
:100940008091790290917A02019690936E02809341
:100950006D02109212028091790290917A028617AC
:10096000970708F06EC0A89B03C010923602A898A3
:1009700081E08093380289B7877F89BF8EB5887FF1
:100980008EBD5FC0949A80911202882309F053C0F3
:1009900020916D0230916E0226173707D0F48091B6
:1009A00014028F3308F041C08F5F8093140290E0EF
:1009B000FC01EE0FFF1FE80FF91FEA5EFD4FE9593A
:1009C000FF4F60817181E756F04026173707E0F04E
:1009D0002CC06217730750F580911402882329F107
:1009E00081508093140290E0FC01EE0FFF1FE80F8E
:1009F000F91FEA5EFD4FE959FF4F60817181E756AB
:100A0000F0406217730788F480913A02E759FF4F6C
:100A1000882339F0808123E0829FC00111248E5FFA
:100A200001C080818093120201C0B90170938500DA
:100A30006093840006C081508093120202C099BD69
:100A400088BDFF91EF91BF91AF919F918F917F9161
:100A50006F915F914F913F912F910F900FBE0F902B
:100A60001F9018951F9360914402709145028091E8
:100A70004602909147024EE050E00E945110609172
:100A800048027091490280914A0290914B0242E1E2
:100A900050E00E94511060914C0270914D02809183
:100AA0004E0290914F0246E150E00E945110609139
:100AB00050027091510280915202909153024AE18A
:100AC00050E00E945110609156027091570280913F
:100AD0005802909159024EE150E00E9451106091ED
:100AE0005A0270915B0280915C0290915D0242E239
:100AF00050E00E9451108091840169E070E00E94F2
:100B00002D10809185016AE070E00E942D10809187
:100B100088016BE070E00E942D108091870168E0F1
:100B200070E00E942D10809175026CE070E00E94D0
:100B30002D10809177026DE070E00E942D10809161
:100B4000690290916A0266E270E00E94381080911A
:100B50006B0290916C0268E270E00E943810809104
:100B60000C0211E081276AE270E00E942D10809152
:100B70000D0281276BE270E00E942D1080916702C8
:100B8000909168026CE270E00E94381080915F02E0
:100B90006EE270E00E942D108DE792E060E444E682
:100BA00050E00E9480108DE393E060E444E251E065
:100BB0000E9480101F91089580E091E068E040E07D
:100BC00050E00E94681008950F931F93DF93CF9316
:100BD000CDB7DEB729970FB6F894DEBF0FBECDBFF5
:100BE0008E010F5F1F4F89E0F80111928A95E9F796
:100BF000C80168E040E050E00E94EF0FC80160E0EB
:100C000071E048E050E00E949700009791F58091D4
:100C10008801833070F5882321F480918701813128
:100C200040F580918701813220F580916902909191
:100C30006A02C2978F579440E0F480916B029091C2
:100C40006C02C2978F579440A0F4809175029091E6
:100C50007602892B71F08091770290917802892B2E
:100C600041F090E080915F028150833118F491E06F
:100C700001C090E0892F29960FB6F894DEBF0FBE11
:100C8000CDBFCF91DF911F910F9108958F929F92C9
:100C9000AF92BF92CF92DF92EF92FF920F931F938A
:100CA000CF93DF93A82E4B0182E00E942C12B82E26
:100CB0000FE4A01609F451C10A15FCF018E4A116BE
:100CC00009F4EAC01A1564F026E4A21609F43CC13E
:100CD0002A150CF4CBC085E4A81609F05EC121C129
:100CE000ABE4AA1609F4B5C0BCE4AB1609F4B7C06E
:100CF000E9E4AE1609F051C1E3C0F6E6AF1609F417
:100D000076C0FA155CF002E6A01679F115E6A11698
:100D100091F021E6A21609F040C11AC08AE6A81691
:100D200009F487C0A3E7AA1609F454C0B7E6AB16C6
:100D300009F033C14AC0E82FF0E0EE0FFF1FEE0FBD
:100D4000FF1FEA5EFD4F26A137A140A551A5A1C214
:100D5000E82FF0E0EE0FFF1FEE0FFF1FEA5EFD4FE2
:100D600026A537A540A951A994C2A82FB0E0FD013E
:100D7000EE0FFF1FEE0FFF1FEA5EFD4F26A937A9FA
:100D800040AD51AD80918601882309F082C2AA0F3F
:100D9000BB1FA759BD4FED90FC90EE0CFF1C0894B3
:100DA000E11CF11CB70180E090E00894E108F10833
:100DB0000E946C1500E010E0A80197010E949F15A9
:100DC000C901DA019C01AD0164C2EB2DF0E0EC5ADF
:100DD000FD4FA4C1EB2DF0E0EE0FFF1FEE0FFF1F44
:100DE000EA5AFD4F208131814281538152C2A82F9E
:100DF000B0E0FD01EA5EFD4F848D882319F020E00C
:100E000032E002C020E030E0FD01EA5EFD4F82A149
:100E100081113160FD01EA5EFD4F80A181112061E9
:100E2000AA5EBD4F5E968C91882309F409C12160AA
:100E300007C18FB7F894EB2DF0E0EE0FFF1FEE0F18
:100E4000FF1FEA5EFD4F20813181428153818FBFB8
:100E500020C260E00E944B03EB2DF0E019C061E07E
:100E60000E944B038B2D0E9413010FC2E82FF0E06C
:100E7000DF01AA5EBD4FE4018881805350968C93B8
:100E8000509790E08981803309F091E05C969C93C3
:100E9000E658FE4F1082F9C1C4010E941212AB2D18
:100EA000B0E0FD01EE0FFF1FEE0FFF1FEA5EFD4FEA
:100EB000628B738B848B958BA658BE4F1C92E5C1B9
:100EC000C4010E941212CB2CDD24E601CC0FDD1FE1
:100ED000C25EDD4F20EC30E0C29EF001C39EF00DFB
:100EE000D29EF00D1124E65CFC4F20813181790106
:100EF00000E010E0AC01CB01DA018E159F05A007E0
:100F0000B10710F4D801C70199838883F601E65828
:100F1000FE4F8081823009F0BDCF8B2D0E94ED0104
:100F2000B4C11FB7F894C4010E941212EB2DF0E077
:100F3000EE0FFF1FEE0FFF1FEA5EFD4F6083718310
:100F4000828393831FBFA1C180918601882309F00A
:100F50009BC18B2D0E94FB0098C1F40180818053BE
:100F600080938601882331F420E030E040E050E0B7
:100F700010E090C180E061E00E944B0380E00E949D
:100F8000130181E061E00E944B0381E00E941301A4
:100F900010927A0110927B0178C120918601222360
:100FA00009F473C18A2D992787FD9095A92FB92F30
:100FB000FC01E154F040EA33F10508F066C1E85C59
:100FC000FF4FEE0FFF1F0590F491E02D0994C4012F
:100FD0000E941212EB2DF0E0EE0FFF1FEE0FFF1F2D
:100FE000EA5EFD4F66A777A780AB91AB4EC1C40107
:100FF0000E941212EB2DF0E0EE0FFF1FEE0FFF1F0D
:10100000EA5EFD4F66AB77AB80AF91AF3EC1C401E6
:101010000E941212EB2DF0E0EE0FFF1FEE0FFF1FEC
:10102000EA5AFD4F60837183828393832EC1EB2D37
:10103000F0E0EE0FFF1FE759FD4F808191819C0189
:1010400040E050E026C1C4010E941212EB2DF0E0F6
:10105000EE0FFF1FE759FD4F7183608316C1BB2060
:1010600019F0809187015BC08091880158C0BB2036
:1010700081F0C4010E940F1280938701883010F420
:1010800090E004C090910C0281E0982790930A02AE
:10109000FCC0C4010E940F1280938801F6C0BB20DF
:1010A00029F08091670290916802C9CF80915F0218
:1010B00036C0BB2089F0C4010E9412126030F0E0FB
:1010C0007F07F1E08F07F0E09F0708F0DDC0709325
:1010D000680260936702D9C0C4010E940F12982F62
:1010E0008150833108F0D0C090935F02CEC0EB2DC9
:1010F000F0E0EE0FFF1FEB58FD4F9FCFC4010E94A1
:101100000F12EB2DF0E0EE0FFF1FEB58FD4F808329
:101110001182BBC0EB2DF0E0EC57FE4F8081282FF1
:1011200030E08ECFEB2DF0E0EC57FE4F90E0D40195
:101130008C91803309F091E09083A7C0BB2081F0AF
:1011400020910C0280918701883010F480E002C069
:1011500081E0822730E040E050E080930A0299C0AD
:1011600080910D02DCCFBB2061F0C4010E940F1200
:1011700010920C02882309F488C081E080930C024D
:1011800084C0C4010E940F1210920D02882309F43A
:101190007CC081E080930D0278C020E030E040E028
:1011A00050E06B2D70E0EB01CC5EDD4FA8818A2F03
:1011B00090E0FC01EE0FFF1FE80FF91F80EC90E0BC
:1011C0008C01609FC001619F900D709F900D112454
:1011D000E80FF91FEA5EFD4FE959FF4F2191319168
:1011E0004081AF5FA883A03408F453C0188251C077
:1011F000C4010E9412124B2D50E0EA01CC5EDD4F7B
:10120000A8812A2F30E0F901EE0FFF1FE20FF31F34
:1012100020EC30E08901409F9001419F300D509FAC
:10122000300D1124E20FF31FEA5EFD4FE959FF4F25
:1012300061937193BC01882799276083AF5FA8836E
:10124000A03418F1188221C0C4010E940F12EB2DA6
:10125000F0E0EC5EFD4F80838034B0F416C0822F46
:1012600090E09C012170307081FF08C0232B19F0A1
:101270000E94DC050AC00E94320507C0232B29F01A
:101280000E94E405882309F4AA2420E030E040E02D
:1012900050E011E0C4016A2D0E94AD122AE4A216AA
:1012A00089F480918601882369F48B2D90E0FC01FC
:1012B000E658FE4F21E02083FC01EA5EFD4F808965
:1012C00080FF20A3812FDF91CF911F910F91FF907D
:1012D000EF90DF90CF90BF90AF909F908F90089548
:1012E0006F927F928F929F92AF92BF92CF92DF9236
:1012F000EF92FF920F931F93CF93DF93C82FD0E00D
:10130000FE01EE0FFF1FEE0FFF1FEA5EFD4FA6A8C6
:10131000B7A8C0ACD1AC60E072E18AE790E0A6016A
:1013200095010E949F15C901DA013C014D0160E061
:1013300072E18AE790E0A60195010E949F150E9444
:1013400039147B018C01C601B5010E9439149B013F
:10135000AC01C801B7010E94A51320E030E040E0D5
:1013600052E40E94091520E030E040E05FE30E9473
:101370002E130E940D145B016C01C401AA27BB2728
:10138000892B39F05FEF652E5FEF752E812C912C44
:101390000BC080E8681671048104910428F440E8C9
:1013A000642E712C812C912CD401C3010197A109C9
:1013B000B109FE0136E0EE0FFF1F3A95E1F7E6575F
:1013C000FE4F20E0819391932F5F2032D9F766245E
:1013D0007724430125E0CC0FDD1F2A95E1F72BC0D0
:1013E000C401B3010E94391420E030E040E052E42F
:1013F0000E9409157B018C01C601B5010E943914B8
:101400009B01AC01C801B7010E94A5130E94921371
:101410000E940D14FE01E60FF11DEE0FFF1FE657AF
:10142000FE4F808191810196918380830894611C95
:10143000711C811C911C6A147B048C049D0480F235
:10144000DF91CF911F910F91FF90EF90DF90CF90A0
:10145000BF90AF909F908F907F906F90089589E09C
:1014600090E00E94BB0F10928401882319F081E064
:10147000809384018AE090E00E94BB0F1092850166
:10148000882319F081E0809385018BE090E00E9431
:10149000BB0F8093880188E090E00E94BB0F80938F
:1014A00087018BE290E00E94BB0F10920D0288230F
:1014B00019F481E080930D0210920B028091870154
:1014C000883018F481E080930B028AE290E00E9459
:1014D000BB0F90E0882309F491E090930C02809177
:1014E0008701883010F480E002C081E08927809372
:1014F0000A02882311F441E001C048E062E273E08F
:1015000080E090E00E941D13809187016091880126
:101510000E94A5000E94E405882319F481E08093CD
:10152000860180E00E94700981E00E94700940916C
:10153000750250917602EDE7F2E020E030E0808124
:1015400091814817590750F4828190E00196280F45
:10155000391F339683E0ED33F80789F730930F0294
:1015600020930E024091770250917802EDE3F3E070
:1015700020E030E0808191814817590750F4828142
:1015800090E00196280F391F339683E0ED3FF8076E
:1015900089F73093110220931002BF9AC7988A9856
:1015A000929A309A389AD798DF9AD498DC9AD6983B
:1015B000DE9AD598DD9AD19AD998D09AD8988E9AF1
:1015C000969AB89AC09A8C9A9498329A3A988B9A2A
:1015D00093988F9A9798E0910B02F0E0E75FFE4FA7
:1015E000808190E09C012170307080FF02C0959A4C
:1015F00001C095988D9A232B11F0C49A01C0C4980C
:10160000BC9A9C012270307081FF02C0DB9A01C03D
:10161000DB98D39A232B11F0C39A01C0C398BB9ACD
:10162000AC014470507082FF02C0DA9A01C0DA98AF
:101630009C012072307085FD02C0D29A01C0D29800
:10164000452B11F0C29A01C0C298232B11F4BA9A0B
:1016500001C0BA9880EA9FE00197F1F7D99AD89A29
:1016600089B78C7F89BF13BE0E94191160E875E2AB
:1016700080E090E00E94AA1008952F923F924F922E
:101680005F926F927F928F929F92AF92BF92CF9212
:10169000DF92EF92FF920F931F93DF93CF93CDB71B
:1016A000DEB72E970FB6F894DEBF0FBECDBF78948D
:1016B0000E942F0AEE24FF24AA2400E0CC24BB249D
:1016C000412C512C80E8682E712C1E010894211C9D
:1016D000311CDD24DA9414E0812E912C8C0E9D1E99
:1016E0000894E11CF11C80918901882309F07CC0D9
:1016F000E114F10409F078C00E94D100182F88236A
:1017000009F472C080E061E00E944B0381E061E077
:101710000E944B038FB7F894409216025092170222
:10172000609218027092190240921A0250921B02A3
:1017300060921C0270921D028FBF0E94F11081E026
:1017400080938901123081F4809308010E94011175
:10175000C10160E020E030E040E050E00E94AD12C6
:10176000C1010E94B51140C01092080110920A02F6
:10177000389AE0910B02F0E0E75FFE4F808180FF36
:1017800003C0959AC49A02C09598C49881FF03C07B
:10179000DB9AC39A02C0DB98C39882FF03C0DA9A2F
:1017A000C29A02C0DA98C29880E00E941A0E80E0C5
:1017B0000E94FB0081E00E94FB0021E020932602B2
:1017C00020932702109232022093300210923302AB
:1017D000209330028091690290916A0290931F02D7
:1017E00080931E0220937A0180910801882309F4D6
:1017F00050C10E3F21F00E946411882361F188B32B
:10180000805888BB0E3F19F00E947111A82EC401A8
:101810006A2D0E946B12082F8823E9F0181614F025
:1018200010E005C0B4010E94460611E01827C4016B
:101830000E94B511112379F00E94A5112BE088E1D7
:1018400090E00FB6F894A89581BD0FBE21BD80E051
:1018500090E00E94C115E114F10409F4C798809149
:101860008901882309F062C0EE2009F05FC08091F1
:1018700032028823B9F480917A01823099F4CD99AB
:1018800002C0E1E0B3C1CE9BB0C1BB2059F0809152
:10189000690290916A0290931F0280931E020E9437
:1018A0001D01BB2480913702882309F03FC0CD99E8
:1018B00003C051E041E006C0CE9B02C04FEF01C023
:1018C00040E050E080913902882371F48091330226
:1018D00090E0252F30E08217930731F080E00E94DE
:1018E000080310927B0122C04F3FD1F08091650226
:1018F000909166029093210280932002252F51112E
:1019000021E020933302222319F0D092310203C048
:1019100081E0809331020E947D01CC24C39406C0F3
:10192000CC2021F080E00E940803CC2490917A0121
:10193000913009F054C080913802882309F44FC0D7
:101940003091260280910A02882381F1832F8150F1
:10195000823070F42091090180913202882319F0BD
:10196000D092300202C09093300210923A020DC021
:1019700020910A0190915402809132028111919537
:101980009093300281E080933A02822F20FF02C0C0
:10199000959A01C0959881FF02C0DB9A01C0DB983F
:1019A00082FF02C0DA9A0DC0DA980BC08091320231
:1019B000882319F0D092300202C090933002109226
:1019C0003A0230FF07C080E00E94ED0182E0809380
:1019D0007A0105C080E00E94F50110927A01909191
:1019E0007B01913009F07CCE80913902882309F483
:1019F00077CE3091270280910A02882381F1832FCC
:101A00008150823070F42091090180913302882343
:101A100019F0D092310202C09093310210923B0231
:101A20000DC020910A0190915502809133028111DD
:101A300091959093310281E080933B02822F20FFA9
:101A400002C0C49A01C0C49881FF02C0C39A01C0F9
:101A5000C39882FF02C0C29A0DC0C2980BC0809189
:101A60003302882319F0D092310202C090933102E0
:101A700010923B0230FF07C081E00E94ED0182E03E
:101A800080937B012DCE81E00E94F50110927B01B5
:101A900027CEE114F10471F488B3805888BB0E940A
:101AA000E900982F80915E02981739F0892F0E94E3
:101AB0001A0E03C0EE2009F013CECC9BAAC0CF9B18
:101AC00002C04FEF01C040E050E01FB7F894809192
:101AD0003802882309F0A6C08091320290E0252FB9
:101AE00030E08217930709F49DC020918400309163
:101AF000850080917102909172022817390708F0D1
:101B000091C027C0E0916902F0916A020BC0E42FF6
:101B1000FF27E7FDF095EE0FFF1FE05AFD4F019004
:101B2000F081E02DF0931F02E0931E02252F51114A
:101B300021E020933202222319F0D092300203C018
:101B400081E0809330024F3F41F480915E02823009
:101B500021F480E00E94C90202C00E941D011FBF43
:101B6000CD9903C051E041E006C0CE9B02C04FEFCB
:101B700001C040E050E01FB7F894809139028823FB
:101B800009F054C08091330290E0252F30E0821795
:101B9000930709F44BC02091860030918700809113
:101BA0007302909174022817390708F03FC018C0DB
:101BB00080916502909166029093210280932002A9
:101BC000252F511121E020933302222319F0D092C6
:101BD000310203C081E0809331020E947D0103C085
:101BE00080E00E9408031FBF7BCDE0E0FF27E7FDF8
:101BF000F095B596EE0FFF1FEA5EFD4F8081918153
:101C000090931F0280931E020E941D01BB24B39477
:101C100049CE80916402882311F051E001C050E068
:101C200041E053CF4F3F09F072CF6CCF4F3F09F0E7
:101C3000BFCFD6CF0F931F93482F80935E02823081
:101C4000A1F4809175029091760290936102809345
:101C50006002909363028093620281E08093640249
:101C600080917702909178021BC08130F1F420912D
:101C7000690230916A02C90163E070E00E948B152D
:101C8000709361026093600230936302209362025A
:101C90004093640280916B0290916C0296958795B7
:101CA00090936602809365023BC080916902909197
:101CB0006A0224E130E0829F8001839F100D929F91
:101CC000100D112440915F02E42FF0E0BF016C5E23
:101CD0007F4FC8010E948B15709361026093600270
:101CE000B9016E1B7F0BC8010E948B1570936302B4
:101CF000609362021092640280916B0290916C0278
:101D0000BC01629FC001639F900D729F900D1124D2
:101D1000642F70E00E948B157093660260936502D9
:101D20001F910F910895982FEBE0F1E020E030E053
:101D30008081891789F4F901EE0FFF1F662331F0C6
:101D4000E20FF31FE55FFE4F81810895E20FF31F5D
:101D5000E55FFE4F828108952F5F3F4F3396253216
:101D6000310531F78FEF08954F925F926F927F9216
:101D70008F929F92AF92BF92CF92DF92EF92FF929B
:101D80000F931F93CF93DF933B014C01442E8EE0C2
:101D900090E00E94D10F60934402709345028093BB
:101DA00046029093470282E190E00E94D10F609337
:101DB00048027093490280934A0290934B0286E155
:101DC00090E00E94D10F60934C0270934D0280937B
:101DD0004E0290934F028AE190E00E94D10F6093EF
:101DE00050027093510280935202909353028EE1FD
:101DF00090E00E94D10F6093560270935702809337
:101E000058029093590282E290E00E94D10F6093B1
:101E10005A0270935B0280935C0290935D0286E2AB
:101E200090E00E94C20F90936A028093690288E258
:101E300090E00E94C20F90936C0280936B028CE042
:101E400090E00E94BB0F05E712E0809375021092AC
:101E500076028DE090E00E94BB0F80937702F8013C
:101E600013828EE290E00E94BB0F80935F028CE2AF
:101E700090E00E94C20F9093680280936702C801AD
:101E8000089660E444E650E00E9401108DE393E080
:101E900060E444E251E00E94011026E132E0790161
:101EA0006DE772E009E712E0E901D90140E050E096
:101EB00055245394A12CB12CE0E8CE2ED12C1C8EAD
:101EC000FA01EA5EFD4F528E1CA25AA218A21E8E83
:101ED000F701A192B192C192D1927F01AD5ABF4F49
:101EE0008D919C911197A355B04019969C938E9318
:101EF0001897188AF901128A138A148A158A66A219
:101F000077A280A691A64EAEFB0180819181A55A51
:101F1000BF4F11969C938E93F801819391938F01FB
:101F20001497019611969C938E93A755B0401D96D9
:101F30009C938E931C974F5F5F4F219612962C5F58
:101F40003F4F60547F4F4230510509F0B8CF80E0D9
:101F50000E941A0EDF91CF911F910F91FF90EF9089
:101F6000DF90CF90BF90AF909F908F907F906F90B9
:101F70005F904F900895E199FECF9FBB8EBBE09A92
:101F80008DB30895E199FECF9FBB8EBBE09A2DB330
:101F9000E199FECF01969FBB8EBBE09A9DB3822F45
:101FA0000895E199FECF9FBB8EBBE09A2DB3E199D6
:101FB000FECF01969FBB8EBBE09A7DB30196E1995F
:101FC000FECF9FBB8EBBE09A3DB3E199FECF019659
:101FD0009FBB8EBBE09A9DB3622F832F0895FC01B7
:101FE00090E00CC0E199FECF9A012F5F3F4F5FBB9D
:101FF0004EBBE09A8DB381939F5FA901961790F332
:102000000895FC0120E025C0E199FECF5FBB4EBBE7
:10201000E09A9DB3E199FECF4F5F5F4F5FBB4EBB30
:1020200041505040E09A8DB390838183CA0102965B
:10203000E199FECF9FBB8EBBE09A8DB34D5F5F4FA2
:10204000E199FECF5FBB4EBBE09A9DB382832F5FC9
:102050003396261708F4D8CF0895E199FECF7FBBB9
:102060006EBB8DBB0FB6F894E29AE19A0FBE08954D
:102070009C01E199FECF7FBB6EBB2DBB0FB6F894E0
:10208000E29AE19A0FBE932FE199FECF6F5F7F4FE7
:102090007FBB6EBB9DBB0FB6F894E29AE19A0FBE70
:1020A0000895EF92FF920F931F938A01F82EE92E65
:1020B000CB01BA010E9438100E5F1F4F8F2D9E2D4D
:1020C000B8010E9438101F910F91FF90EF90089572
:1020D000FC0120E030E011C07081E199FECFC90120
:1020E000840F951F9FBB8EBB7DBB0FB6F894E29A01
:1020F000E19A0FBE2F5F3F4F3196261768F3089580
:10210000EF92FF920F931F93CF93DF93E62E8A01F6
:10211000EC01FF2416C088819981B8010E94381013
:10212000C80102962A81E199FECF9FBB8EBB2DBBD1
:102130000FB6F894E29AE19A0FBE0D5F1F4FF39429
:102140002396FE1440F3DF91CF911F910F91FF90E2
:10215000EF900895EF92FF920F931F937B018C01F4
:1021600082E08BB960E079E08DE390E0A80197010F
:102170000E949F1521503040404050405695479551
:1021800037952795922F232F832F807F99F01BB8A7
:1021900060E874E88EE190E0A80197010E949F1525
:1021A00021503040404050405695479537952795EF
:1021B000922F232F2F7020BD99B98FB7F8941092CA
:1021C0001D0410921E0410923F04109240048FBF11
:1021D000549A539A579A55981F910F91FF90EF90E8
:1021E000089554985398579855988FB7F89410922B
:1021F0001D0410921E0410923F04109240048FBFE1
:102200000895D59ADD9AD798DF9AD69ADE9AD49A0D
:10221000DC9A389A8FB7F89410921D0410921E041D
:1022200010923F04109240048FBF81E080934104DC
:102230000895D598DD9AD798DF9AD698DE9AD498E3
:10224000DC9A109241048FB7F89410921D041092FA
:102250001E0410923F04109240048FBF089598E02E
:10226000DD9887FF02C0DE9A02C00000DE98DD9A8A
:10227000880FCF998F5F915099F7089590914004FE
:1022800080913F049817C9F0829917C0DC9881E8C3
:102290000E942F11829BFECF80E80E942F1187FDA4
:1022A0000BC0E0913F04F0E0E15EFB4F8083809142
:1022B0003F048F5F80933F04DC9A0895DC988F770A
:1022C0000E942F11DC9A089580914104882311F017
:1022D0000E943E1180913F0490914004891B8F71B0
:1022E00008959091400480913F04891711F48FEF75
:1022F0000895E92FF0E0E15EFB4F80819F5F9F71C1
:10230000909340040895282F539B17C090911D046B
:102310009F5F9F7180911E04981729F4559A8091B0
:102320001E049817E1F3E0911D04F0E0E350FC4F28
:10233000208390931D04559A089580914104882329
:1023400019F0822F0E945E110895539B0DC0909149
:102350001D049F5F9F7180911E04981729F4559A60
:1023600080911E049817E1F30895CF93DF93EC0159
:1023700003C021960E94831188818823D1F7DF91C1
:10238000CF9108952F932FB72F939F938F93EF9310
:10239000FF932CB190913F049F5F9F718091400407
:1023A000981741F0E0913F04F0E0E15EFB4F20839D
:1023B00090933F04FF91EF918F919F912F912FBFA9
:1023C0002F9118958F938FB78F939F93EF93FF93D0
:1023D00090911E0480911D04891711F455980AC02C
:1023E000E92FF0E0E350FC4F80819F5F9F71909355
:1023F0001E048CB9FF91EF919F918F918FBF8F91A8
:102400001895FC0191819A330CF0975080818A33A2
:102410000CF087508295807F9F70892B08950E94D1
:1024200001120895EF92FF920F931F938C0104966F
:102430000E940112E82EC80102960E940112F82E95
:10244000C8010E940112682F7F2D8E2D90E01F91F0
:102450000F91FF90EF900895823010F480934F0415
:1024600080914F040895EF92FF921F93CF93DF93D3
:10247000182F7B0190914304909350048091440461
:10248000815380934F048230F8F4892F61E00E94D9
:10249000930E1350282F332727FD3095812F90E07E
:1024A0002817390789F4A5E4B4E0E701F9012A0FF8
:1024B0003B1F02C08D918993A217B307D9F7EE0D88
:1024C000FF1D108281E001C080E0DF91CF911F915C
:1024D000FF90EF900895CF93DF93EC018091420439
:1024E000882321F16A3349F481E288838DE089836E
:1024F0001A82109242048EEF2DC080914E04E82F74
:10250000F0E0ED5BFB4F60838F5F80934E046D3096
:1025100051F4BE010E943312882391F010924204BC
:102520008091500417C08B30A1F40AC06A3389F43B
:1025300010924E0481E0809342041092430409C03B
:1025400081E288838DE089831A82109242048FEFA2
:1025500001C080E0DF91CF910895FF920F931F9308
:10256000CF93DF93EC01122F032FF42E662339F063
:10257000862F60E00E94930E982F87FF04C081E2AF
:10258000888390E04EC08DE388839230D9F19330F8
:10259000C9F4212F302F812F8F708A3008F0895F86
:1025A000805D8B83822F82958F708A3008F0895FDF
:1025B000805D8A83832F8F708A3008F0895F805D09
:1025C00089832FC0963069F58F2D8F708A3008F07F
:1025D000895F805D8E834F2D42954F704A3008F0A1
:1025E000495F405D4D83802F8F708A3008F0895F8E
:1025F000805D8C83302F32953F703A3008F0395F20
:10260000305D3B83812F8F708A3008F0895F805D59
:102610008A83212F22952F702A3008F0295F205DB0
:102620002983FE01E90FF11D8DE081831282DF9184
:10263000CF911F910F91FF90089510924204109234
:102640004E042BE0E3E4F4E0DF011D922A95E9F764
:1026500010924F040E94B40E08955058BB27AA2729
:102660000ED086C177D130F07CD120F031F49F3F7D
:1026700011F41EF46CC10EF4E095E7FB37C1E92FAD
:1026800088D180F3BA17620773078407950718F09B
:1026900071F49EF5B7C10EF4E0950B2EBA2FA02D64
:1026A0000B01B90190010C01CA01A0011124FF27FF
:1026B000591B99F0593F50F4503E68F11A16F040FA
:1026C000A22F232F342F4427585FF3CF46953795F9
:1026D0002795A795F0405395C9F77EF41F16BA0BBE
:1026E000620B730B840BBAF09150A1F0FF0FBB1F6C
:1026F000661F771F881FC2F70EC0BA0F621F731FB5
:10270000841F48F4879577956795B795F7959E3F11
:1027100008F0B3CF9395880F08F09927EE0F97959F
:102720008795089558D180F09F3740F491110EF4A9
:102730006AC160E070E080E89FE3089526F01B1610
:10274000611D711D811DD8C0F2C00CD011C109D10D
:1027500040F000D130F021F45F3F19F0C7C05111B3
:1027600052C1F5C016D198F39923C9F35523B1F39B
:10277000951B550BBB27AA2762177307840738F0F0
:102780009F5F5F4F220F331F441FAA1FA9F333D04F
:102790000E2E3AF0E0E830D091505040E695001C03
:1027A000CAF729D0FE2F27D0660F771F881FBB1FBF
:1027B000261737074807AB07B0E809F0BB0B802D99
:1027C000BF01FF2793585F4F2AF09E3F510568F0E5
:1027D0008DC019C15F3FECF3983EDCF38695779589
:1027E0006795B795F7959F5FC9F7880F911D9695E7
:1027F000879597F90895E1E0660F771F881FBB1F43
:10280000621773078407BA0720F0621B730B840BEF
:10281000BA0BEE1F88F7E0950895C3D088F09F5754
:1028200090F0B92F9927B751A0F0D1F0660F771F1C
:10283000881F991F1AF0BA95C9F712C0B13081F0FC
:10284000E1D0B1E00895DEC0672F782F8827B85F08
:1028500039F0B93FCCF3869577956795B395D9F75D
:102860003EF490958095709561957F4F8F4F9F4F67
:102870000895E89409C097FB3EF490958095709573
:1028800061957F4F8F4F9F4F9923A9F0F92F96E9BC
:10289000BB279395F695879577956795B795F11131
:1028A000F8CFFAF4BB0F11F460FF1BC06F5F7F4FCE
:1028B0008F4F9F4F16C0882311F096E911C07723E0
:1028C00021F09EE8872F762F05C0662371F096E8E9
:1028D000862F70E060E02AF09A95660F771F881FB8
:1028E000DAF7880F9695879597F9089597F99F6776
:1028F00080E870E060E00895882371F4772321F088
:102900009850872B762F07C0662311F499270DC0A6
:102910009051862B70E060E02AF09A95660F771F41
:10292000881FDAF7880F9695879597F908959F3F46
:1029300049F0915028F4869577956795B7959F5FF4
:1029400080389F4F880F9695879597F908959FEF48
:1029500080EC089500240A94161617061806090636
:10296000089500240A941216130614060506089505
:10297000092E0394000C11F4882352F0BB0F40F48D
:10298000BF2B11F460FF04C06F5F7F4F8F4F9F4FCD
:10299000089557FD9058440F551F59F05F3F71F04F
:1029A0004795880F97FB991F61F09F3F79F08795B6
:1029B0000895121613061406551FF2CF4695F1DF3F
:1029C00008C0161617061806991FF1CF86957105CF
:1029D000610508940895E5DFA0F0BEE7B91788F413
:1029E000BB279F3860F41616B11D672F782F8827F4
:1029F000985FF7CF869577956795B11D9395963932
:102A0000C8F30895E894BB2766277727CB0197F989
:102A100008950BD0ADCF9EDF28F0A3DF18F09523EB
:102A200009F064CF94CF1124EECFB3DFA0F3959FCC
:102A3000D1F3950F50E0551F629FF001729FBB27A5
:102A4000F00DB11D639FAA27F00DB11DAA1F649F51
:102A50006627B00DA11D661F829F2227B00DA11D04
:102A6000621F739FB00DA11D621F839FA00D611D8A
:102A7000221F749F3327A00D611D231F849F600DAB
:102A8000211D822F762F6A2F11249F5750408AF0E4
:102A9000E1F088234AF0EE0FFF1FBB1F661F771F70
:102AA000881F91505040A9F79E3F510570F01ECFEE
:102AB000AACF5F3FECF3983EDCF386957795679558
:102AC000B795F795E7959F5FC1F7FE2B880F911D8E
:102AD0009695879597F90895629FD001739FF001AD
:102AE000829FE00DF11D649FE00DF11D929FF00D9E
:102AF000839FF00D749FF00D659FF00D9927729FD5
:102B0000B00DE11DF91F639FB00DE11DF91FBD015F
:102B1000CF0111240895AA1BBB1B51E107C0AA1FB6
:102B2000BB1FA617B70710F0A61BB70B881F991F6E
:102B30005A95A9F780959095BC01CD010895A1E221
:102B40001A2EAA1BBB1BFD010DC0AA1FBB1FEE1F27
:102B5000FF1FA217B307E407F50720F0A21BB30B72
:102B6000E40BF50B661F771F881F991F1A9469F7EE
:102B700060957095809590959B01AC01BD01CF014A
:062B80000895F894FFCF58
:102B8600417374726F4551000103006A00066600C6
:102B9600034906004702004A00004B0000480600B1
:102BA6004D060065000661000662000667000273B6
:102BB60000064506005001004600004C0000410694
:102BC600004206005306006E00064E060044020050
:102BD6006400024301006300025A02007A000252B6
:102BE60006007200064F01005102007100025806ED
:0A2BF60000780006590200540000A8
:00000001FF

C:\Users\Thomas\AppData\Local\Temp\build-257f0514-347c-4697-aed5-e6694d4cdfa1/AstroEQ6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007a  00800100  00002b86  00002c1a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b86  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002d7  0080017a  0080017a  00002c94  2**0
                  ALLOC
  3 .debug_aranges 00000270  00000000  00000000  00002c94  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000006cd  00000000  00000000  00002f04  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003c97  00000000  00000000  000035d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000ca4  00000000  00000000  00007268  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003089  00000000  00000000  00007f0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000440  00000000  00000000  0000af98  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000111e  00000000  00000000  0000b3d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001a50  00000000  00000000  0000c4f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000400  00000000  00000000  0000df46  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

/*
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
       4:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    return inter.integer; //and convert it to an integer
}

char synta_command(){
       8:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
       c:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      10:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      14:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      18:	0c 94 58 03 	jmp	0x6b0	; 0x6b0 <__vector_6>
      1c:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      20:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      24:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      28:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      2c:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      30:	0c 94 48 04 	jmp	0x890	; 0x890 <__vector_12>
      34:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      38:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      3c:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      40:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      44:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      48:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      4c:	0c 94 c2 11 	jmp	0x2384	; 0x2384 <__vector_19>
      50:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      54:	0c 94 e2 11 	jmp	0x23c4	; 0x23c4 <__vector_21>
      58:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      5c:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      60:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      64:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      68:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      6c:	0c 94 95 00 	jmp	0x12a	; 0x12a <__bad_interrupt>
      70:	e7 07       	cpc	r30, r23
      72:	f7 07       	cpc	r31, r23
      74:	92 08       	sbc	r9, r2
      76:	37 08       	sbc	r3, r7
      78:	45 09       	sbc	r20, r5
      7a:	45 09       	sbc	r20, r5
      7c:	45 09       	sbc	r20, r5
      7e:	45 09       	sbc	r20, r5
      80:	45 09       	sbc	r20, r5
      82:	45 09       	sbc	r20, r5
      84:	45 09       	sbc	r20, r5
      86:	45 09       	sbc	r20, r5
      88:	45 09       	sbc	r20, r5
      8a:	23 08       	sbc	r2, r3
      8c:	45 09       	sbc	r20, r5
      8e:	45 09       	sbc	r20, r5
      90:	b3 08       	sbc	r11, r3
      92:	59 08       	sbc	r5, r9
      94:	07 08       	sbc	r0, r7
      96:	2f 09       	sbc	r18, r15
      98:	45 09       	sbc	r20, r5
      9a:	45 09       	sbc	r20, r5
      9c:	45 09       	sbc	r20, r5
      9e:	f8 08       	sbc	r15, r8
      a0:	24 09       	sbc	r18, r4
      a2:	7e 08       	sbc	r7, r14
      a4:	45 09       	sbc	r20, r5
      a6:	45 09       	sbc	r20, r5
      a8:	45 09       	sbc	r20, r5
      aa:	45 09       	sbc	r20, r5
      ac:	45 09       	sbc	r20, r5
      ae:	45 09       	sbc	r20, r5
      b0:	45 09       	sbc	r20, r5
      b2:	45 09       	sbc	r20, r5
      b4:	8a 08       	sbc	r8, r10
      b6:	2f 08       	sbc	r2, r15
      b8:	45 09       	sbc	r20, r5
      ba:	45 09       	sbc	r20, r5
      bc:	45 09       	sbc	r20, r5
      be:	45 09       	sbc	r20, r5
      c0:	45 09       	sbc	r20, r5
      c2:	45 09       	sbc	r20, r5
      c4:	45 09       	sbc	r20, r5
      c6:	45 09       	sbc	r20, r5
      c8:	45 09       	sbc	r20, r5
      ca:	17 08       	sbc	r1, r7
      cc:	45 09       	sbc	r20, r5
      ce:	45 09       	sbc	r20, r5
      d0:	9e 08       	sbc	r9, r14
      d2:	4f 08       	sbc	r4, r15
      d4:	45 09       	sbc	r20, r5
      d6:	45 09       	sbc	r20, r5
      d8:	45 09       	sbc	r20, r5
      da:	45 09       	sbc	r20, r5
      dc:	45 09       	sbc	r20, r5
      de:	cd 08       	sbc	r12, r13
      e0:	45 09       	sbc	r20, r5
      e2:	77 08       	sbc	r7, r7

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d4 e0       	ldi	r29, 0x04	; 4
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61

000000f0 <_Z8wdt_initv>:

// Watchdog disable on boot.
void wdt_init(void) __attribute__((naked)) __attribute__((section(".init3")));
void wdt_init(void)
{
    wdt_disable();
      f0:	88 e1       	ldi	r24, 0x18	; 24
      f2:	0f b6       	in	r0, 0x3f	; 63
      f4:	f8 94       	cli
      f6:	81 bd       	out	0x21, r24	; 33
      f8:	11 bc       	out	0x21, r1	; 33
      fa:	0f be       	out	0x3f, r0	; 63

000000fc <__do_copy_data>:
      fc:	11 e0       	ldi	r17, 0x01	; 1
      fe:	a0 e0       	ldi	r26, 0x00	; 0
     100:	b1 e0       	ldi	r27, 0x01	; 1
     102:	e6 e8       	ldi	r30, 0x86	; 134
     104:	fb e2       	ldi	r31, 0x2B	; 43
     106:	02 c0       	rjmp	.+4      	; 0x10c <.do_copy_data_start>

00000108 <.do_copy_data_loop>:
     108:	05 90       	lpm	r0, Z+
     10a:	0d 92       	st	X+, r0

0000010c <.do_copy_data_start>:
     10c:	aa 37       	cpi	r26, 0x7A	; 122
     10e:	b1 07       	cpc	r27, r17
     110:	d9 f7       	brne	.-10     	; 0x108 <.do_copy_data_loop>

00000112 <__do_clear_bss>:
     112:	14 e0       	ldi	r17, 0x04	; 4
     114:	aa e7       	ldi	r26, 0x7A	; 122
     116:	b1 e0       	ldi	r27, 0x01	; 1
     118:	01 c0       	rjmp	.+2      	; 0x11c <.do_clear_bss_start>

0000011a <.do_clear_bss_loop>:
     11a:	1d 92       	st	X+, r1

0000011c <.do_clear_bss_start>:
     11c:	a1 35       	cpi	r26, 0x51	; 81
     11e:	b1 07       	cpc	r27, r17
     120:	e1 f7       	brne	.-8      	; 0x11a <.do_clear_bss_loop>
     122:	0e 94 3d 0b 	call	0x167a	; 0x167a <main>
     126:	0c 94 c1 15 	jmp	0x2b82	; 0x2b82 <_exit>

0000012a <__bad_interrupt>:
     12a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012e <strncmp>:
     12e:	fb 01       	movw	r30, r22
     130:	dc 01       	movw	r26, r24
     132:	41 50       	subi	r20, 0x01	; 1
     134:	50 40       	sbci	r21, 0x00	; 0
     136:	30 f0       	brcs	.+12     	; 0x144 <strncmp+0x16>
     138:	8d 91       	ld	r24, X+
     13a:	01 90       	ld	r0, Z+
     13c:	80 19       	sub	r24, r0
     13e:	19 f4       	brne	.+6      	; 0x146 <strncmp+0x18>
     140:	00 20       	and	r0, r0
     142:	b9 f7       	brne	.-18     	; 0x132 <strncmp+0x4>
     144:	88 1b       	sub	r24, r24
     146:	99 0b       	sbc	r25, r25
     148:	08 95       	ret

0000014a <buildModeMapping>:
byte modeState[2] = {((LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0)), (( LOW << MODE2) | ( LOW << MODE1) | (LOW << MODE0))}; //Default to 1/8th stepping as that is the same for all

void buildModeMapping(byte microsteps, byte driverVersion){
    //For microstep modes less than 8, we cannot jump to high speed, so we use the SPEEDFAST mode maps. Given that the SPEEDFAST maps are generated for the microstepping modes >=8
    //anyway, we can simply multiply the number of microsteps by 8 if it is less than 8 and thus reduce the number of cases in the mode generation switch statement below 
    if (microsteps < 8){
     14a:	88 30       	cpi	r24, 0x08	; 8
     14c:	18 f4       	brcc	.+6      	; 0x154 <buildModeMapping+0xa>
        microsteps *= 8;
     14e:	88 0f       	add	r24, r24
     150:	88 0f       	add	r24, r24
     152:	88 0f       	add	r24, r24
    }
    //Generate the mode mapping for the current driver version and microstepping modes.
    switch (microsteps) {
     154:	88 30       	cpi	r24, 0x08	; 8
     156:	19 f0       	breq	.+6      	; 0x15e <buildModeMapping+0x14>
     158:	80 32       	cpi	r24, 0x20	; 32
     15a:	a1 f4       	brne	.+40     	; 0x184 <buildModeMapping+0x3a>
     15c:	06 c0       	rjmp	.+12     	; 0x16a <buildModeMapping+0x20>
        case 8:
            // 1/8
            modeState[SPEEDNORM] =                                                                                       (( LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     15e:	83 e0       	ldi	r24, 0x03	; 3
     160:	80 93 09 01 	sts	0x0109, r24
            // 1/1
            modeState[SPEEDFAST] =                                                                                       (( LOW << MODE2) | ( LOW << MODE1) | ( LOW << MODE0));
     164:	10 92 0a 01 	sts	0x010A, r1
     168:	08 95       	ret
            break;
        case 32:
            // 1/32
            modeState[SPEEDNORM] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | (HIGH << MODE1) | ( LOW << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     16a:	62 30       	cpi	r22, 0x02	; 2
     16c:	11 f0       	breq	.+4      	; 0x172 <buildModeMapping+0x28>
     16e:	87 e0       	ldi	r24, 0x07	; 7
     170:	01 c0       	rjmp	.+2      	; 0x174 <buildModeMapping+0x2a>
     172:	82 e2       	ldi	r24, 0x22	; 34
     174:	80 93 09 01 	sts	0x0109, r24
            // 1/4
            modeState[SPEEDFAST] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | (HIGH << MODE1) | ( LOW << MODE0));
     178:	62 30       	cpi	r22, 0x02	; 2
     17a:	11 f0       	breq	.+4      	; 0x180 <buildModeMapping+0x36>
     17c:	82 e0       	ldi	r24, 0x02	; 2
     17e:	0e c0       	rjmp	.+28     	; 0x19c <buildModeMapping+0x52>
     180:	80 e2       	ldi	r24, 0x20	; 32
     182:	0c c0       	rjmp	.+24     	; 0x19c <buildModeMapping+0x52>
            break;
        case 16:
        default:  //Unknown. Default to half/sixteenth stepping
            // 1/16
            modeState[SPEEDNORM] = (driverVersion == DRV882x) ? ((  LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     184:	61 30       	cpi	r22, 0x01	; 1
     186:	11 f0       	breq	.+4      	; 0x18c <buildModeMapping+0x42>
     188:	87 e0       	ldi	r24, 0x07	; 7
     18a:	01 c0       	rjmp	.+2      	; 0x18e <buildModeMapping+0x44>
     18c:	81 e0       	ldi	r24, 0x01	; 1
     18e:	80 93 09 01 	sts	0x0109, r24
            // 1/2
            modeState[SPEEDFAST] = (driverVersion == DRV882x) ? (( HIGH << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0));
     192:	61 30       	cpi	r22, 0x01	; 1
     194:	11 f0       	breq	.+4      	; 0x19a <buildModeMapping+0x50>
     196:	81 e0       	ldi	r24, 0x01	; 1
     198:	01 c0       	rjmp	.+2      	; 0x19c <buildModeMapping+0x52>
     19a:	84 e0       	ldi	r24, 0x04	; 4
     19c:	80 93 0a 01 	sts	0x010A, r24
     1a0:	08 95       	ret

000001a2 <standaloneModeTest>:
    //If we pull down and the pin stays high, then pin must be driven high (DRIVE HIGH)
    //If we pull up and the pin stays low, then pin must be driven low (DRIVE LOW)
    //Otherwise if pin follows us then it must be floating.

    //To start we check for an advanced controller
    setPinValue(standalonePin[STANDALONE_PULL],LOW); //Pull low
     1a2:	38 98       	cbi	0x07, 0	; 7
	...
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(allowAdvancedHCDetection && getPinValue(standalonePin[STANDALONE_IRQ])) {
     1ac:	80 91 0d 02 	lds	r24, 0x020D
     1b0:	88 23       	and	r24, r24
     1b2:	21 f0       	breq	.+8      	; 0x1bc <standaloneModeTest+0x1a>
     1b4:	82 9b       	sbis	0x10, 2	; 16
     1b6:	02 c0       	rjmp	.+4      	; 0x1bc <standaloneModeTest+0x1a>
     1b8:	82 e0       	ldi	r24, 0x02	; 2
     1ba:	08 95       	ret
        //Note: Must be an advanced controller as pin stayed high and we are allowing HC detection. (If HC detection is disallowed its because we have no external pull down available)
        return ADVANCED_HC_MODE;
    }
    //Otherwise we check for a basic controller
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Convert to external pull-up of IRQ
     1bc:	38 9a       	sbi	0x07, 0	; 7
	...
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     1c6:	80 b3       	in	r24, 0x10	; 16
     1c8:	86 95       	lsr	r24
     1ca:	86 95       	lsr	r24
     1cc:	80 95       	com	r24
     1ce:	81 70       	andi	r24, 0x01	; 1
    }


    //If we get this far then it is floating, so we assume EQMOD mode
    return EQMOD_MODE;
}
     1d0:	08 95       	ret

000001d2 <_Z17checkBasicHCSpeedv>:
    // +-----------+-----+-----+
    //
    //Note: if we don't have an external pull-up resistor, this function will return either ST-4 Rate (0,0) or GoTo Rate (1,1)
    //
    byte speed;
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     1d2:	82 99       	sbic	0x10, 2	; 16
     1d4:	02 c0       	rjmp	.+4      	; 0x1da <_Z17checkBasicHCSpeedv+0x8>
     1d6:	80 e0       	ldi	r24, 0x00	; 0
     1d8:	0b c0       	rjmp	.+22     	; 0x1f0 <_Z17checkBasicHCSpeedv+0x1e>
        //Must be a ST-4 rate as IRQ pin is low when external pull-up enabled
        speed = CMD_ST4_DEFAULT;
    } else {
        //Otherwise check which high-speed mode it is
        setPinDir  (standalonePin[STANDALONE_PULL],INPUT); //Disable external resistor by switching to input
     1da:	30 98       	cbi	0x06, 0	; 6
        setPinValue(standalonePin[STANDALONE_PULL],LOW);   //with no internal pull-up (we are using the IRQ pin internal pull-up)
     1dc:	38 98       	cbi	0x07, 0	; 7
	...
        nop(); // Input synchroniser takes a couple of cycles
        nop();
        nop();
        nop();
        
        if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     1e6:	82 9b       	sbis	0x10, 2	; 16
     1e8:	02 c0       	rjmp	.+4      	; 0x1ee <_Z17checkBasicHCSpeedv+0x1c>
     1ea:	82 e0       	ldi	r24, 0x02	; 2
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <_Z17checkBasicHCSpeedv+0x1e>
     1ee:	81 e0       	ldi	r24, 0x01	; 1
            speed = CMD_ST4_STANDALONE;
        } else {
            speed = CMD_ST4_HIGHSPEED;
        }
    }
    setPinDir  (standalonePin[STANDALONE_PULL],OUTPUT); //Ensure we leave an external pull-up of IRQ.
     1f0:	30 9a       	sbi	0x06, 0	; 6
    setPinValue(standalonePin[STANDALONE_PULL],HIGH);
     1f2:	38 9a       	sbi	0x07, 0	; 7
    //And return the new speed
    return speed;
}
     1f4:	08 95       	ret

000001f6 <motorEnable>:




void motorEnable(byte axis){
    if (axis == RA){
     1f6:	88 23       	and	r24, r24
     1f8:	29 f4       	brne	.+10     	; 0x204 <motorEnable+0xe>
        setPinValue(enablePin[RA],LOW); //IC enabled
     1fa:	96 98       	cbi	0x12, 6	; 18
inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
}

inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
     1fc:	81 e0       	ldi	r24, 0x01	; 1
     1fe:	80 93 34 02 	sts	0x0234, r24
     202:	04 c0       	rjmp	.+8      	; 0x20c <motorEnable+0x16>
        cmd_setFVal(RA,CMD_ENABLED);
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
     204:	c0 98       	cbi	0x18, 0	; 24
     206:	81 e0       	ldi	r24, 0x01	; 1
     208:	80 93 35 02 	sts	0x0235, r24
    }
}

//Timer Interrupt-----------------------------------------------------------------------------
void configureTimer(){
    interruptControlRegister(DC) = 0; //disable all timer interrupts.
     20c:	10 92 7d 00 	sts	0x007D, r1
#if defined(__AVR_ATmega162__)
    interruptControlRegister(RA) &= 0b00000011; //for 162, the lower 2 bits of the declination register control another timer, so leave them alone.
     210:	89 b7       	in	r24, 0x39	; 57
     212:	83 70       	andi	r24, 0x03	; 3
     214:	89 bf       	out	0x39, r24	; 57
#else
    interruptControlRegister(RA) = 0;
#endif
    //set to ctc mode (0100)
    TCCR1A = 0;//~((1<<WGM11) | (1<<WGM10));
     216:	1f bc       	out	0x2f, r1	; 47
    TCCR1B = ((1<<WGM12) | (1<<WGM13));
     218:	88 e1       	ldi	r24, 0x18	; 24
     21a:	8e bd       	out	0x2e, r24	; 46
    TCCR3A = 0;//~((1<<WGM31) | (1<<WGM30));
     21c:	10 92 8b 00 	sts	0x008B, r1
    TCCR3B = ((1<<WGM32) | (1<<WGM33));
     220:	80 93 8a 00 	sts	0x008A, r24
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
        cmd_setFVal(DC,CMD_ENABLED);
    }
    configureTimer(); //setup the motor pulse timers.
}
     224:	08 95       	ret

00000226 <motorDisable>:

void motorDisable(byte axis){
    if (axis == RA){
     226:	88 23       	and	r24, r24
     228:	21 f4       	brne	.+8      	; 0x232 <motorDisable+0xc>
        setPinValue(enablePin[RA],HIGH); //IC enabled
     22a:	96 9a       	sbi	0x12, 6	; 18
     22c:	10 92 34 02 	sts	0x0234, r1
     230:	08 95       	ret
        cmd_setFVal(RA,CMD_DISABLED);
    } else {
        setPinValue(enablePin[DC],HIGH); //IC enabled
     232:	c0 9a       	sbi	0x18, 0	; 24
     234:	10 92 35 02 	sts	0x0235, r1
     238:	08 95       	ret

0000023a <motorStartRA>:
        motorStartDC();
    }
}

void motorStartRA(){
    unsigned int IVal = cmd.IVal[RA];
     23a:	40 91 1e 02 	lds	r20, 0x021E
     23e:	50 91 1f 02 	lds	r21, 0x021F
    unsigned int currentIVal;
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
     242:	89 b7       	in	r24, 0x39	; 57
     244:	87 7f       	andi	r24, 0xF7	; 247
     246:	89 bf       	out	0x39, r24	; 57
    currentIVal = currentMotorSpeed(RA);
     248:	e0 91 84 00 	lds	r30, 0x0084
     24c:	f0 91 85 00 	lds	r31, 0x0085
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
     250:	89 b7       	in	r24, 0x39	; 57
     252:	88 60       	ori	r24, 0x08	; 8
     254:	89 bf       	out	0x39, r24	; 57
    
    if (IVal > cmd.minSpeed[RA]){
     256:	20 91 71 02 	lds	r18, 0x0271
     25a:	30 91 72 02 	lds	r19, 0x0272
     25e:	c9 01       	movw	r24, r18
     260:	72 2f       	mov	r23, r18
     262:	69 2f       	mov	r22, r25
     264:	24 17       	cp	r18, r20
     266:	35 07       	cpc	r19, r21
     268:	18 f4       	brcc	.+6      	; 0x270 <motorStartRA+0x36>
     26a:	ca 01       	movw	r24, r20
     26c:	74 2f       	mov	r23, r20
     26e:	69 2f       	mov	r22, r25
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[RA];
    }
    if(cmd.stopped[RA]) {
     270:	a0 91 38 02 	lds	r26, 0x0238
     274:	aa 23       	and	r26, r26
     276:	29 f4       	brne	.+10     	; 0x282 <motorStartRA+0x48>
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[RA]) {
     278:	e2 17       	cp	r30, r18
     27a:	f3 07       	cpc	r31, r19
     27c:	10 f4       	brcc	.+4      	; 0x282 <motorStartRA+0x48>
     27e:	9f 01       	movw	r18, r30
     280:	03 c0       	rjmp	.+6      	; 0x288 <motorStartRA+0x4e>
     282:	87 2f       	mov	r24, r23
     284:	96 2f       	mov	r25, r22
     286:	9c 01       	movw	r18, r24
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
     288:	89 b7       	in	r24, 0x39	; 57
     28a:	87 7f       	andi	r24, 0xF7	; 247
     28c:	89 bf       	out	0x39, r24	; 57
    cmd.currentIVal[RA] = cmd.IVal[RA];
     28e:	50 93 6e 02 	sts	0x026E, r21
     292:	40 93 6d 02 	sts	0x026D, r20
    currentMotorSpeed(RA) = startSpeed;
     296:	30 93 85 00 	sts	0x0085, r19
     29a:	20 93 84 00 	sts	0x0084, r18
    cmd.stopSpeed[RA] = stoppingSpeed;
     29e:	70 93 79 02 	sts	0x0279, r23
     2a2:	60 93 7a 02 	sts	0x027A, r22
    setPinValue(dirPin[RA],(encodeDirection[RA] != cmd.dir[RA]));
     2a6:	90 91 84 01 	lds	r25, 0x0184
     2aa:	80 91 32 02 	lds	r24, 0x0232
     2ae:	98 17       	cp	r25, r24
     2b0:	11 f0       	breq	.+4      	; 0x2b6 <motorStartRA+0x7c>
     2b2:	93 9a       	sbi	0x12, 3	; 18
     2b4:	01 c0       	rjmp	.+2      	; 0x2b8 <motorStartRA+0x7e>
     2b6:	93 98       	cbi	0x12, 3	; 18
    
    if(cmd.stopped[RA]) { //if stopped, configure timers
     2b8:	aa 23       	and	r26, r26
     2ba:	d9 f0       	breq	.+54     	; 0x2f2 <motorStartRA+0xb8>
        irqToNextStep(RA) = 1;
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	99 bd       	out	0x29, r25	; 41
     2c2:	88 bd       	out	0x28, r24	; 40
        accelTableRepeatsLeft[RA] = cmd.accelTable[RA][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
     2c4:	80 91 7f 02 	lds	r24, 0x027F
     2c8:	80 93 12 02 	sts	0x0212, r24
        accelTableIndex[RA] = 0;
     2cc:	10 92 14 02 	sts	0x0214, r1
        distributionSegment(RA) = 0;
     2d0:	12 be       	out	0x32, r1	; 50
        timerCountRegister(RA) = 0;
     2d2:	1d bc       	out	0x2d, r1	; 45
     2d4:	1c bc       	out	0x2c, r1	; 44
        interruptOVFCount(RA) = timerOVF[RA][0];
     2d6:	80 91 8a 01 	lds	r24, 0x018A
     2da:	90 91 8b 01 	lds	r25, 0x018B
     2de:	95 bd       	out	0x25, r25	; 37
     2e0:	84 bd       	out	0x24, r24	; 36
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
     2e2:	8e b5       	in	r24, 0x2e	; 46
     2e4:	89 7f       	andi	r24, 0xF9	; 249
     2e6:	8e bd       	out	0x2e, r24	; 46
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
     2e8:	8e b5       	in	r24, 0x2e	; 46
     2ea:	81 60       	ori	r24, 0x01	; 1
     2ec:	8e bd       	out	0x2e, r24	; 46
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     2ee:	10 92 38 02 	sts	0x0238, r1
        timerCountRegister(RA) = 0;
        interruptOVFCount(RA) = timerOVF[RA][0];
        timerEnable(RA);
        cmd_setStopped(RA, CMD_RUNNING);
    }
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
     2f2:	89 b7       	in	r24, 0x39	; 57
     2f4:	88 60       	ori	r24, 0x08	; 8
     2f6:	89 bf       	out	0x39, r24	; 57
}
     2f8:	08 95       	ret

000002fa <motorStartDC>:

void motorStartDC(){
    unsigned int IVal = cmd.IVal[DC];
     2fa:	40 91 20 02 	lds	r20, 0x0220
     2fe:	50 91 21 02 	lds	r21, 0x0221
    unsigned int currentIVal;
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
     302:	80 91 7d 00 	lds	r24, 0x007D
     306:	8f 7d       	andi	r24, 0xDF	; 223
     308:	80 93 7d 00 	sts	0x007D, r24
    currentIVal = currentMotorSpeed(DC);
     30c:	e0 91 86 00 	lds	r30, 0x0086
     310:	f0 91 87 00 	lds	r31, 0x0087
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
     314:	80 91 7d 00 	lds	r24, 0x007D
     318:	80 62       	ori	r24, 0x20	; 32
     31a:	80 93 7d 00 	sts	0x007D, r24
    
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    if (IVal > cmd.minSpeed[DC]){
     31e:	20 91 73 02 	lds	r18, 0x0273
     322:	30 91 74 02 	lds	r19, 0x0274
     326:	c9 01       	movw	r24, r18
     328:	72 2f       	mov	r23, r18
     32a:	69 2f       	mov	r22, r25
     32c:	24 17       	cp	r18, r20
     32e:	35 07       	cpc	r19, r21
     330:	18 f4       	brcc	.+6      	; 0x338 <motorStartDC+0x3e>
     332:	ca 01       	movw	r24, r20
     334:	74 2f       	mov	r23, r20
     336:	69 2f       	mov	r22, r25
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[DC];
    }
    if(cmd.stopped[DC]) {
     338:	a0 91 39 02 	lds	r26, 0x0239
     33c:	aa 23       	and	r26, r26
     33e:	29 f4       	brne	.+10     	; 0x34a <motorStartDC+0x50>
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[DC]) {
     340:	e2 17       	cp	r30, r18
     342:	f3 07       	cpc	r31, r19
     344:	10 f4       	brcc	.+4      	; 0x34a <motorStartDC+0x50>
     346:	9f 01       	movw	r18, r30
     348:	03 c0       	rjmp	.+6      	; 0x350 <motorStartDC+0x56>
     34a:	87 2f       	mov	r24, r23
     34c:	96 2f       	mov	r25, r22
     34e:	9c 01       	movw	r18, r24
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
     350:	80 91 7d 00 	lds	r24, 0x007D
     354:	8f 7d       	andi	r24, 0xDF	; 223
     356:	80 93 7d 00 	sts	0x007D, r24
    cmd.currentIVal[DC] = cmd.IVal[DC];
     35a:	50 93 70 02 	sts	0x0270, r21
     35e:	40 93 6f 02 	sts	0x026F, r20
    currentMotorSpeed(DC) = startSpeed;
     362:	30 93 87 00 	sts	0x0087, r19
     366:	20 93 86 00 	sts	0x0086, r18
    cmd.stopSpeed[DC] = stoppingSpeed;
     36a:	70 93 7b 02 	sts	0x027B, r23
     36e:	60 93 7c 02 	sts	0x027C, r22
    setPinValue(dirPin[DC],(encodeDirection[DC] != cmd.dir[DC]));
     372:	90 91 85 01 	lds	r25, 0x0185
     376:	80 91 33 02 	lds	r24, 0x0233
     37a:	98 17       	cp	r25, r24
     37c:	11 f0       	breq	.+4      	; 0x382 <motorStartDC+0x88>
     37e:	97 9a       	sbi	0x12, 7	; 18
     380:	01 c0       	rjmp	.+2      	; 0x384 <motorStartDC+0x8a>
     382:	97 98       	cbi	0x12, 7	; 18
    
    if(cmd.stopped[DC]) { //if stopped, configure timers
     384:	aa 23       	and	r26, r26
     386:	19 f1       	breq	.+70     	; 0x3ce <motorStartDC+0xd4>
        irqToNextStep(DC) = 1;
     388:	81 e0       	ldi	r24, 0x01	; 1
     38a:	90 e0       	ldi	r25, 0x00	; 0
     38c:	9b bd       	out	0x2b, r25	; 43
     38e:	8a bd       	out	0x2a, r24	; 42
        accelTableRepeatsLeft[DC] = cmd.accelTable[DC][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
     390:	80 91 3f 03 	lds	r24, 0x033F
     394:	80 93 13 02 	sts	0x0213, r24
        accelTableIndex[DC] = 0;
     398:	10 92 15 02 	sts	0x0215, r1
        distributionSegment(DC) = 0;
     39c:	11 be       	out	0x31, r1	; 49
        timerCountRegister(DC) = 0;
     39e:	10 92 89 00 	sts	0x0089, r1
     3a2:	10 92 88 00 	sts	0x0088, r1
        interruptOVFCount(DC) = timerOVF[DC][0];
     3a6:	80 91 ca 01 	lds	r24, 0x01CA
     3aa:	90 91 cb 01 	lds	r25, 0x01CB
     3ae:	90 93 81 00 	sts	0x0081, r25
     3b2:	80 93 80 00 	sts	0x0080, r24
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
     3b6:	80 91 8a 00 	lds	r24, 0x008A
     3ba:	89 7f       	andi	r24, 0xF9	; 249
     3bc:	80 93 8a 00 	sts	0x008A, r24
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
     3c0:	80 91 8a 00 	lds	r24, 0x008A
     3c4:	81 60       	ori	r24, 0x01	; 1
     3c6:	80 93 8a 00 	sts	0x008A, r24
     3ca:	10 92 39 02 	sts	0x0239, r1
        timerCountRegister(DC) = 0;
        interruptOVFCount(DC) = timerOVF[DC][0];
        timerEnable(DC);
        cmd_setStopped(DC, CMD_RUNNING);
    }
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
     3ce:	80 91 7d 00 	lds	r24, 0x007D
     3d2:	80 62       	ori	r24, 0x20	; 32
     3d4:	80 93 7d 00 	sts	0x007D, r24
}
     3d8:	08 95       	ret

000003da <motorStart>:
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStart functions (one for RA and one for DEC)
void motorStart(byte motor){
    if (motor == RA) {
     3da:	88 23       	and	r24, r24
     3dc:	19 f4       	brne	.+6      	; 0x3e4 <motorStart+0xa>
        motorStartRA();
     3de:	0e 94 1d 01 	call	0x23a	; 0x23a <motorStartRA>
     3e2:	08 95       	ret
    } else {
        motorStartDC();
     3e4:	0e 94 7d 01 	call	0x2fa	; 0x2fa <motorStartDC>
     3e8:	08 95       	ret

000003ea <gotoMode>:

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
}

void gotoMode(byte axis){
     3ea:	9f 92       	push	r9
     3ec:	af 92       	push	r10
     3ee:	bf 92       	push	r11
     3f0:	cf 92       	push	r12
     3f2:	df 92       	push	r13
     3f4:	ef 92       	push	r14
     3f6:	ff 92       	push	r15
     3f8:	0f 93       	push	r16
     3fa:	1f 93       	push	r17
     3fc:	cf 93       	push	r28
     3fe:	df 93       	push	r29
     400:	c8 2e       	mov	r12, r24
    unsigned int decelerationLength = gotoDecelerationLength[axis];
     402:	c8 2f       	mov	r28, r24
     404:	d0 e0       	ldi	r29, 0x00	; 0
     406:	fe 01       	movw	r30, r28
     408:	ee 0f       	add	r30, r30
     40a:	ff 1f       	adc	r31, r31
     40c:	e2 5f       	subi	r30, 0xF2	; 242
     40e:	fd 4f       	sbci	r31, 0xFD	; 253
     410:	00 81       	ld	r16, Z
     412:	11 81       	ldd	r17, Z+1	; 0x01
    
    if (cmd.highSpeedMode[axis]) {
     414:	fe 01       	movw	r30, r28
     416:	ea 5e       	subi	r30, 0xEA	; 234
     418:	fd 4f       	sbci	r31, 0xFD	; 253
     41a:	84 a1       	ldd	r24, Z+36	; 0x24
     41c:	88 23       	and	r24, r24
     41e:	29 f0       	breq	.+10     	; 0x42a <gotoMode+0x40>
        //Additionally in order to maintain the same speed profile in high-speed mode, we actually increase the profile repeats by a factor of sqrt(8)
        //compared with running in normal-speed mode. See Atmel AVR466 app note for calculation.
        decelerationLength = decelerationLength * 3; //multiply by 3 as it is approx sqrt(8)
     420:	c8 01       	movw	r24, r16
     422:	88 0f       	add	r24, r24
     424:	99 1f       	adc	r25, r25
     426:	08 0f       	add	r16, r24
     428:	19 1f       	adc	r17, r25
    }
    
    byte dirMagnitude = abs(cmd.stepDir[axis]);
     42a:	fe 01       	movw	r30, r28
     42c:	ea 5e       	subi	r30, 0xEA	; 234
     42e:	fd 4f       	sbci	r31, 0xFD	; 253
     430:	82 8d       	ldd	r24, Z+26	; 0x1a
     432:	18 16       	cp	r1, r24
     434:	14 f4       	brge	.+4      	; 0x43a <gotoMode+0x50>
     436:	d2 8c       	ldd	r13, Z+26	; 0x1a
     438:	02 c0       	rjmp	.+4      	; 0x43e <gotoMode+0x54>
     43a:	d2 8c       	ldd	r13, Z+26	; 0x1a
     43c:	d1 94       	neg	r13
    byte dir = cmd.dir[axis];
     43e:	fe 01       	movw	r30, r28
     440:	ea 5e       	subi	r30, 0xEA	; 234
     442:	fd 4f       	sbci	r31, 0xFD	; 253
     444:	94 8c       	ldd	r9, Z+28	; 0x1c

    if (cmd.HVal[axis] < 2*dirMagnitude){
     446:	8d 2d       	mov	r24, r13
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	88 0f       	add	r24, r24
     44c:	99 1f       	adc	r25, r25
     44e:	9c 01       	movw	r18, r24
     450:	44 27       	eor	r20, r20
     452:	37 fd       	sbrc	r19, 7
     454:	40 95       	com	r20
     456:	54 2f       	mov	r21, r20
     458:	fe 01       	movw	r30, r28
     45a:	ee 0f       	add	r30, r30
     45c:	ff 1f       	adc	r31, r31
     45e:	ee 0f       	add	r30, r30
     460:	ff 1f       	adc	r31, r31
     462:	ea 5e       	subi	r30, 0xEA	; 234
     464:	fd 4f       	sbci	r31, 0xFD	; 253
     466:	82 89       	ldd	r24, Z+18	; 0x12
     468:	93 89       	ldd	r25, Z+19	; 0x13
     46a:	a4 89       	ldd	r26, Z+20	; 0x14
     46c:	b5 89       	ldd	r27, Z+21	; 0x15
     46e:	82 17       	cp	r24, r18
     470:	93 07       	cpc	r25, r19
     472:	a4 07       	cpc	r26, r20
     474:	b5 07       	cpc	r27, r21
     476:	20 f4       	brcc	.+8      	; 0x480 <gotoMode+0x96>
inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
     478:	22 8b       	std	Z+18, r18	; 0x12
     47a:	33 8b       	std	Z+19, r19	; 0x13
     47c:	44 8b       	std	Z+20, r20	; 0x14
     47e:	55 8b       	std	Z+21, r21	; 0x15
        cmd_setHVal(axis,2*dirMagnitude);
    }

    decelerationLength = decelerationLength * dirMagnitude;
     480:	8d 2d       	mov	r24, r13
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	80 9f       	mul	r24, r16
     486:	b0 01       	movw	r22, r0
     488:	81 9f       	mul	r24, r17
     48a:	70 0d       	add	r23, r0
     48c:	90 9f       	mul	r25, r16
     48e:	70 0d       	add	r23, r0
     490:	11 24       	eor	r1, r1
    //decelleration length is here a multiple of stepDir.
    unsigned long HVal = cmd.HVal[axis];
     492:	fe 01       	movw	r30, r28
     494:	ee 0f       	add	r30, r30
     496:	ff 1f       	adc	r31, r31
     498:	ee 0f       	add	r30, r30
     49a:	ff 1f       	adc	r31, r31
     49c:	ea 5e       	subi	r30, 0xEA	; 234
     49e:	fd 4f       	sbci	r31, 0xFD	; 253
     4a0:	e2 88       	ldd	r14, Z+18	; 0x12
     4a2:	f3 88       	ldd	r15, Z+19	; 0x13
     4a4:	04 89       	ldd	r16, Z+20	; 0x14
     4a6:	15 89       	ldd	r17, Z+21	; 0x15
    unsigned long halfHVal = (HVal >> 1);
     4a8:	a8 01       	movw	r20, r16
     4aa:	97 01       	movw	r18, r14
     4ac:	56 95       	lsr	r21
     4ae:	47 95       	ror	r20
     4b0:	37 95       	ror	r19
     4b2:	27 95       	ror	r18
    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
     4b4:	fe 01       	movw	r30, r28
     4b6:	ee 0f       	add	r30, r30
     4b8:	ff 1f       	adc	r31, r31
     4ba:	eb 58       	subi	r30, 0x8B	; 139
     4bc:	fd 4f       	sbci	r31, 0xFD	; 253
     4be:	a0 80       	ld	r10, Z
     4c0:	b1 80       	ldd	r11, Z+1	; 0x01
    if(dirMagnitude == 8){
     4c2:	88 e0       	ldi	r24, 0x08	; 8
     4c4:	d8 16       	cp	r13, r24
     4c6:	49 f4       	brne	.+18     	; 0x4da <gotoMode+0xf0>
        HVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
     4c8:	88 ef       	ldi	r24, 0xF8	; 248
     4ca:	9f ef       	ldi	r25, 0xFF	; 255
     4cc:	af ef       	ldi	r26, 0xFF	; 255
     4ce:	bf ef       	ldi	r27, 0xFF	; 255
     4d0:	e8 22       	and	r14, r24
     4d2:	f9 22       	and	r15, r25
     4d4:	0a 23       	and	r16, r26
     4d6:	1b 23       	and	r17, r27
    }
    if(dirMagnitude == 8){
        halfHVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
     4d8:	28 7f       	andi	r18, 0xF8	; 248
    }
    //HVal and halfHVal are here a multiple of stepDir
    if (halfHVal < decelerationLength) {
     4da:	cb 01       	movw	r24, r22
     4dc:	a0 e0       	ldi	r26, 0x00	; 0
     4de:	b0 e0       	ldi	r27, 0x00	; 0
     4e0:	28 17       	cp	r18, r24
     4e2:	39 07       	cpc	r19, r25
     4e4:	4a 07       	cpc	r20, r26
     4e6:	5b 07       	cpc	r21, r27
     4e8:	08 f4       	brcc	.+2      	; 0x4ec <gotoMode+0x102>
        decelerationLength = halfHVal;
     4ea:	b9 01       	movw	r22, r18
    }
    HVal -= decelerationLength;
     4ec:	cb 01       	movw	r24, r22
     4ee:	a0 e0       	ldi	r26, 0x00	; 0
     4f0:	b0 e0       	ldi	r27, 0x00	; 0
     4f2:	a8 01       	movw	r20, r16
     4f4:	97 01       	movw	r18, r14
     4f6:	28 1b       	sub	r18, r24
     4f8:	39 0b       	sbc	r19, r25
     4fa:	4a 0b       	sbc	r20, r26
     4fc:	5b 0b       	sbc	r21, r27
     4fe:	da 01       	movw	r26, r20
     500:	c9 01       	movw	r24, r18
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
     502:	fe 01       	movw	r30, r28
     504:	ee 0f       	add	r30, r30
     506:	ff 1f       	adc	r31, r31
     508:	ee 0f       	add	r30, r30
     50a:	ff 1f       	adc	r31, r31
     50c:	ea 5e       	subi	r30, 0xEA	; 234
     50e:	fd 4f       	sbci	r31, 0xFD	; 253
     510:	20 81       	ld	r18, Z
     512:	31 81       	ldd	r19, Z+1	; 0x01
     514:	42 81       	ldd	r20, Z+2	; 0x02
     516:	53 81       	ldd	r21, Z+3	; 0x03
     518:	99 20       	and	r9, r9
     51a:	39 f0       	breq	.+14     	; 0x52a <__stack+0x2b>
     51c:	b0 95       	com	r27
     51e:	a0 95       	com	r26
     520:	90 95       	com	r25
     522:	81 95       	neg	r24
     524:	9f 4f       	sbci	r25, 0xFF	; 255
     526:	af 4f       	sbci	r26, 0xFF	; 255
     528:	bf 4f       	sbci	r27, 0xFF	; 255
     52a:	fe 01       	movw	r30, r28
     52c:	ee 0f       	add	r30, r30
     52e:	ff 1f       	adc	r31, r31
     530:	ee 0f       	add	r30, r30
     532:	ff 1f       	adc	r31, r31
     534:	e4 58       	subi	r30, 0x84	; 132
     536:	fe 4f       	sbci	r31, 0xFE	; 254
     538:	82 0f       	add	r24, r18
     53a:	93 1f       	adc	r25, r19
     53c:	a4 1f       	adc	r26, r20
     53e:	b5 1f       	adc	r27, r21
     540:	80 83       	st	Z, r24
     542:	91 83       	std	Z+1, r25	; 0x01
     544:	a2 83       	std	Z+2, r26	; 0x02
     546:	b3 83       	std	Z+3, r27	; 0x03
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
     548:	cc 0f       	add	r28, r28
     54a:	dd 1f       	adc	r29, r29
     54c:	c2 5e       	subi	r28, 0xE2	; 226
     54e:	dd 4f       	sbci	r29, 0xFD	; 253
     550:	b9 82       	std	Y+1, r11	; 0x01
     552:	a8 82       	st	Y, r10
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
}
inline void clearGotoDecelerating(const byte axis) {
    gotoControlRegister &= ~gotoDeceleratingBitMask(axis);
     554:	95 b3       	in	r25, 0x15	; 21
     556:	cc 20       	and	r12, r12
     558:	11 f4       	brne	.+4      	; 0x55e <__stack+0x5f>
     55a:	8b ef       	ldi	r24, 0xFB	; 251
     55c:	01 c0       	rjmp	.+2      	; 0x560 <__stack+0x61>
     55e:	87 ef       	ldi	r24, 0xF7	; 247
     560:	89 23       	and	r24, r25
     562:	85 bb       	out	0x15, r24	; 21
}
inline bool gotoDecelerating(const byte axis) {
    return (gotoControlRegister & gotoDeceleratingBitMask(axis));
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
     564:	95 b3       	in	r25, 0x15	; 21
     566:	cc 20       	and	r12, r12
     568:	11 f4       	brne	.+4      	; 0x56e <__stack+0x6f>
     56a:	81 e0       	ldi	r24, 0x01	; 1
     56c:	01 c0       	rjmp	.+2      	; 0x570 <__stack+0x71>
     56e:	82 e0       	ldi	r24, 0x02	; 2
     570:	89 2b       	or	r24, r25
     572:	85 bb       	out	0x15, r24	; 21
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
    
    cmd_setIVal(axis, gotoSpeed);
    clearGotoDecelerating(axis);
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
     574:	8c 2d       	mov	r24, r12
     576:	0e 94 ed 01 	call	0x3da	; 0x3da <motorStart>
}
     57a:	df 91       	pop	r29
     57c:	cf 91       	pop	r28
     57e:	1f 91       	pop	r17
     580:	0f 91       	pop	r16
     582:	ff 90       	pop	r15
     584:	ef 90       	pop	r14
     586:	df 90       	pop	r13
     588:	cf 90       	pop	r12
     58a:	bf 90       	pop	r11
     58c:	af 90       	pop	r10
     58e:	9f 90       	pop	r9
     590:	08 95       	ret

00000592 <motorStopRA>:
        motorStopDC(emergency);
    }
}

void motorStopRA(bool emergency){
    if (emergency) {
     592:	88 23       	and	r24, r24
     594:	89 f0       	breq	.+34     	; 0x5b8 <motorStopRA+0x26>
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     596:	89 b7       	in	r24, 0x39	; 57
     598:	87 7f       	andi	r24, 0xF7	; 247
     59a:	89 bf       	out	0x39, r24	; 57
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     59c:	8e b5       	in	r24, 0x2e	; 46
     59e:	88 7f       	andi	r24, 0xF8	; 248
     5a0:	8e bd       	out	0x2e, r24	; 46
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     5a2:	10 92 36 02 	sts	0x0236, r1
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     5a6:	81 e0       	ldi	r24, 0x01	; 1
     5a8:	80 93 38 02 	sts	0x0238, r24
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     5ac:	10 92 26 02 	sts	0x0226, r1
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(RA);
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
     5b0:	10 92 7a 01 	sts	0x017A, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     5b4:	a8 98       	cbi	0x15, 0	; 21
     5b6:	08 95       	ret
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
        clearGotoRunning(RA);
    } else if (!cmd.stopped[RA]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
     5b8:	80 91 38 02 	lds	r24, 0x0238
     5bc:	88 23       	and	r24, r24
     5be:	39 f5       	brne	.+78     	; 0x60e <motorStopRA+0x7c>
        //trigger ISR based decelleration
        //readyToGo[RA] = 0;
        byte oldSREG = SREG;
     5c0:	4f b7       	in	r20, 0x3f	; 63
        cli();
     5c2:	f8 94       	cli
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     5c4:	10 92 36 02 	sts	0x0236, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     5c8:	a8 98       	cbi	0x15, 0	; 21
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     5ca:	10 92 26 02 	sts	0x0226, r1
        cli();
        cmd_setGotoEn(RA,CMD_DISABLED); //No longer in goto mode.
        clearGotoRunning(RA);
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        //interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
        if(cmd.currentIVal[RA] < cmd.minSpeed[RA]){
     5ce:	20 91 71 02 	lds	r18, 0x0271
     5d2:	30 91 72 02 	lds	r19, 0x0272
     5d6:	80 91 6d 02 	lds	r24, 0x026D
     5da:	90 91 6e 02 	lds	r25, 0x026E
     5de:	82 17       	cp	r24, r18
     5e0:	93 07       	cpc	r25, r19
     5e2:	58 f4       	brcc	.+22     	; 0x5fa <motorStopRA+0x68>
            if(cmd.stopSpeed[RA] > cmd.minSpeed[RA]){
     5e4:	80 91 79 02 	lds	r24, 0x0279
     5e8:	90 91 7a 02 	lds	r25, 0x027A
     5ec:	28 17       	cp	r18, r24
     5ee:	39 07       	cpc	r19, r25
     5f0:	20 f4       	brcc	.+8      	; 0x5fa <motorStopRA+0x68>
                cmd.stopSpeed[RA] = cmd.minSpeed[RA];
     5f2:	30 93 7a 02 	sts	0x027A, r19
     5f6:	20 93 79 02 	sts	0x0279, r18
            }
        }/* else {
            stopSpeed[RA] = cmd.currentIVal[RA];
        }*/
        cmd.currentIVal[RA] = cmd.stopSpeed[RA] + 1;//cmd.stepIncrement[motor];
     5fa:	80 91 79 02 	lds	r24, 0x0279
     5fe:	90 91 7a 02 	lds	r25, 0x027A
     602:	01 96       	adiw	r24, 0x01	; 1
     604:	90 93 6e 02 	sts	0x026E, r25
     608:	80 93 6d 02 	sts	0x026D, r24
        SREG = oldSREG;
     60c:	4f bf       	out	0x3f, r20	; 63
     60e:	08 95       	ret

00000610 <motorStopDC>:
        //interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    }
}

void motorStopDC(bool emergency){
    if (emergency) {
     610:	88 23       	and	r24, r24
     612:	a9 f0       	breq	.+42     	; 0x63e <motorStopDC+0x2e>
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     614:	80 91 7d 00 	lds	r24, 0x007D
     618:	8f 7d       	andi	r24, 0xDF	; 223
     61a:	80 93 7d 00 	sts	0x007D, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     61e:	80 91 8a 00 	lds	r24, 0x008A
     622:	88 7f       	andi	r24, 0xF8	; 248
     624:	80 93 8a 00 	sts	0x008A, r24
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     628:	10 92 37 02 	sts	0x0237, r1
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	80 93 39 02 	sts	0x0239, r24
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     632:	10 92 27 02 	sts	0x0227, r1
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(DC);
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
     636:	10 92 7b 01 	sts	0x017B, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     63a:	a9 98       	cbi	0x15, 1	; 21
     63c:	08 95       	ret
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
        clearGotoRunning(DC);
    } else if (!cmd.stopped[DC]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
     63e:	80 91 39 02 	lds	r24, 0x0239
     642:	88 23       	and	r24, r24
     644:	39 f5       	brne	.+78     	; 0x694 <motorStopDC+0x84>
        //trigger ISR based decelleration
        //readyToGo[motor] = 0;
        byte oldSREG = SREG;
     646:	4f b7       	in	r20, 0x3f	; 63
        cli();
     648:	f8 94       	cli
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     64a:	10 92 37 02 	sts	0x0237, r1
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     64e:	10 92 27 02 	sts	0x0227, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     652:	a9 98       	cbi	0x15, 1	; 21
        cli();
        cmd_setGotoEn(DC,CMD_DISABLED); //No longer in goto mode.
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        clearGotoRunning(DC);
        //interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
        if(cmd.currentIVal[DC] < cmd.minSpeed[DC]){
     654:	20 91 73 02 	lds	r18, 0x0273
     658:	30 91 74 02 	lds	r19, 0x0274
     65c:	80 91 6f 02 	lds	r24, 0x026F
     660:	90 91 70 02 	lds	r25, 0x0270
     664:	82 17       	cp	r24, r18
     666:	93 07       	cpc	r25, r19
     668:	58 f4       	brcc	.+22     	; 0x680 <motorStopDC+0x70>
            if(cmd.stopSpeed[DC] > cmd.minSpeed[DC]){
     66a:	80 91 7b 02 	lds	r24, 0x027B
     66e:	90 91 7c 02 	lds	r25, 0x027C
     672:	28 17       	cp	r18, r24
     674:	39 07       	cpc	r19, r25
     676:	20 f4       	brcc	.+8      	; 0x680 <motorStopDC+0x70>
                cmd.stopSpeed[DC] = cmd.minSpeed[DC];
     678:	30 93 7c 02 	sts	0x027C, r19
     67c:	20 93 7b 02 	sts	0x027B, r18
            }
        }/* else {
        stopSpeed[DC] = cmd.currentIVal[DC];
        }*/
        cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//cmd.stepIncrement[motor];
     680:	80 91 7b 02 	lds	r24, 0x027B
     684:	90 91 7c 02 	lds	r25, 0x027C
     688:	01 96       	adiw	r24, 0x01	; 1
     68a:	90 93 70 02 	sts	0x0270, r25
     68e:	80 93 6f 02 	sts	0x026F, r24
        SREG = oldSREG;
     692:	4f bf       	out	0x3f, r20	; 63
     694:	08 95       	ret

00000696 <motorStop>:
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStop functions (one for RA and one for DEC)
void motorStop(byte motor, byte emergency){
    if (motor == RA) {
     696:	88 23       	and	r24, r24
     698:	29 f4       	brne	.+10     	; 0x6a4 <motorStop+0xe>
        motorStopRA(emergency);
     69a:	61 11       	cpse	r22, r1
     69c:	81 e0       	ldi	r24, 0x01	; 1
     69e:	0e 94 c9 02 	call	0x592	; 0x592 <motorStopRA>
     6a2:	08 95       	ret
    } else {
        motorStopDC(emergency);
     6a4:	80 e0       	ldi	r24, 0x00	; 0
     6a6:	61 11       	cpse	r22, r1
     6a8:	81 e0       	ldi	r24, 0x01	; 1
     6aa:	0e 94 08 03 	call	0x610	; 0x610 <motorStopDC>
     6ae:	08 95       	ret

000006b0 <__vector_6>:
}



/*Timer Interrupt Vector*/
ISR(TIMER3_CAPT_vect) {
     6b0:	1f 92       	push	r1
     6b2:	0f 92       	push	r0
     6b4:	0f b6       	in	r0, 0x3f	; 63
     6b6:	0f 92       	push	r0
     6b8:	11 24       	eor	r1, r1
     6ba:	2f 93       	push	r18
     6bc:	3f 93       	push	r19
     6be:	4f 93       	push	r20
     6c0:	5f 93       	push	r21
     6c2:	6f 93       	push	r22
     6c4:	7f 93       	push	r23
     6c6:	8f 93       	push	r24
     6c8:	9f 93       	push	r25
     6ca:	af 93       	push	r26
     6cc:	bf 93       	push	r27
     6ce:	ef 93       	push	r30
     6d0:	ff 93       	push	r31
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(DC)-1;
     6d2:	8a b5       	in	r24, 0x2a	; 42
     6d4:	9b b5       	in	r25, 0x2b	; 43
     6d6:	01 97       	sbiw	r24, 0x01	; 1
    //Check if we are ready to step
    if (irqToNext == 0) {
     6d8:	09 f0       	breq	.+2      	; 0x6dc <__vector_6+0x2c>
     6da:	c7 c0       	rjmp	.+398    	; 0x86a <__vector_6+0x1ba>
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(DC); //Get the current time segement
     6dc:	81 b7       	in	r24, 0x31	; 49
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(DC) = timerOVF[DC][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(DC) = *(int*)((byte*)timerOVF[DC] + index); //Update interrupt base rate.
     6de:	e8 2f       	mov	r30, r24
     6e0:	ee 73       	andi	r30, 0x3E	; 62
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	e6 53       	subi	r30, 0x36	; 54
     6e6:	fe 4f       	sbci	r31, 0xFE	; 254
     6e8:	20 81       	ld	r18, Z
     6ea:	31 81       	ldd	r19, Z+1	; 0x01
     6ec:	30 93 81 00 	sts	0x0081, r19
     6f0:	20 93 80 00 	sts	0x0080, r18
        
        distributionSegment(DC) = timeSegment + 1; //Increment time segement for next time.
     6f4:	8f 5f       	subi	r24, 0xFF	; 255
     6f6:	81 bf       	out	0x31, r24	; 49

        unsigned int currentSpeed = currentMotorSpeed(DC); //Get the current motor speed
     6f8:	60 91 86 00 	lds	r22, 0x0086
     6fc:	70 91 87 00 	lds	r23, 0x0087
        irqToNextStep(DC) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
     700:	7b bd       	out	0x2b, r23	; 43
     702:	6a bd       	out	0x2a, r22	; 42
        
        if (getPinValue(stepPin[DC])){
     704:	2a 9b       	sbis	0x05, 2	; 5
     706:	54 c0       	rjmp	.+168    	; 0x7b0 <__vector_6+0x100>
            //If the step pin is currently high...
            
            setPinValue(stepPin[DC],LOW); //set step pin low to complete step
     708:	3a 98       	cbi	0x07, 2	; 7
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[DC]; 
     70a:	80 91 1a 02 	lds	r24, 0x021A
     70e:	90 91 1b 02 	lds	r25, 0x021B
     712:	a0 91 1c 02 	lds	r26, 0x021C
     716:	b0 91 1d 02 	lds	r27, 0x021D
            jVal = jVal + cmd.stepDir[DC];
     71a:	20 91 31 02 	lds	r18, 0x0231
     71e:	33 27       	eor	r19, r19
     720:	27 fd       	sbrc	r18, 7
     722:	30 95       	com	r19
     724:	43 2f       	mov	r20, r19
     726:	53 2f       	mov	r21, r19
     728:	28 0f       	add	r18, r24
     72a:	39 1f       	adc	r19, r25
     72c:	4a 1f       	adc	r20, r26
     72e:	5b 1f       	adc	r21, r27
            cmd.jVal[DC] = jVal;
     730:	20 93 1a 02 	sts	0x021A, r18
     734:	30 93 1b 02 	sts	0x021B, r19
     738:	40 93 1c 02 	sts	0x021C, r20
     73c:	50 93 1d 02 	sts	0x021D, r21
            
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
     740:	a9 9b       	sbis	0x15, 1	; 21
     742:	1b c0       	rjmp	.+54     	; 0x77a <__vector_6+0xca>
     744:	ab 99       	sbic	0x15, 3	; 21
     746:	19 c0       	rjmp	.+50     	; 0x77a <__vector_6+0xca>
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
     748:	80 91 80 01 	lds	r24, 0x0180
     74c:	90 91 81 01 	lds	r25, 0x0181
     750:	a0 91 82 01 	lds	r26, 0x0182
     754:	b0 91 83 01 	lds	r27, 0x0183
     758:	82 17       	cp	r24, r18
     75a:	93 07       	cpc	r25, r19
     75c:	a4 07       	cpc	r26, r20
     75e:	b5 07       	cpc	r27, r21
     760:	61 f4       	brne	.+24     	; 0x77a <__vector_6+0xca>
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
     762:	ab 9a       	sbi	0x15, 3	; 21
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(DC); //Mark that we have started decelleration.
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
     764:	80 91 7b 02 	lds	r24, 0x027B
     768:	90 91 7c 02 	lds	r25, 0x027C
     76c:	01 96       	adiw	r24, 0x01	; 1
     76e:	90 93 70 02 	sts	0x0270, r25
     772:	80 93 6f 02 	sts	0x026F, r24
                    accelTableRepeatsLeft[DC] = 0;
     776:	10 92 13 02 	sts	0x0213, r1
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[DC]) {
     77a:	80 91 7b 02 	lds	r24, 0x027B
     77e:	90 91 7c 02 	lds	r25, 0x027C
     782:	86 17       	cp	r24, r22
     784:	97 07       	cpc	r25, r23
     786:	08 f0       	brcs	.+2      	; 0x78a <__vector_6+0xda>
     788:	72 c0       	rjmp	.+228    	; 0x86e <__vector_6+0x1be>
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(DC)){ 
     78a:	a9 9b       	sbis	0x15, 1	; 21
     78c:	03 c0       	rjmp	.+6      	; 0x794 <__vector_6+0xe4>
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     78e:	10 92 37 02 	sts	0x0237, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     792:	a9 98       	cbi	0x15, 1	; 21
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     794:	81 e0       	ldi	r24, 0x01	; 1
     796:	80 93 39 02 	sts	0x0239, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     79a:	80 91 7d 00 	lds	r24, 0x007D
     79e:	8f 7d       	andi	r24, 0xDF	; 223
     7a0:	80 93 7d 00 	sts	0x007D, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     7a4:	80 91 8a 00 	lds	r24, 0x008A
     7a8:	88 7f       	andi	r24, 0xF8	; 248
     7aa:	80 93 8a 00 	sts	0x008A, r24
     7ae:	5f c0       	rjmp	.+190    	; 0x86e <__vector_6+0x1be>
                cmd_setStopped(DC,CMD_STOPPED); //mark as stopped 
                timerDisable(DC);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[DC],HIGH); //Set it high to start next step.
     7b0:	3a 9a       	sbi	0x07, 2	; 7
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[DC]; //load the number of repeats left for this accel table entry
     7b2:	80 91 13 02 	lds	r24, 0x0213
            if (repeatsReqd == 0) { 
     7b6:	88 23       	and	r24, r24
     7b8:	09 f0       	breq	.+2      	; 0x7bc <__vector_6+0x10c>
     7ba:	53 c0       	rjmp	.+166    	; 0x862 <__vector_6+0x1b2>
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[DC]; //Get the target speed
     7bc:	20 91 6f 02 	lds	r18, 0x026F
     7c0:	30 91 70 02 	lds	r19, 0x0270
                if (currentSpeed > targetSpeed) {
     7c4:	26 17       	cp	r18, r22
     7c6:	37 07       	cpc	r19, r23
     7c8:	d0 f4       	brcc	.+52     	; 0x7fe <__vector_6+0x14e>
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
     7ca:	80 91 15 02 	lds	r24, 0x0215
                    if (accelIndex >= AccelTableLength-1) {
     7ce:	8f 33       	cpi	r24, 0x3F	; 63
     7d0:	08 f0       	brcs	.+2      	; 0x7d4 <__vector_6+0x124>
     7d2:	41 c0       	rjmp	.+130    	; 0x856 <__vector_6+0x1a6>
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
     7d4:	8f 5f       	subi	r24, 0xFF	; 255
                        accelTableIndex[DC] = accelIndex; //Save the new index back
     7d6:	80 93 15 02 	sts	0x0215, r24
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	fc 01       	movw	r30, r24
     7de:	ee 0f       	add	r30, r30
     7e0:	ff 1f       	adc	r31, r31
     7e2:	e8 0f       	add	r30, r24
     7e4:	f9 1f       	adc	r31, r25
     7e6:	ea 5e       	subi	r30, 0xEA	; 234
     7e8:	fd 4f       	sbci	r31, 0xFD	; 253
     7ea:	e9 5d       	subi	r30, 0xD9	; 217
     7ec:	fe 4f       	sbci	r31, 0xFE	; 254
     7ee:	60 81       	ld	r22, Z
     7f0:	71 81       	ldd	r23, Z+1	; 0x01
     7f2:	e7 52       	subi	r30, 0x27	; 39
     7f4:	f1 40       	sbci	r31, 0x01	; 1
                        if (currentSpeed <= targetSpeed) {
     7f6:	26 17       	cp	r18, r22
     7f8:	37 07       	cpc	r19, r23
     7fa:	e0 f0       	brcs	.+56     	; 0x834 <__vector_6+0x184>
     7fc:	2c c0       	rjmp	.+88     	; 0x856 <__vector_6+0x1a6>
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
     7fe:	62 17       	cp	r22, r18
     800:	73 07       	cpc	r23, r19
     802:	50 f5       	brcc	.+84     	; 0x858 <__vector_6+0x1a8>
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
     804:	80 91 15 02 	lds	r24, 0x0215
                    if (accelIndex == 0) {
     808:	88 23       	and	r24, r24
     80a:	29 f1       	breq	.+74     	; 0x856 <__vector_6+0x1a6>
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
     80c:	81 50       	subi	r24, 0x01	; 1
                        accelTableIndex[DC] = accelIndex; //Save the new index back
     80e:	80 93 15 02 	sts	0x0215, r24
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	fc 01       	movw	r30, r24
     816:	ee 0f       	add	r30, r30
     818:	ff 1f       	adc	r31, r31
     81a:	e8 0f       	add	r30, r24
     81c:	f9 1f       	adc	r31, r25
     81e:	ea 5e       	subi	r30, 0xEA	; 234
     820:	fd 4f       	sbci	r31, 0xFD	; 253
     822:	e9 5d       	subi	r30, 0xD9	; 217
     824:	fe 4f       	sbci	r31, 0xFE	; 254
     826:	60 81       	ld	r22, Z
     828:	71 81       	ldd	r23, Z+1	; 0x01
     82a:	e7 52       	subi	r30, 0x27	; 39
     82c:	f1 40       	sbci	r31, 0x01	; 1
                        if (currentSpeed >= targetSpeed) {
     82e:	62 17       	cp	r22, r18
     830:	73 07       	cpc	r23, r19
     832:	88 f4       	brcc	.+34     	; 0x856 <__vector_6+0x1a6>
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
     834:	80 91 3b 02 	lds	r24, 0x023B
     838:	e7 5d       	subi	r30, 0xD7	; 215
     83a:	fe 4f       	sbci	r31, 0xFE	; 254
     83c:	88 23       	and	r24, r24
     83e:	39 f0       	breq	.+14     	; 0x84e <__vector_6+0x19e>
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
     840:	80 81       	ld	r24, Z
     842:	23 e0       	ldi	r18, 0x03	; 3
     844:	82 9f       	mul	r24, r18
     846:	c0 01       	movw	r24, r0
     848:	11 24       	eor	r1, r1
     84a:	8e 5f       	subi	r24, 0xFE	; 254
     84c:	01 c0       	rjmp	.+2      	; 0x850 <__vector_6+0x1a0>
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
     84e:	80 81       	ld	r24, Z
     850:	80 93 13 02 	sts	0x0213, r24
     854:	01 c0       	rjmp	.+2      	; 0x858 <__vector_6+0x1a8>
     856:	b9 01       	movw	r22, r18
                            }
                        }
                    }
                }
                currentMotorSpeed(DC) = currentSpeed; //Update the current speed in case it has changed.
     858:	70 93 87 00 	sts	0x0087, r23
     85c:	60 93 86 00 	sts	0x0086, r22
     860:	06 c0       	rjmp	.+12     	; 0x86e <__vector_6+0x1be>
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[DC] = repeatsReqd - 1;
     862:	81 50       	subi	r24, 0x01	; 1
     864:	80 93 13 02 	sts	0x0213, r24
     868:	02 c0       	rjmp	.+4      	; 0x86e <__vector_6+0x1be>
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(DC) = irqToNext; //Update the number of IRQs remaining until the next step.
     86a:	9b bd       	out	0x2b, r25	; 43
     86c:	8a bd       	out	0x2a, r24	; 42
    }   


}
     86e:	ff 91       	pop	r31
     870:	ef 91       	pop	r30
     872:	bf 91       	pop	r27
     874:	af 91       	pop	r26
     876:	9f 91       	pop	r25
     878:	8f 91       	pop	r24
     87a:	7f 91       	pop	r23
     87c:	6f 91       	pop	r22
     87e:	5f 91       	pop	r21
     880:	4f 91       	pop	r20
     882:	3f 91       	pop	r19
     884:	2f 91       	pop	r18
     886:	0f 90       	pop	r0
     888:	0f be       	out	0x3f, r0	; 63
     88a:	0f 90       	pop	r0
     88c:	1f 90       	pop	r1
     88e:	18 95       	reti

00000890 <__vector_12>:




/*Timer Interrupt Vector*/
ISR(TIMER1_CAPT_vect) {
     890:	1f 92       	push	r1
     892:	0f 92       	push	r0
     894:	0f b6       	in	r0, 0x3f	; 63
     896:	0f 92       	push	r0
     898:	11 24       	eor	r1, r1
     89a:	2f 93       	push	r18
     89c:	3f 93       	push	r19
     89e:	4f 93       	push	r20
     8a0:	5f 93       	push	r21
     8a2:	6f 93       	push	r22
     8a4:	7f 93       	push	r23
     8a6:	8f 93       	push	r24
     8a8:	9f 93       	push	r25
     8aa:	af 93       	push	r26
     8ac:	bf 93       	push	r27
     8ae:	ef 93       	push	r30
     8b0:	ff 93       	push	r31
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(RA)-1;
     8b2:	88 b5       	in	r24, 0x28	; 40
     8b4:	99 b5       	in	r25, 0x29	; 41
     8b6:	01 97       	sbiw	r24, 0x01	; 1
    //Check if we are ready to step
    if (irqToNext == 0) {
     8b8:	09 f0       	breq	.+2      	; 0x8bc <__vector_12+0x2c>
     8ba:	c1 c0       	rjmp	.+386    	; 0xa3e <__vector_12+0x1ae>
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(RA); //Get the current time segement
     8bc:	82 b7       	in	r24, 0x32	; 50
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(RA) = timerOVF[RA][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(RA) = *(int*)((byte*)timerOVF[RA] + index); //Update interrupt base rate.
     8be:	e8 2f       	mov	r30, r24
     8c0:	ee 73       	andi	r30, 0x3E	; 62
     8c2:	f0 e0       	ldi	r31, 0x00	; 0
     8c4:	e6 57       	subi	r30, 0x76	; 118
     8c6:	fe 4f       	sbci	r31, 0xFE	; 254
     8c8:	20 81       	ld	r18, Z
     8ca:	31 81       	ldd	r19, Z+1	; 0x01
     8cc:	35 bd       	out	0x25, r19	; 37
     8ce:	24 bd       	out	0x24, r18	; 36
        
        distributionSegment(RA) = timeSegment + 1; //Increment time segement for next time.
     8d0:	8f 5f       	subi	r24, 0xFF	; 255
     8d2:	82 bf       	out	0x32, r24	; 50

        unsigned int currentSpeed = currentMotorSpeed(RA); //Get the current motor speed
     8d4:	60 91 84 00 	lds	r22, 0x0084
     8d8:	70 91 85 00 	lds	r23, 0x0085
        irqToNextStep(RA) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
     8dc:	79 bd       	out	0x29, r23	; 41
     8de:	68 bd       	out	0x28, r22	; 40
        
        if (getPinValue(stepPin[RA])){
     8e0:	84 9b       	sbis	0x10, 4	; 16
     8e2:	50 c0       	rjmp	.+160    	; 0x984 <__vector_12+0xf4>
            //If the step pin is currently high...
            
            setPinValue(stepPin[RA],LOW); //set step pin low to complete step
     8e4:	94 98       	cbi	0x12, 4	; 18
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[RA]; 
     8e6:	80 91 16 02 	lds	r24, 0x0216
     8ea:	90 91 17 02 	lds	r25, 0x0217
     8ee:	a0 91 18 02 	lds	r26, 0x0218
     8f2:	b0 91 19 02 	lds	r27, 0x0219
            jVal = jVal + cmd.stepDir[RA];
     8f6:	20 91 30 02 	lds	r18, 0x0230
     8fa:	33 27       	eor	r19, r19
     8fc:	27 fd       	sbrc	r18, 7
     8fe:	30 95       	com	r19
     900:	43 2f       	mov	r20, r19
     902:	53 2f       	mov	r21, r19
     904:	28 0f       	add	r18, r24
     906:	39 1f       	adc	r19, r25
     908:	4a 1f       	adc	r20, r26
     90a:	5b 1f       	adc	r21, r27
            cmd.jVal[RA] = jVal;
     90c:	20 93 16 02 	sts	0x0216, r18
     910:	30 93 17 02 	sts	0x0217, r19
     914:	40 93 18 02 	sts	0x0218, r20
     918:	50 93 19 02 	sts	0x0219, r21
            
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
     91c:	a8 9b       	sbis	0x15, 0	; 21
     91e:	1b c0       	rjmp	.+54     	; 0x956 <__vector_12+0xc6>
     920:	aa 99       	sbic	0x15, 2	; 21
     922:	19 c0       	rjmp	.+50     	; 0x956 <__vector_12+0xc6>
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
     924:	80 91 7c 01 	lds	r24, 0x017C
     928:	90 91 7d 01 	lds	r25, 0x017D
     92c:	a0 91 7e 01 	lds	r26, 0x017E
     930:	b0 91 7f 01 	lds	r27, 0x017F
     934:	82 17       	cp	r24, r18
     936:	93 07       	cpc	r25, r19
     938:	a4 07       	cpc	r26, r20
     93a:	b5 07       	cpc	r27, r21
     93c:	61 f4       	brne	.+24     	; 0x956 <__vector_12+0xc6>
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
     93e:	aa 9a       	sbi	0x15, 2	; 21
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(RA); //Mark that we have started decelleration.
                    cmd.currentIVal[RA] = cmd.stopSpeed[RA]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
     940:	80 91 79 02 	lds	r24, 0x0279
     944:	90 91 7a 02 	lds	r25, 0x027A
     948:	01 96       	adiw	r24, 0x01	; 1
     94a:	90 93 6e 02 	sts	0x026E, r25
     94e:	80 93 6d 02 	sts	0x026D, r24
                    accelTableRepeatsLeft[RA] = 0;
     952:	10 92 12 02 	sts	0x0212, r1
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[RA]) {
     956:	80 91 79 02 	lds	r24, 0x0279
     95a:	90 91 7a 02 	lds	r25, 0x027A
     95e:	86 17       	cp	r24, r22
     960:	97 07       	cpc	r25, r23
     962:	08 f0       	brcs	.+2      	; 0x966 <__vector_12+0xd6>
     964:	6e c0       	rjmp	.+220    	; 0xa42 <__vector_12+0x1b2>
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(RA)){ 
     966:	a8 9b       	sbis	0x15, 0	; 21
     968:	03 c0       	rjmp	.+6      	; 0x970 <__vector_12+0xe0>
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     96a:	10 92 36 02 	sts	0x0236, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     96e:	a8 98       	cbi	0x15, 0	; 21
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     970:	81 e0       	ldi	r24, 0x01	; 1
     972:	80 93 38 02 	sts	0x0238, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     976:	89 b7       	in	r24, 0x39	; 57
     978:	87 7f       	andi	r24, 0xF7	; 247
     97a:	89 bf       	out	0x39, r24	; 57
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     97c:	8e b5       	in	r24, 0x2e	; 46
     97e:	88 7f       	andi	r24, 0xF8	; 248
     980:	8e bd       	out	0x2e, r24	; 46
     982:	5f c0       	rjmp	.+190    	; 0xa42 <__vector_12+0x1b2>
                cmd_setStopped(RA,CMD_STOPPED); //mark as stopped 
                timerDisable(RA);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[RA],HIGH); //Set it high to start next step.
     984:	94 9a       	sbi	0x12, 4	; 18
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[RA]; //load the number of repeats left for this accel table entry
     986:	80 91 12 02 	lds	r24, 0x0212
            if (repeatsReqd == 0) { 
     98a:	88 23       	and	r24, r24
     98c:	09 f0       	breq	.+2      	; 0x990 <__vector_12+0x100>
     98e:	53 c0       	rjmp	.+166    	; 0xa36 <__vector_12+0x1a6>
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[RA]; //Get the target speed
     990:	20 91 6d 02 	lds	r18, 0x026D
     994:	30 91 6e 02 	lds	r19, 0x026E
                if (currentSpeed > targetSpeed) {
     998:	26 17       	cp	r18, r22
     99a:	37 07       	cpc	r19, r23
     99c:	d0 f4       	brcc	.+52     	; 0x9d2 <__vector_12+0x142>
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
     99e:	80 91 14 02 	lds	r24, 0x0214
                    if (accelIndex >= AccelTableLength-1) {
     9a2:	8f 33       	cpi	r24, 0x3F	; 63
     9a4:	08 f0       	brcs	.+2      	; 0x9a8 <__vector_12+0x118>
     9a6:	41 c0       	rjmp	.+130    	; 0xa2a <__vector_12+0x19a>
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
     9a8:	8f 5f       	subi	r24, 0xFF	; 255
                        accelTableIndex[RA] = accelIndex; //Save the new index back
     9aa:	80 93 14 02 	sts	0x0214, r24
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
     9ae:	90 e0       	ldi	r25, 0x00	; 0
     9b0:	fc 01       	movw	r30, r24
     9b2:	ee 0f       	add	r30, r30
     9b4:	ff 1f       	adc	r31, r31
     9b6:	e8 0f       	add	r30, r24
     9b8:	f9 1f       	adc	r31, r25
     9ba:	ea 5e       	subi	r30, 0xEA	; 234
     9bc:	fd 4f       	sbci	r31, 0xFD	; 253
     9be:	e9 59       	subi	r30, 0x99	; 153
     9c0:	ff 4f       	sbci	r31, 0xFF	; 255
     9c2:	60 81       	ld	r22, Z
     9c4:	71 81       	ldd	r23, Z+1	; 0x01
     9c6:	e7 56       	subi	r30, 0x67	; 103
     9c8:	f0 40       	sbci	r31, 0x00	; 0
                        if (currentSpeed <= targetSpeed) {
     9ca:	26 17       	cp	r18, r22
     9cc:	37 07       	cpc	r19, r23
     9ce:	e0 f0       	brcs	.+56     	; 0xa08 <__vector_12+0x178>
     9d0:	2c c0       	rjmp	.+88     	; 0xa2a <__vector_12+0x19a>
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
     9d2:	62 17       	cp	r22, r18
     9d4:	73 07       	cpc	r23, r19
     9d6:	50 f5       	brcc	.+84     	; 0xa2c <__vector_12+0x19c>
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
     9d8:	80 91 14 02 	lds	r24, 0x0214
                    if (accelIndex == 0) {
     9dc:	88 23       	and	r24, r24
     9de:	29 f1       	breq	.+74     	; 0xa2a <__vector_12+0x19a>
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
     9e0:	81 50       	subi	r24, 0x01	; 1
                        accelTableIndex[RA] = accelIndex; //Save the new index back
     9e2:	80 93 14 02 	sts	0x0214, r24
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	fc 01       	movw	r30, r24
     9ea:	ee 0f       	add	r30, r30
     9ec:	ff 1f       	adc	r31, r31
     9ee:	e8 0f       	add	r30, r24
     9f0:	f9 1f       	adc	r31, r25
     9f2:	ea 5e       	subi	r30, 0xEA	; 234
     9f4:	fd 4f       	sbci	r31, 0xFD	; 253
     9f6:	e9 59       	subi	r30, 0x99	; 153
     9f8:	ff 4f       	sbci	r31, 0xFF	; 255
     9fa:	60 81       	ld	r22, Z
     9fc:	71 81       	ldd	r23, Z+1	; 0x01
     9fe:	e7 56       	subi	r30, 0x67	; 103
     a00:	f0 40       	sbci	r31, 0x00	; 0
                        if (currentSpeed >= targetSpeed) {
     a02:	62 17       	cp	r22, r18
     a04:	73 07       	cpc	r23, r19
     a06:	88 f4       	brcc	.+34     	; 0xa2a <__vector_12+0x19a>
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
     a08:	80 91 3a 02 	lds	r24, 0x023A
     a0c:	e7 59       	subi	r30, 0x97	; 151
     a0e:	ff 4f       	sbci	r31, 0xFF	; 255
     a10:	88 23       	and	r24, r24
     a12:	39 f0       	breq	.+14     	; 0xa22 <__vector_12+0x192>
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
     a14:	80 81       	ld	r24, Z
     a16:	23 e0       	ldi	r18, 0x03	; 3
     a18:	82 9f       	mul	r24, r18
     a1a:	c0 01       	movw	r24, r0
     a1c:	11 24       	eor	r1, r1
     a1e:	8e 5f       	subi	r24, 0xFE	; 254
     a20:	01 c0       	rjmp	.+2      	; 0xa24 <__vector_12+0x194>
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
     a22:	80 81       	ld	r24, Z
     a24:	80 93 12 02 	sts	0x0212, r24
     a28:	01 c0       	rjmp	.+2      	; 0xa2c <__vector_12+0x19c>
     a2a:	b9 01       	movw	r22, r18
                            }
                        }
                    }
                }
                currentMotorSpeed(RA) = currentSpeed; //Update the current speed in case it has changed.
     a2c:	70 93 85 00 	sts	0x0085, r23
     a30:	60 93 84 00 	sts	0x0084, r22
     a34:	06 c0       	rjmp	.+12     	; 0xa42 <__vector_12+0x1b2>
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[RA] = repeatsReqd - 1;
     a36:	81 50       	subi	r24, 0x01	; 1
     a38:	80 93 12 02 	sts	0x0212, r24
     a3c:	02 c0       	rjmp	.+4      	; 0xa42 <__vector_12+0x1b2>
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(RA) = irqToNext; //Update the number of IRQs remaining until the next step.
     a3e:	99 bd       	out	0x29, r25	; 41
     a40:	88 bd       	out	0x28, r24	; 40
    }   


}
     a42:	ff 91       	pop	r31
     a44:	ef 91       	pop	r30
     a46:	bf 91       	pop	r27
     a48:	af 91       	pop	r26
     a4a:	9f 91       	pop	r25
     a4c:	8f 91       	pop	r24
     a4e:	7f 91       	pop	r23
     a50:	6f 91       	pop	r22
     a52:	5f 91       	pop	r21
     a54:	4f 91       	pop	r20
     a56:	3f 91       	pop	r19
     a58:	2f 91       	pop	r18
     a5a:	0f 90       	pop	r0
     a5c:	0f be       	out	0x3f, r0	; 63
     a5e:	0f 90       	pop	r0
     a60:	1f 90       	pop	r1
     a62:	18 95       	reti

00000a64 <storeEEPROM>:

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
}

void storeEEPROM(){
     a64:	1f 93       	push	r17
    EEPROM_writeLong(cmd.aVal[RA],aVal1_Address);
     a66:	60 91 44 02 	lds	r22, 0x0244
     a6a:	70 91 45 02 	lds	r23, 0x0245
     a6e:	80 91 46 02 	lds	r24, 0x0246
     a72:	90 91 47 02 	lds	r25, 0x0247
     a76:	4e e0       	ldi	r20, 0x0E	; 14
     a78:	50 e0       	ldi	r21, 0x00	; 0
     a7a:	0e 94 51 10 	call	0x20a2	; 0x20a2 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.aVal[DC],aVal2_Address);
     a7e:	60 91 48 02 	lds	r22, 0x0248
     a82:	70 91 49 02 	lds	r23, 0x0249
     a86:	80 91 4a 02 	lds	r24, 0x024A
     a8a:	90 91 4b 02 	lds	r25, 0x024B
     a8e:	42 e1       	ldi	r20, 0x12	; 18
     a90:	50 e0       	ldi	r21, 0x00	; 0
     a92:	0e 94 51 10 	call	0x20a2	; 0x20a2 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.bVal[RA],bVal1_Address);
     a96:	60 91 4c 02 	lds	r22, 0x024C
     a9a:	70 91 4d 02 	lds	r23, 0x024D
     a9e:	80 91 4e 02 	lds	r24, 0x024E
     aa2:	90 91 4f 02 	lds	r25, 0x024F
     aa6:	46 e1       	ldi	r20, 0x16	; 22
     aa8:	50 e0       	ldi	r21, 0x00	; 0
     aaa:	0e 94 51 10 	call	0x20a2	; 0x20a2 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.bVal[DC],bVal2_Address);
     aae:	60 91 50 02 	lds	r22, 0x0250
     ab2:	70 91 51 02 	lds	r23, 0x0251
     ab6:	80 91 52 02 	lds	r24, 0x0252
     aba:	90 91 53 02 	lds	r25, 0x0253
     abe:	4a e1       	ldi	r20, 0x1A	; 26
     ac0:	50 e0       	ldi	r21, 0x00	; 0
     ac2:	0e 94 51 10 	call	0x20a2	; 0x20a2 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.sVal[RA],sVal1_Address);
     ac6:	60 91 56 02 	lds	r22, 0x0256
     aca:	70 91 57 02 	lds	r23, 0x0257
     ace:	80 91 58 02 	lds	r24, 0x0258
     ad2:	90 91 59 02 	lds	r25, 0x0259
     ad6:	4e e1       	ldi	r20, 0x1E	; 30
     ad8:	50 e0       	ldi	r21, 0x00	; 0
     ada:	0e 94 51 10 	call	0x20a2	; 0x20a2 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.sVal[DC],sVal2_Address);
     ade:	60 91 5a 02 	lds	r22, 0x025A
     ae2:	70 91 5b 02 	lds	r23, 0x025B
     ae6:	80 91 5c 02 	lds	r24, 0x025C
     aea:	90 91 5d 02 	lds	r25, 0x025D
     aee:	42 e2       	ldi	r20, 0x22	; 34
     af0:	50 e0       	ldi	r21, 0x00	; 0
     af2:	0e 94 51 10 	call	0x20a2	; 0x20a2 <_Z16EEPROM_writeLongmj>
    EEPROM_writeByte(encodeDirection[RA],RAReverse_Address);
     af6:	80 91 84 01 	lds	r24, 0x0184
     afa:	69 e0       	ldi	r22, 0x09	; 9
     afc:	70 e0       	ldi	r23, 0x00	; 0
     afe:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(encodeDirection[DC],DECReverse_Address);
     b02:	80 91 85 01 	lds	r24, 0x0185
     b06:	6a e0       	ldi	r22, 0x0A	; 10
     b08:	70 e0       	ldi	r23, 0x00	; 0
     b0a:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(driverVersion,Driver_Address);
     b0e:	80 91 88 01 	lds	r24, 0x0188
     b12:	6b e0       	ldi	r22, 0x0B	; 11
     b14:	70 e0       	ldi	r23, 0x00	; 0
     b16:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(microstepConf,Microstep_Address);
     b1a:	80 91 87 01 	lds	r24, 0x0187
     b1e:	68 e0       	ldi	r22, 0x08	; 8
     b20:	70 e0       	ldi	r23, 0x00	; 0
     b22:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(cmd.normalGotoSpeed[RA],RAGoto_Address);
     b26:	80 91 75 02 	lds	r24, 0x0275
     b2a:	6c e0       	ldi	r22, 0x0C	; 12
     b2c:	70 e0       	ldi	r23, 0x00	; 0
     b2e:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(cmd.normalGotoSpeed[DC],DECGoto_Address);
     b32:	80 91 77 02 	lds	r24, 0x0277
     b36:	6d e0       	ldi	r22, 0x0D	; 13
     b38:	70 e0       	ldi	r23, 0x00	; 0
     b3a:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeInt(cmd.siderealIVal[RA],IVal1_Address);
     b3e:	80 91 69 02 	lds	r24, 0x0269
     b42:	90 91 6a 02 	lds	r25, 0x026A
     b46:	66 e2       	ldi	r22, 0x26	; 38
     b48:	70 e0       	ldi	r23, 0x00	; 0
     b4a:	0e 94 38 10 	call	0x2070	; 0x2070 <_Z15EEPROM_writeIntjj>
    EEPROM_writeInt(cmd.siderealIVal[DC],IVal2_Address);
     b4e:	80 91 6b 02 	lds	r24, 0x026B
     b52:	90 91 6c 02 	lds	r25, 0x026C
     b56:	68 e2       	ldi	r22, 0x28	; 40
     b58:	70 e0       	ldi	r23, 0x00	; 0
     b5a:	0e 94 38 10 	call	0x2070	; 0x2070 <_Z15EEPROM_writeIntjj>
    EEPROM_writeByte(!disableGearChange, GearEnable_Address);
     b5e:	80 91 0c 02 	lds	r24, 0x020C
     b62:	11 e0       	ldi	r17, 0x01	; 1
     b64:	81 27       	eor	r24, r17
     b66:	6a e2       	ldi	r22, 0x2A	; 42
     b68:	70 e0       	ldi	r23, 0x00	; 0
     b6a:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(!allowAdvancedHCDetection, AdvHCEnable_Address);
     b6e:	80 91 0d 02 	lds	r24, 0x020D
     b72:	81 27       	eor	r24, r17
     b74:	6b e2       	ldi	r22, 0x2B	; 43
     b76:	70 e0       	ldi	r23, 0x00	; 0
     b78:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeInt(cmd.st4DecBacklash, DecBacklash_Address);
     b7c:	80 91 67 02 	lds	r24, 0x0267
     b80:	90 91 68 02 	lds	r25, 0x0268
     b84:	6c e2       	ldi	r22, 0x2C	; 44
     b86:	70 e0       	ldi	r23, 0x00	; 0
     b88:	0e 94 38 10 	call	0x2070	; 0x2070 <_Z15EEPROM_writeIntjj>
    EEPROM_writeByte(cmd.st4SpeedFactor, SpeedFactor_Address);
     b8c:	80 91 5f 02 	lds	r24, 0x025F
     b90:	6e e2       	ldi	r22, 0x2E	; 46
     b92:	70 e0       	ldi	r23, 0x00	; 0
     b94:	0e 94 2d 10 	call	0x205a	; 0x205a <_Z16EEPROM_writeBytehj>
    EEPROM_writeAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address);
     b98:	8d e7       	ldi	r24, 0x7D	; 125
     b9a:	92 e0       	ldi	r25, 0x02	; 2
     b9c:	60 e4       	ldi	r22, 0x40	; 64
     b9e:	44 e6       	ldi	r20, 0x64	; 100
     ba0:	50 e0       	ldi	r21, 0x00	; 0
     ba2:	0e 94 80 10 	call	0x2100	; 0x2100 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>
    EEPROM_writeAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address);
     ba6:	8d e3       	ldi	r24, 0x3D	; 61
     ba8:	93 e0       	ldi	r25, 0x03	; 3
     baa:	60 e4       	ldi	r22, 0x40	; 64
     bac:	44 e2       	ldi	r20, 0x24	; 36
     bae:	51 e0       	ldi	r21, 0x01	; 1
     bb0:	0e 94 80 10 	call	0x2100	; 0x2100 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>
}
     bb4:	1f 91       	pop	r17
     bb6:	08 95       	ret

00000bb8 <buildEEPROM>:
    }
    return true;
}

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
     bb8:	80 e0       	ldi	r24, 0x00	; 0
     bba:	91 e0       	ldi	r25, 0x01	; 1
     bbc:	68 e0       	ldi	r22, 0x08	; 8
     bbe:	40 e0       	ldi	r20, 0x00	; 0
     bc0:	50 e0       	ldi	r21, 0x00	; 0
     bc2:	0e 94 68 10 	call	0x20d0	; 0x20d0 <_Z18EEPROM_writeStringPKchj>
}
     bc6:	08 95       	ret

00000bc8 <checkEEPROM>:

/*
 * EEPROM Validation and Programming Routines
 */

bool checkEEPROM(){
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	df 93       	push	r29
     bce:	cf 93       	push	r28
     bd0:	cd b7       	in	r28, 0x3d	; 61
     bd2:	de b7       	in	r29, 0x3e	; 62
     bd4:	29 97       	sbiw	r28, 0x09	; 9
     bd6:	0f b6       	in	r0, 0x3f	; 63
     bd8:	f8 94       	cli
     bda:	de bf       	out	0x3e, r29	; 62
     bdc:	0f be       	out	0x3f, r0	; 63
     bde:	cd bf       	out	0x3d, r28	; 61
    char temp[9] = {0};
     be0:	8e 01       	movw	r16, r28
     be2:	0f 5f       	subi	r16, 0xFF	; 255
     be4:	1f 4f       	sbci	r17, 0xFF	; 255
     be6:	89 e0       	ldi	r24, 0x09	; 9
     be8:	f8 01       	movw	r30, r16
     bea:	11 92       	st	Z+, r1
     bec:	8a 95       	dec	r24
     bee:	e9 f7       	brne	.-6      	; 0xbea <checkEEPROM+0x22>
    EEPROM_readString(temp,8,AstroEQID_Address);
     bf0:	c8 01       	movw	r24, r16
     bf2:	68 e0       	ldi	r22, 0x08	; 8
     bf4:	40 e0       	ldi	r20, 0x00	; 0
     bf6:	50 e0       	ldi	r21, 0x00	; 0
     bf8:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <_Z17EEPROM_readStringPchj>
    if(strncmp(temp,"AstroEQ",8)){
     bfc:	c8 01       	movw	r24, r16
     bfe:	60 e0       	ldi	r22, 0x00	; 0
     c00:	71 e0       	ldi	r23, 0x01	; 1
     c02:	48 e0       	ldi	r20, 0x08	; 8
     c04:	50 e0       	ldi	r21, 0x00	; 0
     c06:	0e 94 97 00 	call	0x12e	; 0x12e <strncmp>
     c0a:	00 97       	sbiw	r24, 0x00	; 0
     c0c:	91 f5       	brne	.+100    	; 0xc72 <checkEEPROM+0xaa>
        return false;
    }
    if (driverVersion > DRV8834){
     c0e:	80 91 88 01 	lds	r24, 0x0188
     c12:	83 30       	cpi	r24, 0x03	; 3
     c14:	70 f5       	brcc	.+92     	; 0xc72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((driverVersion == A498x) && microstepConf > 16){
     c16:	88 23       	and	r24, r24
     c18:	21 f4       	brne	.+8      	; 0xc22 <checkEEPROM+0x5a>
     c1a:	80 91 87 01 	lds	r24, 0x0187
     c1e:	81 31       	cpi	r24, 0x11	; 17
     c20:	40 f5       	brcc	.+80     	; 0xc72 <checkEEPROM+0xaa>
        return false; //invalid value.
    } else if (microstepConf > 32){
     c22:	80 91 87 01 	lds	r24, 0x0187
     c26:	81 32       	cpi	r24, 0x21	; 33
     c28:	20 f5       	brcc	.+72     	; 0xc72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[RA] > 1200) || (cmd.siderealIVal[RA] < MIN_IVAL)) {
     c2a:	80 91 69 02 	lds	r24, 0x0269
     c2e:	90 91 6a 02 	lds	r25, 0x026A
     c32:	c2 97       	sbiw	r24, 0x32	; 50
     c34:	8f 57       	subi	r24, 0x7F	; 127
     c36:	94 40       	sbci	r25, 0x04	; 4
     c38:	e0 f4       	brcc	.+56     	; 0xc72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[DC] > 1200) || (cmd.siderealIVal[DC] < MIN_IVAL)) {
     c3a:	80 91 6b 02 	lds	r24, 0x026B
     c3e:	90 91 6c 02 	lds	r25, 0x026C
     c42:	c2 97       	sbiw	r24, 0x32	; 50
     c44:	8f 57       	subi	r24, 0x7F	; 127
     c46:	94 40       	sbci	r25, 0x04	; 4
     c48:	a0 f4       	brcc	.+40     	; 0xc72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[RA] == 0){
     c4a:	80 91 75 02 	lds	r24, 0x0275
     c4e:	90 91 76 02 	lds	r25, 0x0276
     c52:	89 2b       	or	r24, r25
     c54:	71 f0       	breq	.+28     	; 0xc72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[DC] == 0){
     c56:	80 91 77 02 	lds	r24, 0x0277
     c5a:	90 91 78 02 	lds	r25, 0x0278
     c5e:	89 2b       	or	r24, r25
     c60:	41 f0       	breq	.+16     	; 0xc72 <checkEEPROM+0xaa>
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	80 91 5f 02 	lds	r24, 0x025F
     c68:	81 50       	subi	r24, 0x01	; 1
     c6a:	83 31       	cpi	r24, 0x13	; 19
     c6c:	18 f4       	brcc	.+6      	; 0xc74 <checkEEPROM+0xac>
     c6e:	91 e0       	ldi	r25, 0x01	; 1
     c70:	01 c0       	rjmp	.+2      	; 0xc74 <checkEEPROM+0xac>
     c72:	90 e0       	ldi	r25, 0x00	; 0
    }
    if((cmd.st4SpeedFactor < 1) || (cmd.st4SpeedFactor > 19)){
        return false; //invalid value
    }
    return true;
}
     c74:	89 2f       	mov	r24, r25
     c76:	29 96       	adiw	r28, 0x09	; 9
     c78:	0f b6       	in	r0, 0x3f	; 63
     c7a:	f8 94       	cli
     c7c:	de bf       	out	0x3e, r29	; 62
     c7e:	0f be       	out	0x3f, r0	; 63
     c80:	cd bf       	out	0x3d, r28	; 61
     c82:	cf 91       	pop	r28
     c84:	df 91       	pop	r29
     c86:	1f 91       	pop	r17
     c88:	0f 91       	pop	r16
     c8a:	08 95       	ret

00000c8c <decodeCommand>:

/*
 * Decode and Perform the Command
 */

bool decodeCommand(char command, char* buffer){ //each command is axis specific. The axis being modified can be retrieved by calling synta_axis()
     c8c:	8f 92       	push	r8
     c8e:	9f 92       	push	r9
     c90:	af 92       	push	r10
     c92:	bf 92       	push	r11
     c94:	cf 92       	push	r12
     c96:	df 92       	push	r13
     c98:	ef 92       	push	r14
     c9a:	ff 92       	push	r15
     c9c:	0f 93       	push	r16
     c9e:	1f 93       	push	r17
     ca0:	cf 93       	push	r28
     ca2:	df 93       	push	r29
     ca4:	a8 2e       	mov	r10, r24
     ca6:	4b 01       	movw	r8, r22
    unsigned long responseData = 0; //data for response
    bool success = true;
    byte axis = synta_axis();
     ca8:	82 e0       	ldi	r24, 0x02	; 2
     caa:	0e 94 2c 12 	call	0x2458	; 0x2458 <_Z10synta_axish>
     cae:	b8 2e       	mov	r11, r24
    unsigned int correction;
    byte oldSREG;
    switch(command) {
     cb0:	0f e4       	ldi	r16, 0x4F	; 79
     cb2:	a0 16       	cp	r10, r16
     cb4:	09 f4       	brne	.+2      	; 0xcb8 <decodeCommand+0x2c>
     cb6:	51 c1       	rjmp	.+674    	; 0xf5a <decodeCommand+0x2ce>
     cb8:	0a 15       	cp	r16, r10
     cba:	fc f0       	brlt	.+62     	; 0xcfa <decodeCommand+0x6e>
     cbc:	18 e4       	ldi	r17, 0x48	; 72
     cbe:	a1 16       	cp	r10, r17
     cc0:	09 f4       	brne	.+2      	; 0xcc4 <decodeCommand+0x38>
     cc2:	ea c0       	rjmp	.+468    	; 0xe98 <decodeCommand+0x20c>
     cc4:	1a 15       	cp	r17, r10
     cc6:	64 f0       	brlt	.+24     	; 0xce0 <decodeCommand+0x54>
     cc8:	26 e4       	ldi	r18, 0x46	; 70
     cca:	a2 16       	cp	r10, r18
     ccc:	09 f4       	brne	.+2      	; 0xcd0 <decodeCommand+0x44>
     cce:	3c c1       	rjmp	.+632    	; 0xf48 <decodeCommand+0x2bc>
     cd0:	2a 15       	cp	r18, r10
     cd2:	0c f4       	brge	.+2      	; 0xcd6 <decodeCommand+0x4a>
     cd4:	cb c0       	rjmp	.+406    	; 0xe6c <decodeCommand+0x1e0>
     cd6:	85 e4       	ldi	r24, 0x45	; 69
     cd8:	a8 16       	cp	r10, r24
     cda:	09 f0       	breq	.+2      	; 0xcde <decodeCommand+0x52>
     cdc:	5e c1       	rjmp	.+700    	; 0xf9a <decodeCommand+0x30e>
     cde:	21 c1       	rjmp	.+578    	; 0xf22 <decodeCommand+0x296>
     ce0:	ab e4       	ldi	r26, 0x4B	; 75
     ce2:	aa 16       	cp	r10, r26
     ce4:	09 f4       	brne	.+2      	; 0xce8 <decodeCommand+0x5c>
     ce6:	b5 c0       	rjmp	.+362    	; 0xe52 <decodeCommand+0x1c6>
     ce8:	bc e4       	ldi	r27, 0x4C	; 76
     cea:	ab 16       	cp	r10, r27
     cec:	09 f4       	brne	.+2      	; 0xcf0 <decodeCommand+0x64>
     cee:	b7 c0       	rjmp	.+366    	; 0xe5e <decodeCommand+0x1d2>
     cf0:	e9 e4       	ldi	r30, 0x49	; 73
     cf2:	ae 16       	cp	r10, r30
     cf4:	09 f0       	breq	.+2      	; 0xcf8 <decodeCommand+0x6c>
     cf6:	51 c1       	rjmp	.+674    	; 0xf9a <decodeCommand+0x30e>
     cf8:	e3 c0       	rjmp	.+454    	; 0xec0 <decodeCommand+0x234>
     cfa:	f6 e6       	ldi	r31, 0x66	; 102
     cfc:	af 16       	cp	r10, r31
     cfe:	09 f4       	brne	.+2      	; 0xd02 <decodeCommand+0x76>
     d00:	76 c0       	rjmp	.+236    	; 0xdee <decodeCommand+0x162>
     d02:	fa 15       	cp	r31, r10
     d04:	5c f0       	brlt	.+22     	; 0xd1c <decodeCommand+0x90>
     d06:	02 e6       	ldi	r16, 0x62	; 98
     d08:	a0 16       	cp	r10, r16
     d0a:	79 f1       	breq	.+94     	; 0xd6a <decodeCommand+0xde>
     d0c:	15 e6       	ldi	r17, 0x65	; 101
     d0e:	a1 16       	cp	r10, r17
     d10:	91 f0       	breq	.+36     	; 0xd36 <decodeCommand+0xaa>
     d12:	21 e6       	ldi	r18, 0x61	; 97
     d14:	a2 16       	cp	r10, r18
     d16:	09 f0       	breq	.+2      	; 0xd1a <decodeCommand+0x8e>
     d18:	40 c1       	rjmp	.+640    	; 0xf9a <decodeCommand+0x30e>
     d1a:	1a c0       	rjmp	.+52     	; 0xd50 <decodeCommand+0xc4>
     d1c:	8a e6       	ldi	r24, 0x6A	; 106
     d1e:	a8 16       	cp	r10, r24
     d20:	09 f4       	brne	.+2      	; 0xd24 <decodeCommand+0x98>
     d22:	87 c0       	rjmp	.+270    	; 0xe32 <decodeCommand+0x1a6>
     d24:	a3 e7       	ldi	r26, 0x73	; 115
     d26:	aa 16       	cp	r10, r26
     d28:	09 f4       	brne	.+2      	; 0xd2c <decodeCommand+0xa0>
     d2a:	54 c0       	rjmp	.+168    	; 0xdd4 <decodeCommand+0x148>
     d2c:	b7 e6       	ldi	r27, 0x67	; 103
     d2e:	ab 16       	cp	r10, r27
     d30:	09 f0       	breq	.+2      	; 0xd34 <decodeCommand+0xa8>
     d32:	33 c1       	rjmp	.+614    	; 0xf9a <decodeCommand+0x30e>
     d34:	4a c0       	rjmp	.+148    	; 0xdca <decodeCommand+0x13e>
        case 'e': //readonly, return the eVal (version number)
            responseData = cmd.eVal[axis]; //response to the e command is stored in the eVal function for that axis.
     d36:	e8 2f       	mov	r30, r24
     d38:	f0 e0       	ldi	r31, 0x00	; 0
     d3a:	ee 0f       	add	r30, r30
     d3c:	ff 1f       	adc	r31, r31
     d3e:	ee 0f       	add	r30, r30
     d40:	ff 1f       	adc	r31, r31
     d42:	ea 5e       	subi	r30, 0xEA	; 234
     d44:	fd 4f       	sbci	r31, 0xFD	; 253
     d46:	26 a1       	ldd	r18, Z+38	; 0x26
     d48:	37 a1       	ldd	r19, Z+39	; 0x27
     d4a:	40 a5       	ldd	r20, Z+40	; 0x28
     d4c:	51 a5       	ldd	r21, Z+41	; 0x29
     d4e:	a1 c2       	rjmp	.+1346   	; 0x1292 <decodeCommand+0x606>
            break;
        case 'a': //readonly, return the aVal (steps per axis)
            responseData = cmd.aVal[axis]; //response to the a command is stored in the aVal function for that axis.
     d50:	e8 2f       	mov	r30, r24
     d52:	f0 e0       	ldi	r31, 0x00	; 0
     d54:	ee 0f       	add	r30, r30
     d56:	ff 1f       	adc	r31, r31
     d58:	ee 0f       	add	r30, r30
     d5a:	ff 1f       	adc	r31, r31
     d5c:	ea 5e       	subi	r30, 0xEA	; 234
     d5e:	fd 4f       	sbci	r31, 0xFD	; 253
     d60:	26 a5       	ldd	r18, Z+46	; 0x2e
     d62:	37 a5       	ldd	r19, Z+47	; 0x2f
     d64:	40 a9       	ldd	r20, Z+48	; 0x30
     d66:	51 a9       	ldd	r21, Z+49	; 0x31
     d68:	94 c2       	rjmp	.+1320   	; 0x1292 <decodeCommand+0x606>
            break;
        case 'b': //readonly, return the bVal (sidereal step rate)
            responseData = cmd.bVal[axis]; //response to the b command is stored in the bVal function for that axis.
     d6a:	a8 2f       	mov	r26, r24
     d6c:	b0 e0       	ldi	r27, 0x00	; 0
     d6e:	fd 01       	movw	r30, r26
     d70:	ee 0f       	add	r30, r30
     d72:	ff 1f       	adc	r31, r31
     d74:	ee 0f       	add	r30, r30
     d76:	ff 1f       	adc	r31, r31
     d78:	ea 5e       	subi	r30, 0xEA	; 234
     d7a:	fd 4f       	sbci	r31, 0xFD	; 253
     d7c:	26 a9       	ldd	r18, Z+54	; 0x36
     d7e:	37 a9       	ldd	r19, Z+55	; 0x37
     d80:	40 ad       	ldd	r20, Z+56	; 0x38
     d82:	51 ad       	ldd	r21, Z+57	; 0x39
            if (!progMode) {
     d84:	80 91 86 01 	lds	r24, 0x0186
     d88:	88 23       	and	r24, r24
     d8a:	09 f0       	breq	.+2      	; 0xd8e <decodeCommand+0x102>
     d8c:	82 c2       	rjmp	.+1284   	; 0x1292 <decodeCommand+0x606>
                //If not in programming mode, we need to apply a correction factor to ensure that calculations in EQMOD round correctly
                correction = (cmd.siderealIVal[axis] << 1);
     d8e:	aa 0f       	add	r26, r26
     d90:	bb 1f       	adc	r27, r27
     d92:	a7 59       	subi	r26, 0x97	; 151
     d94:	bd 4f       	sbci	r27, 0xFD	; 253
     d96:	ed 90       	ld	r14, X+
     d98:	fc 90       	ld	r15, X
     d9a:	ee 0c       	add	r14, r14
     d9c:	ff 1c       	adc	r15, r15
                responseData = (responseData * (correction+1))/correction; //account for rounding inside Skywatcher DLL.
     d9e:	08 94       	sec
     da0:	e1 1c       	adc	r14, r1
     da2:	f1 1c       	adc	r15, r1
     da4:	b7 01       	movw	r22, r14
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	08 94       	sec
     dac:	e1 08       	sbc	r14, r1
     dae:	f1 08       	sbc	r15, r1
     db0:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <__mulsi3>
     db4:	00 e0       	ldi	r16, 0x00	; 0
     db6:	10 e0       	ldi	r17, 0x00	; 0
     db8:	a8 01       	movw	r20, r16
     dba:	97 01       	movw	r18, r14
     dbc:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <__udivmodsi4>
     dc0:	c9 01       	movw	r24, r18
     dc2:	da 01       	movw	r26, r20
     dc4:	9c 01       	movw	r18, r24
     dc6:	ad 01       	movw	r20, r26
     dc8:	64 c2       	rjmp	.+1224   	; 0x1292 <decodeCommand+0x606>
            }
            break;
        case 'g': //readonly, return the gVal (high speed multiplier)
            responseData = cmd.gVal[axis]; //response to the g command is stored in the gVal function for that axis.
     dca:	eb 2d       	mov	r30, r11
     dcc:	f0 e0       	ldi	r31, 0x00	; 0
     dce:	ec 5a       	subi	r30, 0xAC	; 172
     dd0:	fd 4f       	sbci	r31, 0xFD	; 253
     dd2:	a4 c1       	rjmp	.+840    	; 0x111c <decodeCommand+0x490>
            break;
        case 's': //readonly, return the sVal (steps per worm rotation)
            responseData = cmd.sVal[axis]; //response to the s command is stored in the sVal function for that axis.
     dd4:	eb 2d       	mov	r30, r11
     dd6:	f0 e0       	ldi	r31, 0x00	; 0
     dd8:	ee 0f       	add	r30, r30
     dda:	ff 1f       	adc	r31, r31
     ddc:	ee 0f       	add	r30, r30
     dde:	ff 1f       	adc	r31, r31
     de0:	ea 5a       	subi	r30, 0xAA	; 170
     de2:	fd 4f       	sbci	r31, 0xFD	; 253
     de4:	20 81       	ld	r18, Z
     de6:	31 81       	ldd	r19, Z+1	; 0x01
     de8:	42 81       	ldd	r20, Z+2	; 0x02
     dea:	53 81       	ldd	r21, Z+3	; 0x03
     dec:	52 c2       	rjmp	.+1188   	; 0x1292 <decodeCommand+0x606>
    }
}

inline unsigned int cmd_fVal(byte target){ //_fVal: 00ds000g000f; d = dir, s = stopped, g = goto, f = energised
    unsigned int fVal = 0;
    if (cmd.dir[target]) {
     dee:	a8 2f       	mov	r26, r24
     df0:	b0 e0       	ldi	r27, 0x00	; 0
     df2:	fd 01       	movw	r30, r26
     df4:	ea 5e       	subi	r30, 0xEA	; 234
     df6:	fd 4f       	sbci	r31, 0xFD	; 253
     df8:	84 8d       	ldd	r24, Z+28	; 0x1c
     dfa:	88 23       	and	r24, r24
     dfc:	19 f0       	breq	.+6      	; 0xe04 <decodeCommand+0x178>
     dfe:	20 e0       	ldi	r18, 0x00	; 0
     e00:	32 e0       	ldi	r19, 0x02	; 2
     e02:	02 c0       	rjmp	.+4      	; 0xe08 <decodeCommand+0x17c>
     e04:	20 e0       	ldi	r18, 0x00	; 0
     e06:	30 e0       	ldi	r19, 0x00	; 0
        fVal |= (1 << 9);
    }
    if (cmd.stopped[target]) {
     e08:	fd 01       	movw	r30, r26
     e0a:	ea 5e       	subi	r30, 0xEA	; 234
     e0c:	fd 4f       	sbci	r31, 0xFD	; 253
     e0e:	82 a1       	ldd	r24, Z+34	; 0x22
     e10:	81 11       	cpse	r24, r1
        fVal |= (1 << 8);
     e12:	31 60       	ori	r19, 0x01	; 1
    }
    if (cmd.gotoEn[target]) {
     e14:	fd 01       	movw	r30, r26
     e16:	ea 5e       	subi	r30, 0xEA	; 234
     e18:	fd 4f       	sbci	r31, 0xFD	; 253
     e1a:	80 a1       	ldd	r24, Z+32	; 0x20
     e1c:	81 11       	cpse	r24, r1
        fVal |= (1 << 4);
     e1e:	20 61       	ori	r18, 0x10	; 16
    }
    if (cmd.FVal[target]){
     e20:	aa 5e       	subi	r26, 0xEA	; 234
     e22:	bd 4f       	sbci	r27, 0xFD	; 253
     e24:	5e 96       	adiw	r26, 0x1e	; 30
     e26:	8c 91       	ld	r24, X
     e28:	88 23       	and	r24, r24
     e2a:	09 f4       	brne	.+2      	; 0xe2e <decodeCommand+0x1a2>
     e2c:	09 c1       	rjmp	.+530    	; 0x1040 <decodeCommand+0x3b4>
        fVal |= (1 << 0);
     e2e:	21 60       	ori	r18, 0x01	; 1
     e30:	07 c1       	rjmp	.+526    	; 0x1040 <decodeCommand+0x3b4>
            break;
        case 'f': //readonly, return the fVal (axis status)
            responseData = cmd_fVal(axis); //response to the f command is stored in the fVal function for that axis.
            break;
        case 'j': //readonly, return the jVal (current position)
            oldSREG = SREG; 
     e32:	8f b7       	in	r24, 0x3f	; 63
            cli();  //The next bit needs to be atomic, just in case the motors are running
     e34:	f8 94       	cli
            responseData = cmd.jVal[axis]; //response to the j command is stored in the jVal function for that axis.
     e36:	eb 2d       	mov	r30, r11
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	ee 0f       	add	r30, r30
     e3c:	ff 1f       	adc	r31, r31
     e3e:	ee 0f       	add	r30, r30
     e40:	ff 1f       	adc	r31, r31
     e42:	ea 5e       	subi	r30, 0xEA	; 234
     e44:	fd 4f       	sbci	r31, 0xFD	; 253
     e46:	20 81       	ld	r18, Z
     e48:	31 81       	ldd	r19, Z+1	; 0x01
     e4a:	42 81       	ldd	r20, Z+2	; 0x02
     e4c:	53 81       	ldd	r21, Z+3	; 0x03
            SREG = oldSREG;
     e4e:	8f bf       	out	0x3f, r24	; 63
     e50:	20 c2       	rjmp	.+1088   	; 0x1292 <decodeCommand+0x606>
            break;
        case 'K': //stop the motor, return empty response
            motorStop(axis,0); //normal ISR based decelleration trigger.
     e52:	60 e0       	ldi	r22, 0x00	; 0
     e54:	0e 94 4b 03 	call	0x696	; 0x696 <motorStop>
            readyToGo[axis] = 0;
     e58:	eb 2d       	mov	r30, r11
     e5a:	f0 e0       	ldi	r31, 0x00	; 0
     e5c:	19 c0       	rjmp	.+50     	; 0xe90 <decodeCommand+0x204>
            break;
        case 'L':
            motorStop(axis,1); //emergency axis stop.
     e5e:	61 e0       	ldi	r22, 0x01	; 1
     e60:	0e 94 4b 03 	call	0x696	; 0x696 <motorStop>
            motorDisable(axis); //shutdown driver power.
     e64:	8b 2d       	mov	r24, r11
     e66:	0e 94 13 01 	call	0x226	; 0x226 <motorDisable>
     e6a:	0f c2       	rjmp	.+1054   	; 0x128a <decodeCommand+0x5fe>
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     e6c:	e8 2f       	mov	r30, r24
     e6e:	f0 e0       	ldi	r31, 0x00	; 0
     e70:	df 01       	movw	r26, r30
     e72:	aa 5e       	subi	r26, 0xEA	; 234
     e74:	bd 4f       	sbci	r27, 0xFD	; 253
     e76:	e4 01       	movw	r28, r8
     e78:	88 81       	ld	r24, Y
     e7a:	80 53       	subi	r24, 0x30	; 48
     e7c:	50 96       	adiw	r26, 0x10	; 16
     e7e:	8c 93       	st	X, r24
     e80:	50 97       	sbiw	r26, 0x10	; 16
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	89 81       	ldd	r24, Y+1	; 0x01
     e86:	80 33       	cpi	r24, 0x30	; 48
     e88:	09 f0       	breq	.+2      	; 0xe8c <decodeCommand+0x200>
     e8a:	91 e0       	ldi	r25, 0x01	; 1
     e8c:	5c 96       	adiw	r26, 0x1c	; 28
     e8e:	9c 93       	st	X, r25
            /*if (packetIn[0] == '0'){
              packetIn[0] = '2'; //don't allow a high torque goto. But do allow a high torque slew.
            }*/
            cmd_setGVal(axis, (buffer[0] - '0')); //Store the current mode for the axis
            cmd_setDir(axis, (buffer[1] != '0') ? CMD_REVERSE : CMD_FORWARD); //Store the current direction for that axis
            readyToGo[axis] = 0;
     e90:	e6 58       	subi	r30, 0x86	; 134
     e92:	fe 4f       	sbci	r31, 0xFE	; 254
     e94:	10 82       	st	Z, r1
     e96:	f9 c1       	rjmp	.+1010   	; 0x128a <decodeCommand+0x5fe>
            break;
        case 'H': //set goto position, return empty response (this sets the number of steps to move from cuurent position if in goto mode)
            cmd_setHVal(axis, synta_hexToLong(buffer)); //set the goto position container (convert string to long first)
     e98:	c4 01       	movw	r24, r8
     e9a:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
     e9e:	ab 2d       	mov	r26, r11
     ea0:	b0 e0       	ldi	r27, 0x00	; 0
     ea2:	fd 01       	movw	r30, r26
     ea4:	ee 0f       	add	r30, r30
     ea6:	ff 1f       	adc	r31, r31
     ea8:	ee 0f       	add	r30, r30
     eaa:	ff 1f       	adc	r31, r31
     eac:	ea 5e       	subi	r30, 0xEA	; 234
     eae:	fd 4f       	sbci	r31, 0xFD	; 253
     eb0:	62 8b       	std	Z+18, r22	; 0x12
     eb2:	73 8b       	std	Z+19, r23	; 0x13
     eb4:	84 8b       	std	Z+20, r24	; 0x14
     eb6:	95 8b       	std	Z+21, r25	; 0x15
            readyToGo[axis] = 0;
     eb8:	a6 58       	subi	r26, 0x86	; 134
     eba:	be 4f       	sbci	r27, 0xFE	; 254
     ebc:	1c 92       	st	X, r1
     ebe:	e5 c1       	rjmp	.+970    	; 0x128a <decodeCommand+0x5fe>
            break;
        case 'I': //set slew speed, return empty response (this sets the speed to move at if in slew mode)
            responseData = synta_hexToLong(buffer); //convert string to long first
     ec0:	c4 01       	movw	r24, r8
     ec2:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
            if (responseData < cmd.accelTable[axis][AccelTableLength-1].speed) {
     ec6:	cb 2c       	mov	r12, r11
     ec8:	dd 24       	eor	r13, r13
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
     eca:	e6 01       	movw	r28, r12
     ecc:	cc 0f       	add	r28, r28
     ece:	dd 1f       	adc	r29, r29
     ed0:	c2 5e       	subi	r28, 0xE2	; 226
     ed2:	dd 4f       	sbci	r29, 0xFD	; 253
     ed4:	20 ec       	ldi	r18, 0xC0	; 192
     ed6:	30 e0       	ldi	r19, 0x00	; 0
     ed8:	c2 9e       	mul	r12, r18
     eda:	f0 01       	movw	r30, r0
     edc:	c3 9e       	mul	r12, r19
     ede:	f0 0d       	add	r31, r0
     ee0:	d2 9e       	mul	r13, r18
     ee2:	f0 0d       	add	r31, r0
     ee4:	11 24       	eor	r1, r1
     ee6:	e6 5c       	subi	r30, 0xC6	; 198
     ee8:	fc 4f       	sbci	r31, 0xFC	; 252
     eea:	20 81       	ld	r18, Z
     eec:	31 81       	ldd	r19, Z+1	; 0x01
     eee:	79 01       	movw	r14, r18
     ef0:	00 e0       	ldi	r16, 0x00	; 0
     ef2:	10 e0       	ldi	r17, 0x00	; 0
     ef4:	ac 01       	movw	r20, r24
     ef6:	cb 01       	movw	r24, r22
     ef8:	da 01       	movw	r26, r20
     efa:	8e 15       	cp	r24, r14
     efc:	9f 05       	cpc	r25, r15
     efe:	a0 07       	cpc	r26, r16
     f00:	b1 07       	cpc	r27, r17
     f02:	10 f4       	brcc	.+4      	; 0xf08 <decodeCommand+0x27c>
     f04:	d8 01       	movw	r26, r16
     f06:	c7 01       	movw	r24, r14
     f08:	99 83       	std	Y+1, r25	; 0x01
     f0a:	88 83       	st	Y, r24
                //Limit the IVal to the largest speed in the acceleration table to prevent sudden rapid acceleration at the end.
                responseData = cmd.accelTable[axis][AccelTableLength-1].speed; 
            }
            cmd_setIVal(axis, responseData); //set the speed container
            responseData = 0;
            if (readyToGo[axis] == 2) {
     f0c:	f6 01       	movw	r30, r12
     f0e:	e6 58       	subi	r30, 0x86	; 134
     f10:	fe 4f       	sbci	r31, 0xFE	; 254
     f12:	80 81       	ld	r24, Z
     f14:	82 30       	cpi	r24, 0x02	; 2
     f16:	09 f0       	breq	.+2      	; 0xf1a <decodeCommand+0x28e>
     f18:	bd cf       	rjmp	.-134    	; 0xe94 <decodeCommand+0x208>
                //If we are in a running mode which allows speed update without motor reconfiguration
                motorStart(axis); //Simply update the speed.
     f1a:	8b 2d       	mov	r24, r11
     f1c:	0e 94 ed 01 	call	0x3da	; 0x3da <motorStart>
     f20:	b4 c1       	rjmp	.+872    	; 0x128a <decodeCommand+0x5fe>
                //Otherwise we are no longer ready to go until the next :J command is received
                readyToGo[axis] = 0;
            }
            break;
        case 'E': //set the current position, return empty response
            oldSREG = SREG; 
     f22:	1f b7       	in	r17, 0x3f	; 63
            cli();  //The next bit needs to be atomic, just in case the motors are running
     f24:	f8 94       	cli
            cmd_setjVal(axis, synta_hexToLong(buffer)); //set the current position (used to sync to what EQMOD thinks is the current position at startup
     f26:	c4 01       	movw	r24, r8
     f28:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
     f2c:	eb 2d       	mov	r30, r11
     f2e:	f0 e0       	ldi	r31, 0x00	; 0
     f30:	ee 0f       	add	r30, r30
     f32:	ff 1f       	adc	r31, r31
     f34:	ee 0f       	add	r30, r30
     f36:	ff 1f       	adc	r31, r31
     f38:	ea 5e       	subi	r30, 0xEA	; 234
     f3a:	fd 4f       	sbci	r31, 0xFD	; 253
     f3c:	60 83       	st	Z, r22
     f3e:	71 83       	std	Z+1, r23	; 0x01
     f40:	82 83       	std	Z+2, r24	; 0x02
     f42:	93 83       	std	Z+3, r25	; 0x03
            SREG = oldSREG;
     f44:	1f bf       	out	0x3f, r17	; 63
     f46:	a1 c1       	rjmp	.+834    	; 0x128a <decodeCommand+0x5fe>
            break;
        case 'F': //Enable the motor driver, return empty response
            if (progMode == 0) { //only allow motors to be enabled outside of programming mode.
     f48:	80 91 86 01 	lds	r24, 0x0186
     f4c:	88 23       	and	r24, r24
     f4e:	09 f0       	breq	.+2      	; 0xf52 <decodeCommand+0x2c6>
     f50:	9b c1       	rjmp	.+822    	; 0x1288 <decodeCommand+0x5fc>
                motorEnable(axis); //This enables the motors - gives the motor driver board power
     f52:	8b 2d       	mov	r24, r11
     f54:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <motorEnable>
     f58:	98 c1       	rjmp	.+816    	; 0x128a <decodeCommand+0x5fe>
            }
            break;
            
        //Command required for entering programming mode. All other programming commands cannot be used when progMode = 0 (normal ops)
        case 'O': //set the programming mode.
            progMode = buffer[0] - '0';              //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
     f5a:	f4 01       	movw	r30, r8
     f5c:	80 81       	ld	r24, Z
     f5e:	80 53       	subi	r24, 0x30	; 48
     f60:	80 93 86 01 	sts	0x0186, r24
            if (progMode != 0) {
     f64:	88 23       	and	r24, r24
     f66:	31 f4       	brne	.+12     	; 0xf74 <decodeCommand+0x2e8>
     f68:	20 e0       	ldi	r18, 0x00	; 0
     f6a:	30 e0       	ldi	r19, 0x00	; 0
     f6c:	40 e0       	ldi	r20, 0x00	; 0
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	10 e0       	ldi	r17, 0x00	; 0
     f72:	90 c1       	rjmp	.+800    	; 0x1294 <decodeCommand+0x608>
                motorStop(RA,1); //emergency axis stop.
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	61 e0       	ldi	r22, 0x01	; 1
     f78:	0e 94 4b 03 	call	0x696	; 0x696 <motorStop>
                motorDisable(RA); //shutdown driver power.
     f7c:	80 e0       	ldi	r24, 0x00	; 0
     f7e:	0e 94 13 01 	call	0x226	; 0x226 <motorDisable>
                motorStop(DC,1); //emergency axis stop.
     f82:	81 e0       	ldi	r24, 0x01	; 1
     f84:	61 e0       	ldi	r22, 0x01	; 1
     f86:	0e 94 4b 03 	call	0x696	; 0x696 <motorStop>
                motorDisable(DC); //shutdown driver power.
     f8a:	81 e0       	ldi	r24, 0x01	; 1
     f8c:	0e 94 13 01 	call	0x226	; 0x226 <motorDisable>
                readyToGo[RA] = 0;
     f90:	10 92 7a 01 	sts	0x017A, r1
                readyToGo[DC] = 0;
     f94:	10 92 7b 01 	sts	0x017B, r1
     f98:	78 c1       	rjmp	.+752    	; 0x128a <decodeCommand+0x5fe>
            }
            break;

        default:
            //Prevent any chance of accidentally running configuration commands when not in programming mode.
            if (progMode != 0) {
     f9a:	20 91 86 01 	lds	r18, 0x0186
     f9e:	22 23       	and	r18, r18
     fa0:	09 f4       	brne	.+2      	; 0xfa4 <decodeCommand+0x318>
     fa2:	73 c1       	rjmp	.+742    	; 0x128a <decodeCommand+0x5fe>
                //The following are used for configuration ----------
                switch(command) {
     fa4:	8a 2d       	mov	r24, r10
     fa6:	99 27       	eor	r25, r25
     fa8:	87 fd       	sbrc	r24, 7
     faa:	90 95       	com	r25
     fac:	a9 2f       	mov	r26, r25
     fae:	b9 2f       	mov	r27, r25
     fb0:	fc 01       	movw	r30, r24
     fb2:	e1 54       	subi	r30, 0x41	; 65
     fb4:	f0 40       	sbci	r31, 0x00	; 0
     fb6:	ea 33       	cpi	r30, 0x3A	; 58
     fb8:	f1 05       	cpc	r31, r1
     fba:	08 f0       	brcs	.+2      	; 0xfbe <decodeCommand+0x332>
     fbc:	66 c1       	rjmp	.+716    	; 0x128a <decodeCommand+0x5fe>
     fbe:	e8 5c       	subi	r30, 0xC8	; 200
     fc0:	ff 4f       	sbci	r31, 0xFF	; 255
     fc2:	ee 0f       	add	r30, r30
     fc4:	ff 1f       	adc	r31, r31
     fc6:	05 90       	lpm	r0, Z+
     fc8:	f4 91       	lpm	r31, Z+
     fca:	e0 2d       	mov	r30, r0
     fcc:	09 94       	ijmp
                    case 'A': //store the aVal (steps per axis)
                        cmd_setaVal(axis, synta_hexToLong(buffer)); //store aVal for that axis.
     fce:	c4 01       	movw	r24, r8
     fd0:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
}

inline void cmd_setaVal(byte target, unsigned long _aVal){ //Set Method
    cmd.aVal[target] = _aVal;
     fd4:	eb 2d       	mov	r30, r11
     fd6:	f0 e0       	ldi	r31, 0x00	; 0
     fd8:	ee 0f       	add	r30, r30
     fda:	ff 1f       	adc	r31, r31
     fdc:	ee 0f       	add	r30, r30
     fde:	ff 1f       	adc	r31, r31
     fe0:	ea 5e       	subi	r30, 0xEA	; 234
     fe2:	fd 4f       	sbci	r31, 0xFD	; 253
     fe4:	66 a7       	std	Z+46, r22	; 0x2e
     fe6:	77 a7       	std	Z+47, r23	; 0x2f
     fe8:	80 ab       	std	Z+48, r24	; 0x30
     fea:	91 ab       	std	Z+49, r25	; 0x31
     fec:	4e c1       	rjmp	.+668    	; 0x128a <decodeCommand+0x5fe>
                        break;
                    case 'B': //store the bVal (sidereal rate)
                        cmd_setbVal(axis, synta_hexToLong(buffer)); //store bVal for that axis.
     fee:	c4 01       	movw	r24, r8
     ff0:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
}

inline void cmd_setbVal(byte target, unsigned long _bVal){ //Set Method
    cmd.bVal[target] = _bVal;
     ff4:	eb 2d       	mov	r30, r11
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	ee 0f       	add	r30, r30
     ffa:	ff 1f       	adc	r31, r31
     ffc:	ee 0f       	add	r30, r30
     ffe:	ff 1f       	adc	r31, r31
    1000:	ea 5e       	subi	r30, 0xEA	; 234
    1002:	fd 4f       	sbci	r31, 0xFD	; 253
    1004:	66 ab       	std	Z+54, r22	; 0x36
    1006:	77 ab       	std	Z+55, r23	; 0x37
    1008:	80 af       	std	Z+56, r24	; 0x38
    100a:	91 af       	std	Z+57, r25	; 0x39
    100c:	3e c1       	rjmp	.+636    	; 0x128a <decodeCommand+0x5fe>
                        break;
                    case 'S': //store the sVal (steps per worm rotation)
                        cmd_setsVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
    100e:	c4 01       	movw	r24, r8
    1010:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
}

inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
    1014:	eb 2d       	mov	r30, r11
    1016:	f0 e0       	ldi	r31, 0x00	; 0
    1018:	ee 0f       	add	r30, r30
    101a:	ff 1f       	adc	r31, r31
    101c:	ee 0f       	add	r30, r30
    101e:	ff 1f       	adc	r31, r31
    1020:	ea 5a       	subi	r30, 0xAA	; 170
    1022:	fd 4f       	sbci	r31, 0xFD	; 253
    1024:	60 83       	st	Z, r22
    1026:	71 83       	std	Z+1, r23	; 0x01
    1028:	82 83       	std	Z+2, r24	; 0x02
    102a:	93 83       	std	Z+3, r25	; 0x03
    102c:	2e c1       	rjmp	.+604    	; 0x128a <decodeCommand+0x5fe>
                        break;
                    case 'n': //return the IVal (EQMOD Speed at sidereal)
                        responseData = cmd.siderealIVal[axis];
    102e:	eb 2d       	mov	r30, r11
    1030:	f0 e0       	ldi	r31, 0x00	; 0
    1032:	ee 0f       	add	r30, r30
    1034:	ff 1f       	adc	r31, r31
    1036:	e7 59       	subi	r30, 0x97	; 151
    1038:	fd 4f       	sbci	r31, 0xFD	; 253
    103a:	80 81       	ld	r24, Z
    103c:	91 81       	ldd	r25, Z+1	; 0x01
    103e:	9c 01       	movw	r18, r24
    1040:	40 e0       	ldi	r20, 0x00	; 0
    1042:	50 e0       	ldi	r21, 0x00	; 0
    1044:	26 c1       	rjmp	.+588    	; 0x1292 <decodeCommand+0x606>
                        break;
                    case 'N': //store the IVal (EQMOD Speed at sidereal)
                        cmd_setsideIVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
    1046:	c4 01       	movw	r24, r8
    1048:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
    }
    return fVal;
}

inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
    104c:	eb 2d       	mov	r30, r11
    104e:	f0 e0       	ldi	r31, 0x00	; 0
    1050:	ee 0f       	add	r30, r30
    1052:	ff 1f       	adc	r31, r31
    1054:	e7 59       	subi	r30, 0x97	; 151
    1056:	fd 4f       	sbci	r31, 0xFD	; 253
    1058:	71 83       	std	Z+1, r23	; 0x01
    105a:	60 83       	st	Z, r22
    105c:	16 c1       	rjmp	.+556    	; 0x128a <decodeCommand+0x5fe>
                        break;
                    case 'd': //return the driver version or step mode
                        if (axis) {
    105e:	bb 20       	and	r11, r11
    1060:	19 f0       	breq	.+6      	; 0x1068 <decodeCommand+0x3dc>
                            responseData = microstepConf; 
    1062:	80 91 87 01 	lds	r24, 0x0187
    1066:	5b c0       	rjmp	.+182    	; 0x111e <decodeCommand+0x492>
                        } else {
                            responseData = driverVersion;
    1068:	80 91 88 01 	lds	r24, 0x0188
    106c:	58 c0       	rjmp	.+176    	; 0x111e <decodeCommand+0x492>
                        }
                        break;
                    case 'D': //store the driver verison and step modes
                        if (axis) {
    106e:	bb 20       	and	r11, r11
    1070:	81 f0       	breq	.+32     	; 0x1092 <decodeCommand+0x406>
                            microstepConf = synta_hexToByte(buffer); //store step mode.
    1072:	c4 01       	movw	r24, r8
    1074:	0e 94 0f 12 	call	0x241e	; 0x241e <_Z15synta_hexToBytePc>
    1078:	80 93 87 01 	sts	0x0187, r24
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    107c:	88 30       	cpi	r24, 0x08	; 8
    107e:	10 f4       	brcc	.+4      	; 0x1084 <decodeCommand+0x3f8>
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	04 c0       	rjmp	.+8      	; 0x108c <decodeCommand+0x400>
    1084:	90 91 0c 02 	lds	r25, 0x020C
    1088:	81 e0       	ldi	r24, 0x01	; 1
    108a:	98 27       	eor	r25, r24
    108c:	90 93 0a 02 	sts	0x020A, r25
    1090:	fc c0       	rjmp	.+504    	; 0x128a <decodeCommand+0x5fe>
                        } else {
                            driverVersion = synta_hexToByte(buffer); //store driver version.
    1092:	c4 01       	movw	r24, r8
    1094:	0e 94 0f 12 	call	0x241e	; 0x241e <_Z15synta_hexToBytePc>
    1098:	80 93 88 01 	sts	0x0188, r24
    109c:	f6 c0       	rjmp	.+492    	; 0x128a <decodeCommand+0x5fe>
                        }
                        break;
                    case 'r': //return the dec backlash or st4 speed factor
                        if (axis) {
    109e:	bb 20       	and	r11, r11
    10a0:	29 f0       	breq	.+10     	; 0x10ac <decodeCommand+0x420>
                            responseData = cmd.st4DecBacklash; 
    10a2:	80 91 67 02 	lds	r24, 0x0267
    10a6:	90 91 68 02 	lds	r25, 0x0268
    10aa:	c9 cf       	rjmp	.-110    	; 0x103e <decodeCommand+0x3b2>
                        } else {
                            responseData = cmd.st4SpeedFactor;
    10ac:	80 91 5f 02 	lds	r24, 0x025F
    10b0:	36 c0       	rjmp	.+108    	; 0x111e <decodeCommand+0x492>
                        }
                        break;
                    case 'R': //store the dec backlash or st4 speed factor
                        if (axis) {
    10b2:	bb 20       	and	r11, r11
    10b4:	89 f0       	breq	.+34     	; 0x10d8 <decodeCommand+0x44c>
                            unsigned long dataIn = synta_hexToLong(buffer); //store step mode.
    10b6:	c4 01       	movw	r24, r8
    10b8:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
                            if (dataIn > 65535) {
    10bc:	60 30       	cpi	r22, 0x00	; 0
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	7f 07       	cpc	r23, r31
    10c2:	f1 e0       	ldi	r31, 0x01	; 1
    10c4:	8f 07       	cpc	r24, r31
    10c6:	f0 e0       	ldi	r31, 0x00	; 0
    10c8:	9f 07       	cpc	r25, r31
    10ca:	08 f0       	brcs	.+2      	; 0x10ce <decodeCommand+0x442>
    10cc:	dd c0       	rjmp	.+442    	; 0x1288 <decodeCommand+0x5fc>
inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
}

inline void cmd_setst4DecBacklash(unsigned int _backlash){ //Set Method
    cmd.st4DecBacklash = _backlash;
    10ce:	70 93 68 02 	sts	0x0268, r23
    10d2:	60 93 67 02 	sts	0x0267, r22
    10d6:	d9 c0       	rjmp	.+434    	; 0x128a <decodeCommand+0x5fe>
                                command = '\0'; //If the step rate is out of range, force an error response packet.
                            } else {
                                cmd_setst4DecBacklash(dataIn); //store st4 speed factor
                            }
                        } else {
                            byte factor = synta_hexToByte(buffer);
    10d8:	c4 01       	movw	r24, r8
    10da:	0e 94 0f 12 	call	0x241e	; 0x241e <_Z15synta_hexToBytePc>
    10de:	98 2f       	mov	r25, r24
                            if ((factor > 19) || (factor < 1)) {
    10e0:	81 50       	subi	r24, 0x01	; 1
    10e2:	83 31       	cpi	r24, 0x13	; 19
    10e4:	08 f0       	brcs	.+2      	; 0x10e8 <decodeCommand+0x45c>
    10e6:	d0 c0       	rjmp	.+416    	; 0x1288 <decodeCommand+0x5fc>
inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
}

inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
    10e8:	90 93 5f 02 	sts	0x025F, r25
    10ec:	ce c0       	rjmp	.+412    	; 0x128a <decodeCommand+0x5fe>
                                cmd_setst4SpeedFactor(factor); //store st4 speed factor
                            }
                        }
                        break;
                    case 'z': //return the Goto speed
                        responseData = cmd.normalGotoSpeed[axis];
    10ee:	eb 2d       	mov	r30, r11
    10f0:	f0 e0       	ldi	r31, 0x00	; 0
    10f2:	ee 0f       	add	r30, r30
    10f4:	ff 1f       	adc	r31, r31
    10f6:	eb 58       	subi	r30, 0x8B	; 139
    10f8:	fd 4f       	sbci	r31, 0xFD	; 253
    10fa:	9f cf       	rjmp	.-194    	; 0x103a <decodeCommand+0x3ae>
                        break;
                    case 'Z': //return the Goto speed factor
                        cmd.normalGotoSpeed[axis] = synta_hexToByte(buffer); //store the goto speed factor
    10fc:	c4 01       	movw	r24, r8
    10fe:	0e 94 0f 12 	call	0x241e	; 0x241e <_Z15synta_hexToBytePc>
    1102:	eb 2d       	mov	r30, r11
    1104:	f0 e0       	ldi	r31, 0x00	; 0
    1106:	ee 0f       	add	r30, r30
    1108:	ff 1f       	adc	r31, r31
    110a:	eb 58       	subi	r30, 0x8B	; 139
    110c:	fd 4f       	sbci	r31, 0xFD	; 253
    110e:	80 83       	st	Z, r24
    1110:	11 82       	std	Z+1, r1	; 0x01
    1112:	bb c0       	rjmp	.+374    	; 0x128a <decodeCommand+0x5fe>
                        break;
                    case 'c': //return the axisDirectionReverse
                        responseData = encodeDirection[axis];
    1114:	eb 2d       	mov	r30, r11
    1116:	f0 e0       	ldi	r31, 0x00	; 0
    1118:	ec 57       	subi	r30, 0x7C	; 124
    111a:	fe 4f       	sbci	r31, 0xFE	; 254
    111c:	80 81       	ld	r24, Z
    111e:	28 2f       	mov	r18, r24
    1120:	30 e0       	ldi	r19, 0x00	; 0
    1122:	8e cf       	rjmp	.-228    	; 0x1040 <decodeCommand+0x3b4>
                        break;
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
    1124:	eb 2d       	mov	r30, r11
    1126:	f0 e0       	ldi	r31, 0x00	; 0
    1128:	ec 57       	subi	r30, 0x7C	; 124
    112a:	fe 4f       	sbci	r31, 0xFE	; 254
    112c:	90 e0       	ldi	r25, 0x00	; 0
    112e:	d4 01       	movw	r26, r8
    1130:	8c 91       	ld	r24, X
    1132:	80 33       	cpi	r24, 0x30	; 48
    1134:	09 f0       	breq	.+2      	; 0x1138 <decodeCommand+0x4ac>
    1136:	91 e0       	ldi	r25, 0x01	; 1
    1138:	90 83       	st	Z, r25
    113a:	a7 c0       	rjmp	.+334    	; 0x128a <decodeCommand+0x5fe>
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
    113c:	bb 20       	and	r11, r11
    113e:	81 f0       	breq	.+32     	; 0x1160 <decodeCommand+0x4d4>
                            responseData = disableGearChange; 
    1140:	20 91 0c 02 	lds	r18, 0x020C
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    1144:	80 91 87 01 	lds	r24, 0x0187
    1148:	88 30       	cpi	r24, 0x08	; 8
    114a:	10 f4       	brcc	.+4      	; 0x1150 <decodeCommand+0x4c4>
    114c:	80 e0       	ldi	r24, 0x00	; 0
    114e:	02 c0       	rjmp	.+4      	; 0x1154 <decodeCommand+0x4c8>
    1150:	81 e0       	ldi	r24, 0x01	; 1
    1152:	82 27       	eor	r24, r18
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
                            responseData = disableGearChange; 
    1154:	30 e0       	ldi	r19, 0x00	; 0
    1156:	40 e0       	ldi	r20, 0x00	; 0
    1158:	50 e0       	ldi	r21, 0x00	; 0
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    115a:	80 93 0a 02 	sts	0x020A, r24
    115e:	99 c0       	rjmp	.+306    	; 0x1292 <decodeCommand+0x606>
                        } else {
                            responseData = allowAdvancedHCDetection;
    1160:	80 91 0d 02 	lds	r24, 0x020D
    1164:	dc cf       	rjmp	.-72     	; 0x111e <decodeCommand+0x492>
                        }
                        break;
                    case 'Q': //store the disableGearChange/allowAdvancedHCDetection setting
                        if (axis) {
    1166:	bb 20       	and	r11, r11
    1168:	61 f0       	breq	.+24     	; 0x1182 <decodeCommand+0x4f6>
                            disableGearChange = synta_hexToByte(buffer); //store whether we can change gear
    116a:	c4 01       	movw	r24, r8
    116c:	0e 94 0f 12 	call	0x241e	; 0x241e <_Z15synta_hexToBytePc>
    1170:	10 92 0c 02 	sts	0x020C, r1
    1174:	88 23       	and	r24, r24
    1176:	09 f4       	brne	.+2      	; 0x117a <decodeCommand+0x4ee>
    1178:	88 c0       	rjmp	.+272    	; 0x128a <decodeCommand+0x5fe>
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	80 93 0c 02 	sts	0x020C, r24
    1180:	84 c0       	rjmp	.+264    	; 0x128a <decodeCommand+0x5fe>
                        } else {
                            allowAdvancedHCDetection = synta_hexToByte(buffer); //store whether to allow advanced hand controller detection
    1182:	c4 01       	movw	r24, r8
    1184:	0e 94 0f 12 	call	0x241e	; 0x241e <_Z15synta_hexToBytePc>
    1188:	10 92 0d 02 	sts	0x020D, r1
    118c:	88 23       	and	r24, r24
    118e:	09 f4       	brne	.+2      	; 0x1192 <decodeCommand+0x506>
    1190:	7c c0       	rjmp	.+248    	; 0x128a <decodeCommand+0x5fe>
    1192:	81 e0       	ldi	r24, 0x01	; 1
    1194:	80 93 0d 02 	sts	0x020D, r24
    1198:	78 c0       	rjmp	.+240    	; 0x128a <decodeCommand+0x5fe>
    struct {
        Byter lowByter;
        Byter highByter;
    };
    InterMaker(unsigned long _integer){
        integer = _integer;
    119a:	20 e0       	ldi	r18, 0x00	; 0
    119c:	30 e0       	ldi	r19, 0x00	; 0
    119e:	40 e0       	ldi	r20, 0x00	; 0
    11a0:	50 e0       	ldi	r21, 0x00	; 0
                        }
                        break;
                    case 'x': {  //return the accelTable
                        Inter responsePack = InterMaker(0);
                        responsePack.lowByter.integer = cmd.accelTable[axis][accelTableIndex[axis]].speed;
    11a2:	6b 2d       	mov	r22, r11
    11a4:	70 e0       	ldi	r23, 0x00	; 0
    11a6:	eb 01       	movw	r28, r22
    11a8:	cc 5e       	subi	r28, 0xEC	; 236
    11aa:	dd 4f       	sbci	r29, 0xFD	; 253
    11ac:	a8 81       	ld	r26, Y
    11ae:	8a 2f       	mov	r24, r26
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	fc 01       	movw	r30, r24
    11b4:	ee 0f       	add	r30, r30
    11b6:	ff 1f       	adc	r31, r31
    11b8:	e8 0f       	add	r30, r24
    11ba:	f9 1f       	adc	r31, r25
    11bc:	80 ec       	ldi	r24, 0xC0	; 192
    11be:	90 e0       	ldi	r25, 0x00	; 0
    11c0:	8c 01       	movw	r16, r24
    11c2:	60 9f       	mul	r22, r16
    11c4:	c0 01       	movw	r24, r0
    11c6:	61 9f       	mul	r22, r17
    11c8:	90 0d       	add	r25, r0
    11ca:	70 9f       	mul	r23, r16
    11cc:	90 0d       	add	r25, r0
    11ce:	11 24       	eor	r1, r1
    11d0:	e8 0f       	add	r30, r24
    11d2:	f9 1f       	adc	r31, r25
    11d4:	ea 5e       	subi	r30, 0xEA	; 234
    11d6:	fd 4f       	sbci	r31, 0xFD	; 253
    11d8:	e9 59       	subi	r30, 0x99	; 153
    11da:	ff 4f       	sbci	r31, 0xFF	; 255
    11dc:	21 91       	ld	r18, Z+
    11de:	31 91       	ld	r19, Z+
                        responsePack.highByter.low = cmd.accelTable[axis][accelTableIndex[axis]].repeats; 
    11e0:	40 81       	ld	r20, Z
                        responseData = responsePack.integer;
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if reading sequentially.
    11e2:	af 5f       	subi	r26, 0xFF	; 255
    11e4:	a8 83       	st	Y, r26
                        if (accelTableIndex[axis] >= AccelTableLength) {
    11e6:	a0 34       	cpi	r26, 0x40	; 64
    11e8:	08 f4       	brcc	.+2      	; 0x11ec <decodeCommand+0x560>
    11ea:	53 c0       	rjmp	.+166    	; 0x1292 <decodeCommand+0x606>
                            accelTableIndex[axis] = 0; //Wrap around
    11ec:	18 82       	st	Y, r1
    11ee:	51 c0       	rjmp	.+162    	; 0x1292 <decodeCommand+0x606>
                        }
                        break;
                    }
                    case 'X': { //store the accelTable value for address set by 'Y', or next address after last 'X'
                        unsigned long dataIn = synta_hexToLong(buffer);
    11f0:	c4 01       	movw	r24, r8
    11f2:	0e 94 12 12 	call	0x2424	; 0x2424 <_Z15synta_hexToLongPc>
                        cmd.accelTable[axis][accelTableIndex[axis]].speed = (unsigned int)dataIn; //lower two bytes is speed
    11f6:	4b 2d       	mov	r20, r11
    11f8:	50 e0       	ldi	r21, 0x00	; 0
    11fa:	ea 01       	movw	r28, r20
    11fc:	cc 5e       	subi	r28, 0xEC	; 236
    11fe:	dd 4f       	sbci	r29, 0xFD	; 253
    1200:	a8 81       	ld	r26, Y
    1202:	2a 2f       	mov	r18, r26
    1204:	30 e0       	ldi	r19, 0x00	; 0
    1206:	f9 01       	movw	r30, r18
    1208:	ee 0f       	add	r30, r30
    120a:	ff 1f       	adc	r31, r31
    120c:	e2 0f       	add	r30, r18
    120e:	f3 1f       	adc	r31, r19
    1210:	20 ec       	ldi	r18, 0xC0	; 192
    1212:	30 e0       	ldi	r19, 0x00	; 0
    1214:	89 01       	movw	r16, r18
    1216:	40 9f       	mul	r20, r16
    1218:	90 01       	movw	r18, r0
    121a:	41 9f       	mul	r20, r17
    121c:	30 0d       	add	r19, r0
    121e:	50 9f       	mul	r21, r16
    1220:	30 0d       	add	r19, r0
    1222:	11 24       	eor	r1, r1
    1224:	e2 0f       	add	r30, r18
    1226:	f3 1f       	adc	r31, r19
    1228:	ea 5e       	subi	r30, 0xEA	; 234
    122a:	fd 4f       	sbci	r31, 0xFD	; 253
    122c:	e9 59       	subi	r30, 0x99	; 153
    122e:	ff 4f       	sbci	r31, 0xFF	; 255
    1230:	61 93       	st	Z+, r22
    1232:	71 93       	st	Z+, r23
                        cmd.accelTable[axis][accelTableIndex[axis]].repeats = (byte)(dataIn>>16); //upper byte is repeats.
    1234:	bc 01       	movw	r22, r24
    1236:	88 27       	eor	r24, r24
    1238:	99 27       	eor	r25, r25
    123a:	60 83       	st	Z, r22
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if programming sequentially.
    123c:	af 5f       	subi	r26, 0xFF	; 255
    123e:	a8 83       	st	Y, r26
                        if (accelTableIndex[axis] >= AccelTableLength) {
    1240:	a0 34       	cpi	r26, 0x40	; 64
    1242:	18 f1       	brcs	.+70     	; 0x128a <decodeCommand+0x5fe>
                            accelTableIndex[axis] = 0; //Wrap around
    1244:	18 82       	st	Y, r1
    1246:	21 c0       	rjmp	.+66     	; 0x128a <decodeCommand+0x5fe>
                        }
                        break;
                    }
                    case 'Y': //store the accelTableIndex value
                        //Use axis=0 to set which address we are accessing (we'll repurpose accelTableIndex[RA] in prog mode for this)
                        accelTableIndex[axis] = synta_hexToByte(buffer);
    1248:	c4 01       	movw	r24, r8
    124a:	0e 94 0f 12 	call	0x241e	; 0x241e <_Z15synta_hexToBytePc>
    124e:	eb 2d       	mov	r30, r11
    1250:	f0 e0       	ldi	r31, 0x00	; 0
    1252:	ec 5e       	subi	r30, 0xEC	; 236
    1254:	fd 4f       	sbci	r31, 0xFD	; 253
    1256:	80 83       	st	Z, r24
                        if (accelTableIndex[axis] >= AccelTableLength) {
    1258:	80 34       	cpi	r24, 0x40	; 64
    125a:	b0 f4       	brcc	.+44     	; 0x1288 <decodeCommand+0x5fc>
    125c:	16 c0       	rjmp	.+44     	; 0x128a <decodeCommand+0x5fe>
                            command = '\0'; //If the address out of range, force an error response packet.
                        }
                        break;
                    case 'T': //set mode, return empty response
                        if (progMode & 2) {
    125e:	82 2f       	mov	r24, r18
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	9c 01       	movw	r18, r24
    1264:	21 70       	andi	r18, 0x01	; 1
    1266:	30 70       	andi	r19, 0x00	; 0
    1268:	81 ff       	sbrs	r24, 1
    126a:	08 c0       	rjmp	.+16     	; 0x127c <decodeCommand+0x5f0>
                        //proceed with eeprom write
                            if (progMode & 1) {
    126c:	23 2b       	or	r18, r19
    126e:	19 f0       	breq	.+6      	; 0x1276 <decodeCommand+0x5ea>
                                buildEEPROM();
    1270:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <buildEEPROM>
    1274:	0a c0       	rjmp	.+20     	; 0x128a <decodeCommand+0x5fe>
                            } else {
                                storeEEPROM();
    1276:	0e 94 32 05 	call	0xa64	; 0xa64 <storeEEPROM>
    127a:	07 c0       	rjmp	.+14     	; 0x128a <decodeCommand+0x5fe>
                            }
                        } else if (progMode & 1) {
    127c:	23 2b       	or	r18, r19
    127e:	29 f0       	breq	.+10     	; 0x128a <decodeCommand+0x5fe>
                            if (!checkEEPROM()) { //check if EEPROM contains valid data.
    1280:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <checkEEPROM>
    1284:	88 23       	and	r24, r24
    1286:	09 f4       	brne	.+2      	; 0x128a <decodeCommand+0x5fe>
    1288:	aa 24       	eor	r10, r10
    128a:	20 e0       	ldi	r18, 0x00	; 0
    128c:	30 e0       	ldi	r19, 0x00	; 0
    128e:	40 e0       	ldi	r20, 0x00	; 0
    1290:	50 e0       	ldi	r21, 0x00	; 0
    1292:	11 e0       	ldi	r17, 0x01	; 1
                }
            }
            break;
    }
  
    synta_assembleResponse(buffer, command, responseData); //generate correct response (this is required as is)
    1294:	c4 01       	movw	r24, r8
    1296:	6a 2d       	mov	r22, r10
    1298:	0e 94 ad 12 	call	0x255a	; 0x255a <_Z22synta_assembleResponsePccm>
    
    if ((command == 'J') && (progMode == 0)) { //J tells us we are ready to begin the requested movement.
    129c:	2a e4       	ldi	r18, 0x4A	; 74
    129e:	a2 16       	cp	r10, r18
    12a0:	89 f4       	brne	.+34     	; 0x12c4 <decodeCommand+0x638>
    12a2:	80 91 86 01 	lds	r24, 0x0186
    12a6:	88 23       	and	r24, r24
    12a8:	69 f4       	brne	.+26     	; 0x12c4 <decodeCommand+0x638>
        readyToGo[axis] = 1; //So signal we are ready to go and when the last movement complets this one will execute.
    12aa:	8b 2d       	mov	r24, r11
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	fc 01       	movw	r30, r24
    12b0:	e6 58       	subi	r30, 0x86	; 134
    12b2:	fe 4f       	sbci	r31, 0xFE	; 254
    12b4:	21 e0       	ldi	r18, 0x01	; 1
    12b6:	20 83       	st	Z, r18
        if (!(cmd.GVal[axis] & 1)){
    12b8:	fc 01       	movw	r30, r24
    12ba:	ea 5e       	subi	r30, 0xEA	; 234
    12bc:	fd 4f       	sbci	r31, 0xFD	; 253
    12be:	80 89       	ldd	r24, Z+16	; 0x10
    12c0:	80 ff       	sbrs	r24, 0
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
    12c2:	20 a3       	std	Z+32, r18	; 0x20
            //If go-to mode requested
            cmd_setGotoEn(axis,CMD_ENABLED);
        }
    }
    return success;
}
    12c4:	81 2f       	mov	r24, r17
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	1f 91       	pop	r17
    12cc:	0f 91       	pop	r16
    12ce:	ff 90       	pop	r15
    12d0:	ef 90       	pop	r14
    12d2:	df 90       	pop	r13
    12d4:	cf 90       	pop	r12
    12d6:	bf 90       	pop	r11
    12d8:	af 90       	pop	r10
    12da:	9f 90       	pop	r9
    12dc:	8f 90       	pop	r8
    12de:	08 95       	ret

000012e0 <calculateRate>:
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
}

void calculateRate(byte axis){
    12e0:	6f 92       	push	r6
    12e2:	7f 92       	push	r7
    12e4:	8f 92       	push	r8
    12e6:	9f 92       	push	r9
    12e8:	af 92       	push	r10
    12ea:	bf 92       	push	r11
    12ec:	cf 92       	push	r12
    12ee:	df 92       	push	r13
    12f0:	ef 92       	push	r14
    12f2:	ff 92       	push	r15
    12f4:	0f 93       	push	r16
    12f6:	1f 93       	push	r17
    12f8:	cf 93       	push	r28
    12fa:	df 93       	push	r29
  
    unsigned long rate;
    unsigned long remainder;
    float floatRemainder;
    unsigned long divisor = cmd.bVal[axis];
    12fc:	c8 2f       	mov	r28, r24
    12fe:	d0 e0       	ldi	r29, 0x00	; 0
    1300:	fe 01       	movw	r30, r28
    1302:	ee 0f       	add	r30, r30
    1304:	ff 1f       	adc	r31, r31
    1306:	ee 0f       	add	r30, r30
    1308:	ff 1f       	adc	r31, r31
    130a:	ea 5e       	subi	r30, 0xEA	; 234
    130c:	fd 4f       	sbci	r31, 0xFD	; 253
    130e:	a6 a8       	ldd	r10, Z+54	; 0x36
    1310:	b7 a8       	ldd	r11, Z+55	; 0x37
    1312:	c0 ac       	ldd	r12, Z+56	; 0x38
    1314:	d1 ac       	ldd	r13, Z+57	; 0x39
    byte distWidth = DecimalDistnWidth;
    
    //When dividing a very large number by a much smaller on, float accuracy is abismal. So firstly we use integer math to split the division into quotient and remainder
    rate = timerCountRate / divisor; //Calculate the quotient
    1316:	60 e0       	ldi	r22, 0x00	; 0
    1318:	72 e1       	ldi	r23, 0x12	; 18
    131a:	8a e7       	ldi	r24, 0x7A	; 122
    131c:	90 e0       	ldi	r25, 0x00	; 0
    131e:	a6 01       	movw	r20, r12
    1320:	95 01       	movw	r18, r10
    1322:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <__udivmodsi4>
    1326:	c9 01       	movw	r24, r18
    1328:	da 01       	movw	r26, r20
    132a:	3c 01       	movw	r6, r24
    132c:	4d 01       	movw	r8, r26
    remainder = timerCountRate % divisor; //Calculate the remainder
    
    //Then convert the remainder into a decimal number (division of a small number by a larger one, improving accuracy)
    floatRemainder = (float)remainder/(float)divisor; //Convert the remainder to a decimal.
    132e:	60 e0       	ldi	r22, 0x00	; 0
    1330:	72 e1       	ldi	r23, 0x12	; 18
    1332:	8a e7       	ldi	r24, 0x7A	; 122
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	a6 01       	movw	r20, r12
    1338:	95 01       	movw	r18, r10
    133a:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <__udivmodsi4>
    133e:	0e 94 39 14 	call	0x2872	; 0x2872 <__floatunsisf>
    1342:	7b 01       	movw	r14, r22
    1344:	8c 01       	movw	r16, r24
    1346:	c6 01       	movw	r24, r12
    1348:	b5 01       	movw	r22, r10
    134a:	0e 94 39 14 	call	0x2872	; 0x2872 <__floatunsisf>
    134e:	9b 01       	movw	r18, r22
    1350:	ac 01       	movw	r20, r24
    1352:	c8 01       	movw	r24, r16
    1354:	b7 01       	movw	r22, r14
    1356:	0e 94 a5 13 	call	0x274a	; 0x274a <__divsf3>
    
    //Multiply the remainder by distributionWidth to work out an approximate number of extra clocks needed per full step (each step is 'distributionWidth' microsteps)
    floatRemainder *= (float)distWidth; 
    //This many extra cycles are needed:
    remainder = (unsigned long)(floatRemainder+0.5f); 
    135a:	20 e0       	ldi	r18, 0x00	; 0
    135c:	30 e0       	ldi	r19, 0x00	; 0
    135e:	40 e0       	ldi	r20, 0x00	; 0
    1360:	52 e4       	ldi	r21, 0x42	; 66
    1362:	0e 94 09 15 	call	0x2a12	; 0x2a12 <__mulsf3>
    1366:	20 e0       	ldi	r18, 0x00	; 0
    1368:	30 e0       	ldi	r19, 0x00	; 0
    136a:	40 e0       	ldi	r20, 0x00	; 0
    136c:	5f e3       	ldi	r21, 0x3F	; 63
    136e:	0e 94 2e 13 	call	0x265c	; 0x265c <__addsf3>
    1372:	0e 94 0d 14 	call	0x281a	; 0x281a <__fixunssfsi>
    1376:	5b 01       	movw	r10, r22
    1378:	6c 01       	movw	r12, r24
    
    //Now truncate to an unsigned int with a sensible max value (the int is to avoid register issues with the 16 bit timer)
    if((unsigned int)(rate >> 16)){
    137a:	c4 01       	movw	r24, r8
    137c:	aa 27       	eor	r26, r26
    137e:	bb 27       	eor	r27, r27
    1380:	89 2b       	or	r24, r25
    1382:	39 f0       	breq	.+14     	; 0x1392 <calculateRate+0xb2>
    1384:	5f ef       	ldi	r21, 0xFF	; 255
    1386:	65 2e       	mov	r6, r21
    1388:	5f ef       	ldi	r21, 0xFF	; 255
    138a:	75 2e       	mov	r7, r21
    138c:	81 2c       	mov	r8, r1
    138e:	91 2c       	mov	r9, r1
    1390:	0b c0       	rjmp	.+22     	; 0x13a8 <calculateRate+0xc8>
        rate = 65535UL;
    } else if (rate < 128UL) {
    1392:	80 e8       	ldi	r24, 0x80	; 128
    1394:	68 16       	cp	r6, r24
    1396:	71 04       	cpc	r7, r1
    1398:	81 04       	cpc	r8, r1
    139a:	91 04       	cpc	r9, r1
    139c:	28 f4       	brcc	.+10     	; 0x13a8 <calculateRate+0xc8>
    139e:	40 e8       	ldi	r20, 0x80	; 128
    13a0:	64 2e       	mov	r6, r20
    13a2:	71 2c       	mov	r7, r1
    13a4:	81 2c       	mov	r8, r1
    13a6:	91 2c       	mov	r9, r1
        rate = 128UL;
    }
#if defined(__AVR_ATmega162__)
    rate--;
    13a8:	d4 01       	movw	r26, r8
    13aa:	c3 01       	movw	r24, r6
    13ac:	01 97       	sbiw	r24, 0x01	; 1
    13ae:	a1 09       	sbc	r26, r1
    13b0:	b1 09       	sbc	r27, r1
    13b2:	fe 01       	movw	r30, r28
    13b4:	36 e0       	ldi	r19, 0x06	; 6
    13b6:	ee 0f       	add	r30, r30
    13b8:	ff 1f       	adc	r31, r31
    13ba:	3a 95       	dec	r19
    13bc:	e1 f7       	brne	.-8      	; 0x13b6 <calculateRate+0xd6>
    13be:	e6 57       	subi	r30, 0x76	; 118
    13c0:	fe 4f       	sbci	r31, 0xFE	; 254
    13c2:	20 e0       	ldi	r18, 0x00	; 0
#endif
  
    for (byte i = 0; i < distWidth; i++){
#if defined(__AVR_ATmega162__)
        timerOVF[axis][i] = rate; //Subtract 1 as timer is 0 indexed.
    13c4:	81 93       	st	Z+, r24
    13c6:	91 93       	st	Z+, r25
    }
#if defined(__AVR_ATmega162__)
    rate--;
#endif
  
    for (byte i = 0; i < distWidth; i++){
    13c8:	2f 5f       	subi	r18, 0xFF	; 255
    13ca:	20 32       	cpi	r18, 0x20	; 32
    13cc:	d9 f7       	brne	.-10     	; 0x13c4 <calculateRate+0xe4>
    13ce:	66 24       	eor	r6, r6
    13d0:	77 24       	eor	r7, r7
    13d2:	43 01       	movw	r8, r6
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
        distn *= (float)distWidth;
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    13d4:	25 e0       	ldi	r18, 0x05	; 5
    13d6:	cc 0f       	add	r28, r28
    13d8:	dd 1f       	adc	r29, r29
    13da:	2a 95       	dec	r18
    13dc:	e1 f7       	brne	.-8      	; 0x13d6 <calculateRate+0xf6>
    13de:	2b c0       	rjmp	.+86     	; 0x1436 <calculateRate+0x156>
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
    13e0:	c4 01       	movw	r24, r8
    13e2:	b3 01       	movw	r22, r6
    13e4:	0e 94 39 14 	call	0x2872	; 0x2872 <__floatunsisf>
        distn *= (float)distWidth;
    13e8:	20 e0       	ldi	r18, 0x00	; 0
    13ea:	30 e0       	ldi	r19, 0x00	; 0
    13ec:	40 e0       	ldi	r20, 0x00	; 0
    13ee:	52 e4       	ldi	r21, 0x42	; 66
    13f0:	0e 94 09 15 	call	0x2a12	; 0x2a12 <__mulsf3>
    13f4:	7b 01       	movw	r14, r22
    13f6:	8c 01       	movw	r16, r24
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
    13f8:	c6 01       	movw	r24, r12
    13fa:	b5 01       	movw	r22, r10
    13fc:	0e 94 39 14 	call	0x2872	; 0x2872 <__floatunsisf>
    1400:	9b 01       	movw	r18, r22
    1402:	ac 01       	movw	r20, r24
    1404:	c8 01       	movw	r24, r16
    1406:	b7 01       	movw	r22, r14
    1408:	0e 94 a5 13 	call	0x274a	; 0x274a <__divsf3>
    140c:	0e 94 92 13 	call	0x2724	; 0x2724 <ceil>
        timerOVF[axis][index] += 1;
    1410:	0e 94 0d 14 	call	0x281a	; 0x281a <__fixunssfsi>
    1414:	fe 01       	movw	r30, r28
    1416:	e6 0f       	add	r30, r22
    1418:	f1 1d       	adc	r31, r1
    141a:	ee 0f       	add	r30, r30
    141c:	ff 1f       	adc	r31, r31
    141e:	e6 57       	subi	r30, 0x76	; 118
    1420:	fe 4f       	sbci	r31, 0xFE	; 254
    1422:	80 81       	ld	r24, Z
    1424:	91 81       	ldd	r25, Z+1	; 0x01
    1426:	01 96       	adiw	r24, 0x01	; 1
    1428:	91 83       	std	Z+1, r25	; 0x01
    142a:	80 83       	st	Z, r24
        timerOVF[axis][i] = rate; //Hmm, for some reason this one doesn't need 1 subtracting???
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
    142c:	08 94       	sec
    142e:	61 1c       	adc	r6, r1
    1430:	71 1c       	adc	r7, r1
    1432:	81 1c       	adc	r8, r1
    1434:	91 1c       	adc	r9, r1
    1436:	6a 14       	cp	r6, r10
    1438:	7b 04       	cpc	r7, r11
    143a:	8c 04       	cpc	r8, r12
    143c:	9d 04       	cpc	r9, r13
    143e:	80 f2       	brcs	.-96     	; 0x13e0 <calculateRate+0x100>
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    }
    
}
    1440:	df 91       	pop	r29
    1442:	cf 91       	pop	r28
    1444:	1f 91       	pop	r17
    1446:	0f 91       	pop	r16
    1448:	ff 90       	pop	r15
    144a:	ef 90       	pop	r14
    144c:	df 90       	pop	r13
    144e:	cf 90       	pop	r12
    1450:	bf 90       	pop	r11
    1452:	af 90       	pop	r10
    1454:	9f 90       	pop	r9
    1456:	8f 90       	pop	r8
    1458:	7f 90       	pop	r7
    145a:	6f 90       	pop	r6
    145c:	08 95       	ret

0000145e <systemInitialiser>:

void systemInitialiser(){    
    
    encodeDirection[RA] = EEPROM_readByte(RAReverse_Address) ? CMD_REVERSE : CMD_FORWARD;  //reverse the right ascension if 1
    145e:	89 e0       	ldi	r24, 0x09	; 9
    1460:	90 e0       	ldi	r25, 0x00	; 0
    1462:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    1466:	10 92 84 01 	sts	0x0184, r1
    146a:	88 23       	and	r24, r24
    146c:	19 f0       	breq	.+6      	; 0x1474 <systemInitialiser+0x16>
    146e:	81 e0       	ldi	r24, 0x01	; 1
    1470:	80 93 84 01 	sts	0x0184, r24
    encodeDirection[DC] = EEPROM_readByte(DECReverse_Address) ? CMD_REVERSE : CMD_FORWARD; //reverse the declination if 1
    1474:	8a e0       	ldi	r24, 0x0A	; 10
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    147c:	10 92 85 01 	sts	0x0185, r1
    1480:	88 23       	and	r24, r24
    1482:	19 f0       	breq	.+6      	; 0x148a <systemInitialiser+0x2c>
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	80 93 85 01 	sts	0x0185, r24
    
    driverVersion = EEPROM_readByte(Driver_Address);
    148a:	8b e0       	ldi	r24, 0x0B	; 11
    148c:	90 e0       	ldi	r25, 0x00	; 0
    148e:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    1492:	80 93 88 01 	sts	0x0188, r24
    microstepConf = EEPROM_readByte(Microstep_Address);
    1496:	88 e0       	ldi	r24, 0x08	; 8
    1498:	90 e0       	ldi	r25, 0x00	; 0
    149a:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    149e:	80 93 87 01 	sts	0x0187, r24

    allowAdvancedHCDetection = !EEPROM_readByte(AdvHCEnable_Address);
    14a2:	8b e2       	ldi	r24, 0x2B	; 43
    14a4:	90 e0       	ldi	r25, 0x00	; 0
    14a6:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    14aa:	10 92 0d 02 	sts	0x020D, r1
    14ae:	88 23       	and	r24, r24
    14b0:	19 f4       	brne	.+6      	; 0x14b8 <systemInitialiser+0x5a>
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	80 93 0d 02 	sts	0x020D, r24
    
    defaultSpeedState = (microstepConf >= 8) ? SPEEDNORM : SPEEDFAST;
    14b8:	10 92 0b 02 	sts	0x020B, r1
    14bc:	80 91 87 01 	lds	r24, 0x0187
    14c0:	88 30       	cpi	r24, 0x08	; 8
    14c2:	18 f4       	brcc	.+6      	; 0x14ca <systemInitialiser+0x6c>
    14c4:	81 e0       	ldi	r24, 0x01	; 1
    14c6:	80 93 0b 02 	sts	0x020B, r24
    disableGearChange = !EEPROM_readByte(GearEnable_Address);
    14ca:	8a e2       	ldi	r24, 0x2A	; 42
    14cc:	90 e0       	ldi	r25, 0x00	; 0
    14ce:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    14d2:	90 e0       	ldi	r25, 0x00	; 0
    14d4:	88 23       	and	r24, r24
    14d6:	09 f4       	brne	.+2      	; 0x14da <systemInitialiser+0x7c>
    14d8:	91 e0       	ldi	r25, 0x01	; 1
    14da:	90 93 0c 02 	sts	0x020C, r25
    canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    14de:	80 91 87 01 	lds	r24, 0x0187
    14e2:	88 30       	cpi	r24, 0x08	; 8
    14e4:	10 f4       	brcc	.+4      	; 0x14ea <systemInitialiser+0x8c>
    14e6:	80 e0       	ldi	r24, 0x00	; 0
    14e8:	02 c0       	rjmp	.+4      	; 0x14ee <systemInitialiser+0x90>
    14ea:	81 e0       	ldi	r24, 0x01	; 1
    14ec:	89 27       	eor	r24, r25
    14ee:	80 93 0a 02 	sts	0x020A, r24
        
    synta_initialise(ASTROEQ_VER,(canJumpToHighspeed ? 8 : 1)); //initialise mount instance, specify version!
    14f2:	88 23       	and	r24, r24
    14f4:	11 f4       	brne	.+4      	; 0x14fa <systemInitialiser+0x9c>
    14f6:	41 e0       	ldi	r20, 0x01	; 1
    14f8:	01 c0       	rjmp	.+2      	; 0x14fc <systemInitialiser+0x9e>
    14fa:	48 e0       	ldi	r20, 0x08	; 8
    14fc:	62 e2       	ldi	r22, 0x22	; 34
    14fe:	73 e0       	ldi	r23, 0x03	; 3
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	90 e0       	ldi	r25, 0x00	; 0
    1504:	0e 94 1d 13 	call	0x263a	; 0x263a <_Z16synta_initialisemh>
    
    buildModeMapping(microstepConf, driverVersion);
    1508:	80 91 87 01 	lds	r24, 0x0187
    150c:	60 91 88 01 	lds	r22, 0x0188
    1510:	0e 94 a5 00 	call	0x14a	; 0x14a <buildModeMapping>
    
    if(!checkEEPROM()){
    1514:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <checkEEPROM>
    1518:	88 23       	and	r24, r24
    151a:	19 f4       	brne	.+6      	; 0x1522 <systemInitialiser+0xc4>
        progMode = PROGMODE; //prevent AstroEQ startup if EEPROM is blank.
    151c:	81 e0       	ldi	r24, 0x01	; 1
    151e:	80 93 86 01 	sts	0x0186, r24
    }

    calculateRate(RA); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    1522:	80 e0       	ldi	r24, 0x00	; 0
    1524:	0e 94 70 09 	call	0x12e0	; 0x12e0 <calculateRate>
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    1528:	81 e0       	ldi	r24, 0x01	; 1
    152a:	0e 94 70 09 	call	0x12e0	; 0x12e0 <calculateRate>
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    152e:	40 91 75 02 	lds	r20, 0x0275
    1532:	50 91 76 02 	lds	r21, 0x0276
    1536:	ed e7       	ldi	r30, 0x7D	; 125
    1538:	f2 e0       	ldi	r31, 0x02	; 2
    153a:	20 e0       	ldi	r18, 0x00	; 0
    153c:	30 e0       	ldi	r19, 0x00	; 0
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
    153e:	80 81       	ld	r24, Z
    1540:	91 81       	ldd	r25, Z+1	; 0x01
    1542:	48 17       	cp	r20, r24
    1544:	59 07       	cpc	r21, r25
    1546:	50 f4       	brcc	.+20     	; 0x155c <systemInitialiser+0xfe>
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
    1548:	82 81       	ldd	r24, Z+2	; 0x02
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	01 96       	adiw	r24, 0x01	; 1
    154e:	28 0f       	add	r18, r24
    1550:	39 1f       	adc	r19, r25
    1552:	33 96       	adiw	r30, 0x03	; 3

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
    1554:	83 e0       	ldi	r24, 0x03	; 3
    1556:	ed 33       	cpi	r30, 0x3D	; 61
    1558:	f8 07       	cpc	r31, r24
    155a:	89 f7       	brne	.-30     	; 0x153e <systemInitialiser+0xe0>
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
    155c:	30 93 0f 02 	sts	0x020F, r19
    1560:	20 93 0e 02 	sts	0x020E, r18
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    1564:	40 91 77 02 	lds	r20, 0x0277
    1568:	50 91 78 02 	lds	r21, 0x0278
    156c:	ed e3       	ldi	r30, 0x3D	; 61
    156e:	f3 e0       	ldi	r31, 0x03	; 3
    1570:	20 e0       	ldi	r18, 0x00	; 0
    1572:	30 e0       	ldi	r19, 0x00	; 0
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
    1574:	80 81       	ld	r24, Z
    1576:	91 81       	ldd	r25, Z+1	; 0x01
    1578:	48 17       	cp	r20, r24
    157a:	59 07       	cpc	r21, r25
    157c:	50 f4       	brcc	.+20     	; 0x1592 <systemInitialiser+0x134>
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
    157e:	82 81       	ldd	r24, Z+2	; 0x02
    1580:	90 e0       	ldi	r25, 0x00	; 0
    1582:	01 96       	adiw	r24, 0x01	; 1
    1584:	28 0f       	add	r18, r24
    1586:	39 1f       	adc	r19, r25
    1588:	33 96       	adiw	r30, 0x03	; 3

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
    158a:	83 e0       	ldi	r24, 0x03	; 3
    158c:	ed 3f       	cpi	r30, 0xFD	; 253
    158e:	f8 07       	cpc	r31, r24
    1590:	89 f7       	brne	.-30     	; 0x1574 <systemInitialiser+0x116>
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
    1592:	30 93 11 02 	sts	0x0211, r19
    1596:	20 93 10 02 	sts	0x0210, r18
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateDecelerationLength(RA);
    calculateDecelerationLength(DC);
    
    //Status pin to output low
    setPinDir  (statusPin,OUTPUT);
    159a:	bf 9a       	sbi	0x17, 7	; 23
    setPinValue(statusPin,   LOW);
    159c:	c7 98       	cbi	0x18, 7	; 24

    //Standalone Speed/IRQ pin to input no-pullup
    setPinDir  (standalonePin[  STANDALONE_IRQ], INPUT);
    159e:	8a 98       	cbi	0x11, 2	; 17
    setPinValue(standalonePin[  STANDALONE_IRQ],  HIGH); //enable pull-up to pull IRQ high.
    15a0:	92 9a       	sbi	0x12, 2	; 18

    //Standalone Pullup/Pulldown pin to output high
    setPinDir  (standalonePin[ STANDALONE_PULL],OUTPUT);
    15a2:	30 9a       	sbi	0x06, 0	; 6
    setPinValue(standalonePin[ STANDALONE_PULL],  HIGH);
    15a4:	38 9a       	sbi	0x07, 0	; 7
    
    //ST4 pins to input with pullup
    setPinDir  (st4Pins[RA][ST4P],INPUT);
    15a6:	d7 98       	cbi	0x1a, 7	; 26
    setPinValue(st4Pins[RA][ST4P],HIGH );
    15a8:	df 9a       	sbi	0x1b, 7	; 27
    setPinDir  (st4Pins[RA][ST4N],INPUT);
    15aa:	d4 98       	cbi	0x1a, 4	; 26
    setPinValue(st4Pins[RA][ST4N],HIGH );
    15ac:	dc 9a       	sbi	0x1b, 4	; 27
    setPinDir  (st4Pins[DC][ST4P],INPUT);
    15ae:	d6 98       	cbi	0x1a, 6	; 26
    setPinValue(st4Pins[DC][ST4P],HIGH );
    15b0:	de 9a       	sbi	0x1b, 6	; 27
    setPinDir  (st4Pins[DC][ST4N],INPUT);
    15b2:	d5 98       	cbi	0x1a, 5	; 26
    setPinValue(st4Pins[DC][ST4N],HIGH );
    15b4:	dd 9a       	sbi	0x1b, 5	; 27
    
    //Reset pins to output
    setPinDir  (resetPin[RA],OUTPUT);
    15b6:	d1 9a       	sbi	0x1a, 1	; 26
    setPinValue(resetPin[RA],   LOW);  //Motor driver in Reset
    15b8:	d9 98       	cbi	0x1b, 1	; 27
    setPinDir  (resetPin[DC],OUTPUT);
    15ba:	d0 9a       	sbi	0x1a, 0	; 26
    setPinValue(resetPin[DC],   LOW);  //Motor driver in Reset 
    15bc:	d8 98       	cbi	0x1b, 0	; 27
    
    //Enable pins to output
    setPinDir  (enablePin[RA],OUTPUT);
    15be:	8e 9a       	sbi	0x11, 6	; 17
    setPinValue(enablePin[RA],  HIGH); //Motor Driver Disabled
    15c0:	96 9a       	sbi	0x12, 6	; 18
    setPinDir  (enablePin[DC],OUTPUT);
    15c2:	b8 9a       	sbi	0x17, 0	; 23
    setPinValue(enablePin[DC],  HIGH); //Motor Driver Disabled
    15c4:	c0 9a       	sbi	0x18, 0	; 24
    
    //Step pins to output
    setPinDir  (stepPin[RA],OUTPUT);
    15c6:	8c 9a       	sbi	0x11, 4	; 17
    setPinValue(stepPin[RA],   LOW);
    15c8:	94 98       	cbi	0x12, 4	; 18
    setPinDir  (stepPin[DC],OUTPUT);
    15ca:	32 9a       	sbi	0x06, 2	; 6
    setPinValue(stepPin[DC],   LOW);
    15cc:	3a 98       	cbi	0x07, 2	; 7
    
    //Direction pins to output
    setPinDir  (dirPin[RA],OUTPUT);
    15ce:	8b 9a       	sbi	0x11, 3	; 17
    setPinValue(dirPin[RA],   LOW);
    15d0:	93 98       	cbi	0x12, 3	; 18
    setPinDir  (dirPin[DC],OUTPUT);
    15d2:	8f 9a       	sbi	0x11, 7	; 17
    setPinValue(dirPin[DC],   LOW);
    15d4:	97 98       	cbi	0x12, 7	; 18
    
    //Load the correct mode
    byte state = modeState[defaultSpeedState]; //Extract the default mode - If the microstep mode is >= then we start in NORMAL mode, otherwise we use FAST mode

    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    15d6:	e0 91 0b 02 	lds	r30, 0x020B
    15da:	f0 e0       	ldi	r31, 0x00	; 0
    15dc:	e7 5f       	subi	r30, 0xF7	; 247
    15de:	fe 4f       	sbci	r31, 0xFE	; 254
    15e0:	80 81       	ld	r24, Z
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	9c 01       	movw	r18, r24
    15e6:	21 70       	andi	r18, 0x01	; 1
    15e8:	30 70       	andi	r19, 0x00	; 0
    15ea:	80 ff       	sbrs	r24, 0
    15ec:	02 c0       	rjmp	.+4      	; 0x15f2 <systemInitialiser+0x194>
    15ee:	95 9a       	sbi	0x12, 5	; 18
    15f0:	01 c0       	rjmp	.+2      	; 0x15f4 <systemInitialiser+0x196>
    15f2:	95 98       	cbi	0x12, 5	; 18
    setPinDir  (modePins[RA][MODE0],  OUTPUT                      ); 
    15f4:	8d 9a       	sbi	0x11, 5	; 17
    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    15f6:	23 2b       	or	r18, r19
    15f8:	11 f0       	breq	.+4      	; 0x15fe <systemInitialiser+0x1a0>
    15fa:	c4 9a       	sbi	0x18, 4	; 24
    15fc:	01 c0       	rjmp	.+2      	; 0x1600 <systemInitialiser+0x1a2>
    15fe:	c4 98       	cbi	0x18, 4	; 24
    setPinDir  (modePins[DC][MODE0],  OUTPUT                      );
    1600:	bc 9a       	sbi	0x17, 4	; 23
    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    1602:	9c 01       	movw	r18, r24
    1604:	22 70       	andi	r18, 0x02	; 2
    1606:	30 70       	andi	r19, 0x00	; 0
    1608:	81 ff       	sbrs	r24, 1
    160a:	02 c0       	rjmp	.+4      	; 0x1610 <systemInitialiser+0x1b2>
    160c:	db 9a       	sbi	0x1b, 3	; 27
    160e:	01 c0       	rjmp	.+2      	; 0x1612 <systemInitialiser+0x1b4>
    1610:	db 98       	cbi	0x1b, 3	; 27
    setPinDir  (modePins[RA][MODE1],  OUTPUT                      );
    1612:	d3 9a       	sbi	0x1a, 3	; 26
    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    1614:	23 2b       	or	r18, r19
    1616:	11 f0       	breq	.+4      	; 0x161c <systemInitialiser+0x1be>
    1618:	c3 9a       	sbi	0x18, 3	; 24
    161a:	01 c0       	rjmp	.+2      	; 0x161e <systemInitialiser+0x1c0>
    161c:	c3 98       	cbi	0x18, 3	; 24
    setPinDir  (modePins[DC][MODE1],  OUTPUT                      );
    161e:	bb 9a       	sbi	0x17, 3	; 23
    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    1620:	ac 01       	movw	r20, r24
    1622:	44 70       	andi	r20, 0x04	; 4
    1624:	50 70       	andi	r21, 0x00	; 0
    1626:	82 ff       	sbrs	r24, 2
    1628:	02 c0       	rjmp	.+4      	; 0x162e <systemInitialiser+0x1d0>
    162a:	da 9a       	sbi	0x1b, 2	; 27
    162c:	01 c0       	rjmp	.+2      	; 0x1630 <systemInitialiser+0x1d2>
    162e:	da 98       	cbi	0x1b, 2	; 27
    setPinDir  (modePins[RA][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    1630:	9c 01       	movw	r18, r24
    1632:	20 72       	andi	r18, 0x20	; 32
    1634:	30 70       	andi	r19, 0x00	; 0
    1636:	85 fd       	sbrc	r24, 5
    1638:	02 c0       	rjmp	.+4      	; 0x163e <systemInitialiser+0x1e0>
    163a:	d2 9a       	sbi	0x1a, 2	; 26
    163c:	01 c0       	rjmp	.+2      	; 0x1640 <systemInitialiser+0x1e2>
    163e:	d2 98       	cbi	0x1a, 2	; 26
    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    1640:	45 2b       	or	r20, r21
    1642:	11 f0       	breq	.+4      	; 0x1648 <systemInitialiser+0x1ea>
    1644:	c2 9a       	sbi	0x18, 2	; 24
    1646:	01 c0       	rjmp	.+2      	; 0x164a <systemInitialiser+0x1ec>
    1648:	c2 98       	cbi	0x18, 2	; 24
    setPinDir  (modePins[DC][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    164a:	23 2b       	or	r18, r19
    164c:	11 f4       	brne	.+4      	; 0x1652 <systemInitialiser+0x1f4>
    164e:	ba 9a       	sbi	0x17, 2	; 23
    1650:	01 c0       	rjmp	.+2      	; 0x1654 <systemInitialiser+0x1f6>
    1652:	ba 98       	cbi	0x17, 2	; 23
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    1654:	80 ea       	ldi	r24, 0xA0	; 160
    1656:	9f e0       	ldi	r25, 0x0F	; 15
    1658:	01 97       	sbiw	r24, 0x01	; 1
    165a:	f1 f7       	brne	.-4      	; 0x1658 <systemInitialiser+0x1fa>

    //Give some time for the Motor Drivers to reset.
    _delay_ms(1);

    //Then bring them out of reset.
    setPinValue(resetPin[RA],HIGH);
    165c:	d9 9a       	sbi	0x1b, 1	; 27
    setPinValue(resetPin[DC],HIGH);
    165e:	d8 9a       	sbi	0x1b, 0	; 27
    //Timer 0 registers are being used as general purpose data storage for high efficency
    //interrupt routines. So timer must be fully disabled. The ATMegaxxx0 has three of these
    //registers, but the ATMega162 doesn't, so I've had to improvise and use other registers
    //instead. See PinMappings.h for the ATMega162 to see which registers have been #defined
    //as GPIORx.
    TIMSK &= ~(_BV(TOIE0) | _BV(OCIE0));
    1660:	89 b7       	in	r24, 0x39	; 57
    1662:	8c 7f       	andi	r24, 0xFC	; 252
    1664:	89 bf       	out	0x39, r24	; 57
    TCCR0 = 0;
    1666:	13 be       	out	0x33, r1	; 51
#endif

    //Ensure SPI is disabled
    SPI_disable();
    1668:	0e 94 19 11 	call	0x2232	; 0x2232 <_Z11SPI_disablev>
    
    //Initialise the Serial port:
    Serial_initialise(BAUD_RATE); //SyncScan runs at 9600Baud, use a serial port of your choice as defined in SerialLink.h
    166c:	60 e8       	ldi	r22, 0x80	; 128
    166e:	75 e2       	ldi	r23, 0x25	; 37
    1670:	80 e0       	ldi	r24, 0x00	; 0
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	0e 94 aa 10 	call	0x2154	; 0x2154 <_Z17Serial_initialisem>
      
}
    1678:	08 95       	ret

0000167a <main>:

/*
 * AstroEQ firmware main() function
 */

int main(void) {
    167a:	2f 92       	push	r2
    167c:	3f 92       	push	r3
    167e:	4f 92       	push	r4
    1680:	5f 92       	push	r5
    1682:	6f 92       	push	r6
    1684:	7f 92       	push	r7
    1686:	8f 92       	push	r8
    1688:	9f 92       	push	r9
    168a:	af 92       	push	r10
    168c:	bf 92       	push	r11
    168e:	cf 92       	push	r12
    1690:	df 92       	push	r13
    1692:	ef 92       	push	r14
    1694:	ff 92       	push	r15
    1696:	0f 93       	push	r16
    1698:	1f 93       	push	r17
    169a:	df 93       	push	r29
    169c:	cf 93       	push	r28
    169e:	cd b7       	in	r28, 0x3d	; 61
    16a0:	de b7       	in	r29, 0x3e	; 62
    16a2:	2e 97       	sbiw	r28, 0x0e	; 14
    16a4:	0f b6       	in	r0, 0x3f	; 63
    16a6:	f8 94       	cli
    16a8:	de bf       	out	0x3e, r29	; 62
    16aa:	0f be       	out	0x3f, r0	; 63
    16ac:	cd bf       	out	0x3d, r28	; 61
    //Enable global interrupt flag
    sei();
    16ae:	78 94       	sei
    //Initialise global variables from the EEPROM
    systemInitialiser();
    16b0:	0e 94 2f 0a 	call	0x145e	; 0x145e <systemInitialiser>
    16b4:	ee 24       	eor	r14, r14
    16b6:	ff 24       	eor	r15, r15
    16b8:	aa 24       	eor	r10, r10
    16ba:	00 e0       	ldi	r16, 0x00	; 0
    16bc:	cc 24       	eor	r12, r12
    16be:	bb 24       	eor	r11, r11
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
    16c0:	41 2c       	mov	r4, r1
    16c2:	51 2c       	mov	r5, r1
    16c4:	80 e8       	ldi	r24, 0x80	; 128
    16c6:	68 2e       	mov	r6, r24
    16c8:	71 2c       	mov	r7, r1
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
    16ca:	1e 01       	movw	r2, r28
    16cc:	08 94       	sec
    16ce:	21 1c       	adc	r2, r1
    16d0:	31 1c       	adc	r3, r1
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    16d2:	dd 24       	eor	r13, r13
    16d4:	da 94       	dec	r13
                if (decoded != -2) {
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
    16d6:	14 e0       	ldi	r17, 0x04	; 4
    16d8:	81 2e       	mov	r8, r17
    16da:	91 2c       	mov	r9, r1
    16dc:	8c 0e       	add	r8, r28
    16de:	9d 1e       	adc	r9, r29
    int8_t decoded = 0; //Whether we have decoded the packet
    char decodedPacket[11]; //temporary store for completed command ready to be processed
    
    for(;;){ //Run loop

        loopCount++; //Counter used to time events based on number of loops.
    16e0:	08 94       	sec
    16e2:	e1 1c       	adc	r14, r1
    16e4:	f1 1c       	adc	r15, r1

        if (!standaloneMode && (loopCount == 0)) { 
    16e6:	80 91 89 01 	lds	r24, 0x0189
    16ea:	88 23       	and	r24, r24
    16ec:	09 f0       	breq	.+2      	; 0x16f0 <main+0x76>
    16ee:	7c c0       	rjmp	.+248    	; 0x17e8 <main+0x16e>
    16f0:	e1 14       	cp	r14, r1
    16f2:	f1 04       	cpc	r15, r1
    16f4:	09 f0       	breq	.+2      	; 0x16f8 <main+0x7e>
    16f6:	78 c0       	rjmp	.+240    	; 0x17e8 <main+0x16e>
            //If we are not in standalone mode, periodically check if we have just entered it
            byte mode = standaloneModeTest();
    16f8:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <standaloneModeTest>
    16fc:	18 2f       	mov	r17, r24
            if (mode != EQMOD_MODE) {
    16fe:	88 23       	and	r24, r24
    1700:	09 f4       	brne	.+2      	; 0x1704 <main+0x8a>
    1702:	72 c0       	rjmp	.+228    	; 0x17e8 <main+0x16e>
                //If we have just entered stand-alone mode, then we enable the motors and configure the mount
                motorStop(RA, true); //Ensure both motors are stopped
    1704:	80 e0       	ldi	r24, 0x00	; 0
    1706:	61 e0       	ldi	r22, 0x01	; 1
    1708:	0e 94 4b 03 	call	0x696	; 0x696 <motorStop>
                motorStop(DC, true);
    170c:	81 e0       	ldi	r24, 0x01	; 1
    170e:	61 e0       	ldi	r22, 0x01	; 1
    1710:	0e 94 4b 03 	call	0x696	; 0x696 <motorStop>
                
                //This next bit needs to be atomic
                byte oldSREG = SREG; 
    1714:	8f b7       	in	r24, 0x3f	; 63
                cli();  
    1716:	f8 94       	cli
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
    1718:	40 92 16 02 	sts	0x0216, r4
    171c:	50 92 17 02 	sts	0x0217, r5
    1720:	60 92 18 02 	sts	0x0218, r6
    1724:	70 92 19 02 	sts	0x0219, r7
                cmd_setjVal(RA, 0x800000); //set the current position to the middle
                cmd_setjVal(DC, 0x800000); //set the current position to the middle
                SREG = oldSREG;
    1728:	40 92 1a 02 	sts	0x021A, r4
    172c:	50 92 1b 02 	sts	0x021B, r5
    1730:	60 92 1c 02 	sts	0x021C, r6
    1734:	70 92 1d 02 	sts	0x021D, r7
    1738:	8f bf       	out	0x3f, r24	; 63
                //End atomic
                //Disable Serial
                Serial_disable();
    173a:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <_Z14Serial_disablev>
    
                //We are now in standalone mode.
                standaloneMode = true; 
    173e:	81 e0       	ldi	r24, 0x01	; 1
    1740:	80 93 89 01 	sts	0x0189, r24
                
                //Next check what type of hand controller we have
                if (mode == ADVANCED_HC_MODE) {
    1744:	12 30       	cpi	r17, 0x02	; 2
    1746:	81 f4       	brne	.+32     	; 0x1768 <main+0xee>
                    //We pulled low, but pin stayed high
                    //This means we must have an advanced controller actively pulling the line high
                    syntaMode = true; 
    1748:	80 93 08 01 	sts	0x0108, r24
                    
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    174c:	0e 94 01 11 	call	0x2202	; 0x2202 <_Z14SPI_initialisev>
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
    1750:	c1 01       	movw	r24, r2
    1752:	60 e0       	ldi	r22, 0x00	; 0
    1754:	20 e0       	ldi	r18, 0x00	; 0
    1756:	30 e0       	ldi	r19, 0x00	; 0
    1758:	40 e0       	ldi	r20, 0x00	; 0
    175a:	50 e0       	ldi	r21, 0x00	; 0
    175c:	0e 94 ad 12 	call	0x255a	; 0x255a <_Z22synta_assembleResponsePccm>
                    Serial_writeStr(welcome); //Send error packet to trigger controller state machine.
    1760:	c1 01       	movw	r24, r2
    1762:	0e 94 b5 11 	call	0x236a	; 0x236a <_Z15Serial_writeStrPc>
    1766:	40 c0       	rjmp	.+128    	; 0x17e8 <main+0x16e>
                    
                } else {
                    //Pin either is being pulled low by us or by something else
                    //This means we might have a basic controller actively pulling the line low
                    //Even if we don't we would default to basic mode.
                    syntaMode = false;
    1768:	10 92 08 01 	sts	0x0108, r1
                    
                    //High speed not supported in Basic HC
                    canJumpToHighspeed = false;
    176c:	10 92 0a 02 	sts	0x020A, r1
                    
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    1770:	38 9a       	sbi	0x07, 0	; 7
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    1772:	e0 91 0b 02 	lds	r30, 0x020B
    1776:	f0 e0       	ldi	r31, 0x00	; 0
    1778:	e7 5f       	subi	r30, 0xF7	; 247
    177a:	fe 4f       	sbci	r31, 0xFE	; 254
    177c:	80 81       	ld	r24, Z
    177e:	80 ff       	sbrs	r24, 0
    1780:	03 c0       	rjmp	.+6      	; 0x1788 <main+0x10e>
    1782:	95 9a       	sbi	0x12, 5	; 18
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    1784:	c4 9a       	sbi	0x18, 4	; 24
    1786:	02 c0       	rjmp	.+4      	; 0x178c <main+0x112>
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    1788:	95 98       	cbi	0x12, 5	; 18
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    178a:	c4 98       	cbi	0x18, 4	; 24
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    178c:	81 ff       	sbrs	r24, 1
    178e:	03 c0       	rjmp	.+6      	; 0x1796 <main+0x11c>
    1790:	db 9a       	sbi	0x1b, 3	; 27
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    1792:	c3 9a       	sbi	0x18, 3	; 24
    1794:	02 c0       	rjmp	.+4      	; 0x179a <main+0x120>
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    1796:	db 98       	cbi	0x1b, 3	; 27
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    1798:	c3 98       	cbi	0x18, 3	; 24
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    179a:	82 ff       	sbrs	r24, 2
    179c:	03 c0       	rjmp	.+6      	; 0x17a4 <main+0x12a>
    179e:	da 9a       	sbi	0x1b, 2	; 27
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    17a0:	c2 9a       	sbi	0x18, 2	; 24
    17a2:	02 c0       	rjmp	.+4      	; 0x17a8 <main+0x12e>
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    17a4:	da 98       	cbi	0x1b, 2	; 27
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    17a6:	c2 98       	cbi	0x18, 2	; 24
                    
                    Commands_configureST4Speed(CMD_ST4_DEFAULT); //Change the ST4 speeds to default
    17a8:	80 e0       	ldi	r24, 0x00	; 0
    17aa:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <_Z26Commands_configureST4Speedh>
                    
                    motorEnable(RA); //Ensure the motors are enabled
    17ae:	80 e0       	ldi	r24, 0x00	; 0
    17b0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <motorEnable>
                    motorEnable(DC);
    17b4:	81 e0       	ldi	r24, 0x01	; 1
    17b6:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <motorEnable>
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
    17ba:	21 e0       	ldi	r18, 0x01	; 1
    17bc:	20 93 26 02 	sts	0x0226, r18
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    17c0:	20 93 27 02 	sts	0x0227, r18
    17c4:	10 92 32 02 	sts	0x0232, r1

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    17c8:	20 93 30 02 	sts	0x0230, r18
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    17cc:	10 92 33 02 	sts	0x0233, r1

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    17d0:	20 93 30 02 	sts	0x0230, r18
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    17d4:	80 91 69 02 	lds	r24, 0x0269
    17d8:	90 91 6a 02 	lds	r25, 0x026A
    17dc:	90 93 1f 02 	sts	0x021F, r25
    17e0:	80 93 1e 02 	sts	0x021E, r24
                    cmd_updateStepDir(RA ,1);
                    cmd_setDir       (DC, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA,1);
                    cmd_setIVal      (RA, cmd.siderealIVal[RA]); //Set RA speed to sidereal
                    
                    readyToGo[RA] = 1; //Signal we are ready to go on the RA axis to start sideral tracking
    17e4:	20 93 7a 01 	sts	0x017A, r18
            }
            //If we end up in standalone mode, we don't exit until a reset.
        }

        /////////////
        if (syntaMode) {
    17e8:	80 91 08 01 	lds	r24, 0x0108
    17ec:	88 23       	and	r24, r24
    17ee:	09 f4       	brne	.+2      	; 0x17f2 <main+0x178>
    17f0:	50 c1       	rjmp	.+672    	; 0x1a92 <main+0x418>
        //
        // EQMOD or Advanced Hand Controller Synta Mode
        //
            //Check if we need to run the command parser
            
            if ((decoded == -2) || Serial_available()) { //is there a byte in buffer or we still need to process the previous byte?
    17f2:	0e 3f       	cpi	r16, 0xFE	; 254
    17f4:	21 f0       	breq	.+8      	; 0x17fe <main+0x184>
    17f6:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_Z16Serial_availablev>
    17fa:	88 23       	and	r24, r24
    17fc:	61 f1       	breq	.+88     	; 0x1856 <main+0x1dc>
                //Toggle on the LED to indicate activity.
                togglePin(statusPin);
    17fe:	88 b3       	in	r24, 0x18	; 24
    1800:	80 58       	subi	r24, 0x80	; 128
    1802:	88 bb       	out	0x18, r24	; 24
                //See what character we need to parse
                if (decoded != -2) {
    1804:	0e 3f       	cpi	r16, 0xFE	; 254
    1806:	19 f0       	breq	.+6      	; 0x180e <main+0x194>
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
    1808:	0e 94 71 11 	call	0x22e2	; 0x22e2 <_Z11Serial_readv>
    180c:	a8 2e       	mov	r10, r24
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
    180e:	c4 01       	movw	r24, r8
    1810:	6a 2d       	mov	r22, r10
    1812:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <_Z20synta_recieveCommandPcc>
    1816:	08 2f       	mov	r16, r24
                //Once full command packet recieved, synta_recieveCommand populates either an error packet (and returns -1), or data packet (returns 1). If incomplete, decodedPacket is unchanged and 0 is returned
                if (decoded != 0){ //Send a response
    1818:	88 23       	and	r24, r24
    181a:	e9 f0       	breq	.+58     	; 0x1856 <main+0x1dc>
                    if (decoded > 0){ //Valid Packet, current command is in decoded variable.
    181c:	18 16       	cp	r1, r24
    181e:	14 f0       	brlt	.+4      	; 0x1824 <main+0x1aa>
    1820:	10 e0       	ldi	r17, 0x00	; 0
    1822:	05 c0       	rjmp	.+10     	; 0x182e <main+0x1b4>
                        mcuReset = !decodeCommand(decoded,decodedPacket); //decode the valid packet and populate response.
    1824:	b4 01       	movw	r22, r8
    1826:	0e 94 46 06 	call	0xc8c	; 0xc8c <decodeCommand>
    182a:	11 e0       	ldi	r17, 0x01	; 1
    182c:	18 27       	eor	r17, r24
                    }
                    Serial_writeStr(decodedPacket); //send the response packet (recieveCommand() generated the error packet, or decodeCommand() a valid response)
    182e:	c4 01       	movw	r24, r8
    1830:	0e 94 b5 11 	call	0x236a	; 0x236a <_Z15Serial_writeStrPc>
                } //otherwise command not yet fully recieved, so wait for next byte
                
                if (mcuReset) {
    1834:	11 23       	and	r17, r17
    1836:	79 f0       	breq	.+30     	; 0x1856 <main+0x1dc>
                    //Special case. We were asked to reset the MCU.
                    Serial_flush(); //Flush out last response.
    1838:	0e 94 a5 11 	call	0x234a	; 0x234a <_Z12Serial_flushv>
                    wdt_enable(WDTO_120MS); //WDT has been set to reset MCU.
    183c:	2b e0       	ldi	r18, 0x0B	; 11
    183e:	88 e1       	ldi	r24, 0x18	; 24
    1840:	90 e0       	ldi	r25, 0x00	; 0
    1842:	0f b6       	in	r0, 0x3f	; 63
    1844:	f8 94       	cli
    1846:	a8 95       	wdr
    1848:	81 bd       	out	0x21, r24	; 33
    184a:	0f be       	out	0x3f, r0	; 63
    184c:	21 bd       	out	0x21, r18	; 33
                    exit(0); //Done
    184e:	80 e0       	ldi	r24, 0x00	; 0
    1850:	90 e0       	ldi	r25, 0x00	; 0
    1852:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <_exit>
                }
            }
            if (loopCount == 0) {
    1856:	e1 14       	cp	r14, r1
    1858:	f1 04       	cpc	r15, r1
    185a:	09 f4       	brne	.+2      	; 0x185e <main+0x1e4>
                setPinValue(statusPin, 0);
    185c:	c7 98       	cbi	0x18, 7	; 24
            }
            
            //
            //ST4 button handling
            //
            if (!standaloneMode && ((loopCount & 0xFF) == 0)){
    185e:	80 91 89 01 	lds	r24, 0x0189
    1862:	88 23       	and	r24, r24
    1864:	09 f0       	breq	.+2      	; 0x1868 <main+0x1ee>
    1866:	62 c0       	rjmp	.+196    	; 0x192c <main+0x2b2>
    1868:	ee 20       	and	r14, r14
    186a:	09 f0       	breq	.+2      	; 0x186e <main+0x1f4>
    186c:	5f c0       	rjmp	.+190    	; 0x192c <main+0x2b2>
                //We only check the ST-4 buttons in EQMOD mode when not doing Go-To, and only every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //In Synta mode, we only allow the ST-4 port to move forward, and only if EQMOD has configured us previously to be in tracking mode
                    if ((cmd.dir[RA] == CMD_FORWARD) && (readyToGo[RA] == 2)) {
    186e:	80 91 32 02 	lds	r24, 0x0232
    1872:	88 23       	and	r24, r24
    1874:	b9 f4       	brne	.+46     	; 0x18a4 <main+0x22a>
    1876:	80 91 7a 01 	lds	r24, 0x017A
    187a:	82 30       	cpi	r24, 0x02	; 2
    187c:	99 f4       	brne	.+38     	; 0x18a4 <main+0x22a>
                        //Determine which ST4 pin if any
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    187e:	cd 99       	sbic	0x19, 5	; 25
    1880:	02 c0       	rjmp	.+4      	; 0x1886 <main+0x20c>
    1882:	e1 e0       	ldi	r30, 0x01	; 1
    1884:	b3 c1       	rjmp	.+870    	; 0x1bec <main+0x572>
    1886:	ce 9b       	sbis	0x19, 6	; 25
    1888:	b0 c1       	rjmp	.+864    	; 0x1bea <main+0x570>
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
                            isST4Move[RA] = true; //Now doing ST4 movement
                        }
                        else if (isST4Move[RA]) { 
    188a:	bb 20       	and	r11, r11
    188c:	59 f0       	breq	.+22     	; 0x18a4 <main+0x22a>
    188e:	80 91 69 02 	lds	r24, 0x0269
    1892:	90 91 6a 02 	lds	r25, 0x026A
    1896:	90 93 1f 02 	sts	0x021F, r25
    189a:	80 93 1e 02 	sts	0x021E, r24
                            //Only return to sidereal speed if we are in an ST4 move.
                            cmd_setIVal(RA,cmd.siderealIVal[RA]);
                            motorStartRA();
    189e:	0e 94 1d 01 	call	0x23a	; 0x23a <motorStartRA>
    18a2:	bb 24       	eor	r11, r11
                            isST4Move[RA] = false; //No longer ST4 movement
                        }
                    }
                }//End RA
                
                if (!cmd.gotoEn[DC]) {//Start DEC
    18a4:	80 91 37 02 	lds	r24, 0x0237
    18a8:	88 23       	and	r24, r24
    18aa:	09 f0       	breq	.+2      	; 0x18ae <main+0x234>
    18ac:	3f c0       	rjmp	.+126    	; 0x192c <main+0x2b2>
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    18ae:	cd 99       	sbic	0x19, 5	; 25
    18b0:	03 c0       	rjmp	.+6      	; 0x18b8 <main+0x23e>
    18b2:	51 e0       	ldi	r21, 0x01	; 1
    18b4:	41 e0       	ldi	r20, 0x01	; 1
    18b6:	06 c0       	rjmp	.+12     	; 0x18c4 <main+0x24a>
    18b8:	ce 9b       	sbis	0x19, 6	; 25
    18ba:	02 c0       	rjmp	.+4      	; 0x18c0 <main+0x246>
    18bc:	4f ef       	ldi	r20, 0xFF	; 255
    18be:	01 c0       	rjmp	.+2      	; 0x18c2 <main+0x248>
    18c0:	40 e0       	ldi	r20, 0x00	; 0
    18c2:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir)) {
    18c4:	80 91 39 02 	lds	r24, 0x0239
    18c8:	88 23       	and	r24, r24
    18ca:	71 f4       	brne	.+28     	; 0x18e8 <main+0x26e>
    18cc:	80 91 33 02 	lds	r24, 0x0233
    18d0:	90 e0       	ldi	r25, 0x00	; 0
    18d2:	25 2f       	mov	r18, r21
    18d4:	30 e0       	ldi	r19, 0x00	; 0
    18d6:	82 17       	cp	r24, r18
    18d8:	93 07       	cpc	r25, r19
    18da:	31 f0       	breq	.+12     	; 0x18e8 <main+0x26e>
                        //If we are currently moving in the wrong direction
                        motorStopDC(false); //Stop the Dec motor
    18dc:	80 e0       	ldi	r24, 0x00	; 0
    18de:	0e 94 08 03 	call	0x610	; 0x610 <motorStopDC>
                        readyToGo[DC]=0;    //No longer ready to go as we have now deleted any pre-running EQMOD movement.
    18e2:	10 92 7b 01 	sts	0x017B, r1
    18e6:	22 c0       	rjmp	.+68     	; 0x192c <main+0x2b2>
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
    18e8:	4f 3f       	cpi	r20, 0xFF	; 255
    18ea:	d1 f0       	breq	.+52     	; 0x1920 <main+0x2a6>
    18ec:	80 91 65 02 	lds	r24, 0x0265
    18f0:	90 91 66 02 	lds	r25, 0x0266
    18f4:	90 93 21 02 	sts	0x0221, r25
    18f8:	80 93 20 02 	sts	0x0220, r24
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
    18fc:	25 2f       	mov	r18, r21
    18fe:	51 11       	cpse	r21, r1
    1900:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1902:	20 93 33 02 	sts	0x0233, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1906:	22 23       	and	r18, r18
    1908:	19 f0       	breq	.+6      	; 0x1910 <main+0x296>
        cmd.stepDir[target] = -stepSize; //set step direction
    190a:	d0 92 31 02 	sts	0x0231, r13
    190e:	03 c0       	rjmp	.+6      	; 0x1916 <main+0x29c>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1910:	81 e0       	ldi	r24, 0x01	; 1
    1912:	80 93 31 02 	sts	0x0231, r24
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
    1916:	0e 94 7d 01 	call	0x2fa	; 0x2fa <motorStartDC>
    191a:	cc 24       	eor	r12, r12
    191c:	c3 94       	inc	r12
    191e:	06 c0       	rjmp	.+12     	; 0x192c <main+0x2b2>
                            isST4Move[DC] = true; //Now doing ST4 movement
                        } else if (isST4Move[DC]) {
    1920:	cc 20       	and	r12, r12
    1922:	21 f0       	breq	.+8      	; 0x192c <main+0x2b2>
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
    1924:	80 e0       	ldi	r24, 0x00	; 0
    1926:	0e 94 08 03 	call	0x610	; 0x610 <motorStopDC>
    192a:	cc 24       	eor	r12, r12
                    }
                }//End DEC
            }
            
            //Check both axes - loop unravelled for speed efficiency - lots of Flash available.
            if(readyToGo[RA]==1){
    192c:	90 91 7a 01 	lds	r25, 0x017A
    1930:	91 30       	cpi	r25, 0x01	; 1
    1932:	09 f0       	breq	.+2      	; 0x1936 <main+0x2bc>
    1934:	54 c0       	rjmp	.+168    	; 0x19de <main+0x364>
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[RA] == CMD_STOPPED){
    1936:	80 91 38 02 	lds	r24, 0x0238
    193a:	88 23       	and	r24, r24
    193c:	09 f4       	brne	.+2      	; 0x1940 <main+0x2c6>
    193e:	4f c0       	rjmp	.+158    	; 0x19de <main+0x364>
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[RA];
    1940:	30 91 26 02 	lds	r19, 0x0226
                    if (canJumpToHighspeed){
    1944:	80 91 0a 02 	lds	r24, 0x020A
    1948:	88 23       	and	r24, r24
    194a:	81 f1       	breq	.+96     	; 0x19ac <main+0x332>
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
    194c:	83 2f       	mov	r24, r19
    194e:	81 50       	subi	r24, 0x01	; 1
    1950:	82 30       	cpi	r24, 0x02	; 2
    1952:	70 f4       	brcc	.+28     	; 0x1970 <main+0x2f6>
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
    1954:	20 91 09 01 	lds	r18, 0x0109
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1958:	80 91 32 02 	lds	r24, 0x0232
    195c:	88 23       	and	r24, r24
    195e:	19 f0       	breq	.+6      	; 0x1966 <main+0x2ec>
        cmd.stepDir[target] = -stepSize; //set step direction
    1960:	d0 92 30 02 	sts	0x0230, r13
    1964:	02 c0       	rjmp	.+4      	; 0x196a <main+0x2f0>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1966:	90 93 30 02 	sts	0x0230, r25
                            cmd_updateStepDir(RA,1);
                            cmd.highSpeedMode[RA] = false;
    196a:	10 92 3a 02 	sts	0x023A, r1
    196e:	0d c0       	rjmp	.+26     	; 0x198a <main+0x310>
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
    1970:	20 91 0a 01 	lds	r18, 0x010A
                            cmd_updateStepDir(RA,cmd.gVal[RA]);
    1974:	90 91 54 02 	lds	r25, 0x0254
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1978:	80 91 32 02 	lds	r24, 0x0232
    197c:	81 11       	cpse	r24, r1
        cmd.stepDir[target] = -stepSize; //set step direction
    197e:	91 95       	neg	r25
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1980:	90 93 30 02 	sts	0x0230, r25
                            cmd.highSpeedMode[RA] = true;
    1984:	81 e0       	ldi	r24, 0x01	; 1
    1986:	80 93 3a 02 	sts	0x023A, r24
                        }
                        setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0)));
    198a:	82 2f       	mov	r24, r18
    198c:	20 ff       	sbrs	r18, 0
    198e:	02 c0       	rjmp	.+4      	; 0x1994 <main+0x31a>
    1990:	95 9a       	sbi	0x12, 5	; 18
    1992:	01 c0       	rjmp	.+2      	; 0x1996 <main+0x31c>
    1994:	95 98       	cbi	0x12, 5	; 18
                        setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1)));
    1996:	81 ff       	sbrs	r24, 1
    1998:	02 c0       	rjmp	.+4      	; 0x199e <main+0x324>
    199a:	db 9a       	sbi	0x1b, 3	; 27
    199c:	01 c0       	rjmp	.+2      	; 0x19a0 <main+0x326>
    199e:	db 98       	cbi	0x1b, 3	; 27
                        setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2)));
    19a0:	82 ff       	sbrs	r24, 2
    19a2:	02 c0       	rjmp	.+4      	; 0x19a8 <main+0x32e>
    19a4:	da 9a       	sbi	0x1b, 2	; 27
    19a6:	0d c0       	rjmp	.+26     	; 0x19c2 <main+0x348>
    19a8:	da 98       	cbi	0x1b, 2	; 27
    19aa:	0b c0       	rjmp	.+22     	; 0x19c2 <main+0x348>
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    19ac:	80 91 32 02 	lds	r24, 0x0232
    19b0:	88 23       	and	r24, r24
    19b2:	19 f0       	breq	.+6      	; 0x19ba <main+0x340>
        cmd.stepDir[target] = -stepSize; //set step direction
    19b4:	d0 92 30 02 	sts	0x0230, r13
    19b8:	02 c0       	rjmp	.+4      	; 0x19be <main+0x344>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    19ba:	90 93 30 02 	sts	0x0230, r25
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(RA,1); //Just move along at one step per step
                        cmd.highSpeedMode[RA] = false;
    19be:	10 92 3a 02 	sts	0x023A, r1
                    }
                    if(GVal & 1){
    19c2:	30 ff       	sbrs	r19, 0
    19c4:	07 c0       	rjmp	.+14     	; 0x19d4 <main+0x35a>
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
    19c6:	80 e0       	ldi	r24, 0x00	; 0
    19c8:	0e 94 ed 01 	call	0x3da	; 0x3da <motorStart>
                        cmd.highSpeedMode[RA] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(RA); //Slew type
                        readyToGo[RA] = 2;
    19cc:	82 e0       	ldi	r24, 0x02	; 2
    19ce:	80 93 7a 01 	sts	0x017A, r24
    19d2:	05 c0       	rjmp	.+10     	; 0x19de <main+0x364>
                    } else {
                        //This is the function for goto mode. You may need to customise it for a different motor driver
                        gotoMode(RA); //Goto Mode
    19d4:	80 e0       	ldi	r24, 0x00	; 0
    19d6:	0e 94 f5 01 	call	0x3ea	; 0x3ea <gotoMode>
                        readyToGo[RA] = 0;
    19da:	10 92 7a 01 	sts	0x017A, r1
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
            if(readyToGo[DC]==1){
    19de:	90 91 7b 01 	lds	r25, 0x017B
    19e2:	91 30       	cpi	r25, 0x01	; 1
    19e4:	09 f0       	breq	.+2      	; 0x19e8 <main+0x36e>
    19e6:	7c ce       	rjmp	.-776    	; 0x16e0 <main+0x66>
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[DC] == CMD_STOPPED){
    19e8:	80 91 39 02 	lds	r24, 0x0239
    19ec:	88 23       	and	r24, r24
    19ee:	09 f4       	brne	.+2      	; 0x19f2 <main+0x378>
    19f0:	77 ce       	rjmp	.-786    	; 0x16e0 <main+0x66>
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[DC];
    19f2:	30 91 27 02 	lds	r19, 0x0227
                    if (canJumpToHighspeed){
    19f6:	80 91 0a 02 	lds	r24, 0x020A
    19fa:	88 23       	and	r24, r24
    19fc:	81 f1       	breq	.+96     	; 0x1a5e <main+0x3e4>
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
    19fe:	83 2f       	mov	r24, r19
    1a00:	81 50       	subi	r24, 0x01	; 1
    1a02:	82 30       	cpi	r24, 0x02	; 2
    1a04:	70 f4       	brcc	.+28     	; 0x1a22 <main+0x3a8>
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
    1a06:	20 91 09 01 	lds	r18, 0x0109
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1a0a:	80 91 33 02 	lds	r24, 0x0233
    1a0e:	88 23       	and	r24, r24
    1a10:	19 f0       	breq	.+6      	; 0x1a18 <main+0x39e>
        cmd.stepDir[target] = -stepSize; //set step direction
    1a12:	d0 92 31 02 	sts	0x0231, r13
    1a16:	02 c0       	rjmp	.+4      	; 0x1a1c <main+0x3a2>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1a18:	90 93 31 02 	sts	0x0231, r25
                            cmd_updateStepDir(DC,1);
                            cmd.highSpeedMode[DC] = false;
    1a1c:	10 92 3b 02 	sts	0x023B, r1
    1a20:	0d c0       	rjmp	.+26     	; 0x1a3c <main+0x3c2>
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
    1a22:	20 91 0a 01 	lds	r18, 0x010A
                            cmd_updateStepDir(DC,cmd.gVal[DC]);
    1a26:	90 91 55 02 	lds	r25, 0x0255
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1a2a:	80 91 33 02 	lds	r24, 0x0233
    1a2e:	81 11       	cpse	r24, r1
        cmd.stepDir[target] = -stepSize; //set step direction
    1a30:	91 95       	neg	r25
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1a32:	90 93 31 02 	sts	0x0231, r25
                            cmd.highSpeedMode[DC] = true;
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	80 93 3b 02 	sts	0x023B, r24
                        }
                        setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0)));
    1a3c:	82 2f       	mov	r24, r18
    1a3e:	20 ff       	sbrs	r18, 0
    1a40:	02 c0       	rjmp	.+4      	; 0x1a46 <main+0x3cc>
    1a42:	c4 9a       	sbi	0x18, 4	; 24
    1a44:	01 c0       	rjmp	.+2      	; 0x1a48 <main+0x3ce>
    1a46:	c4 98       	cbi	0x18, 4	; 24
                        setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1)));
    1a48:	81 ff       	sbrs	r24, 1
    1a4a:	02 c0       	rjmp	.+4      	; 0x1a50 <main+0x3d6>
    1a4c:	c3 9a       	sbi	0x18, 3	; 24
    1a4e:	01 c0       	rjmp	.+2      	; 0x1a52 <main+0x3d8>
    1a50:	c3 98       	cbi	0x18, 3	; 24
                        setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2)));
    1a52:	82 ff       	sbrs	r24, 2
    1a54:	02 c0       	rjmp	.+4      	; 0x1a5a <main+0x3e0>
    1a56:	c2 9a       	sbi	0x18, 2	; 24
    1a58:	0d c0       	rjmp	.+26     	; 0x1a74 <main+0x3fa>
    1a5a:	c2 98       	cbi	0x18, 2	; 24
    1a5c:	0b c0       	rjmp	.+22     	; 0x1a74 <main+0x3fa>
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1a5e:	80 91 33 02 	lds	r24, 0x0233
    1a62:	88 23       	and	r24, r24
    1a64:	19 f0       	breq	.+6      	; 0x1a6c <main+0x3f2>
        cmd.stepDir[target] = -stepSize; //set step direction
    1a66:	d0 92 31 02 	sts	0x0231, r13
    1a6a:	02 c0       	rjmp	.+4      	; 0x1a70 <main+0x3f6>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1a6c:	90 93 31 02 	sts	0x0231, r25
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(DC,1); //Just move along at one step per step
                        cmd.highSpeedMode[DC] = false;
    1a70:	10 92 3b 02 	sts	0x023B, r1
                    }
                    if(GVal & 1){
    1a74:	30 ff       	sbrs	r19, 0
    1a76:	07 c0       	rjmp	.+14     	; 0x1a86 <main+0x40c>
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	0e 94 ed 01 	call	0x3da	; 0x3da <motorStart>
                        cmd.highSpeedMode[DC] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(DC); //Slew type
                        readyToGo[DC] = 2; //We are now in a running mode which speed can be changed without stopping motor (unless a command changes the direction)
    1a7e:	82 e0       	ldi	r24, 0x02	; 2
    1a80:	80 93 7b 01 	sts	0x017B, r24
    1a84:	2d ce       	rjmp	.-934    	; 0x16e0 <main+0x66>
                    } else {
                        //This is the function for goto mode.
                        gotoMode(DC); //Goto Mode
    1a86:	81 e0       	ldi	r24, 0x01	; 1
    1a88:	0e 94 f5 01 	call	0x3ea	; 0x3ea <gotoMode>
                        readyToGo[DC] = 0; //We are now in a mode where no further changes can be made to the motor (apart from requesting a stop) until the go-to movement is done.
    1a8c:	10 92 7b 01 	sts	0x017B, r1
    1a90:	27 ce       	rjmp	.-946    	; 0x16e0 <main+0x66>
        //////////
        } else {
        //
        // ST4 Basic Hand Controller Mode
        //
            if (loopCount == 0) {
    1a92:	e1 14       	cp	r14, r1
    1a94:	f1 04       	cpc	r15, r1
    1a96:	71 f4       	brne	.+28     	; 0x1ab4 <main+0x43a>
                //we run these checks every so often, not all the time.
                
                //Update status LED
                togglePin(statusPin); //Toggle status pin at roughly constant rate in basic mode as indicator
    1a98:	88 b3       	in	r24, 0x18	; 24
    1a9a:	80 58       	subi	r24, 0x80	; 128
    1a9c:	88 bb       	out	0x18, r24	; 24
                
                //Check the speed
                byte newBasicHCSpeed = checkBasicHCSpeed();
    1a9e:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <_Z17checkBasicHCSpeedv>
    1aa2:	98 2f       	mov	r25, r24
                if (newBasicHCSpeed != cmd.st4Mode) {
    1aa4:	80 91 5e 02 	lds	r24, 0x025E
    1aa8:	98 17       	cp	r25, r24
    1aaa:	39 f0       	breq	.+14     	; 0x1aba <main+0x440>
                    //Only update speed if changed.
                    Commands_configureST4Speed(newBasicHCSpeed); //Change the ST4 speeds
    1aac:	89 2f       	mov	r24, r25
    1aae:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <_Z26Commands_configureST4Speedh>
    1ab2:	03 c0       	rjmp	.+6      	; 0x1aba <main+0x440>
            }
            
            //
            //NESW button handling - uses ST4 pins
            //
            if ((loopCount & 0xFF) == 0){
    1ab4:	ee 20       	and	r14, r14
    1ab6:	09 f0       	breq	.+2      	; 0x1aba <main+0x440>
    1ab8:	13 ce       	rjmp	.-986    	; 0x16e0 <main+0x66>
                //We only check the buttons every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
    1aba:	cc 9b       	sbis	0x19, 4	; 25
    1abc:	aa c0       	rjmp	.+340    	; 0x1c12 <main+0x598>
    1abe:	cf 9b       	sbis	0x19, 7	; 25
    1ac0:	02 c0       	rjmp	.+4      	; 0x1ac6 <main+0x44c>
    1ac2:	4f ef       	ldi	r20, 0xFF	; 255
    1ac4:	01 c0       	rjmp	.+2      	; 0x1ac8 <main+0x44e>
    1ac6:	40 e0       	ldi	r20, 0x00	; 0
    1ac8:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
    1aca:	1f b7       	in	r17, 0x3f	; 63
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
    1acc:	f8 94       	cli
                    if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] != dir) && (currentMotorSpeed(RA) < cmd.minSpeed[RA])) {
    1ace:	80 91 38 02 	lds	r24, 0x0238
    1ad2:	88 23       	and	r24, r24
    1ad4:	09 f0       	breq	.+2      	; 0x1ad8 <main+0x45e>
    1ad6:	a6 c0       	rjmp	.+332    	; 0x1c24 <main+0x5aa>
    1ad8:	80 91 32 02 	lds	r24, 0x0232
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	25 2f       	mov	r18, r21
    1ae0:	30 e0       	ldi	r19, 0x00	; 0
    1ae2:	82 17       	cp	r24, r18
    1ae4:	93 07       	cpc	r25, r19
    1ae6:	09 f4       	brne	.+2      	; 0x1aea <main+0x470>
    1ae8:	9d c0       	rjmp	.+314    	; 0x1c24 <main+0x5aa>
    1aea:	20 91 84 00 	lds	r18, 0x0084
    1aee:	30 91 85 00 	lds	r19, 0x0085
    1af2:	80 91 71 02 	lds	r24, 0x0271
    1af6:	90 91 72 02 	lds	r25, 0x0272
    1afa:	28 17       	cp	r18, r24
    1afc:	39 07       	cpc	r19, r25
    1afe:	08 f0       	brcs	.+2      	; 0x1b02 <main+0x488>
    1b00:	91 c0       	rjmp	.+290    	; 0x1c24 <main+0x5aa>
    1b02:	27 c0       	rjmp	.+78     	; 0x1b52 <main+0x4d8>
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
    1b04:	e0 91 69 02 	lds	r30, 0x0269
    1b08:	f0 91 6a 02 	lds	r31, 0x026A
    1b0c:	0b c0       	rjmp	.+22     	; 0x1b24 <main+0x4aa>
    1b0e:	e4 2f       	mov	r30, r20
    1b10:	ff 27       	eor	r31, r31
    1b12:	e7 fd       	sbrc	r30, 7
    1b14:	f0 95       	com	r31
    1b16:	ee 0f       	add	r30, r30
    1b18:	ff 1f       	adc	r31, r31
    1b1a:	e0 5a       	subi	r30, 0xA0	; 160
    1b1c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b1e:	01 90       	ld	r0, Z+
    1b20:	f0 81       	ld	r31, Z
    1b22:	e0 2d       	mov	r30, r0
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1b24:	f0 93 1f 02 	sts	0x021F, r31
    1b28:	e0 93 1e 02 	sts	0x021E, r30
                        cmd_setDir(RA,dir);
    1b2c:	25 2f       	mov	r18, r21
    1b2e:	51 11       	cpse	r21, r1
    1b30:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1b32:	20 93 32 02 	sts	0x0232, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1b36:	22 23       	and	r18, r18
    1b38:	19 f0       	breq	.+6      	; 0x1b40 <main+0x4c6>
        cmd.stepDir[target] = -stepSize; //set step direction
    1b3a:	d0 92 30 02 	sts	0x0230, r13
    1b3e:	03 c0       	rjmp	.+6      	; 0x1b46 <main+0x4cc>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1b40:	81 e0       	ldi	r24, 0x01	; 1
    1b42:	80 93 30 02 	sts	0x0230, r24
                        cmd_updateStepDir(RA,1);
                        if ((st4Pin == ST4O) && (cmd.st4Mode == CMD_ST4_HIGHSPEED)) {
    1b46:	4f 3f       	cpi	r20, 0xFF	; 255
    1b48:	41 f4       	brne	.+16     	; 0x1b5a <main+0x4e0>
    1b4a:	80 91 5e 02 	lds	r24, 0x025E
    1b4e:	82 30       	cpi	r24, 0x02	; 2
    1b50:	21 f4       	brne	.+8      	; 0x1b5a <main+0x4e0>
                            motorStopRA(false); //If no buttons pressed and in high speed mode, we stop entirely rather than going to tracking
    1b52:	80 e0       	ldi	r24, 0x00	; 0
    1b54:	0e 94 c9 02 	call	0x592	; 0x592 <motorStopRA>
    1b58:	02 c0       	rjmp	.+4      	; 0x1b5e <main+0x4e4>
                                                //This ensures that the motors stop if the handcontroller is subsequently unplugged.
                        } else {
                            motorStartRA(); //If the motor is currently stopped at this point, this will automatically start them.
    1b5a:	0e 94 1d 01 	call	0x23a	; 0x23a <motorStartRA>
                        }
                    }
                    SREG = oldSREG; //End atomic
    1b5e:	1f bf       	out	0x3f, r17	; 63
                }//End RA
                
                {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    1b60:	cd 99       	sbic	0x19, 5	; 25
    1b62:	03 c0       	rjmp	.+6      	; 0x1b6a <main+0x4f0>
    1b64:	51 e0       	ldi	r21, 0x01	; 1
    1b66:	41 e0       	ldi	r20, 0x01	; 1
    1b68:	06 c0       	rjmp	.+12     	; 0x1b76 <main+0x4fc>
    1b6a:	ce 9b       	sbis	0x19, 6	; 25
    1b6c:	02 c0       	rjmp	.+4      	; 0x1b72 <main+0x4f8>
    1b6e:	4f ef       	ldi	r20, 0xFF	; 255
    1b70:	01 c0       	rjmp	.+2      	; 0x1b74 <main+0x4fa>
    1b72:	40 e0       	ldi	r20, 0x00	; 0
    1b74:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
    1b76:	1f b7       	in	r17, 0x3f	; 63
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
    1b78:	f8 94       	cli
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
    1b7a:	80 91 39 02 	lds	r24, 0x0239
    1b7e:	88 23       	and	r24, r24
    1b80:	09 f0       	breq	.+2      	; 0x1b84 <main+0x50a>
    1b82:	54 c0       	rjmp	.+168    	; 0x1c2c <main+0x5b2>
    1b84:	80 91 33 02 	lds	r24, 0x0233
    1b88:	90 e0       	ldi	r25, 0x00	; 0
    1b8a:	25 2f       	mov	r18, r21
    1b8c:	30 e0       	ldi	r19, 0x00	; 0
    1b8e:	82 17       	cp	r24, r18
    1b90:	93 07       	cpc	r25, r19
    1b92:	09 f4       	brne	.+2      	; 0x1b96 <main+0x51c>
    1b94:	4b c0       	rjmp	.+150    	; 0x1c2c <main+0x5b2>
    1b96:	20 91 86 00 	lds	r18, 0x0086
    1b9a:	30 91 87 00 	lds	r19, 0x0087
    1b9e:	80 91 73 02 	lds	r24, 0x0273
    1ba2:	90 91 74 02 	lds	r25, 0x0274
    1ba6:	28 17       	cp	r18, r24
    1ba8:	39 07       	cpc	r19, r25
    1baa:	08 f0       	brcs	.+2      	; 0x1bae <main+0x534>
    1bac:	3f c0       	rjmp	.+126    	; 0x1c2c <main+0x5b2>
    1bae:	18 c0       	rjmp	.+48     	; 0x1be0 <main+0x566>
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1bb0:	80 91 65 02 	lds	r24, 0x0265
    1bb4:	90 91 66 02 	lds	r25, 0x0266
    1bb8:	90 93 21 02 	sts	0x0221, r25
    1bbc:	80 93 20 02 	sts	0x0220, r24
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
    1bc0:	25 2f       	mov	r18, r21
    1bc2:	51 11       	cpse	r21, r1
    1bc4:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1bc6:	20 93 33 02 	sts	0x0233, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1bca:	22 23       	and	r18, r18
    1bcc:	19 f0       	breq	.+6      	; 0x1bd4 <main+0x55a>
        cmd.stepDir[target] = -stepSize; //set step direction
    1bce:	d0 92 31 02 	sts	0x0231, r13
    1bd2:	03 c0       	rjmp	.+6      	; 0x1bda <main+0x560>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1bd4:	81 e0       	ldi	r24, 0x01	; 1
    1bd6:	80 93 31 02 	sts	0x0231, r24
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
    1bda:	0e 94 7d 01 	call	0x2fa	; 0x2fa <motorStartDC>
    1bde:	03 c0       	rjmp	.+6      	; 0x1be6 <main+0x56c>
                        } else {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
    1be0:	80 e0       	ldi	r24, 0x00	; 0
    1be2:	0e 94 08 03 	call	0x610	; 0x610 <motorStopDC>
                        }
                    }
                    SREG = oldSREG; //End atomic
    1be6:	1f bf       	out	0x3f, r17	; 63
    1be8:	7b cd       	rjmp	.-1290   	; 0x16e0 <main+0x66>
    1bea:	e0 e0       	ldi	r30, 0x00	; 0
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1bec:	ff 27       	eor	r31, r31
    1bee:	e7 fd       	sbrc	r30, 7
    1bf0:	f0 95       	com	r31
    1bf2:	b5 96       	adiw	r30, 0x25	; 37
    1bf4:	ee 0f       	add	r30, r30
    1bf6:	ff 1f       	adc	r31, r31
    1bf8:	ea 5e       	subi	r30, 0xEA	; 234
    1bfa:	fd 4f       	sbci	r31, 0xFD	; 253
    1bfc:	80 81       	ld	r24, Z
    1bfe:	91 81       	ldd	r25, Z+1	; 0x01
    1c00:	90 93 1f 02 	sts	0x021F, r25
    1c04:	80 93 1e 02 	sts	0x021E, r24
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                        //Update target speed.
                        if (st4Pin != ST4O) {
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
    1c08:	0e 94 1d 01 	call	0x23a	; 0x23a <motorStartRA>
    1c0c:	bb 24       	eor	r11, r11
    1c0e:	b3 94       	inc	r11
    1c10:	49 ce       	rjmp	.-878    	; 0x18a4 <main+0x22a>
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
    1c12:	80 91 64 02 	lds	r24, 0x0264
    1c16:	88 23       	and	r24, r24
    1c18:	11 f0       	breq	.+4      	; 0x1c1e <main+0x5a4>
    1c1a:	51 e0       	ldi	r21, 0x01	; 1
    1c1c:	01 c0       	rjmp	.+2      	; 0x1c20 <main+0x5a6>
    1c1e:	50 e0       	ldi	r21, 0x00	; 0
    1c20:	41 e0       	ldi	r20, 0x01	; 1
    1c22:	53 cf       	rjmp	.-346    	; 0x1aca <main+0x450>
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
    1c24:	4f 3f       	cpi	r20, 0xFF	; 255
    1c26:	09 f0       	breq	.+2      	; 0x1c2a <main+0x5b0>
    1c28:	72 cf       	rjmp	.-284    	; 0x1b0e <main+0x494>
    1c2a:	6c cf       	rjmp	.-296    	; 0x1b04 <main+0x48a>
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopDC(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
    1c2c:	4f 3f       	cpi	r20, 0xFF	; 255
    1c2e:	09 f0       	breq	.+2      	; 0x1c32 <main+0x5b8>
    1c30:	bf cf       	rjmp	.-130    	; 0x1bb0 <main+0x536>
    1c32:	d6 cf       	rjmp	.-84     	; 0x1be0 <main+0x566>

00001c34 <_Z26Commands_configureST4Speedh>:
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
}

void Commands_configureST4Speed(byte mode) {
    1c34:	0f 93       	push	r16
    1c36:	1f 93       	push	r17
    1c38:	48 2f       	mov	r20, r24
    cmd.st4Mode = mode;
    1c3a:	80 93 5e 02 	sts	0x025E, r24
    if (mode == CMD_ST4_HIGHSPEED) {
    1c3e:	82 30       	cpi	r24, 0x02	; 2
    1c40:	a1 f4       	brne	.+40     	; 0x1c6a <_Z26Commands_configureST4Speedh+0x36>
        //Set the ST4 speeds to highspeed standalone mode (goto speeds)
        cmd.st4RAIVal[ST4P] = cmd.normalGotoSpeed[RA];
    1c42:	80 91 75 02 	lds	r24, 0x0275
    1c46:	90 91 76 02 	lds	r25, 0x0276
    1c4a:	90 93 61 02 	sts	0x0261, r25
    1c4e:	80 93 60 02 	sts	0x0260, r24
        cmd.st4RAIVal[ST4N] = cmd.normalGotoSpeed[RA];
    1c52:	90 93 63 02 	sts	0x0263, r25
    1c56:	80 93 62 02 	sts	0x0262, r24
        cmd.st4RAReverse    = CMD_REVERSE;
    1c5a:	81 e0       	ldi	r24, 0x01	; 1
    1c5c:	80 93 64 02 	sts	0x0264, r24
        cmd.st4DecIVal      = cmd.normalGotoSpeed[DC];
    1c60:	80 91 77 02 	lds	r24, 0x0277
    1c64:	90 91 78 02 	lds	r25, 0x0278
    1c68:	1b c0       	rjmp	.+54     	; 0x1ca0 <_Z26Commands_configureST4Speedh+0x6c>
    } else if (mode == CMD_ST4_STANDALONE) {
    1c6a:	81 30       	cpi	r24, 0x01	; 1
    1c6c:	f1 f4       	brne	.+60     	; 0x1caa <_Z26Commands_configureST4Speedh+0x76>
        //Set the ST4 speeds to standalone mode (2x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA])/3; //3x speed
    1c6e:	20 91 69 02 	lds	r18, 0x0269
    1c72:	30 91 6a 02 	lds	r19, 0x026A
    1c76:	c9 01       	movw	r24, r18
    1c78:	63 e0       	ldi	r22, 0x03	; 3
    1c7a:	70 e0       	ldi	r23, 0x00	; 0
    1c7c:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <__udivmodhi4>
    1c80:	70 93 61 02 	sts	0x0261, r23
    1c84:	60 93 60 02 	sts	0x0260, r22
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA])  ; //-1x speed
    1c88:	30 93 63 02 	sts	0x0263, r19
    1c8c:	20 93 62 02 	sts	0x0262, r18
        cmd.st4RAReverse    = CMD_REVERSE;
    1c90:	40 93 64 02 	sts	0x0264, r20
        cmd.st4DecIVal      =(cmd.siderealIVal[DC])/2; //2x speed
    1c94:	80 91 6b 02 	lds	r24, 0x026B
    1c98:	90 91 6c 02 	lds	r25, 0x026C
    1c9c:	96 95       	lsr	r25
    1c9e:	87 95       	ror	r24
    1ca0:	90 93 66 02 	sts	0x0266, r25
    1ca4:	80 93 65 02 	sts	0x0265, r24
    1ca8:	3b c0       	rjmp	.+118    	; 0x1d20 <_Z26Commands_configureST4Speedh+0xec>
    } else {
        //Set the ST4 speeds to normal mode (0.25x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA] * 20)/(20 + cmd.st4SpeedFactor); //(1+SpeedFactor)x speed   -- Max. IVal = 1200, so this will never overflow.
    1caa:	80 91 69 02 	lds	r24, 0x0269
    1cae:	90 91 6a 02 	lds	r25, 0x026A
    1cb2:	24 e1       	ldi	r18, 0x14	; 20
    1cb4:	30 e0       	ldi	r19, 0x00	; 0
    1cb6:	82 9f       	mul	r24, r18
    1cb8:	80 01       	movw	r16, r0
    1cba:	83 9f       	mul	r24, r19
    1cbc:	10 0d       	add	r17, r0
    1cbe:	92 9f       	mul	r25, r18
    1cc0:	10 0d       	add	r17, r0
    1cc2:	11 24       	eor	r1, r1
    1cc4:	40 91 5f 02 	lds	r20, 0x025F
    1cc8:	e4 2f       	mov	r30, r20
    1cca:	f0 e0       	ldi	r31, 0x00	; 0
    1ccc:	bf 01       	movw	r22, r30
    1cce:	6c 5e       	subi	r22, 0xEC	; 236
    1cd0:	7f 4f       	sbci	r23, 0xFF	; 255
    1cd2:	c8 01       	movw	r24, r16
    1cd4:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <__udivmodhi4>
    1cd8:	70 93 61 02 	sts	0x0261, r23
    1cdc:	60 93 60 02 	sts	0x0260, r22
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA] * 20)/(20 - cmd.st4SpeedFactor); //(1-SpeedFactor)x speed
    1ce0:	b9 01       	movw	r22, r18
    1ce2:	6e 1b       	sub	r22, r30
    1ce4:	7f 0b       	sbc	r23, r31
    1ce6:	c8 01       	movw	r24, r16
    1ce8:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <__udivmodhi4>
    1cec:	70 93 63 02 	sts	0x0263, r23
    1cf0:	60 93 62 02 	sts	0x0262, r22
        cmd.st4RAReverse    = CMD_FORWARD;
    1cf4:	10 92 64 02 	sts	0x0264, r1
        cmd.st4DecIVal      =(cmd.siderealIVal[DC] * 20)/( 0 + cmd.st4SpeedFactor); //(SpeedFactor)x speed
    1cf8:	80 91 6b 02 	lds	r24, 0x026B
    1cfc:	90 91 6c 02 	lds	r25, 0x026C
    1d00:	bc 01       	movw	r22, r24
    1d02:	62 9f       	mul	r22, r18
    1d04:	c0 01       	movw	r24, r0
    1d06:	63 9f       	mul	r22, r19
    1d08:	90 0d       	add	r25, r0
    1d0a:	72 9f       	mul	r23, r18
    1d0c:	90 0d       	add	r25, r0
    1d0e:	11 24       	eor	r1, r1
    1d10:	64 2f       	mov	r22, r20
    1d12:	70 e0       	ldi	r23, 0x00	; 0
    1d14:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <__udivmodhi4>
    1d18:	70 93 66 02 	sts	0x0266, r23
    1d1c:	60 93 65 02 	sts	0x0265, r22
    }
}
    1d20:	1f 91       	pop	r17
    1d22:	0f 91       	pop	r16
    1d24:	08 95       	ret

00001d26 <_Z18Commands_getLengthcb>:
                                                 {'x', 0, 6},
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    1d26:	98 2f       	mov	r25, r24
    1d28:	eb e0       	ldi	r30, 0x0B	; 11
    1d2a:	f1 e0       	ldi	r31, 0x01	; 1
    1d2c:	20 e0       	ldi	r18, 0x00	; 0
    1d2e:	30 e0       	ldi	r19, 0x00	; 0
    for(byte i = 0;i < numberOfCommands;i++){
        if(cmd_commands[i][0] == cmd){
    1d30:	80 81       	ld	r24, Z
    1d32:	89 17       	cp	r24, r25
    1d34:	89 f4       	brne	.+34     	; 0x1d58 <_Z18Commands_getLengthcb+0x32>
    1d36:	f9 01       	movw	r30, r18
    1d38:	ee 0f       	add	r30, r30
    1d3a:	ff 1f       	adc	r31, r31
            if(sendRecieve){
    1d3c:	66 23       	and	r22, r22
    1d3e:	31 f0       	breq	.+12     	; 0x1d4c <_Z18Commands_getLengthcb+0x26>
                return cmd_commands[i][1];
    1d40:	e2 0f       	add	r30, r18
    1d42:	f3 1f       	adc	r31, r19
    1d44:	e5 5f       	subi	r30, 0xF5	; 245
    1d46:	fe 4f       	sbci	r31, 0xFE	; 254
    1d48:	81 81       	ldd	r24, Z+1	; 0x01
    1d4a:	08 95       	ret
            } else {
                return cmd_commands[i][2];
    1d4c:	e2 0f       	add	r30, r18
    1d4e:	f3 1f       	adc	r31, r19
    1d50:	e5 5f       	subi	r30, 0xF5	; 245
    1d52:	fe 4f       	sbci	r31, 0xFE	; 254
    1d54:	82 81       	ldd	r24, Z+2	; 0x02
    1d56:	08 95       	ret
    1d58:	2f 5f       	subi	r18, 0xFF	; 255
    1d5a:	3f 4f       	sbci	r19, 0xFF	; 255
    1d5c:	33 96       	adiw	r30, 0x03	; 3
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    for(byte i = 0;i < numberOfCommands;i++){
    1d5e:	25 32       	cpi	r18, 0x25	; 37
    1d60:	31 05       	cpc	r19, r1
    1d62:	31 f7       	brne	.-52     	; 0x1d30 <_Z18Commands_getLengthcb+0xa>
    1d64:	8f ef       	ldi	r24, 0xFF	; 255
                return cmd_commands[i][2];
            }
        }
    }
    return -1;
}
    1d66:	08 95       	ret

00001d68 <_Z13Commands_initmh>:

#include "commands.h"

Commands cmd = {0};

void Commands_init(unsigned long _eVal, byte _gVal){
    1d68:	4f 92       	push	r4
    1d6a:	5f 92       	push	r5
    1d6c:	6f 92       	push	r6
    1d6e:	7f 92       	push	r7
    1d70:	8f 92       	push	r8
    1d72:	9f 92       	push	r9
    1d74:	af 92       	push	r10
    1d76:	bf 92       	push	r11
    1d78:	cf 92       	push	r12
    1d7a:	df 92       	push	r13
    1d7c:	ef 92       	push	r14
    1d7e:	ff 92       	push	r15
    1d80:	0f 93       	push	r16
    1d82:	1f 93       	push	r17
    1d84:	cf 93       	push	r28
    1d86:	df 93       	push	r29
    1d88:	3b 01       	movw	r6, r22
    1d8a:	4c 01       	movw	r8, r24
    1d8c:	44 2e       	mov	r4, r20
    cmd.aVal[RA] = EEPROM_readLong(aVal1_Address);              //steps/axis
    1d8e:	8e e0       	ldi	r24, 0x0E	; 14
    1d90:	90 e0       	ldi	r25, 0x00	; 0
    1d92:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <_Z15EEPROM_readLongj>
    1d96:	60 93 44 02 	sts	0x0244, r22
    1d9a:	70 93 45 02 	sts	0x0245, r23
    1d9e:	80 93 46 02 	sts	0x0246, r24
    1da2:	90 93 47 02 	sts	0x0247, r25
    cmd.aVal[DC] = EEPROM_readLong(aVal2_Address);              //steps/axis
    1da6:	82 e1       	ldi	r24, 0x12	; 18
    1da8:	90 e0       	ldi	r25, 0x00	; 0
    1daa:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <_Z15EEPROM_readLongj>
    1dae:	60 93 48 02 	sts	0x0248, r22
    1db2:	70 93 49 02 	sts	0x0249, r23
    1db6:	80 93 4a 02 	sts	0x024A, r24
    1dba:	90 93 4b 02 	sts	0x024B, r25
    cmd.bVal[RA] = EEPROM_readLong(bVal1_Address);              //sidereal rate
    1dbe:	86 e1       	ldi	r24, 0x16	; 22
    1dc0:	90 e0       	ldi	r25, 0x00	; 0
    1dc2:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <_Z15EEPROM_readLongj>
    1dc6:	60 93 4c 02 	sts	0x024C, r22
    1dca:	70 93 4d 02 	sts	0x024D, r23
    1dce:	80 93 4e 02 	sts	0x024E, r24
    1dd2:	90 93 4f 02 	sts	0x024F, r25
    cmd.bVal[DC] = EEPROM_readLong(bVal2_Address);              //sidereal rate
    1dd6:	8a e1       	ldi	r24, 0x1A	; 26
    1dd8:	90 e0       	ldi	r25, 0x00	; 0
    1dda:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <_Z15EEPROM_readLongj>
    1dde:	60 93 50 02 	sts	0x0250, r22
    1de2:	70 93 51 02 	sts	0x0251, r23
    1de6:	80 93 52 02 	sts	0x0252, r24
    1dea:	90 93 53 02 	sts	0x0253, r25
    cmd.sVal[RA] = EEPROM_readLong(sVal1_Address);              //steps/worm rotation
    1dee:	8e e1       	ldi	r24, 0x1E	; 30
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <_Z15EEPROM_readLongj>
    1df6:	60 93 56 02 	sts	0x0256, r22
    1dfa:	70 93 57 02 	sts	0x0257, r23
    1dfe:	80 93 58 02 	sts	0x0258, r24
    1e02:	90 93 59 02 	sts	0x0259, r25
    cmd.sVal[DC] = EEPROM_readLong(sVal2_Address);              //steps/worm rotation
    1e06:	82 e2       	ldi	r24, 0x22	; 34
    1e08:	90 e0       	ldi	r25, 0x00	; 0
    1e0a:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <_Z15EEPROM_readLongj>
    1e0e:	60 93 5a 02 	sts	0x025A, r22
    1e12:	70 93 5b 02 	sts	0x025B, r23
    1e16:	80 93 5c 02 	sts	0x025C, r24
    1e1a:	90 93 5d 02 	sts	0x025D, r25
    
    cmd.siderealIVal[RA] = EEPROM_readInt(IVal1_Address);       //steps/worm rotation
    1e1e:	86 e2       	ldi	r24, 0x26	; 38
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <_Z14EEPROM_readIntj>
    1e26:	90 93 6a 02 	sts	0x026A, r25
    1e2a:	80 93 69 02 	sts	0x0269, r24
    cmd.siderealIVal[DC] = EEPROM_readInt(IVal2_Address);       //steps/worm rotation
    1e2e:	88 e2       	ldi	r24, 0x28	; 40
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <_Z14EEPROM_readIntj>
    1e36:	90 93 6c 02 	sts	0x026C, r25
    1e3a:	80 93 6b 02 	sts	0x026B, r24
    cmd.normalGotoSpeed[RA] = EEPROM_readByte(RAGoto_Address);  //IVal for normal goto speed
    1e3e:	8c e0       	ldi	r24, 0x0C	; 12
    1e40:	90 e0       	ldi	r25, 0x00	; 0
    1e42:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    1e46:	05 e7       	ldi	r16, 0x75	; 117
    1e48:	12 e0       	ldi	r17, 0x02	; 2
    1e4a:	80 93 75 02 	sts	0x0275, r24
    1e4e:	10 92 76 02 	sts	0x0276, r1
    cmd.normalGotoSpeed[DC] = EEPROM_readByte(DECGoto_Address); //IVal for normal goto speed
    1e52:	8d e0       	ldi	r24, 0x0D	; 13
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    1e5a:	80 93 77 02 	sts	0x0277, r24
    1e5e:	f8 01       	movw	r30, r16
    1e60:	13 82       	std	Z+3, r1	; 0x03
    cmd.st4SpeedFactor = EEPROM_readByte(SpeedFactor_Address);  //ST4 speed factor
    1e62:	8e e2       	ldi	r24, 0x2E	; 46
    1e64:	90 e0       	ldi	r25, 0x00	; 0
    1e66:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <_Z15EEPROM_readBytej>
    1e6a:	80 93 5f 02 	sts	0x025F, r24
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    1e6e:	8c e2       	ldi	r24, 0x2C	; 44
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <_Z14EEPROM_readIntj>
    1e76:	90 93 68 02 	sts	0x0268, r25
    1e7a:	80 93 67 02 	sts	0x0267, r24
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    1e7e:	c8 01       	movw	r24, r16
    1e80:	08 96       	adiw	r24, 0x08	; 8
    1e82:	60 e4       	ldi	r22, 0x40	; 64
    1e84:	44 e6       	ldi	r20, 0x64	; 100
    1e86:	50 e0       	ldi	r21, 0x00	; 0
    1e88:	0e 94 01 10 	call	0x2002	; 0x2002 <_Z21EEPROM_readAccelTableP16AccelTableStructhj>
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    1e8c:	8d e3       	ldi	r24, 0x3D	; 61
    1e8e:	93 e0       	ldi	r25, 0x03	; 3
    1e90:	60 e4       	ldi	r22, 0x40	; 64
    1e92:	44 e2       	ldi	r20, 0x24	; 36
    1e94:	51 e0       	ldi	r21, 0x01	; 1
    1e96:	0e 94 01 10 	call	0x2002	; 0x2002 <_Z21EEPROM_readAccelTableP16AccelTableStructhj>
    1e9a:	26 e1       	ldi	r18, 0x16	; 22
    1e9c:	32 e0       	ldi	r19, 0x02	; 2
    1e9e:	79 01       	movw	r14, r18
    1ea0:	6d e7       	ldi	r22, 0x7D	; 125
    1ea2:	72 e0       	ldi	r23, 0x02	; 2
    1ea4:	09 e7       	ldi	r16, 0x79	; 121
    1ea6:	12 e0       	ldi	r17, 0x02	; 2
    1ea8:	e9 01       	movw	r28, r18
    1eaa:	d9 01       	movw	r26, r18
    1eac:	40 e0       	ldi	r20, 0x00	; 0
    1eae:	50 e0       	ldi	r21, 0x00	; 0
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
        cmd.stepDir[i] = 1; //1-dir*2
    1eb0:	55 24       	eor	r5, r5
    1eb2:	53 94       	inc	r5
        cmd.highSpeedMode[i] = false;
        cmd.stopped[i] = CMD_STOPPED;
        cmd.gotoEn[i] = CMD_DISABLED;
        cmd.FVal[i] = CMD_DISABLED;
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
    1eb4:	a1 2c       	mov	r10, r1
    1eb6:	b1 2c       	mov	r11, r1
    1eb8:	e0 e8       	ldi	r30, 0x80	; 128
    1eba:	ce 2e       	mov	r12, r30
    1ebc:	d1 2c       	mov	r13, r1
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
    1ebe:	1c 8e       	std	Y+28, r1	; 0x1c
        cmd.stepDir[i] = 1; //1-dir*2
    1ec0:	fa 01       	movw	r30, r20
    1ec2:	ea 5e       	subi	r30, 0xEA	; 234
    1ec4:	fd 4f       	sbci	r31, 0xFD	; 253
    1ec6:	52 8e       	std	Z+26, r5	; 0x1a
        cmd.highSpeedMode[i] = false;
    1ec8:	1c a2       	std	Y+36, r1	; 0x24
        cmd.stopped[i] = CMD_STOPPED;
    1eca:	5a a2       	std	Y+34, r5	; 0x22
        cmd.gotoEn[i] = CMD_DISABLED;
    1ecc:	18 a2       	std	Y+32, r1	; 0x20
        cmd.FVal[i] = CMD_DISABLED;
    1ece:	1e 8e       	std	Y+30, r1	; 0x1e
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
    1ed0:	f7 01       	movw	r30, r14
    1ed2:	a1 92       	st	Z+, r10
    1ed4:	b1 92       	st	Z+, r11
    1ed6:	c1 92       	st	Z+, r12
    1ed8:	d1 92       	st	Z+, r13
    1eda:	7f 01       	movw	r14, r30
        cmd.IVal[i] = cmd.siderealIVal[i]; //Recieved Speed will be set by :I command.
    1edc:	ad 5a       	subi	r26, 0xAD	; 173
    1ede:	bf 4f       	sbci	r27, 0xFF	; 255
    1ee0:	8d 91       	ld	r24, X+
    1ee2:	9c 91       	ld	r25, X
    1ee4:	11 97       	sbiw	r26, 0x01	; 1
    1ee6:	a3 55       	subi	r26, 0x53	; 83
    1ee8:	b0 40       	sbci	r27, 0x00	; 0
    1eea:	19 96       	adiw	r26, 0x09	; 9
    1eec:	9c 93       	st	X, r25
    1eee:	8e 93       	st	-X, r24
    1ef0:	18 97       	sbiw	r26, 0x08	; 8
        cmd.GVal[i] = 0; //Mode recieved from :G command
    1ef2:	18 8a       	std	Y+16, r1	; 0x10
        cmd.HVal[i] = 0; //Value recieved from :H command
    1ef4:	f9 01       	movw	r30, r18
    1ef6:	12 8a       	std	Z+18, r1	; 0x12
    1ef8:	13 8a       	std	Z+19, r1	; 0x13
    1efa:	14 8a       	std	Z+20, r1	; 0x14
    1efc:	15 8a       	std	Z+21, r1	; 0x15
        cmd.eVal[i] = _eVal; //version number
    1efe:	66 a2       	std	Z+38, r6	; 0x26
    1f00:	77 a2       	std	Z+39, r7	; 0x27
    1f02:	80 a6       	std	Z+40, r8	; 0x28
    1f04:	91 a6       	std	Z+41, r9	; 0x29
        cmd.gVal[i] = _gVal; //High speed scalar
    1f06:	4e ae       	std	Y+62, r4	; 0x3e
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
    1f08:	fb 01       	movw	r30, r22
    1f0a:	80 81       	ld	r24, Z
    1f0c:	91 81       	ldd	r25, Z+1	; 0x01
    1f0e:	a5 5a       	subi	r26, 0xA5	; 165
    1f10:	bf 4f       	sbci	r27, 0xFF	; 255
    1f12:	11 96       	adiw	r26, 0x01	; 1
    1f14:	9c 93       	st	X, r25
    1f16:	8e 93       	st	-X, r24
        cmd.stopSpeed[i] = cmd.minSpeed[i];
    1f18:	f8 01       	movw	r30, r16
    1f1a:	81 93       	st	Z+, r24
    1f1c:	91 93       	st	Z+, r25
    1f1e:	8f 01       	movw	r16, r30
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
    1f20:	14 97       	sbiw	r26, 0x04	; 4
    1f22:	01 96       	adiw	r24, 0x01	; 1
    1f24:	11 96       	adiw	r26, 0x01	; 1
    1f26:	9c 93       	st	X, r25
    1f28:	8e 93       	st	-X, r24
    1f2a:	a7 55       	subi	r26, 0x57	; 87
    1f2c:	b0 40       	sbci	r27, 0x00	; 0
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    1f2e:	1d 96       	adiw	r26, 0x0d	; 13
    1f30:	9c 93       	st	X, r25
    1f32:	8e 93       	st	-X, r24
    1f34:	1c 97       	sbiw	r26, 0x0c	; 12
    1f36:	4f 5f       	subi	r20, 0xFF	; 255
    1f38:	5f 4f       	sbci	r21, 0xFF	; 255
    1f3a:	21 96       	adiw	r28, 0x01	; 1
    1f3c:	12 96       	adiw	r26, 0x02	; 2
    1f3e:	2c 5f       	subi	r18, 0xFC	; 252
    1f40:	3f 4f       	sbci	r19, 0xFF	; 255
    1f42:	60 54       	subi	r22, 0x40	; 64
    1f44:	7f 4f       	sbci	r23, 0xFF	; 255
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
    1f46:	42 30       	cpi	r20, 0x02	; 2
    1f48:	51 05       	cpc	r21, r1
    1f4a:	09 f0       	breq	.+2      	; 0x1f4e <_Z13Commands_initmh+0x1e6>
    1f4c:	b8 cf       	rjmp	.-144    	; 0x1ebe <_Z13Commands_initmh+0x156>
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
        cmd.stopSpeed[i] = cmd.minSpeed[i];
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
    1f4e:	80 e0       	ldi	r24, 0x00	; 0
    1f50:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <_Z26Commands_configureST4Speedh>
}
    1f54:	df 91       	pop	r29
    1f56:	cf 91       	pop	r28
    1f58:	1f 91       	pop	r17
    1f5a:	0f 91       	pop	r16
    1f5c:	ff 90       	pop	r15
    1f5e:	ef 90       	pop	r14
    1f60:	df 90       	pop	r13
    1f62:	cf 90       	pop	r12
    1f64:	bf 90       	pop	r11
    1f66:	af 90       	pop	r10
    1f68:	9f 90       	pop	r9
    1f6a:	8f 90       	pop	r8
    1f6c:	7f 90       	pop	r7
    1f6e:	6f 90       	pop	r6
    1f70:	5f 90       	pop	r5
    1f72:	4f 90       	pop	r4
    1f74:	08 95       	ret

00001f76 <_Z15EEPROM_readBytej>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1f76:	e1 99       	sbic	0x1c, 1	; 28
    1f78:	fe cf       	rjmp	.-4      	; 0x1f76 <_Z15EEPROM_readBytej>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1f7a:	9f bb       	out	0x1f, r25	; 31
    1f7c:	8e bb       	out	0x1e, r24	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    1f7e:	e0 9a       	sbi	0x1c, 0	; 28
    1f80:	8d b3       	in	r24, 0x1d	; 29
#include <avr/eeprom.h>
#include "EEPROMReader.h"
 
byte EEPROM_readByte(unsigned int address) {
    return eeprom_read_byte((byte*) address);
}
    1f82:	08 95       	ret

00001f84 <_Z14EEPROM_readIntj>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1f84:	e1 99       	sbic	0x1c, 1	; 28
    1f86:	fe cf       	rjmp	.-4      	; 0x1f84 <_Z14EEPROM_readIntj>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1f88:	9f bb       	out	0x1f, r25	; 31
    1f8a:	8e bb       	out	0x1e, r24	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    1f8c:	e0 9a       	sbi	0x1c, 0	; 28
    1f8e:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1f90:	e1 99       	sbic	0x1c, 1	; 28
    1f92:	fe cf       	rjmp	.-4      	; 0x1f90 <_Z14EEPROM_readIntj+0xc>

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    1f94:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1f96:	9f bb       	out	0x1f, r25	; 31
    1f98:	8e bb       	out	0x1e, r24	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    1f9a:	e0 9a       	sbi	0x1c, 0	; 28
    1f9c:	9d b3       	in	r25, 0x1d	; 29
    return fetcher.integer;
}
    1f9e:	82 2f       	mov	r24, r18
    1fa0:	08 95       	ret

00001fa2 <_Z15EEPROM_readLongj>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1fa2:	e1 99       	sbic	0x1c, 1	; 28
    1fa4:	fe cf       	rjmp	.-4      	; 0x1fa2 <_Z15EEPROM_readLongj>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1fa6:	9f bb       	out	0x1f, r25	; 31
    1fa8:	8e bb       	out	0x1e, r24	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    1faa:	e0 9a       	sbi	0x1c, 0	; 28
    1fac:	2d b3       	in	r18, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1fae:	e1 99       	sbic	0x1c, 1	; 28
    1fb0:	fe cf       	rjmp	.-4      	; 0x1fae <_Z15EEPROM_readLongj+0xc>
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    1fb2:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1fb4:	9f bb       	out	0x1f, r25	; 31
    1fb6:	8e bb       	out	0x1e, r24	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    1fb8:	e0 9a       	sbi	0x1c, 0	; 28
    1fba:	7d b3       	in	r23, 0x1d	; 29
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    fetcher.array[1] = EEPROM_readInt(address+2);
    1fbc:	01 96       	adiw	r24, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1fbe:	e1 99       	sbic	0x1c, 1	; 28
    1fc0:	fe cf       	rjmp	.-4      	; 0x1fbe <_Z15EEPROM_readLongj+0x1c>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1fc2:	9f bb       	out	0x1f, r25	; 31
    1fc4:	8e bb       	out	0x1e, r24	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    1fc6:	e0 9a       	sbi	0x1c, 0	; 28
    1fc8:	3d b3       	in	r19, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1fca:	e1 99       	sbic	0x1c, 1	; 28
    1fcc:	fe cf       	rjmp	.-4      	; 0x1fca <_Z15EEPROM_readLongj+0x28>
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    1fce:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1fd0:	9f bb       	out	0x1f, r25	; 31
    1fd2:	8e bb       	out	0x1e, r24	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    1fd4:	e0 9a       	sbi	0x1c, 0	; 28
    1fd6:	9d b3       	in	r25, 0x1d	; 29
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    1fd8:	62 2f       	mov	r22, r18
    fetcher.array[1] = EEPROM_readInt(address+2);
    1fda:	83 2f       	mov	r24, r19
    return fetcher.integer;
}
    1fdc:	08 95       	ret

00001fde <_Z17EEPROM_readStringPchj>:

void EEPROM_readString(char* string, byte len, unsigned int address) {
    1fde:	fc 01       	movw	r30, r24
    1fe0:	90 e0       	ldi	r25, 0x00	; 0
    1fe2:	0c c0       	rjmp	.+24     	; 0x1ffc <_Z17EEPROM_readStringPchj+0x1e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1fe4:	e1 99       	sbic	0x1c, 1	; 28
    1fe6:	fe cf       	rjmp	.-4      	; 0x1fe4 <_Z17EEPROM_readStringPchj+0x6>
    for(byte i = 0; i < len; i++) {
        string[i] = EEPROM_readByte(address++);
    1fe8:	9a 01       	movw	r18, r20
    1fea:	2f 5f       	subi	r18, 0xFF	; 255
    1fec:	3f 4f       	sbci	r19, 0xFF	; 255
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    1fee:	5f bb       	out	0x1f, r21	; 31
    1ff0:	4e bb       	out	0x1e, r20	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    1ff2:	e0 9a       	sbi	0x1c, 0	; 28
    1ff4:	8d b3       	in	r24, 0x1d	; 29
    1ff6:	81 93       	st	Z+, r24
    fetcher.array[1] = EEPROM_readInt(address+2);
    return fetcher.integer;
}

void EEPROM_readString(char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
    1ff8:	9f 5f       	subi	r25, 0xFF	; 255
    1ffa:	a9 01       	movw	r20, r18
    1ffc:	96 17       	cp	r25, r22
    1ffe:	90 f3       	brcs	.-28     	; 0x1fe4 <_Z17EEPROM_readStringPchj+0x6>
        string[i] = EEPROM_readByte(address++);
    }
}
    2000:	08 95       	ret

00002002 <_Z21EEPROM_readAccelTableP16AccelTableStructhj>:

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    2002:	fc 01       	movw	r30, r24
    2004:	20 e0       	ldi	r18, 0x00	; 0
    2006:	25 c0       	rjmp	.+74     	; 0x2052 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x50>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2008:	e1 99       	sbic	0x1c, 1	; 28
    200a:	fe cf       	rjmp	.-4      	; 0x2008 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x6>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    200c:	5f bb       	out	0x1f, r21	; 31
    200e:	4e bb       	out	0x1e, r20	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2010:	e0 9a       	sbi	0x1c, 0	; 28
    2012:	9d b3       	in	r25, 0x1d	; 29
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2014:	e1 99       	sbic	0x1c, 1	; 28
    2016:	fe cf       	rjmp	.-4      	; 0x2014 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x12>
    2018:	4f 5f       	subi	r20, 0xFF	; 255
    201a:	5f 4f       	sbci	r21, 0xFF	; 255
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    201c:	5f bb       	out	0x1f, r21	; 31
    201e:	4e bb       	out	0x1e, r20	; 30
    2020:	41 50       	subi	r20, 0x01	; 1
    2022:	50 40       	sbci	r21, 0x00	; 0
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2024:	e0 9a       	sbi	0x1c, 0	; 28
    2026:	8d b3       	in	r24, 0x1d	; 29
    for(byte i = 0; i < elements; i++) {
        table[i].speed = EEPROM_readInt(address);
    2028:	90 83       	st	Z, r25
    202a:	81 83       	std	Z+1, r24	; 0x01
    202c:	ca 01       	movw	r24, r20
    202e:	02 96       	adiw	r24, 0x02	; 2
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2030:	e1 99       	sbic	0x1c, 1	; 28
    2032:	fe cf       	rjmp	.-4      	; 0x2030 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x2e>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2034:	9f bb       	out	0x1f, r25	; 31
    2036:	8e bb       	out	0x1e, r24	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2038:	e0 9a       	sbi	0x1c, 0	; 28
    203a:	8d b3       	in	r24, 0x1d	; 29
    203c:	4d 5f       	subi	r20, 0xFD	; 253
    203e:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2040:	e1 99       	sbic	0x1c, 1	; 28
    2042:	fe cf       	rjmp	.-4      	; 0x2040 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x3e>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2044:	5f bb       	out	0x1f, r21	; 31
    2046:	4e bb       	out	0x1e, r20	; 30
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2048:	e0 9a       	sbi	0x1c, 0	; 28
    204a:	9d b3       	in	r25, 0x1d	; 29
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
    204c:	82 83       	std	Z+2, r24	; 0x02
        string[i] = EEPROM_readByte(address++);
    }
}

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
    204e:	2f 5f       	subi	r18, 0xFF	; 255
    2050:	33 96       	adiw	r30, 0x03	; 3
    2052:	26 17       	cp	r18, r22
    2054:	08 f4       	brcc	.+2      	; 0x2058 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x56>
    2056:	d8 cf       	rjmp	.-80     	; 0x2008 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x6>
        table[i].speed = EEPROM_readInt(address);
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
        address = address + sizeof(byte);
    }
}
    2058:	08 95       	ret

0000205a <_Z16EEPROM_writeBytehj>:
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    205a:	e1 99       	sbic	0x1c, 1	; 28
    205c:	fe cf       	rjmp	.-4      	; 0x205a <_Z16EEPROM_writeBytehj>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    205e:	7f bb       	out	0x1f, r23	; 31
    2060:	6e bb       	out	0x1e, r22	; 30
#endif
    EEDR = __value;
    2062:	8d bb       	out	0x1d, r24	; 29
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    2064:	0f b6       	in	r0, 0x3f	; 63
    2066:	f8 94       	cli
    2068:	e2 9a       	sbi	0x1c, 2	; 28
    206a:	e1 9a       	sbi	0x1c, 1	; 28
    206c:	0f be       	out	0x3f, r0	; 63

void EEPROM_writeByte(byte val, unsigned int address) {
    return eeprom_write_byte((byte*) address, val);
}
    206e:	08 95       	ret

00002070 <_Z15EEPROM_writeIntjj>:

void EEPROM_writeInt(unsigned int val, unsigned int address) {
    TwoBytes storer = {val};
    2070:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2072:	e1 99       	sbic	0x1c, 1	; 28
    2074:	fe cf       	rjmp	.-4      	; 0x2072 <_Z15EEPROM_writeIntjj+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2076:	7f bb       	out	0x1f, r23	; 31
    2078:	6e bb       	out	0x1e, r22	; 30
#endif
    EEDR = __value;
    207a:	2d bb       	out	0x1d, r18	; 29
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    207c:	0f b6       	in	r0, 0x3f	; 63
    207e:	f8 94       	cli
    2080:	e2 9a       	sbi	0x1c, 2	; 28
    2082:	e1 9a       	sbi	0x1c, 1	; 28
    2084:	0f be       	out	0x3f, r0	; 63
    EEPROM_writeByte(storer.array[0], address);
    EEPROM_writeByte(storer.array[1], address+1);
    2086:	93 2f       	mov	r25, r19
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2088:	e1 99       	sbic	0x1c, 1	; 28
    208a:	fe cf       	rjmp	.-4      	; 0x2088 <_Z15EEPROM_writeIntjj+0x18>
    208c:	6f 5f       	subi	r22, 0xFF	; 255
    208e:	7f 4f       	sbci	r23, 0xFF	; 255
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2090:	7f bb       	out	0x1f, r23	; 31
    2092:	6e bb       	out	0x1e, r22	; 30
#endif
    EEDR = __value;
    2094:	9d bb       	out	0x1d, r25	; 29
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	e2 9a       	sbi	0x1c, 2	; 28
    209c:	e1 9a       	sbi	0x1c, 1	; 28
    209e:	0f be       	out	0x3f, r0	; 63
}
    20a0:	08 95       	ret

000020a2 <_Z16EEPROM_writeLongmj>:

void EEPROM_writeLong(unsigned long val, unsigned int address) {
    20a2:	ef 92       	push	r14
    20a4:	ff 92       	push	r15
    20a6:	0f 93       	push	r16
    20a8:	1f 93       	push	r17
    20aa:	8a 01       	movw	r16, r20
    FourBytes storer = {val};
    20ac:	f8 2e       	mov	r15, r24
    20ae:	e9 2e       	mov	r14, r25
    EEPROM_writeInt(storer.array[0], address);
    20b0:	cb 01       	movw	r24, r22
    20b2:	ba 01       	movw	r22, r20
    20b4:	0e 94 38 10 	call	0x2070	; 0x2070 <_Z15EEPROM_writeIntjj>
    EEPROM_writeInt(storer.array[1], address+2);
    20b8:	0e 5f       	subi	r16, 0xFE	; 254
    20ba:	1f 4f       	sbci	r17, 0xFF	; 255
    20bc:	8f 2d       	mov	r24, r15
    20be:	9e 2d       	mov	r25, r14
    20c0:	b8 01       	movw	r22, r16
    20c2:	0e 94 38 10 	call	0x2070	; 0x2070 <_Z15EEPROM_writeIntjj>
}
    20c6:	1f 91       	pop	r17
    20c8:	0f 91       	pop	r16
    20ca:	ff 90       	pop	r15
    20cc:	ef 90       	pop	r14
    20ce:	08 95       	ret

000020d0 <_Z18EEPROM_writeStringPKchj>:

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    20d0:	fc 01       	movw	r30, r24
    20d2:	20 e0       	ldi	r18, 0x00	; 0
    20d4:	30 e0       	ldi	r19, 0x00	; 0
    20d6:	11 c0       	rjmp	.+34     	; 0x20fa <_Z18EEPROM_writeStringPKchj+0x2a>
    for(byte i = 0; i < len; i++) {
        EEPROM_writeByte(string[i], address+i);
    20d8:	70 81       	ld	r23, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    20da:	e1 99       	sbic	0x1c, 1	; 28
    20dc:	fe cf       	rjmp	.-4      	; 0x20da <_Z18EEPROM_writeStringPKchj+0xa>
    20de:	c9 01       	movw	r24, r18
    20e0:	84 0f       	add	r24, r20
    20e2:	95 1f       	adc	r25, r21
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    20e4:	9f bb       	out	0x1f, r25	; 31
    20e6:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    20e8:	7d bb       	out	0x1d, r23	; 29
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    20ea:	0f b6       	in	r0, 0x3f	; 63
    20ec:	f8 94       	cli
    20ee:	e2 9a       	sbi	0x1c, 2	; 28
    20f0:	e1 9a       	sbi	0x1c, 1	; 28
    20f2:	0f be       	out	0x3f, r0	; 63
    20f4:	2f 5f       	subi	r18, 0xFF	; 255
    20f6:	3f 4f       	sbci	r19, 0xFF	; 255
    20f8:	31 96       	adiw	r30, 0x01	; 1
    EEPROM_writeInt(storer.array[0], address);
    EEPROM_writeInt(storer.array[1], address+2);
}

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
    20fa:	26 17       	cp	r18, r22
    20fc:	68 f3       	brcs	.-38     	; 0x20d8 <_Z18EEPROM_writeStringPKchj+0x8>
        EEPROM_writeByte(string[i], address+i);
    }
}
    20fe:	08 95       	ret

00002100 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>:

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    2100:	ef 92       	push	r14
    2102:	ff 92       	push	r15
    2104:	0f 93       	push	r16
    2106:	1f 93       	push	r17
    2108:	cf 93       	push	r28
    210a:	df 93       	push	r29
    210c:	e6 2e       	mov	r14, r22
    210e:	8a 01       	movw	r16, r20
    2110:	ec 01       	movw	r28, r24
    2112:	ff 24       	eor	r15, r15
    2114:	16 c0       	rjmp	.+44     	; 0x2142 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x42>
    for(byte i = 0; i < elements; i++) {
        EEPROM_writeInt(table[i].speed,address);
    2116:	88 81       	ld	r24, Y
    2118:	99 81       	ldd	r25, Y+1	; 0x01
    211a:	b8 01       	movw	r22, r16
    211c:	0e 94 38 10 	call	0x2070	; 0x2070 <_Z15EEPROM_writeIntjj>
    2120:	c8 01       	movw	r24, r16
    2122:	02 96       	adiw	r24, 0x02	; 2
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
    2124:	2a 81       	ldd	r18, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2126:	e1 99       	sbic	0x1c, 1	; 28
    2128:	fe cf       	rjmp	.-4      	; 0x2126 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x26>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    212a:	9f bb       	out	0x1f, r25	; 31
    212c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    212e:	2d bb       	out	0x1d, r18	; 29
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    2130:	0f b6       	in	r0, 0x3f	; 63
    2132:	f8 94       	cli
    2134:	e2 9a       	sbi	0x1c, 2	; 28
    2136:	e1 9a       	sbi	0x1c, 1	; 28
    2138:	0f be       	out	0x3f, r0	; 63
    213a:	0d 5f       	subi	r16, 0xFD	; 253
    213c:	1f 4f       	sbci	r17, 0xFF	; 255
        EEPROM_writeByte(string[i], address+i);
    }
}

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
    213e:	f3 94       	inc	r15
    2140:	23 96       	adiw	r28, 0x03	; 3
    2142:	fe 14       	cp	r15, r14
    2144:	40 f3       	brcs	.-48     	; 0x2116 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x16>
        EEPROM_writeInt(table[i].speed,address);
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
        address = address + sizeof(byte);
    }
}
    2146:	df 91       	pop	r29
    2148:	cf 91       	pop	r28
    214a:	1f 91       	pop	r17
    214c:	0f 91       	pop	r16
    214e:	ff 90       	pop	r15
    2150:	ef 90       	pop	r14
    2152:	08 95       	ret

00002154 <_Z17Serial_initialisem>:
RingBuffer rxBuf = {{0},0,0};

bool softSPIEnabled = false;

//Initialise the hardware UART port and set baud rate.
void Serial_initialise(const unsigned long baud) {
    2154:	ef 92       	push	r14
    2156:	ff 92       	push	r15
    2158:	0f 93       	push	r16
    215a:	1f 93       	push	r17
    215c:	7b 01       	movw	r14, r22
    215e:	8c 01       	movw	r16, r24
    Byter baud_setting;

    UCSRnA = _BV(U2Xn);
    2160:	82 e0       	ldi	r24, 0x02	; 2
    2162:	8b b9       	out	0x0b, r24	; 11
    baud_setting.integer = (F_CPU / 4 / baud - 1) / 2;
    2164:	60 e0       	ldi	r22, 0x00	; 0
    2166:	79 e0       	ldi	r23, 0x09	; 9
    2168:	8d e3       	ldi	r24, 0x3D	; 61
    216a:	90 e0       	ldi	r25, 0x00	; 0
    216c:	a8 01       	movw	r20, r16
    216e:	97 01       	movw	r18, r14
    2170:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <__udivmodsi4>
    2174:	21 50       	subi	r18, 0x01	; 1
    2176:	30 40       	sbci	r19, 0x00	; 0
    2178:	40 40       	sbci	r20, 0x00	; 0
    217a:	50 40       	sbci	r21, 0x00	; 0
    217c:	56 95       	lsr	r21
    217e:	47 95       	ror	r20
    2180:	37 95       	ror	r19
    2182:	27 95       	ror	r18
    2184:	92 2f       	mov	r25, r18
    2186:	23 2f       	mov	r18, r19

    if (baud_setting.high & 0xF0) {
    2188:	83 2f       	mov	r24, r19
    218a:	80 7f       	andi	r24, 0xF0	; 240
    218c:	99 f0       	breq	.+38     	; 0x21b4 <_Z17Serial_initialisem+0x60>
        UCSRnA = 0;
    218e:	1b b8       	out	0x0b, r1	; 11
        baud_setting.integer = (F_CPU / 8 / baud - 1) / 2;
    2190:	60 e8       	ldi	r22, 0x80	; 128
    2192:	74 e8       	ldi	r23, 0x84	; 132
    2194:	8e e1       	ldi	r24, 0x1E	; 30
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	a8 01       	movw	r20, r16
    219a:	97 01       	movw	r18, r14
    219c:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <__udivmodsi4>
    21a0:	21 50       	subi	r18, 0x01	; 1
    21a2:	30 40       	sbci	r19, 0x00	; 0
    21a4:	40 40       	sbci	r20, 0x00	; 0
    21a6:	50 40       	sbci	r21, 0x00	; 0
    21a8:	56 95       	lsr	r21
    21aa:	47 95       	ror	r20
    21ac:	37 95       	ror	r19
    21ae:	27 95       	ror	r18
    21b0:	92 2f       	mov	r25, r18
    21b2:	23 2f       	mov	r18, r19
    }

    // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
    UBRRnH = baud_setting.high & 0x0F;
    21b4:	2f 70       	andi	r18, 0x0F	; 15
    21b6:	20 bd       	out	0x20, r18	; 32
    UBRRnL = baud_setting.low;
    21b8:	99 b9       	out	0x09, r25	; 9
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    21ba:	8f b7       	in	r24, 0x3f	; 63
    cli();
    21bc:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    21be:	10 92 1d 04 	sts	0x041D, r1
    txBuf.tail = 0;
    21c2:	10 92 1e 04 	sts	0x041E, r1
    rxBuf.head = 0;
    21c6:	10 92 3f 04 	sts	0x043F, r1
    rxBuf.tail = 0;
    21ca:	10 92 40 04 	sts	0x0440, r1
    SREG = oldSREG;
    21ce:	8f bf       	out	0x3f, r24	; 63

    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.

    //And enable
    sbi(UCSRnB, RXENn);
    21d0:	54 9a       	sbi	0x0a, 4	; 10
    sbi(UCSRnB, TXENn);
    21d2:	53 9a       	sbi	0x0a, 3	; 10
    sbi(UCSRnB, RXCIEn);
    21d4:	57 9a       	sbi	0x0a, 7	; 10
    cbi(UCSRnB, UDRIEn);
    21d6:	55 98       	cbi	0x0a, 5	; 10
}
    21d8:	1f 91       	pop	r17
    21da:	0f 91       	pop	r16
    21dc:	ff 90       	pop	r15
    21de:	ef 90       	pop	r14
    21e0:	08 95       	ret

000021e2 <_Z14Serial_disablev>:

//Disable the hardware UART port
void Serial_disable() {
    cbi(UCSRnB, RXENn);
    21e2:	54 98       	cbi	0x0a, 4	; 10
    cbi(UCSRnB, TXENn);
    21e4:	53 98       	cbi	0x0a, 3	; 10
    cbi(UCSRnB, RXCIEn);
    21e6:	57 98       	cbi	0x0a, 7	; 10
    cbi(UCSRnB, UDRIEn);
    21e8:	55 98       	cbi	0x0a, 5	; 10
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    21ea:	8f b7       	in	r24, 0x3f	; 63
    cli();
    21ec:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    21ee:	10 92 1d 04 	sts	0x041D, r1
    txBuf.tail = 0;
    21f2:	10 92 1e 04 	sts	0x041E, r1
    rxBuf.head = 0;
    21f6:	10 92 3f 04 	sts	0x043F, r1
    rxBuf.tail = 0;
    21fa:	10 92 40 04 	sts	0x0440, r1
    SREG = oldSREG;
    21fe:	8f bf       	out	0x3f, r24	; 63
    cbi(UCSRnB, RXENn);
    cbi(UCSRnB, TXENn);
    cbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}
    2200:	08 95       	ret

00002202 <_Z14SPI_initialisev>:
}

//Initialise the Software SPI by setting ports to correct direction and state.
void SPI_initialise() {
    //Set all SPI pins to idle levels
    setPinDir  (SPIClockPin_Define,OUTPUT); //Clock is output idle high
    2202:	d5 9a       	sbi	0x1a, 5	; 26
    setPinValue(SPIClockPin_Define,  HIGH);
    2204:	dd 9a       	sbi	0x1b, 5	; 27
    setPinDir  (SPIMISOPin_Define,  INPUT); //MISO is input pull-up
    2206:	d7 98       	cbi	0x1a, 7	; 26
    setPinValue(SPIMISOPin_Define,   HIGH);
    2208:	df 9a       	sbi	0x1b, 7	; 27
    setPinDir  (SPIMOSIPin_Define, OUTPUT); //MOSI is output idle high
    220a:	d6 9a       	sbi	0x1a, 6	; 26
    setPinValue(SPIMOSIPin_Define,   HIGH);
    220c:	de 9a       	sbi	0x1b, 6	; 27
    setPinDir  (SPISSnPin_Define,  OUTPUT); //SSn is output idle high
    220e:	d4 9a       	sbi	0x1a, 4	; 26
    setPinValue(SPISSnPin_Define,    HIGH);
    2210:	dc 9a       	sbi	0x1b, 4	; 27
    //Standalone pin is switching to SPI ready, so ensure we out pull-up is to high.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    2212:	38 9a       	sbi	0x07, 0	; 7
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    2214:	8f b7       	in	r24, 0x3f	; 63
    cli();
    2216:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    2218:	10 92 1d 04 	sts	0x041D, r1
    txBuf.tail = 0;
    221c:	10 92 1e 04 	sts	0x041E, r1
    rxBuf.head = 0;
    2220:	10 92 3f 04 	sts	0x043F, r1
    rxBuf.tail = 0;
    2224:	10 92 40 04 	sts	0x0440, r1
    SREG = oldSREG;
    2228:	8f bf       	out	0x3f, r24	; 63
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.
    
    //Now enabled
    softSPIEnabled = true;
    222a:	81 e0       	ldi	r24, 0x01	; 1
    222c:	80 93 41 04 	sts	0x0441, r24
}
    2230:	08 95       	ret

00002232 <_Z11SPI_disablev>:

//Disable the Software SPI by setting all ports back to input pull-up
void SPI_disable() {
    //Set all SPI pins to High-Z
    setPinDir  (SPIClockPin_Define, INPUT);
    2232:	d5 98       	cbi	0x1a, 5	; 26
    setPinValue(SPIClockPin_Define,  HIGH);
    2234:	dd 9a       	sbi	0x1b, 5	; 27
    setPinDir  (SPIMISOPin_Define,  INPUT);
    2236:	d7 98       	cbi	0x1a, 7	; 26
    setPinValue(SPIMISOPin_Define,   HIGH);
    2238:	df 9a       	sbi	0x1b, 7	; 27
    setPinDir  (SPIMOSIPin_Define,  INPUT);
    223a:	d6 98       	cbi	0x1a, 6	; 26
    setPinValue(SPIMOSIPin_Define,   HIGH);
    223c:	de 9a       	sbi	0x1b, 6	; 27
    setPinDir  (SPISSnPin_Define,   INPUT);
    223e:	d4 98       	cbi	0x1a, 4	; 26
    setPinValue(SPISSnPin_Define,    HIGH);
    2240:	dc 9a       	sbi	0x1b, 4	; 27
    //Now disabled
    softSPIEnabled = false;
    2242:	10 92 41 04 	sts	0x0441, r1
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    2246:	8f b7       	in	r24, 0x3f	; 63
    cli();
    2248:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    224a:	10 92 1d 04 	sts	0x041D, r1
    txBuf.tail = 0;
    224e:	10 92 1e 04 	sts	0x041E, r1
    rxBuf.head = 0;
    2252:	10 92 3f 04 	sts	0x043F, r1
    rxBuf.tail = 0;
    2256:	10 92 40 04 	sts	0x0440, r1
    SREG = oldSREG;
    225a:	8f bf       	out	0x3f, r24	; 63
    setPinDir  (SPISSnPin_Define,   INPUT);
    setPinValue(SPISSnPin_Define,    HIGH);
    //Now disabled
    softSPIEnabled = false;
    Serial_clear(); //Empty the buffer of any outstanding data.
}
    225c:	08 95       	ret

0000225e <_Z12SPI_transferh>:

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    225e:	98 e0       	ldi	r25, 0x08	; 8
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
        setPinValue(SPIClockPin_Define,LOW); //Falling Edge   //--     2 cycles         .
    2260:	dd 98       	cbi	0x1b, 5	; 27
        if (data & 0x80) { //Send MSB first                   //-- 2 cycles | 1 cycle    |
    2262:	87 ff       	sbrs	r24, 7
    2264:	02 c0       	rjmp	.+4      	; 0x226a <_Z12SPI_transferh+0xc>
            setPinValue(SPIMOSIPin_Define,HIGH);              //-- 2 cycles | -          |
    2266:	de 9a       	sbi	0x1b, 6	; 27
    2268:	02 c0       	rjmp	.+4      	; 0x226e <_Z12SPI_transferh+0x10>
        } else {                                              //--          | 2 cycles    > 8 cycles for both paths
            nop();                                            //--          | 1 cycle    |
    226a:	00 00       	nop
            setPinValue(SPIMOSIPin_Define,LOW);               //--          | 2 cycles   |
    226c:	de 98       	cbi	0x1b, 6	; 27
        }                                                     //-- 2 cycles | -         '
        setPinValue(SPIClockPin_Define,HIGH); //Rising Edge   //--      2 cycles        .
    226e:	dd 9a       	sbi	0x1b, 5	; 27
        data = data << 1; //Shift MSB-1 to MSB                //--      1 cycle          |
    2270:	88 0f       	add	r24, r24
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
    2272:	cf 99       	sbic	0x19, 7	; 25
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
    2274:	8f 5f       	subi	r24, 0xFF	; 255
}

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
    2276:	91 50       	subi	r25, 0x01	; 1
    2278:	99 f7       	brne	.-26     	; 0x2260 <_Z12SPI_transferh+0x2>
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
        }                                                     //--       3 cycles       '
    }                                                         //-- Total Path is 16 cycles = 1MHz @ 16MHz clock
    return data; //Return shifted in data.                    //-- 5 Cycles on entry (including CALL), 3 cycles on exit (including RET)
}
    227a:	08 95       	ret

0000227c <_Z8SPI_readv>:
//Performs an SPI read request and stores the data in the RX buffer.
// - If there is no space in the buffer, a read request will *not* be performed
//   The buffer should be first emptied by using Serial_read()
void SPI_read(void) {
    //First we check if there is space in the buffer, and that the slave has data to send
    if ((rxBuf.tail != rxBuf.head) && !(getPinValue(standalonePin[STANDALONE_IRQ]))) {
    227c:	90 91 40 04 	lds	r25, 0x0440
    2280:	80 91 3f 04 	lds	r24, 0x043F
    2284:	98 17       	cp	r25, r24
    2286:	c9 f0       	breq	.+50     	; 0x22ba <_Z8SPI_readv+0x3e>
    2288:	82 99       	sbic	0x10, 2	; 16
    228a:	17 c0       	rjmp	.+46     	; 0x22ba <_Z8SPI_readv+0x3e>
        //If there is, then do a read request  
        setPinValue(SPISSnPin_Define,LOW); //Select the slave
    228c:	dc 98       	cbi	0x1b, 4	; 27
        SPI_transfer(SPI_READ); //First send a read request
    228e:	81 e8       	ldi	r24, 0x81	; 129
    2290:	0e 94 2f 11 	call	0x225e	; 0x225e <_Z12SPI_transferh>
        while(!getPinValue(standalonePin[STANDALONE_IRQ])); //Wait for the slave to have loaded its data
    2294:	82 9b       	sbis	0x10, 2	; 16
    2296:	fe cf       	rjmp	.-4      	; 0x2294 <_Z8SPI_readv+0x18>
        byte data = SPI_transfer(SPI_RESP); //Then send a response request (clocks data from slave to master and informs slave that transfer is done)
    2298:	80 e8       	ldi	r24, 0x80	; 128
    229a:	0e 94 2f 11 	call	0x225e	; 0x225e <_Z12SPI_transferh>
        if (SPI_ISDATA(data)) {
    229e:	87 fd       	sbrc	r24, 7
    22a0:	0b c0       	rjmp	.+22     	; 0x22b8 <_Z8SPI_readv+0x3c>
            //If the slave had data available (indicated by the MSB being clear)
            rxBuf.buffer[rxBuf.head] = data; //Store the data
    22a2:	e0 91 3f 04 	lds	r30, 0x043F
    22a6:	f0 e0       	ldi	r31, 0x00	; 0
    22a8:	e1 5e       	subi	r30, 0xE1	; 225
    22aa:	fb 4f       	sbci	r31, 0xFB	; 251
    22ac:	80 83       	st	Z, r24
            rxBuf.head++; //And increment the head
    22ae:	80 91 3f 04 	lds	r24, 0x043F
    22b2:	8f 5f       	subi	r24, 0xFF	; 255
    22b4:	80 93 3f 04 	sts	0x043F, r24
        }
        setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    22b8:	dc 9a       	sbi	0x1b, 4	; 27
    22ba:	08 95       	ret

000022bc <_Z9SPI_writeh>:
    }
}

//Performs an SPI write request.
void SPI_write(byte data) {
    setPinValue(SPISSnPin_Define,LOW); //Select the slave
    22bc:	dc 98       	cbi	0x1b, 4	; 27
    SPI_transfer(data & SPI_DATA); 
    22be:	8f 77       	andi	r24, 0x7F	; 127
    22c0:	0e 94 2f 11 	call	0x225e	; 0x225e <_Z12SPI_transferh>
    setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    22c4:	dc 9a       	sbi	0x1b, 4	; 27
}
    22c6:	08 95       	ret

000022c8 <_Z16Serial_availablev>:

//Checks if there is any data available in the RX buffer.
// - If in SPI mode, this will also perform an SPI read transfer to see if there is any valid data.
byte Serial_available(void) {
    if (softSPIEnabled) {
    22c8:	80 91 41 04 	lds	r24, 0x0441
    22cc:	88 23       	and	r24, r24
    22ce:	11 f0       	breq	.+4      	; 0x22d4 <_Z16Serial_availablev+0xc>
        //If SPI is enabled, we do a read to check if there is any data.
        SPI_read();
    22d0:	0e 94 3e 11 	call	0x227c	; 0x227c <_Z8SPI_readv>
    }
    return ((rxBuf.head - rxBuf.tail) & BUFFER_PTR_MASK); //number of bytes available
    22d4:	80 91 3f 04 	lds	r24, 0x043F
    22d8:	90 91 40 04 	lds	r25, 0x0440
    22dc:	89 1b       	sub	r24, r25
}
    22de:	8f 71       	andi	r24, 0x1F	; 31
    22e0:	08 95       	ret

000022e2 <_Z11Serial_readv>:

//Returns the next available data byte in the buffer
// - If there is nothing there, -1 is returned.
char Serial_read(void) {
    //If UART is enabled
    byte tail = rxBuf.tail;
    22e2:	90 91 40 04 	lds	r25, 0x0440
    if (rxBuf.head == tail) {
    22e6:	80 91 3f 04 	lds	r24, 0x043F
    22ea:	89 17       	cp	r24, r25
    22ec:	11 f4       	brne	.+4      	; 0x22f2 <_Z11Serial_readv+0x10>
    22ee:	8f ef       	ldi	r24, 0xFF	; 255
    22f0:	08 95       	ret
        return -1;
    } else {
        char c = rxBuf.buffer[tail];
    22f2:	e9 2f       	mov	r30, r25
    22f4:	f0 e0       	ldi	r31, 0x00	; 0
    22f6:	e1 5e       	subi	r30, 0xE1	; 225
    22f8:	fb 4f       	sbci	r31, 0xFB	; 251
    22fa:	80 81       	ld	r24, Z
        rxBuf.tail = ((tail + 1) & BUFFER_PTR_MASK);
    22fc:	9f 5f       	subi	r25, 0xFF	; 255
    22fe:	9f 71       	andi	r25, 0x1F	; 31
    2300:	90 93 40 04 	sts	0x0440, r25
        return c;
    }
}
    2304:	08 95       	ret

00002306 <_Z12Serial_writec>:

//Write a byte of data
// - If in UART mode, the byte is stored into the TX buffer when there is space.
// - If in SPI mode, a write transfer is performed.
void Serial_write(char ch) {
    2306:	28 2f       	mov	r18, r24
    if (UCSRnB & _BV(TXENn)) { 
    2308:	53 9b       	sbis	0x0a, 3	; 10
    230a:	17 c0       	rjmp	.+46     	; 0x233a <_Z12Serial_writec+0x34>
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
    230c:	90 91 1d 04 	lds	r25, 0x041D
    2310:	9f 5f       	subi	r25, 0xFF	; 255
    2312:	9f 71       	andi	r25, 0x1F	; 31
        if (head == txBuf.tail) {
    2314:	80 91 1e 04 	lds	r24, 0x041E
    2318:	98 17       	cp	r25, r24
    231a:	29 f4       	brne	.+10     	; 0x2326 <_Z12Serial_writec+0x20>
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
    231c:	55 9a       	sbi	0x0a, 5	; 10
            while (head == txBuf.tail); //wait for buffer to have some space
    231e:	80 91 1e 04 	lds	r24, 0x041E
    2322:	98 17       	cp	r25, r24
    2324:	e1 f3       	breq	.-8      	; 0x231e <_Z12Serial_writec+0x18>
        }
        
        txBuf.buffer[txBuf.head] = ch; //Load the new data into the buffer
    2326:	e0 91 1d 04 	lds	r30, 0x041D
    232a:	f0 e0       	ldi	r31, 0x00	; 0
    232c:	e3 50       	subi	r30, 0x03	; 3
    232e:	fc 4f       	sbci	r31, 0xFC	; 252
    2330:	20 83       	st	Z, r18
        txBuf.head = head; //And store the new head.
    2332:	90 93 1d 04 	sts	0x041D, r25
        sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled if not already
    2336:	55 9a       	sbi	0x0a, 5	; 10
    2338:	08 95       	ret
    } else if (softSPIEnabled) {
    233a:	80 91 41 04 	lds	r24, 0x0441
    233e:	88 23       	and	r24, r24
    2340:	19 f0       	breq	.+6      	; 0x2348 <_Z12Serial_writec+0x42>
        //If SPI is enabled, we do an SPI write.
        SPI_write(ch);
    2342:	82 2f       	mov	r24, r18
    2344:	0e 94 5e 11 	call	0x22bc	; 0x22bc <_Z9SPI_writeh>
    2348:	08 95       	ret

0000234a <_Z12Serial_flushv>:
    }
}

//Flushes data from TX buffer
void Serial_flush() {
    if (UCSRnB & _BV(TXENn)) { 
    234a:	53 9b       	sbis	0x0a, 3	; 10
    234c:	0d c0       	rjmp	.+26     	; 0x2368 <_Z12Serial_flushv+0x1e>
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
    234e:	90 91 1d 04 	lds	r25, 0x041D
    2352:	9f 5f       	subi	r25, 0xFF	; 255
    2354:	9f 71       	andi	r25, 0x1F	; 31
        if (head == txBuf.tail) {
    2356:	80 91 1e 04 	lds	r24, 0x041E
    235a:	98 17       	cp	r25, r24
    235c:	29 f4       	brne	.+10     	; 0x2368 <_Z12Serial_flushv+0x1e>
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
    235e:	55 9a       	sbi	0x0a, 5	; 10
            while (head == txBuf.tail); //wait for buffer to have some space
    2360:	80 91 1e 04 	lds	r24, 0x041E
    2364:	98 17       	cp	r25, r24
    2366:	e1 f3       	breq	.-8      	; 0x2360 <_Z12Serial_flushv+0x16>
    2368:	08 95       	ret

0000236a <_Z15Serial_writeStrPc>:
        }
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    236a:	cf 93       	push	r28
    236c:	df 93       	push	r29
    236e:	ec 01       	movw	r28, r24
    2370:	03 c0       	rjmp	.+6      	; 0x2378 <_Z15Serial_writeStrPc+0xe>
    while (*str) {
        Serial_write(*str++);
    2372:	21 96       	adiw	r28, 0x01	; 1
    2374:	0e 94 83 11 	call	0x2306	; 0x2306 <_Z12Serial_writec>
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    while (*str) {
    2378:	88 81       	ld	r24, Y
    237a:	88 23       	and	r24, r24
    237c:	d1 f7       	brne	.-12     	; 0x2372 <_Z15Serial_writeStrPc+0x8>
        Serial_write(*str++);
    }
}
    237e:	df 91       	pop	r29
    2380:	cf 91       	pop	r28
    2382:	08 95       	ret

00002384 <__vector_19>:
        "push r30    \n\t"
        "push r31    \n\t"
        :
        : "a" (c), "r" (head), "r" (tail), "I" (_SFR_IO_ADDR(SREG))
        :
    );
    2384:	2f 93       	push	r18
    2386:	2f b7       	in	r18, 0x3f	; 63
    2388:	2f 93       	push	r18
    238a:	9f 93       	push	r25
    238c:	8f 93       	push	r24
    238e:	ef 93       	push	r30
    2390:	ff 93       	push	r31

    //Read in from the serial data register
    c = UDRn;
    2392:	2c b1       	in	r18, 0x0c	; 12
    //get the current head
    head = rxBuf.head;
    2394:	90 91 3f 04 	lds	r25, 0x043F
    head++;
    head &= BUFFER_PTR_MASK;
    2398:	9f 5f       	subi	r25, 0xFF	; 255
    239a:	9f 71       	andi	r25, 0x1F	; 31
    tail = rxBuf.tail;
    239c:	80 91 40 04 	lds	r24, 0x0440

    if (head != tail) {
    23a0:	98 17       	cp	r25, r24
    23a2:	41 f0       	breq	.+16     	; 0x23b4 <__vector_19+0x30>
        rxBuf.buffer[rxBuf.head] = c;
    23a4:	e0 91 3f 04 	lds	r30, 0x043F
    23a8:	f0 e0       	ldi	r31, 0x00	; 0
    23aa:	e1 5e       	subi	r30, 0xE1	; 225
    23ac:	fb 4f       	sbci	r31, 0xFB	; 251
    23ae:	20 83       	st	Z, r18
        rxBuf.head = head;
    23b0:	90 93 3f 04 	sts	0x043F, r25
        "pop %0     \n\t"
        "reti       \n\t"
        : "=a" (c), "=r" (head), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
    23b4:	ff 91       	pop	r31
    23b6:	ef 91       	pop	r30
    23b8:	8f 91       	pop	r24
    23ba:	9f 91       	pop	r25
    23bc:	2f 91       	pop	r18
    23be:	2f bf       	out	0x3f, r18	; 63
    23c0:	2f 91       	pop	r18
    23c2:	18 95       	reti

000023c4 <__vector_21>:
        "push %0       \n\t"
        "push %1       \n\t"
        "push r30      \n\t"
        "push r31      \n\t"
        :: "r" (temp), "r" (tail), "I" (_SFR_IO_ADDR(SREG)):
    );
    23c4:	8f 93       	push	r24
    23c6:	8f b7       	in	r24, 0x3f	; 63
    23c8:	8f 93       	push	r24
    23ca:	9f 93       	push	r25
    23cc:	ef 93       	push	r30
    23ce:	ff 93       	push	r31
    tail = txBuf.tail;
    23d0:	90 91 1e 04 	lds	r25, 0x041E
    temp = txBuf.head;
    23d4:	80 91 1d 04 	lds	r24, 0x041D
    if (temp == tail) {
    23d8:	89 17       	cp	r24, r25
    23da:	11 f4       	brne	.+4      	; 0x23e0 <__vector_21+0x1c>
        // Buffer empty, so disable interrupts
        cbi(UCSRnB, UDRIEn);
    23dc:	55 98       	cbi	0x0a, 5	; 10
    23de:	0a c0       	rjmp	.+20     	; 0x23f4 <__vector_21+0x30>
    } else {
        // There is more data in the output buffer. Send the next byte
        temp = txBuf.buffer[tail];
    23e0:	e9 2f       	mov	r30, r25
    23e2:	f0 e0       	ldi	r31, 0x00	; 0
    23e4:	e3 50       	subi	r30, 0x03	; 3
    23e6:	fc 4f       	sbci	r31, 0xFC	; 252
    23e8:	80 81       	ld	r24, Z
        tail++;
    23ea:	9f 5f       	subi	r25, 0xFF	; 255
        tail &= BUFFER_PTR_MASK;
    23ec:	9f 71       	andi	r25, 0x1F	; 31
        txBuf.tail = tail;
    23ee:	90 93 1e 04 	sts	0x041E, r25
        UDRn = temp;
    23f2:	8c b9       	out	0x0c, r24	; 12
        "pop %0     \n\t"
        "reti       \n\t"
        : "=r" (temp), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
    23f4:	ff 91       	pop	r31
    23f6:	ef 91       	pop	r30
    23f8:	9f 91       	pop	r25
    23fa:	8f 91       	pop	r24
    23fc:	8f bf       	out	0x3f, r24	; 63
    23fe:	8f 91       	pop	r24
    2400:	18 95       	reti

00002402 <_Z9hexToBytePc>:
    if (hex > '9'){
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    }
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    2402:	fc 01       	movw	r30, r24
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    2404:	91 81       	ldd	r25, Z+1	; 0x01
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
    2406:	9a 33       	cpi	r25, 0x3A	; 58
    2408:	0c f0       	brlt	.+2      	; 0x240c <_Z9hexToBytePc+0xa>
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    240a:	97 50       	subi	r25, 0x07	; 7
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    240c:	80 81       	ld	r24, Z
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
    240e:	8a 33       	cpi	r24, 0x3A	; 58
    2410:	0c f0       	brlt	.+2      	; 0x2414 <_Z9hexToBytePc+0x12>
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    2412:	87 50       	subi	r24, 0x07	; 7
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
    2414:	82 95       	swap	r24
    2416:	80 7f       	andi	r24, 0xF0	; 240
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    2418:	9f 70       	andi	r25, 0x0F	; 15
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
}
    241a:	89 2b       	or	r24, r25
    241c:	08 95       	ret

0000241e <_Z15synta_hexToBytePc>:

byte synta_hexToByte(char* hex){
    return hexToByte(hex);
    241e:	0e 94 01 12 	call	0x2402	; 0x2402 <_Z9hexToBytePc>
}
    2422:	08 95       	ret

00002424 <_Z15synta_hexToLongPc>:
unsigned long synta_hexToLong(char* hex){
    2424:	ef 92       	push	r14
    2426:	ff 92       	push	r15
    2428:	0f 93       	push	r16
    242a:	1f 93       	push	r17
    242c:	8c 01       	movw	r16, r24
    //  strncpy(str+2,&hex[2],2); //Middle Byte
    //  strncpy(str+4,hex,2); //Upper Byte
    //  str[6] = 0;
    //  return strtol(str,&boo,16); //convert hex to long integer

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    242e:	04 96       	adiw	r24, 0x04	; 4
    2430:	0e 94 01 12 	call	0x2402	; 0x2402 <_Z9hexToBytePc>
    2434:	e8 2e       	mov	r14, r24
    2436:	c8 01       	movw	r24, r16
    2438:	02 96       	adiw	r24, 0x02	; 2
    243a:	0e 94 01 12 	call	0x2402	; 0x2402 <_Z9hexToBytePc>
    243e:	f8 2e       	mov	r15, r24
    2440:	c8 01       	movw	r24, r16
    2442:	0e 94 01 12 	call	0x2402	; 0x2402 <_Z9hexToBytePc>
    return inter.integer; //and convert it to an integer
}
    2446:	68 2f       	mov	r22, r24
    2448:	7f 2d       	mov	r23, r15
    244a:	8e 2d       	mov	r24, r14
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	1f 91       	pop	r17
    2450:	0f 91       	pop	r16
    2452:	ff 90       	pop	r15
    2454:	ef 90       	pop	r14
    2456:	08 95       	ret

00002458 <_Z10synta_axish>:
char synta_command(){
    return _command;
}

byte synta_axis(byte axis){
    if(axis < 2){
    2458:	82 30       	cpi	r24, 0x02	; 2
    245a:	10 f4       	brcc	.+4      	; 0x2460 <_Z10synta_axish+0x8>
        _axis = axis;
    245c:	80 93 4f 04 	sts	0x044F, r24
    }
    return _axis;
}
    2460:	80 91 4f 04 	lds	r24, 0x044F
    2464:	08 95       	ret

00002466 <_Z21synta_validateCommandhPc>:
    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    2466:	ef 92       	push	r14
    2468:	ff 92       	push	r15
    246a:	1f 93       	push	r17
    246c:	cf 93       	push	r28
    246e:	df 93       	push	r29
    2470:	18 2f       	mov	r17, r24
    2472:	7b 01       	movw	r14, r22
    _command = commandString[0]; //first byte is command
    2474:	90 91 43 04 	lds	r25, 0x0443
    2478:	90 93 50 04 	sts	0x0450, r25
    _axis = commandString[1] - 49; //second byte is axis
    247c:	80 91 44 04 	lds	r24, 0x0444
    2480:	81 53       	subi	r24, 0x31	; 49
    2482:	80 93 4f 04 	sts	0x044F, r24
    if(_axis > 1){
    2486:	82 30       	cpi	r24, 0x02	; 2
    2488:	f8 f4       	brcc	.+62     	; 0x24c8 <_Z21synta_validateCommandhPc+0x62>
        return false; //incorrect axis
    }
    char requiredLength = Commands_getLength(_command,1); //get the required length of this command
    248a:	89 2f       	mov	r24, r25
    248c:	61 e0       	ldi	r22, 0x01	; 1
    248e:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <_Z18Commands_getLengthcb>
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    2492:	13 50       	subi	r17, 0x03	; 3
    if(requiredLength != len){ //If invalid command, or not required length
    2494:	28 2f       	mov	r18, r24
    2496:	33 27       	eor	r19, r19
    2498:	27 fd       	sbrc	r18, 7
    249a:	30 95       	com	r19
    249c:	81 2f       	mov	r24, r17
    249e:	90 e0       	ldi	r25, 0x00	; 0
    24a0:	28 17       	cp	r18, r24
    24a2:	39 07       	cpc	r19, r25
    24a4:	89 f4       	brne	.+34     	; 0x24c8 <_Z21synta_validateCommandhPc+0x62>
    24a6:	a5 e4       	ldi	r26, 0x45	; 69
    24a8:	b4 e0       	ldi	r27, 0x04	; 4
    24aa:	e7 01       	movw	r28, r14
    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    24ac:	f9 01       	movw	r30, r18
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
    24ae:	2a 0f       	add	r18, r26
    24b0:	3b 1f       	adc	r19, r27
    24b2:	02 c0       	rjmp	.+4      	; 0x24b8 <_Z21synta_validateCommandhPc+0x52>
        decoded[i] = commandString[i + 2];
    24b4:	8d 91       	ld	r24, X+
    24b6:	89 93       	st	Y+, r24
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
    24b8:	a2 17       	cp	r26, r18
    24ba:	b3 07       	cpc	r27, r19
    24bc:	d9 f7       	brne	.-10     	; 0x24b4 <_Z21synta_validateCommandhPc+0x4e>
        decoded[i] = commandString[i + 2];
    }
    decoded[i] = '\0'; //Null
    24be:	ee 0d       	add	r30, r14
    24c0:	ff 1d       	adc	r31, r15
    24c2:	10 82       	st	Z, r1
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	01 c0       	rjmp	.+2      	; 0x24ca <_Z21synta_validateCommandhPc+0x64>
    return true;
    24c8:	80 e0       	ldi	r24, 0x00	; 0
}
    24ca:	df 91       	pop	r29
    24cc:	cf 91       	pop	r28
    24ce:	1f 91       	pop	r17
    24d0:	ff 90       	pop	r15
    24d2:	ef 90       	pop	r14
    24d4:	08 95       	ret

000024d6 <_Z20synta_recieveCommandPcc>:

char synta_recieveCommand(char* dataPacket, char character){
    24d6:	cf 93       	push	r28
    24d8:	df 93       	push	r29
    24da:	ec 01       	movw	r28, r24
    if(validPacket){
    24dc:	80 91 42 04 	lds	r24, 0x0442
    24e0:	88 23       	and	r24, r24
    24e2:	21 f1       	breq	.+72     	; 0x252c <_Z20synta_recieveCommandPcc+0x56>
        if (character == startInChar){
    24e4:	6a 33       	cpi	r22, 0x3A	; 58
    24e6:	49 f4       	brne	.+18     	; 0x24fa <_Z20synta_recieveCommandPcc+0x24>
            dataPacket[0] = errorChar;
    24e8:	81 e2       	ldi	r24, 0x21	; 33
    24ea:	88 83       	st	Y, r24
            dataPacket[1] = endChar;
    24ec:	8d e0       	ldi	r24, 0x0D	; 13
    24ee:	89 83       	std	Y+1, r24	; 0x01
            dataPacket[2] = '\0';
    24f0:	1a 82       	std	Y+2, r1	; 0x02
            validPacket = 0; //new command without old finishing! (dataPacket contains error message)
    24f2:	10 92 42 04 	sts	0x0442, r1
    24f6:	8e ef       	ldi	r24, 0xFE	; 254
    24f8:	2d c0       	rjmp	.+90     	; 0x2554 <_Z20synta_recieveCommandPcc+0x7e>
            return -2;
        }

        commandString[commandIndex++] = character; //Add character to current string build
    24fa:	80 91 4e 04 	lds	r24, 0x044E
    24fe:	e8 2f       	mov	r30, r24
    2500:	f0 e0       	ldi	r31, 0x00	; 0
    2502:	ed 5b       	subi	r30, 0xBD	; 189
    2504:	fb 4f       	sbci	r31, 0xFB	; 251
    2506:	60 83       	st	Z, r22
    2508:	8f 5f       	subi	r24, 0xFF	; 255
    250a:	80 93 4e 04 	sts	0x044E, r24

        if(character == endChar){
    250e:	6d 30       	cpi	r22, 0x0D	; 13
    2510:	51 f4       	brne	.+20     	; 0x2526 <_Z20synta_recieveCommandPcc+0x50>
            if(synta_validateCommand(commandIndex, dataPacket)){
    2512:	be 01       	movw	r22, r28
    2514:	0e 94 33 12 	call	0x2466	; 0x2466 <_Z21synta_validateCommandhPc>
    2518:	88 23       	and	r24, r24
    251a:	91 f0       	breq	.+36     	; 0x2540 <_Z20synta_recieveCommandPcc+0x6a>
                validPacket = 0;
    251c:	10 92 42 04 	sts	0x0442, r1
                return _command; //Successful decode (dataPacket contains decoded packet, return value is the current command)
    2520:	80 91 50 04 	lds	r24, 0x0450
    2524:	17 c0       	rjmp	.+46     	; 0x2554 <_Z20synta_recieveCommandPcc+0x7e>
            } else {
                goto error; //Decode Failed (dataPacket contains error message)
            }
        } else if (commandIndex == sizeof(commandString)){
    2526:	8b 30       	cpi	r24, 0x0B	; 11
    2528:	a1 f4       	brne	.+40     	; 0x2552 <_Z20synta_recieveCommandPcc+0x7c>
    252a:	0a c0       	rjmp	.+20     	; 0x2540 <_Z20synta_recieveCommandPcc+0x6a>
            goto error; //Message too long! (dataPacket contains error message)
        }
    } else if (character == startInChar){
    252c:	6a 33       	cpi	r22, 0x3A	; 58
    252e:	89 f4       	brne	.+34     	; 0x2552 <_Z20synta_recieveCommandPcc+0x7c>
        //Begin new command
        commandIndex = 0;
    2530:	10 92 4e 04 	sts	0x044E, r1
        validPacket = 1;
    2534:	81 e0       	ldi	r24, 0x01	; 1
    2536:	80 93 42 04 	sts	0x0442, r24
        commandString[0] = '\0';
    253a:	10 92 43 04 	sts	0x0443, r1
    253e:	09 c0       	rjmp	.+18     	; 0x2552 <_Z20synta_recieveCommandPcc+0x7c>
    }
    return 0; //Decode not finished (dataPacket unchanged)
error:
    dataPacket[0] = errorChar;
    2540:	81 e2       	ldi	r24, 0x21	; 33
    2542:	88 83       	st	Y, r24
    dataPacket[1] = endChar;
    2544:	8d e0       	ldi	r24, 0x0D	; 13
    2546:	89 83       	std	Y+1, r24	; 0x01
    dataPacket[2] = '\0';
    2548:	1a 82       	std	Y+2, r1	; 0x02
    validPacket = 0;
    254a:	10 92 42 04 	sts	0x0442, r1
    254e:	8f ef       	ldi	r24, 0xFF	; 255
    2550:	01 c0       	rjmp	.+2      	; 0x2554 <_Z20synta_recieveCommandPcc+0x7e>
    return -1;
    2552:	80 e0       	ldi	r24, 0x00	; 0
}
    2554:	df 91       	pop	r29
    2556:	cf 91       	pop	r28
    2558:	08 95       	ret

0000255a <_Z22synta_assembleResponsePccm>:
inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
}

void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData){
    255a:	ff 92       	push	r15
    255c:	0f 93       	push	r16
    255e:	1f 93       	push	r17
    2560:	cf 93       	push	r28
    2562:	df 93       	push	r29
    2564:	ec 01       	movw	r28, r24
    2566:	12 2f       	mov	r17, r18
    2568:	03 2f       	mov	r16, r19
    256a:	f4 2e       	mov	r15, r20
    char replyLength = (commandOrError == '\0') ? -1 : Commands_getLength(commandOrError,0); //get the number of data bytes for response
    256c:	66 23       	and	r22, r22
    256e:	39 f0       	breq	.+14     	; 0x257e <_Z22synta_assembleResponsePccm+0x24>
    2570:	86 2f       	mov	r24, r22
    2572:	60 e0       	ldi	r22, 0x00	; 0
    2574:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <_Z18Commands_getLengthcb>
    2578:	98 2f       	mov	r25, r24

    if (replyLength < 0) {
    257a:	87 ff       	sbrs	r24, 7
    257c:	04 c0       	rjmp	.+8      	; 0x2586 <_Z22synta_assembleResponsePccm+0x2c>
        replyLength = 0;
        dataPacket[0] = errorChar;  
    257e:	81 e2       	ldi	r24, 0x21	; 33
    2580:	88 83       	st	Y, r24
    2582:	90 e0       	ldi	r25, 0x00	; 0
    2584:	4e c0       	rjmp	.+156    	; 0x2622 <_Z22synta_assembleResponsePccm+0xc8>
    } else {
        dataPacket[0] = startOutChar;
    2586:	8d e3       	ldi	r24, 0x3D	; 61
    2588:	88 83       	st	Y, r24

        if (replyLength == 2) {
    258a:	92 30       	cpi	r25, 0x02	; 2
    258c:	d9 f1       	breq	.+118    	; 0x2604 <_Z22synta_assembleResponsePccm+0xaa>
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
    258e:	93 30       	cpi	r25, 0x03	; 3
    2590:	c9 f4       	brne	.+50     	; 0x25c4 <_Z22synta_assembleResponsePccm+0x6a>
            DoubleNibbler nibble = { responseData };
    2592:	21 2f       	mov	r18, r17
    2594:	30 2f       	mov	r19, r16
            nibbleToHex(dataPacket+3, nibble.low);
    2596:	81 2f       	mov	r24, r17
    2598:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    259a:	8a 30       	cpi	r24, 0x0A	; 10
    259c:	08 f0       	brcs	.+2      	; 0x25a0 <_Z22synta_assembleResponsePccm+0x46>
        nibble += (('A'-'0')-0xA);
    259e:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    25a0:	80 5d       	subi	r24, 0xD0	; 208
    25a2:	8b 83       	std	Y+3, r24	; 0x03
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
    25a4:	82 2f       	mov	r24, r18
    25a6:	82 95       	swap	r24
    25a8:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    25aa:	8a 30       	cpi	r24, 0x0A	; 10
    25ac:	08 f0       	brcs	.+2      	; 0x25b0 <_Z22synta_assembleResponsePccm+0x56>
        nibble += (('A'-'0')-0xA);
    25ae:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    25b0:	80 5d       	subi	r24, 0xD0	; 208
    25b2:	8a 83       	std	Y+2, r24	; 0x02
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
    25b4:	83 2f       	mov	r24, r19
    25b6:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    25b8:	8a 30       	cpi	r24, 0x0A	; 10
    25ba:	08 f0       	brcs	.+2      	; 0x25be <_Z22synta_assembleResponsePccm+0x64>
        nibble += (('A'-'0')-0xA);
    25bc:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    25be:	80 5d       	subi	r24, 0xD0	; 208
    25c0:	89 83       	std	Y+1, r24	; 0x01
    25c2:	2f c0       	rjmp	.+94     	; 0x2622 <_Z22synta_assembleResponsePccm+0xc8>
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
        } else if (replyLength == 6) {
    25c4:	96 30       	cpi	r25, 0x06	; 6
    25c6:	69 f5       	brne	.+90     	; 0x2622 <_Z22synta_assembleResponsePccm+0xc8>
    }
    *hex = (nibble + '0');
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    25c8:	8f 2d       	mov	r24, r15
    25ca:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    25cc:	8a 30       	cpi	r24, 0x0A	; 10
    25ce:	08 f0       	brcs	.+2      	; 0x25d2 <_Z22synta_assembleResponsePccm+0x78>
        nibble += (('A'-'0')-0xA);
    25d0:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    25d2:	80 5d       	subi	r24, 0xD0	; 208
    25d4:	8e 83       	std	Y+6, r24	; 0x06
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    25d6:	4f 2d       	mov	r20, r15
    25d8:	42 95       	swap	r20
    25da:	4f 70       	andi	r20, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    25dc:	4a 30       	cpi	r20, 0x0A	; 10
    25de:	08 f0       	brcs	.+2      	; 0x25e2 <_Z22synta_assembleResponsePccm+0x88>
        nibble += (('A'-'0')-0xA);
    25e0:	49 5f       	subi	r20, 0xF9	; 249
    }
    *hex = (nibble + '0');
    25e2:	40 5d       	subi	r20, 0xD0	; 208
    25e4:	4d 83       	std	Y+5, r20	; 0x05
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    25e6:	80 2f       	mov	r24, r16
    25e8:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    25ea:	8a 30       	cpi	r24, 0x0A	; 10
    25ec:	08 f0       	brcs	.+2      	; 0x25f0 <_Z22synta_assembleResponsePccm+0x96>
        nibble += (('A'-'0')-0xA);
    25ee:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    25f0:	80 5d       	subi	r24, 0xD0	; 208
    25f2:	8c 83       	std	Y+4, r24	; 0x04
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    25f4:	30 2f       	mov	r19, r16
    25f6:	32 95       	swap	r19
    25f8:	3f 70       	andi	r19, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    25fa:	3a 30       	cpi	r19, 0x0A	; 10
    25fc:	08 f0       	brcs	.+2      	; 0x2600 <_Z22synta_assembleResponsePccm+0xa6>
        nibble += (('A'-'0')-0xA);
    25fe:	39 5f       	subi	r19, 0xF9	; 249
    }
    *hex = (nibble + '0');
    2600:	30 5d       	subi	r19, 0xD0	; 208
    2602:	3b 83       	std	Y+3, r19	; 0x03
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    2604:	81 2f       	mov	r24, r17
    2606:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2608:	8a 30       	cpi	r24, 0x0A	; 10
    260a:	08 f0       	brcs	.+2      	; 0x260e <_Z22synta_assembleResponsePccm+0xb4>
        nibble += (('A'-'0')-0xA);
    260c:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    260e:	80 5d       	subi	r24, 0xD0	; 208
    2610:	8a 83       	std	Y+2, r24	; 0x02
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    2612:	21 2f       	mov	r18, r17
    2614:	22 95       	swap	r18
    2616:	2f 70       	andi	r18, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2618:	2a 30       	cpi	r18, 0x0A	; 10
    261a:	08 f0       	brcs	.+2      	; 0x261e <_Z22synta_assembleResponsePccm+0xc4>
        nibble += (('A'-'0')-0xA);
    261c:	29 5f       	subi	r18, 0xF9	; 249
    }
    *hex = (nibble + '0');
    261e:	20 5d       	subi	r18, 0xD0	; 208
    2620:	29 83       	std	Y+1, r18	; 0x01
            private_byteToHex(dataPacket+2,dataPacket+1,inter.lowByter.lowNibbler);
        }

    }

    dataPacket[(byte)replyLength + 1] = endChar;
    2622:	fe 01       	movw	r30, r28
    2624:	e9 0f       	add	r30, r25
    2626:	f1 1d       	adc	r31, r1
    2628:	8d e0       	ldi	r24, 0x0D	; 13
    262a:	81 83       	std	Z+1, r24	; 0x01
    dataPacket[(byte)replyLength + 2] = '\0';  
    262c:	12 82       	std	Z+2, r1	; 0x02
    return;
}
    262e:	df 91       	pop	r29
    2630:	cf 91       	pop	r28
    2632:	1f 91       	pop	r17
    2634:	0f 91       	pop	r16
    2636:	ff 90       	pop	r15
    2638:	08 95       	ret

0000263a <_Z16synta_initialisemh>:

byte _axis;
char _command;

void synta_initialise(unsigned long eVal, byte gVal){
    validPacket = 0;
    263a:	10 92 42 04 	sts	0x0442, r1
    commandIndex = 0;
    263e:	10 92 4e 04 	sts	0x044E, r1
    memset(commandString,0,sizeof(commandString));
    2642:	2b e0       	ldi	r18, 0x0B	; 11
    2644:	e3 e4       	ldi	r30, 0x43	; 67
    2646:	f4 e0       	ldi	r31, 0x04	; 4
    2648:	df 01       	movw	r26, r30
    264a:	1d 92       	st	X+, r1
    264c:	2a 95       	dec	r18
    264e:	e9 f7       	brne	.-6      	; 0x264a <_Z16synta_initialisemh+0x10>
    _axis = 0;
    2650:	10 92 4f 04 	sts	0x044F, r1
    Commands_init(eVal, gVal);
    2654:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <_Z13Commands_initmh>
}
    2658:	08 95       	ret

0000265a <__subsf3>:
    265a:	50 58       	subi	r21, 0x80	; 128

0000265c <__addsf3>:
    265c:	bb 27       	eor	r27, r27
    265e:	aa 27       	eor	r26, r26
    2660:	0e d0       	rcall	.+28     	; 0x267e <__addsf3x>
    2662:	86 c1       	rjmp	.+780    	; 0x2970 <__fp_round>
    2664:	77 d1       	rcall	.+750    	; 0x2954 <__fp_pscA>
    2666:	30 f0       	brcs	.+12     	; 0x2674 <__addsf3+0x18>
    2668:	7c d1       	rcall	.+760    	; 0x2962 <__fp_pscB>
    266a:	20 f0       	brcs	.+8      	; 0x2674 <__addsf3+0x18>
    266c:	31 f4       	brne	.+12     	; 0x267a <__addsf3+0x1e>
    266e:	9f 3f       	cpi	r25, 0xFF	; 255
    2670:	11 f4       	brne	.+4      	; 0x2676 <__addsf3+0x1a>
    2672:	1e f4       	brtc	.+6      	; 0x267a <__addsf3+0x1e>
    2674:	6c c1       	rjmp	.+728    	; 0x294e <__fp_nan>
    2676:	0e f4       	brtc	.+2      	; 0x267a <__addsf3+0x1e>
    2678:	e0 95       	com	r30
    267a:	e7 fb       	bst	r30, 7
    267c:	37 c1       	rjmp	.+622    	; 0x28ec <__fp_inf>

0000267e <__addsf3x>:
    267e:	e9 2f       	mov	r30, r25
    2680:	88 d1       	rcall	.+784    	; 0x2992 <__fp_split3>
    2682:	80 f3       	brcs	.-32     	; 0x2664 <__addsf3+0x8>
    2684:	ba 17       	cp	r27, r26
    2686:	62 07       	cpc	r22, r18
    2688:	73 07       	cpc	r23, r19
    268a:	84 07       	cpc	r24, r20
    268c:	95 07       	cpc	r25, r21
    268e:	18 f0       	brcs	.+6      	; 0x2696 <__addsf3x+0x18>
    2690:	71 f4       	brne	.+28     	; 0x26ae <__addsf3x+0x30>
    2692:	9e f5       	brtc	.+102    	; 0x26fa <__addsf3x+0x7c>
    2694:	b7 c1       	rjmp	.+878    	; 0x2a04 <__fp_zero>
    2696:	0e f4       	brtc	.+2      	; 0x269a <__addsf3x+0x1c>
    2698:	e0 95       	com	r30
    269a:	0b 2e       	mov	r0, r27
    269c:	ba 2f       	mov	r27, r26
    269e:	a0 2d       	mov	r26, r0
    26a0:	0b 01       	movw	r0, r22
    26a2:	b9 01       	movw	r22, r18
    26a4:	90 01       	movw	r18, r0
    26a6:	0c 01       	movw	r0, r24
    26a8:	ca 01       	movw	r24, r20
    26aa:	a0 01       	movw	r20, r0
    26ac:	11 24       	eor	r1, r1
    26ae:	ff 27       	eor	r31, r31
    26b0:	59 1b       	sub	r21, r25
    26b2:	99 f0       	breq	.+38     	; 0x26da <__addsf3x+0x5c>
    26b4:	59 3f       	cpi	r21, 0xF9	; 249
    26b6:	50 f4       	brcc	.+20     	; 0x26cc <__addsf3x+0x4e>
    26b8:	50 3e       	cpi	r21, 0xE0	; 224
    26ba:	68 f1       	brcs	.+90     	; 0x2716 <__addsf3x+0x98>
    26bc:	1a 16       	cp	r1, r26
    26be:	f0 40       	sbci	r31, 0x00	; 0
    26c0:	a2 2f       	mov	r26, r18
    26c2:	23 2f       	mov	r18, r19
    26c4:	34 2f       	mov	r19, r20
    26c6:	44 27       	eor	r20, r20
    26c8:	58 5f       	subi	r21, 0xF8	; 248
    26ca:	f3 cf       	rjmp	.-26     	; 0x26b2 <__addsf3x+0x34>
    26cc:	46 95       	lsr	r20
    26ce:	37 95       	ror	r19
    26d0:	27 95       	ror	r18
    26d2:	a7 95       	ror	r26
    26d4:	f0 40       	sbci	r31, 0x00	; 0
    26d6:	53 95       	inc	r21
    26d8:	c9 f7       	brne	.-14     	; 0x26cc <__addsf3x+0x4e>
    26da:	7e f4       	brtc	.+30     	; 0x26fa <__addsf3x+0x7c>
    26dc:	1f 16       	cp	r1, r31
    26de:	ba 0b       	sbc	r27, r26
    26e0:	62 0b       	sbc	r22, r18
    26e2:	73 0b       	sbc	r23, r19
    26e4:	84 0b       	sbc	r24, r20
    26e6:	ba f0       	brmi	.+46     	; 0x2716 <__addsf3x+0x98>
    26e8:	91 50       	subi	r25, 0x01	; 1
    26ea:	a1 f0       	breq	.+40     	; 0x2714 <__addsf3x+0x96>
    26ec:	ff 0f       	add	r31, r31
    26ee:	bb 1f       	adc	r27, r27
    26f0:	66 1f       	adc	r22, r22
    26f2:	77 1f       	adc	r23, r23
    26f4:	88 1f       	adc	r24, r24
    26f6:	c2 f7       	brpl	.-16     	; 0x26e8 <__addsf3x+0x6a>
    26f8:	0e c0       	rjmp	.+28     	; 0x2716 <__addsf3x+0x98>
    26fa:	ba 0f       	add	r27, r26
    26fc:	62 1f       	adc	r22, r18
    26fe:	73 1f       	adc	r23, r19
    2700:	84 1f       	adc	r24, r20
    2702:	48 f4       	brcc	.+18     	; 0x2716 <__addsf3x+0x98>
    2704:	87 95       	ror	r24
    2706:	77 95       	ror	r23
    2708:	67 95       	ror	r22
    270a:	b7 95       	ror	r27
    270c:	f7 95       	ror	r31
    270e:	9e 3f       	cpi	r25, 0xFE	; 254
    2710:	08 f0       	brcs	.+2      	; 0x2714 <__addsf3x+0x96>
    2712:	b3 cf       	rjmp	.-154    	; 0x267a <__addsf3+0x1e>
    2714:	93 95       	inc	r25
    2716:	88 0f       	add	r24, r24
    2718:	08 f0       	brcs	.+2      	; 0x271c <__addsf3x+0x9e>
    271a:	99 27       	eor	r25, r25
    271c:	ee 0f       	add	r30, r30
    271e:	97 95       	ror	r25
    2720:	87 95       	ror	r24
    2722:	08 95       	ret

00002724 <ceil>:
    2724:	58 d1       	rcall	.+688    	; 0x29d6 <__fp_trunc>
    2726:	80 f0       	brcs	.+32     	; 0x2748 <ceil+0x24>
    2728:	9f 37       	cpi	r25, 0x7F	; 127
    272a:	40 f4       	brcc	.+16     	; 0x273c <ceil+0x18>
    272c:	91 11       	cpse	r25, r1
    272e:	0e f4       	brtc	.+2      	; 0x2732 <ceil+0xe>
    2730:	6a c1       	rjmp	.+724    	; 0x2a06 <__fp_szero>
    2732:	60 e0       	ldi	r22, 0x00	; 0
    2734:	70 e0       	ldi	r23, 0x00	; 0
    2736:	80 e8       	ldi	r24, 0x80	; 128
    2738:	9f e3       	ldi	r25, 0x3F	; 63
    273a:	08 95       	ret
    273c:	26 f0       	brts	.+8      	; 0x2746 <ceil+0x22>
    273e:	1b 16       	cp	r1, r27
    2740:	61 1d       	adc	r22, r1
    2742:	71 1d       	adc	r23, r1
    2744:	81 1d       	adc	r24, r1
    2746:	d8 c0       	rjmp	.+432    	; 0x28f8 <__fp_mintl>
    2748:	f2 c0       	rjmp	.+484    	; 0x292e <__fp_mpack>

0000274a <__divsf3>:
    274a:	0c d0       	rcall	.+24     	; 0x2764 <__divsf3x>
    274c:	11 c1       	rjmp	.+546    	; 0x2970 <__fp_round>
    274e:	09 d1       	rcall	.+530    	; 0x2962 <__fp_pscB>
    2750:	40 f0       	brcs	.+16     	; 0x2762 <__divsf3+0x18>
    2752:	00 d1       	rcall	.+512    	; 0x2954 <__fp_pscA>
    2754:	30 f0       	brcs	.+12     	; 0x2762 <__divsf3+0x18>
    2756:	21 f4       	brne	.+8      	; 0x2760 <__divsf3+0x16>
    2758:	5f 3f       	cpi	r21, 0xFF	; 255
    275a:	19 f0       	breq	.+6      	; 0x2762 <__divsf3+0x18>
    275c:	c7 c0       	rjmp	.+398    	; 0x28ec <__fp_inf>
    275e:	51 11       	cpse	r21, r1
    2760:	52 c1       	rjmp	.+676    	; 0x2a06 <__fp_szero>
    2762:	f5 c0       	rjmp	.+490    	; 0x294e <__fp_nan>

00002764 <__divsf3x>:
    2764:	16 d1       	rcall	.+556    	; 0x2992 <__fp_split3>
    2766:	98 f3       	brcs	.-26     	; 0x274e <__divsf3+0x4>

00002768 <__divsf3_pse>:
    2768:	99 23       	and	r25, r25
    276a:	c9 f3       	breq	.-14     	; 0x275e <__divsf3+0x14>
    276c:	55 23       	and	r21, r21
    276e:	b1 f3       	breq	.-20     	; 0x275c <__divsf3+0x12>
    2770:	95 1b       	sub	r25, r21
    2772:	55 0b       	sbc	r21, r21
    2774:	bb 27       	eor	r27, r27
    2776:	aa 27       	eor	r26, r26
    2778:	62 17       	cp	r22, r18
    277a:	73 07       	cpc	r23, r19
    277c:	84 07       	cpc	r24, r20
    277e:	38 f0       	brcs	.+14     	; 0x278e <__divsf3_pse+0x26>
    2780:	9f 5f       	subi	r25, 0xFF	; 255
    2782:	5f 4f       	sbci	r21, 0xFF	; 255
    2784:	22 0f       	add	r18, r18
    2786:	33 1f       	adc	r19, r19
    2788:	44 1f       	adc	r20, r20
    278a:	aa 1f       	adc	r26, r26
    278c:	a9 f3       	breq	.-22     	; 0x2778 <__divsf3_pse+0x10>
    278e:	33 d0       	rcall	.+102    	; 0x27f6 <__divsf3_pse+0x8e>
    2790:	0e 2e       	mov	r0, r30
    2792:	3a f0       	brmi	.+14     	; 0x27a2 <__divsf3_pse+0x3a>
    2794:	e0 e8       	ldi	r30, 0x80	; 128
    2796:	30 d0       	rcall	.+96     	; 0x27f8 <__divsf3_pse+0x90>
    2798:	91 50       	subi	r25, 0x01	; 1
    279a:	50 40       	sbci	r21, 0x00	; 0
    279c:	e6 95       	lsr	r30
    279e:	00 1c       	adc	r0, r0
    27a0:	ca f7       	brpl	.-14     	; 0x2794 <__divsf3_pse+0x2c>
    27a2:	29 d0       	rcall	.+82     	; 0x27f6 <__divsf3_pse+0x8e>
    27a4:	fe 2f       	mov	r31, r30
    27a6:	27 d0       	rcall	.+78     	; 0x27f6 <__divsf3_pse+0x8e>
    27a8:	66 0f       	add	r22, r22
    27aa:	77 1f       	adc	r23, r23
    27ac:	88 1f       	adc	r24, r24
    27ae:	bb 1f       	adc	r27, r27
    27b0:	26 17       	cp	r18, r22
    27b2:	37 07       	cpc	r19, r23
    27b4:	48 07       	cpc	r20, r24
    27b6:	ab 07       	cpc	r26, r27
    27b8:	b0 e8       	ldi	r27, 0x80	; 128
    27ba:	09 f0       	breq	.+2      	; 0x27be <__divsf3_pse+0x56>
    27bc:	bb 0b       	sbc	r27, r27
    27be:	80 2d       	mov	r24, r0
    27c0:	bf 01       	movw	r22, r30
    27c2:	ff 27       	eor	r31, r31
    27c4:	93 58       	subi	r25, 0x83	; 131
    27c6:	5f 4f       	sbci	r21, 0xFF	; 255
    27c8:	2a f0       	brmi	.+10     	; 0x27d4 <__divsf3_pse+0x6c>
    27ca:	9e 3f       	cpi	r25, 0xFE	; 254
    27cc:	51 05       	cpc	r21, r1
    27ce:	68 f0       	brcs	.+26     	; 0x27ea <__divsf3_pse+0x82>
    27d0:	8d c0       	rjmp	.+282    	; 0x28ec <__fp_inf>
    27d2:	19 c1       	rjmp	.+562    	; 0x2a06 <__fp_szero>
    27d4:	5f 3f       	cpi	r21, 0xFF	; 255
    27d6:	ec f3       	brlt	.-6      	; 0x27d2 <__divsf3_pse+0x6a>
    27d8:	98 3e       	cpi	r25, 0xE8	; 232
    27da:	dc f3       	brlt	.-10     	; 0x27d2 <__divsf3_pse+0x6a>
    27dc:	86 95       	lsr	r24
    27de:	77 95       	ror	r23
    27e0:	67 95       	ror	r22
    27e2:	b7 95       	ror	r27
    27e4:	f7 95       	ror	r31
    27e6:	9f 5f       	subi	r25, 0xFF	; 255
    27e8:	c9 f7       	brne	.-14     	; 0x27dc <__divsf3_pse+0x74>
    27ea:	88 0f       	add	r24, r24
    27ec:	91 1d       	adc	r25, r1
    27ee:	96 95       	lsr	r25
    27f0:	87 95       	ror	r24
    27f2:	97 f9       	bld	r25, 7
    27f4:	08 95       	ret
    27f6:	e1 e0       	ldi	r30, 0x01	; 1
    27f8:	66 0f       	add	r22, r22
    27fa:	77 1f       	adc	r23, r23
    27fc:	88 1f       	adc	r24, r24
    27fe:	bb 1f       	adc	r27, r27
    2800:	62 17       	cp	r22, r18
    2802:	73 07       	cpc	r23, r19
    2804:	84 07       	cpc	r24, r20
    2806:	ba 07       	cpc	r27, r26
    2808:	20 f0       	brcs	.+8      	; 0x2812 <__divsf3_pse+0xaa>
    280a:	62 1b       	sub	r22, r18
    280c:	73 0b       	sbc	r23, r19
    280e:	84 0b       	sbc	r24, r20
    2810:	ba 0b       	sbc	r27, r26
    2812:	ee 1f       	adc	r30, r30
    2814:	88 f7       	brcc	.-30     	; 0x27f8 <__divsf3_pse+0x90>
    2816:	e0 95       	com	r30
    2818:	08 95       	ret

0000281a <__fixunssfsi>:
    281a:	c3 d0       	rcall	.+390    	; 0x29a2 <__fp_splitA>
    281c:	88 f0       	brcs	.+34     	; 0x2840 <__fixunssfsi+0x26>
    281e:	9f 57       	subi	r25, 0x7F	; 127
    2820:	90 f0       	brcs	.+36     	; 0x2846 <__fixunssfsi+0x2c>
    2822:	b9 2f       	mov	r27, r25
    2824:	99 27       	eor	r25, r25
    2826:	b7 51       	subi	r27, 0x17	; 23
    2828:	a0 f0       	brcs	.+40     	; 0x2852 <__fixunssfsi+0x38>
    282a:	d1 f0       	breq	.+52     	; 0x2860 <__fixunssfsi+0x46>
    282c:	66 0f       	add	r22, r22
    282e:	77 1f       	adc	r23, r23
    2830:	88 1f       	adc	r24, r24
    2832:	99 1f       	adc	r25, r25
    2834:	1a f0       	brmi	.+6      	; 0x283c <__fixunssfsi+0x22>
    2836:	ba 95       	dec	r27
    2838:	c9 f7       	brne	.-14     	; 0x282c <__fixunssfsi+0x12>
    283a:	12 c0       	rjmp	.+36     	; 0x2860 <__fixunssfsi+0x46>
    283c:	b1 30       	cpi	r27, 0x01	; 1
    283e:	81 f0       	breq	.+32     	; 0x2860 <__fixunssfsi+0x46>
    2840:	e1 d0       	rcall	.+450    	; 0x2a04 <__fp_zero>
    2842:	b1 e0       	ldi	r27, 0x01	; 1
    2844:	08 95       	ret
    2846:	de c0       	rjmp	.+444    	; 0x2a04 <__fp_zero>
    2848:	67 2f       	mov	r22, r23
    284a:	78 2f       	mov	r23, r24
    284c:	88 27       	eor	r24, r24
    284e:	b8 5f       	subi	r27, 0xF8	; 248
    2850:	39 f0       	breq	.+14     	; 0x2860 <__fixunssfsi+0x46>
    2852:	b9 3f       	cpi	r27, 0xF9	; 249
    2854:	cc f3       	brlt	.-14     	; 0x2848 <__fixunssfsi+0x2e>
    2856:	86 95       	lsr	r24
    2858:	77 95       	ror	r23
    285a:	67 95       	ror	r22
    285c:	b3 95       	inc	r27
    285e:	d9 f7       	brne	.-10     	; 0x2856 <__fixunssfsi+0x3c>
    2860:	3e f4       	brtc	.+14     	; 0x2870 <__fixunssfsi+0x56>
    2862:	90 95       	com	r25
    2864:	80 95       	com	r24
    2866:	70 95       	com	r23
    2868:	61 95       	neg	r22
    286a:	7f 4f       	sbci	r23, 0xFF	; 255
    286c:	8f 4f       	sbci	r24, 0xFF	; 255
    286e:	9f 4f       	sbci	r25, 0xFF	; 255
    2870:	08 95       	ret

00002872 <__floatunsisf>:
    2872:	e8 94       	clt
    2874:	09 c0       	rjmp	.+18     	; 0x2888 <__floatsisf+0x12>

00002876 <__floatsisf>:
    2876:	97 fb       	bst	r25, 7
    2878:	3e f4       	brtc	.+14     	; 0x2888 <__floatsisf+0x12>
    287a:	90 95       	com	r25
    287c:	80 95       	com	r24
    287e:	70 95       	com	r23
    2880:	61 95       	neg	r22
    2882:	7f 4f       	sbci	r23, 0xFF	; 255
    2884:	8f 4f       	sbci	r24, 0xFF	; 255
    2886:	9f 4f       	sbci	r25, 0xFF	; 255
    2888:	99 23       	and	r25, r25
    288a:	a9 f0       	breq	.+42     	; 0x28b6 <__floatsisf+0x40>
    288c:	f9 2f       	mov	r31, r25
    288e:	96 e9       	ldi	r25, 0x96	; 150
    2890:	bb 27       	eor	r27, r27
    2892:	93 95       	inc	r25
    2894:	f6 95       	lsr	r31
    2896:	87 95       	ror	r24
    2898:	77 95       	ror	r23
    289a:	67 95       	ror	r22
    289c:	b7 95       	ror	r27
    289e:	f1 11       	cpse	r31, r1
    28a0:	f8 cf       	rjmp	.-16     	; 0x2892 <__floatsisf+0x1c>
    28a2:	fa f4       	brpl	.+62     	; 0x28e2 <__floatsisf+0x6c>
    28a4:	bb 0f       	add	r27, r27
    28a6:	11 f4       	brne	.+4      	; 0x28ac <__floatsisf+0x36>
    28a8:	60 ff       	sbrs	r22, 0
    28aa:	1b c0       	rjmp	.+54     	; 0x28e2 <__floatsisf+0x6c>
    28ac:	6f 5f       	subi	r22, 0xFF	; 255
    28ae:	7f 4f       	sbci	r23, 0xFF	; 255
    28b0:	8f 4f       	sbci	r24, 0xFF	; 255
    28b2:	9f 4f       	sbci	r25, 0xFF	; 255
    28b4:	16 c0       	rjmp	.+44     	; 0x28e2 <__floatsisf+0x6c>
    28b6:	88 23       	and	r24, r24
    28b8:	11 f0       	breq	.+4      	; 0x28be <__floatsisf+0x48>
    28ba:	96 e9       	ldi	r25, 0x96	; 150
    28bc:	11 c0       	rjmp	.+34     	; 0x28e0 <__floatsisf+0x6a>
    28be:	77 23       	and	r23, r23
    28c0:	21 f0       	breq	.+8      	; 0x28ca <__floatsisf+0x54>
    28c2:	9e e8       	ldi	r25, 0x8E	; 142
    28c4:	87 2f       	mov	r24, r23
    28c6:	76 2f       	mov	r23, r22
    28c8:	05 c0       	rjmp	.+10     	; 0x28d4 <__floatsisf+0x5e>
    28ca:	66 23       	and	r22, r22
    28cc:	71 f0       	breq	.+28     	; 0x28ea <__floatsisf+0x74>
    28ce:	96 e8       	ldi	r25, 0x86	; 134
    28d0:	86 2f       	mov	r24, r22
    28d2:	70 e0       	ldi	r23, 0x00	; 0
    28d4:	60 e0       	ldi	r22, 0x00	; 0
    28d6:	2a f0       	brmi	.+10     	; 0x28e2 <__floatsisf+0x6c>
    28d8:	9a 95       	dec	r25
    28da:	66 0f       	add	r22, r22
    28dc:	77 1f       	adc	r23, r23
    28de:	88 1f       	adc	r24, r24
    28e0:	da f7       	brpl	.-10     	; 0x28d8 <__floatsisf+0x62>
    28e2:	88 0f       	add	r24, r24
    28e4:	96 95       	lsr	r25
    28e6:	87 95       	ror	r24
    28e8:	97 f9       	bld	r25, 7
    28ea:	08 95       	ret

000028ec <__fp_inf>:
    28ec:	97 f9       	bld	r25, 7
    28ee:	9f 67       	ori	r25, 0x7F	; 127
    28f0:	80 e8       	ldi	r24, 0x80	; 128
    28f2:	70 e0       	ldi	r23, 0x00	; 0
    28f4:	60 e0       	ldi	r22, 0x00	; 0
    28f6:	08 95       	ret

000028f8 <__fp_mintl>:
    28f8:	88 23       	and	r24, r24
    28fa:	71 f4       	brne	.+28     	; 0x2918 <__fp_mintl+0x20>
    28fc:	77 23       	and	r23, r23
    28fe:	21 f0       	breq	.+8      	; 0x2908 <__fp_mintl+0x10>
    2900:	98 50       	subi	r25, 0x08	; 8
    2902:	87 2b       	or	r24, r23
    2904:	76 2f       	mov	r23, r22
    2906:	07 c0       	rjmp	.+14     	; 0x2916 <__fp_mintl+0x1e>
    2908:	66 23       	and	r22, r22
    290a:	11 f4       	brne	.+4      	; 0x2910 <__fp_mintl+0x18>
    290c:	99 27       	eor	r25, r25
    290e:	0d c0       	rjmp	.+26     	; 0x292a <__fp_mintl+0x32>
    2910:	90 51       	subi	r25, 0x10	; 16
    2912:	86 2b       	or	r24, r22
    2914:	70 e0       	ldi	r23, 0x00	; 0
    2916:	60 e0       	ldi	r22, 0x00	; 0
    2918:	2a f0       	brmi	.+10     	; 0x2924 <__fp_mintl+0x2c>
    291a:	9a 95       	dec	r25
    291c:	66 0f       	add	r22, r22
    291e:	77 1f       	adc	r23, r23
    2920:	88 1f       	adc	r24, r24
    2922:	da f7       	brpl	.-10     	; 0x291a <__fp_mintl+0x22>
    2924:	88 0f       	add	r24, r24
    2926:	96 95       	lsr	r25
    2928:	87 95       	ror	r24
    292a:	97 f9       	bld	r25, 7
    292c:	08 95       	ret

0000292e <__fp_mpack>:
    292e:	9f 3f       	cpi	r25, 0xFF	; 255
    2930:	49 f0       	breq	.+18     	; 0x2944 <__fp_mpack+0x16>
    2932:	91 50       	subi	r25, 0x01	; 1
    2934:	28 f4       	brcc	.+10     	; 0x2940 <__fp_mpack+0x12>
    2936:	86 95       	lsr	r24
    2938:	77 95       	ror	r23
    293a:	67 95       	ror	r22
    293c:	b7 95       	ror	r27
    293e:	9f 5f       	subi	r25, 0xFF	; 255
    2940:	80 38       	cpi	r24, 0x80	; 128
    2942:	9f 4f       	sbci	r25, 0xFF	; 255
    2944:	88 0f       	add	r24, r24
    2946:	96 95       	lsr	r25
    2948:	87 95       	ror	r24
    294a:	97 f9       	bld	r25, 7
    294c:	08 95       	ret

0000294e <__fp_nan>:
    294e:	9f ef       	ldi	r25, 0xFF	; 255
    2950:	80 ec       	ldi	r24, 0xC0	; 192
    2952:	08 95       	ret

00002954 <__fp_pscA>:
    2954:	00 24       	eor	r0, r0
    2956:	0a 94       	dec	r0
    2958:	16 16       	cp	r1, r22
    295a:	17 06       	cpc	r1, r23
    295c:	18 06       	cpc	r1, r24
    295e:	09 06       	cpc	r0, r25
    2960:	08 95       	ret

00002962 <__fp_pscB>:
    2962:	00 24       	eor	r0, r0
    2964:	0a 94       	dec	r0
    2966:	12 16       	cp	r1, r18
    2968:	13 06       	cpc	r1, r19
    296a:	14 06       	cpc	r1, r20
    296c:	05 06       	cpc	r0, r21
    296e:	08 95       	ret

00002970 <__fp_round>:
    2970:	09 2e       	mov	r0, r25
    2972:	03 94       	inc	r0
    2974:	00 0c       	add	r0, r0
    2976:	11 f4       	brne	.+4      	; 0x297c <__fp_round+0xc>
    2978:	88 23       	and	r24, r24
    297a:	52 f0       	brmi	.+20     	; 0x2990 <__fp_round+0x20>
    297c:	bb 0f       	add	r27, r27
    297e:	40 f4       	brcc	.+16     	; 0x2990 <__fp_round+0x20>
    2980:	bf 2b       	or	r27, r31
    2982:	11 f4       	brne	.+4      	; 0x2988 <__fp_round+0x18>
    2984:	60 ff       	sbrs	r22, 0
    2986:	04 c0       	rjmp	.+8      	; 0x2990 <__fp_round+0x20>
    2988:	6f 5f       	subi	r22, 0xFF	; 255
    298a:	7f 4f       	sbci	r23, 0xFF	; 255
    298c:	8f 4f       	sbci	r24, 0xFF	; 255
    298e:	9f 4f       	sbci	r25, 0xFF	; 255
    2990:	08 95       	ret

00002992 <__fp_split3>:
    2992:	57 fd       	sbrc	r21, 7
    2994:	90 58       	subi	r25, 0x80	; 128
    2996:	44 0f       	add	r20, r20
    2998:	55 1f       	adc	r21, r21
    299a:	59 f0       	breq	.+22     	; 0x29b2 <__fp_splitA+0x10>
    299c:	5f 3f       	cpi	r21, 0xFF	; 255
    299e:	71 f0       	breq	.+28     	; 0x29bc <__fp_splitA+0x1a>
    29a0:	47 95       	ror	r20

000029a2 <__fp_splitA>:
    29a2:	88 0f       	add	r24, r24
    29a4:	97 fb       	bst	r25, 7
    29a6:	99 1f       	adc	r25, r25
    29a8:	61 f0       	breq	.+24     	; 0x29c2 <__fp_splitA+0x20>
    29aa:	9f 3f       	cpi	r25, 0xFF	; 255
    29ac:	79 f0       	breq	.+30     	; 0x29cc <__fp_splitA+0x2a>
    29ae:	87 95       	ror	r24
    29b0:	08 95       	ret
    29b2:	12 16       	cp	r1, r18
    29b4:	13 06       	cpc	r1, r19
    29b6:	14 06       	cpc	r1, r20
    29b8:	55 1f       	adc	r21, r21
    29ba:	f2 cf       	rjmp	.-28     	; 0x29a0 <__fp_split3+0xe>
    29bc:	46 95       	lsr	r20
    29be:	f1 df       	rcall	.-30     	; 0x29a2 <__fp_splitA>
    29c0:	08 c0       	rjmp	.+16     	; 0x29d2 <__fp_splitA+0x30>
    29c2:	16 16       	cp	r1, r22
    29c4:	17 06       	cpc	r1, r23
    29c6:	18 06       	cpc	r1, r24
    29c8:	99 1f       	adc	r25, r25
    29ca:	f1 cf       	rjmp	.-30     	; 0x29ae <__fp_splitA+0xc>
    29cc:	86 95       	lsr	r24
    29ce:	71 05       	cpc	r23, r1
    29d0:	61 05       	cpc	r22, r1
    29d2:	08 94       	sec
    29d4:	08 95       	ret

000029d6 <__fp_trunc>:
    29d6:	e5 df       	rcall	.-54     	; 0x29a2 <__fp_splitA>
    29d8:	a0 f0       	brcs	.+40     	; 0x2a02 <__fp_trunc+0x2c>
    29da:	be e7       	ldi	r27, 0x7E	; 126
    29dc:	b9 17       	cp	r27, r25
    29de:	88 f4       	brcc	.+34     	; 0x2a02 <__fp_trunc+0x2c>
    29e0:	bb 27       	eor	r27, r27
    29e2:	9f 38       	cpi	r25, 0x8F	; 143
    29e4:	60 f4       	brcc	.+24     	; 0x29fe <__fp_trunc+0x28>
    29e6:	16 16       	cp	r1, r22
    29e8:	b1 1d       	adc	r27, r1
    29ea:	67 2f       	mov	r22, r23
    29ec:	78 2f       	mov	r23, r24
    29ee:	88 27       	eor	r24, r24
    29f0:	98 5f       	subi	r25, 0xF8	; 248
    29f2:	f7 cf       	rjmp	.-18     	; 0x29e2 <__fp_trunc+0xc>
    29f4:	86 95       	lsr	r24
    29f6:	77 95       	ror	r23
    29f8:	67 95       	ror	r22
    29fa:	b1 1d       	adc	r27, r1
    29fc:	93 95       	inc	r25
    29fe:	96 39       	cpi	r25, 0x96	; 150
    2a00:	c8 f3       	brcs	.-14     	; 0x29f4 <__fp_trunc+0x1e>
    2a02:	08 95       	ret

00002a04 <__fp_zero>:
    2a04:	e8 94       	clt

00002a06 <__fp_szero>:
    2a06:	bb 27       	eor	r27, r27
    2a08:	66 27       	eor	r22, r22
    2a0a:	77 27       	eor	r23, r23
    2a0c:	cb 01       	movw	r24, r22
    2a0e:	97 f9       	bld	r25, 7
    2a10:	08 95       	ret

00002a12 <__mulsf3>:
    2a12:	0b d0       	rcall	.+22     	; 0x2a2a <__mulsf3x>
    2a14:	ad cf       	rjmp	.-166    	; 0x2970 <__fp_round>
    2a16:	9e df       	rcall	.-196    	; 0x2954 <__fp_pscA>
    2a18:	28 f0       	brcs	.+10     	; 0x2a24 <__mulsf3+0x12>
    2a1a:	a3 df       	rcall	.-186    	; 0x2962 <__fp_pscB>
    2a1c:	18 f0       	brcs	.+6      	; 0x2a24 <__mulsf3+0x12>
    2a1e:	95 23       	and	r25, r21
    2a20:	09 f0       	breq	.+2      	; 0x2a24 <__mulsf3+0x12>
    2a22:	64 cf       	rjmp	.-312    	; 0x28ec <__fp_inf>
    2a24:	94 cf       	rjmp	.-216    	; 0x294e <__fp_nan>
    2a26:	11 24       	eor	r1, r1
    2a28:	ee cf       	rjmp	.-36     	; 0x2a06 <__fp_szero>

00002a2a <__mulsf3x>:
    2a2a:	b3 df       	rcall	.-154    	; 0x2992 <__fp_split3>
    2a2c:	a0 f3       	brcs	.-24     	; 0x2a16 <__mulsf3+0x4>

00002a2e <__mulsf3_pse>:
    2a2e:	95 9f       	mul	r25, r21
    2a30:	d1 f3       	breq	.-12     	; 0x2a26 <__mulsf3+0x14>
    2a32:	95 0f       	add	r25, r21
    2a34:	50 e0       	ldi	r21, 0x00	; 0
    2a36:	55 1f       	adc	r21, r21
    2a38:	62 9f       	mul	r22, r18
    2a3a:	f0 01       	movw	r30, r0
    2a3c:	72 9f       	mul	r23, r18
    2a3e:	bb 27       	eor	r27, r27
    2a40:	f0 0d       	add	r31, r0
    2a42:	b1 1d       	adc	r27, r1
    2a44:	63 9f       	mul	r22, r19
    2a46:	aa 27       	eor	r26, r26
    2a48:	f0 0d       	add	r31, r0
    2a4a:	b1 1d       	adc	r27, r1
    2a4c:	aa 1f       	adc	r26, r26
    2a4e:	64 9f       	mul	r22, r20
    2a50:	66 27       	eor	r22, r22
    2a52:	b0 0d       	add	r27, r0
    2a54:	a1 1d       	adc	r26, r1
    2a56:	66 1f       	adc	r22, r22
    2a58:	82 9f       	mul	r24, r18
    2a5a:	22 27       	eor	r18, r18
    2a5c:	b0 0d       	add	r27, r0
    2a5e:	a1 1d       	adc	r26, r1
    2a60:	62 1f       	adc	r22, r18
    2a62:	73 9f       	mul	r23, r19
    2a64:	b0 0d       	add	r27, r0
    2a66:	a1 1d       	adc	r26, r1
    2a68:	62 1f       	adc	r22, r18
    2a6a:	83 9f       	mul	r24, r19
    2a6c:	a0 0d       	add	r26, r0
    2a6e:	61 1d       	adc	r22, r1
    2a70:	22 1f       	adc	r18, r18
    2a72:	74 9f       	mul	r23, r20
    2a74:	33 27       	eor	r19, r19
    2a76:	a0 0d       	add	r26, r0
    2a78:	61 1d       	adc	r22, r1
    2a7a:	23 1f       	adc	r18, r19
    2a7c:	84 9f       	mul	r24, r20
    2a7e:	60 0d       	add	r22, r0
    2a80:	21 1d       	adc	r18, r1
    2a82:	82 2f       	mov	r24, r18
    2a84:	76 2f       	mov	r23, r22
    2a86:	6a 2f       	mov	r22, r26
    2a88:	11 24       	eor	r1, r1
    2a8a:	9f 57       	subi	r25, 0x7F	; 127
    2a8c:	50 40       	sbci	r21, 0x00	; 0
    2a8e:	8a f0       	brmi	.+34     	; 0x2ab2 <__mulsf3_pse+0x84>
    2a90:	e1 f0       	breq	.+56     	; 0x2aca <__mulsf3_pse+0x9c>
    2a92:	88 23       	and	r24, r24
    2a94:	4a f0       	brmi	.+18     	; 0x2aa8 <__mulsf3_pse+0x7a>
    2a96:	ee 0f       	add	r30, r30
    2a98:	ff 1f       	adc	r31, r31
    2a9a:	bb 1f       	adc	r27, r27
    2a9c:	66 1f       	adc	r22, r22
    2a9e:	77 1f       	adc	r23, r23
    2aa0:	88 1f       	adc	r24, r24
    2aa2:	91 50       	subi	r25, 0x01	; 1
    2aa4:	50 40       	sbci	r21, 0x00	; 0
    2aa6:	a9 f7       	brne	.-22     	; 0x2a92 <__mulsf3_pse+0x64>
    2aa8:	9e 3f       	cpi	r25, 0xFE	; 254
    2aaa:	51 05       	cpc	r21, r1
    2aac:	70 f0       	brcs	.+28     	; 0x2aca <__mulsf3_pse+0x9c>
    2aae:	1e cf       	rjmp	.-452    	; 0x28ec <__fp_inf>
    2ab0:	aa cf       	rjmp	.-172    	; 0x2a06 <__fp_szero>
    2ab2:	5f 3f       	cpi	r21, 0xFF	; 255
    2ab4:	ec f3       	brlt	.-6      	; 0x2ab0 <__mulsf3_pse+0x82>
    2ab6:	98 3e       	cpi	r25, 0xE8	; 232
    2ab8:	dc f3       	brlt	.-10     	; 0x2ab0 <__mulsf3_pse+0x82>
    2aba:	86 95       	lsr	r24
    2abc:	77 95       	ror	r23
    2abe:	67 95       	ror	r22
    2ac0:	b7 95       	ror	r27
    2ac2:	f7 95       	ror	r31
    2ac4:	e7 95       	ror	r30
    2ac6:	9f 5f       	subi	r25, 0xFF	; 255
    2ac8:	c1 f7       	brne	.-16     	; 0x2aba <__mulsf3_pse+0x8c>
    2aca:	fe 2b       	or	r31, r30
    2acc:	88 0f       	add	r24, r24
    2ace:	91 1d       	adc	r25, r1
    2ad0:	96 95       	lsr	r25
    2ad2:	87 95       	ror	r24
    2ad4:	97 f9       	bld	r25, 7
    2ad6:	08 95       	ret

00002ad8 <__mulsi3>:
    2ad8:	62 9f       	mul	r22, r18
    2ada:	d0 01       	movw	r26, r0
    2adc:	73 9f       	mul	r23, r19
    2ade:	f0 01       	movw	r30, r0
    2ae0:	82 9f       	mul	r24, r18
    2ae2:	e0 0d       	add	r30, r0
    2ae4:	f1 1d       	adc	r31, r1
    2ae6:	64 9f       	mul	r22, r20
    2ae8:	e0 0d       	add	r30, r0
    2aea:	f1 1d       	adc	r31, r1
    2aec:	92 9f       	mul	r25, r18
    2aee:	f0 0d       	add	r31, r0
    2af0:	83 9f       	mul	r24, r19
    2af2:	f0 0d       	add	r31, r0
    2af4:	74 9f       	mul	r23, r20
    2af6:	f0 0d       	add	r31, r0
    2af8:	65 9f       	mul	r22, r21
    2afa:	f0 0d       	add	r31, r0
    2afc:	99 27       	eor	r25, r25
    2afe:	72 9f       	mul	r23, r18
    2b00:	b0 0d       	add	r27, r0
    2b02:	e1 1d       	adc	r30, r1
    2b04:	f9 1f       	adc	r31, r25
    2b06:	63 9f       	mul	r22, r19
    2b08:	b0 0d       	add	r27, r0
    2b0a:	e1 1d       	adc	r30, r1
    2b0c:	f9 1f       	adc	r31, r25
    2b0e:	bd 01       	movw	r22, r26
    2b10:	cf 01       	movw	r24, r30
    2b12:	11 24       	eor	r1, r1
    2b14:	08 95       	ret

00002b16 <__udivmodhi4>:
    2b16:	aa 1b       	sub	r26, r26
    2b18:	bb 1b       	sub	r27, r27
    2b1a:	51 e1       	ldi	r21, 0x11	; 17
    2b1c:	07 c0       	rjmp	.+14     	; 0x2b2c <__udivmodhi4_ep>

00002b1e <__udivmodhi4_loop>:
    2b1e:	aa 1f       	adc	r26, r26
    2b20:	bb 1f       	adc	r27, r27
    2b22:	a6 17       	cp	r26, r22
    2b24:	b7 07       	cpc	r27, r23
    2b26:	10 f0       	brcs	.+4      	; 0x2b2c <__udivmodhi4_ep>
    2b28:	a6 1b       	sub	r26, r22
    2b2a:	b7 0b       	sbc	r27, r23

00002b2c <__udivmodhi4_ep>:
    2b2c:	88 1f       	adc	r24, r24
    2b2e:	99 1f       	adc	r25, r25
    2b30:	5a 95       	dec	r21
    2b32:	a9 f7       	brne	.-22     	; 0x2b1e <__udivmodhi4_loop>
    2b34:	80 95       	com	r24
    2b36:	90 95       	com	r25
    2b38:	bc 01       	movw	r22, r24
    2b3a:	cd 01       	movw	r24, r26
    2b3c:	08 95       	ret

00002b3e <__udivmodsi4>:
    2b3e:	a1 e2       	ldi	r26, 0x21	; 33
    2b40:	1a 2e       	mov	r1, r26
    2b42:	aa 1b       	sub	r26, r26
    2b44:	bb 1b       	sub	r27, r27
    2b46:	fd 01       	movw	r30, r26
    2b48:	0d c0       	rjmp	.+26     	; 0x2b64 <__udivmodsi4_ep>

00002b4a <__udivmodsi4_loop>:
    2b4a:	aa 1f       	adc	r26, r26
    2b4c:	bb 1f       	adc	r27, r27
    2b4e:	ee 1f       	adc	r30, r30
    2b50:	ff 1f       	adc	r31, r31
    2b52:	a2 17       	cp	r26, r18
    2b54:	b3 07       	cpc	r27, r19
    2b56:	e4 07       	cpc	r30, r20
    2b58:	f5 07       	cpc	r31, r21
    2b5a:	20 f0       	brcs	.+8      	; 0x2b64 <__udivmodsi4_ep>
    2b5c:	a2 1b       	sub	r26, r18
    2b5e:	b3 0b       	sbc	r27, r19
    2b60:	e4 0b       	sbc	r30, r20
    2b62:	f5 0b       	sbc	r31, r21

00002b64 <__udivmodsi4_ep>:
    2b64:	66 1f       	adc	r22, r22
    2b66:	77 1f       	adc	r23, r23
    2b68:	88 1f       	adc	r24, r24
    2b6a:	99 1f       	adc	r25, r25
    2b6c:	1a 94       	dec	r1
    2b6e:	69 f7       	brne	.-38     	; 0x2b4a <__udivmodsi4_loop>
    2b70:	60 95       	com	r22
    2b72:	70 95       	com	r23
    2b74:	80 95       	com	r24
    2b76:	90 95       	com	r25
    2b78:	9b 01       	movw	r18, r22
    2b7a:	ac 01       	movw	r20, r24
    2b7c:	bd 01       	movw	r22, r26
    2b7e:	cf 01       	movw	r24, r30
    2b80:	08 95       	ret

00002b82 <_exit>:
    2b82:	f8 94       	cli

00002b84 <__stop_program>:
    2b84:	ff cf       	rjmp	.-2      	; 0x2b84 <__stop_program>
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\commands.cpp"
//Command Structures ---------------------------------------------------------
//
// Definition of the commands used by the Synta protocol, and variables in which responses
// are storedz
//
// Data structure of flag Flag:
//   flag = xxxx00ds000g000f where bits:
//   x = dont care
//   d = dir
//   s = stopped
//   g = goto
//   f = energised
//
// Only dir can be used to set the direction, but stepDir method can be used
// to returns it in a more useful format
//
//----------------------------------------------------------------------------

#include "commands.h"

Commands cmd = {0};

void Commands_init(unsigned long _eVal, byte _gVal){
    cmd.aVal[RA] = EEPROM_readLong(aVal1_Address);              //steps/axis
    cmd.aVal[DC] = EEPROM_readLong(aVal2_Address);              //steps/axis
    cmd.bVal[RA] = EEPROM_readLong(bVal1_Address);              //sidereal rate
    cmd.bVal[DC] = EEPROM_readLong(bVal2_Address);              //sidereal rate
    cmd.sVal[RA] = EEPROM_readLong(sVal1_Address);              //steps/worm rotation
    cmd.sVal[DC] = EEPROM_readLong(sVal2_Address);              //steps/worm rotation
    
    cmd.siderealIVal[RA] = EEPROM_readInt(IVal1_Address);       //steps/worm rotation
    cmd.siderealIVal[DC] = EEPROM_readInt(IVal2_Address);       //steps/worm rotation
    cmd.normalGotoSpeed[RA] = EEPROM_readByte(RAGoto_Address);  //IVal for normal goto speed
    cmd.normalGotoSpeed[DC] = EEPROM_readByte(DECGoto_Address); //IVal for normal goto speed
    cmd.st4SpeedFactor = EEPROM_readByte(SpeedFactor_Address);  //ST4 speed factor
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
        cmd.stepDir[i] = 1; //1-dir*2
        cmd.highSpeedMode[i] = false;
        cmd.stopped[i] = CMD_STOPPED;
        cmd.gotoEn[i] = CMD_DISABLED;
        cmd.FVal[i] = CMD_DISABLED;
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
        cmd.IVal[i] = cmd.siderealIVal[i]; //Recieved Speed will be set by :I command.
        cmd.GVal[i] = 0; //Mode recieved from :G command
        cmd.HVal[i] = 0; //Value recieved from :H command
        cmd.eVal[i] = _eVal; //version number
        cmd.gVal[i] = _gVal; //High speed scalar
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
        cmd.stopSpeed[i] = cmd.minSpeed[i];
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
}

void Commands_configureST4Speed(byte mode) {
    cmd.st4Mode = mode;
    if (mode == CMD_ST4_HIGHSPEED) {
        //Set the ST4 speeds to highspeed standalone mode (goto speeds)
        cmd.st4RAIVal[ST4P] = cmd.normalGotoSpeed[RA];
        cmd.st4RAIVal[ST4N] = cmd.normalGotoSpeed[RA];
        cmd.st4RAReverse    = CMD_REVERSE;
        cmd.st4DecIVal      = cmd.normalGotoSpeed[DC];
    } else if (mode == CMD_ST4_STANDALONE) {
        //Set the ST4 speeds to standalone mode (2x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA])/3; //3x speed
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA])  ; //-1x speed
        cmd.st4RAReverse    = CMD_REVERSE;
        cmd.st4DecIVal      =(cmd.siderealIVal[DC])/2; //2x speed
    } else {
        //Set the ST4 speeds to normal mode (0.25x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA] * 20)/(20 + cmd.st4SpeedFactor); //(1+SpeedFactor)x speed   -- Max. IVal = 1200, so this will never overflow.
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA] * 20)/(20 - cmd.st4SpeedFactor); //(1-SpeedFactor)x speed
        cmd.st4RAReverse    = CMD_FORWARD;
        cmd.st4DecIVal      =(cmd.siderealIVal[DC] * 20)/( 0 + cmd.st4SpeedFactor); //(SpeedFactor)x speed
    }
}

const char cmd_commands[numberOfCommands][3] = { {'j', 0, 6}, //arranged in order of most frequently used to reduce searching time.
                                                 {'f', 0, 3},
                                                 {'I', 6, 0},
                                                 {'G', 2, 0},
                                                 {'J', 0, 0},
                                                 {'K', 0, 0},
                                                 {'H', 6, 0},
                                                 {'M', 6, 0},
                                                 {'e', 0, 6},
                                                 {'a', 0, 6},
                                                 {'b', 0, 6},
                                                 {'g', 0, 2},
                                                 {'s', 0, 6},
                                                 {'E', 6, 0},
                                                 {'P', 1, 0},
                                                 {'F', 0, 0},
                                                 {'L', 0, 0},
                                                 //Programmer Commands
                                                 {'A', 6, 0},
                                                 {'B', 6, 0},
                                                 {'S', 6, 0},
                                                 {'n', 0, 6},
                                                 {'N', 6, 0},
                                                 {'D', 2, 0},
                                                 {'d', 0, 2},
                                                 {'C', 1, 0},
                                                 {'c', 0, 2},
                                                 {'Z', 2, 0},
                                                 {'z', 0, 2},
                                                 {'R', 6, 0},
                                                 {'r', 0, 6},
                                                 {'O', 1, 0},
                                                 {'Q', 2, 0},
                                                 {'q', 0, 2},
                                                 {'X', 6, 0},
                                                 {'x', 0, 6},
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    for(byte i = 0;i < numberOfCommands;i++){
        if(cmd_commands[i][0] == cmd){
            if(sendRecieve){
                return cmd_commands[i][1];
            } else {
                return cmd_commands[i][2];
            }
        }
    }
    return -1;
}

//void Commands::setStepLength(byte target, byte stepLength) {
//  if (stepDir[target] > 0) {
//    stepDir[target] = stepLength;
//  } else {
//    stepDir[target] = -stepLength;
//  }
//}

ELF          S                 4     (   %RU  $ >   :;I  $ >  $ >  :;   :;I8
  :;  	 :;I8
  
I  ! I/  5 I  .?:;@@
   :;I  .?:;@I@
   :;I   :;I
  4 :;I    4 :;I  & I  4 :;I  4 :;I?
  4 :;I
   Y                                       z7       int                         ,       n       oE   #     ph   #     #;      %;  #     &K  #    'K  #    ([  #    );  #    *  #/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\commands.h"
//_fVal Flag get/set callers -------------------------------------------------
//
//Data structure of _fVal Flag:
//  _fVal = xxxx00ds000g000f where bits:
//  x = dont care
//  d = dir
//  s = stopped
//  g = goto
//  f = energised
//
//Only dir can be used to set the direction, but stepDir method can be used
//to returns it in a more useful format
//
//----------------------------------------------------------------------------

#ifndef __COMMANDS_H__
#define __COMMANDS_H__
  
#include "AstroEQ.h"
#include "EEPROMReader.h" //Read config file

#define CMD_ST4_HIGHSPEED   2
#define CMD_ST4_STANDALONE  1
#define CMD_ST4_DEFAULT     0

#define CMD_FORWARD         false
#define CMD_REVERSE         true

#define CMD_STOPPED         true
#define CMD_RUNNING         false

#define CMD_ENABLED         true
#define CMD_DISABLED        false

typedef struct{        
    //class variables
    unsigned long    jVal           [2]; //_jVal: Current position
    unsigned int     IVal           [2]; //_IVal: speed to move if in slew mode
    unsigned int     motorSpeed     [2]; //speed at which moving. Accelerates to IVal.
    byte             GVal           [2]; //_GVal: slew/goto mode
    unsigned long    HVal           [2]; //_HVal: steps to move if in goto mode
    volatile char    stepDir        [2]; 
    bool             dir            [2];
    bool             FVal           [2];
    bool             gotoEn         [2];
    bool             stopped        [2];
    bool             highSpeedMode  [2];
    unsigned long    eVal           [2]; //_eVal: Version number
    unsigned long    aVal           [2]; //_aVal: Steps per axis revolution
    unsigned long    bVal           [2]; //_bVal: Sidereal Rate of axis
    byte             gVal           [2]; //_gVal: Speed scalar for highspeed slew
    unsigned long    sVal           [2]; //_sVal: Steps per worm gear revolution
    byte             st4Mode;            //Current ST-4 mode
    byte             st4SpeedFactor;     //Multiplication factor to get st4 speed. min = 1 = 0.05x, max = 19 = 0.95x.
    unsigned int     st4RAIVal      [2]; //_IVal: for RA ST4 movements ({RA+,RA-});
    bool             st4RAReverse;       //Reverse RA- axis direction if true.
    unsigned int     st4DecIVal;         //_IVal: for declination ST4 movements
    unsigned int     st4DecBacklash;     //Number of steps to perform on ST-4 direction change ---- Not yet implemented.
    unsigned int     siderealIVal   [2]; //_IVal: at sidereal rate
    unsigned int     currentIVal    [2]; //this will be upldated to match the requested IVal once the motors are stopped.
    unsigned int     minSpeed       [2]; //slowest speed allowed
    unsigned int     normalGotoSpeed[2]; //IVal for normal goto movement.
    unsigned int     stopSpeed      [2]; //Speed at which mount should stop. May be lower than minSpeed if doing a very slow IVal.
    AccelTableStruct accelTable     [2][AccelTableLength]; //Acceleration profile now controlled via lookup table. The first element will be used for cmd.minSpeed[]. max repeat=85
} Commands;

#define numberOfCommands 37

void Commands_init(unsigned long _eVal, byte _gVal);
void Commands_configureST4Speed(byte mode);
char Commands_getLength(char cmd, bool sendRecieve);
  
//Command definitions
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    }
}

inline unsigned int cmd_fVal(byte target){ //_fVal: 00ds000g000f; d = dir, s = stopped, g = goto, f = energised
    unsigned int fVal = 0;
    if (cmd.dir[target]) {
        fVal |= (1 << 9);
    }
    if (cmd.stopped[target]) {
        fVal |= (1 << 8);
    }
    if (cmd.gotoEn[target]) {
        fVal |= (1 << 4);
    }
    if (cmd.FVal[target]){
        fVal |= (1 << 0);
    }
    return fVal;
}

inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
}

inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
}

inline void cmd_setaVal(byte target, unsigned long _aVal){ //Set Method
    cmd.aVal[target] = _aVal;
}

inline void cmd_setbVal(byte target, unsigned long _bVal){ //Set Method
    cmd.bVal[target] = _bVal;
}

inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
}

inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
}

inline void cmd_setst4DecBacklash(unsigned int _backlash){ //Set Method
    cmd.st4DecBacklash = _backlash;
}


#endif //__COMMANDS_H__
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMAddresses.h"
#include "avr/io.h"

#define EEPROMStart_Address (                      0 )
#define AstroEQID_Address   (EEPROMStart_Address + 0 )
#define Microstep_Address   (EEPROMStart_Address + 8 ) //whether to use microstepping.
#define RAReverse_Address   (EEPROMStart_Address + 9 )
#define DECReverse_Address  (EEPROMStart_Address + 10)
#define Driver_Address      (EEPROMStart_Address + 11)
#define RAGoto_Address      (EEPROMStart_Address + 12)
#define DECGoto_Address     (EEPROMStart_Address + 13)
#define aVal1_Address       (EEPROMStart_Address + 14) //steps/axis
#define aVal2_Address       (EEPROMStart_Address + 18) //steps/axis
#define bVal1_Address       (EEPROMStart_Address + 22) //sidereal rate
#define bVal2_Address       (EEPROMStart_Address + 26) //sidereal rate
#define sVal1_Address       (EEPROMStart_Address + 30) //steps/worm rotation
#define sVal2_Address       (EEPROMStart_Address + 34) //steps/worm rotation
#define IVal1_Address       (EEPROMStart_Address + 38) //steps/worm rotation
#define IVal2_Address       (EEPROMStart_Address + 40) //steps/worm rotation
#define GearEnable_Address  (EEPROMStart_Address + 42) //Allow "gear change"
#define AdvHCEnable_Address (EEPROMStart_Address + 43) //Allow advanced controller detection
#define DecBacklash_Address (EEPROMStart_Address + 44) //DEC backlash correction factor
#define SpeedFactor_Address (EEPROMStart_Address + 46) //ST4 Speed Factor (0.05x to 0.95x sidereal as multiple of 1/20)

#define AccelTableLength 64
#define AccelTable1_Address (EEPROMStart_Address + 100) //Leave a gap so we can add more settings later.
#define AccelTable2_Address (EEPROMStart_Address + 100 + AccelTableLength*3)

#if ((EEPROMStart_Address + 100 + (6*AccelTableLength) - 1) > E2END)
    #error "AccelTable too large for EEPROM"
#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMReader.cpp"

#include <avr/eeprom.h>
#include "EEPROMReader.h"
 
byte EEPROM_readByte(unsigned int address) {
    return eeprom_read_byte((byte*) address);
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    fetcher.array[1] = EEPROM_readInt(address+2);
    return fetcher.integer;
}

void EEPROM_readString(char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
        string[i] = EEPROM_readByte(address++);
    }
}

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
        table[i].speed = EEPROM_readInt(address);
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
        address = address + sizeof(byte);
    }
}

void EEPROM_writeByte(byte val, unsigned int address) {
    return eeprom_write_byte((byte*) address, val);
}

void EEPROM_writeInt(unsigned int val, unsigned int address) {
    TwoBytes storer = {val};
    EEPROM_writeByte(storer.array[0], address);
    EEPROM_writeByte(storer.array[1], address+1);
}

void EEPROM_writeLong(unsigned long val, unsigned int address) {
    FourBytes storer = {val};
    EEPROM_writeInt(storer.array[0], address);
    EEPROM_writeInt(storer.array[1], address+2);
}

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
        EEPROM_writeByte(string[i], address+i);
    }
}

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
        EEPROM_writeInt(table[i].speed,address);
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
        address = address + sizeof(byte);
    }
}
ELF          S            X     4     ( + ( %RU  $ >   :;I  $ >  :;   :;I  I  ! I/  	$ >  
:;   :;I8
  .:;I    :;I  4 :;I   I  & I  .?:;I    :;I     1  4 1    .:;    :;I   :;I  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMReader.h"
#ifndef __EEPROM_H__
#define __EEPROM_H__

#include "AstroEQ.h"

byte EEPROM_readByte(unsigned int address);
unsigned int EEPROM_readInt(unsigned int address);
unsigned long EEPROM_readLong(unsigned int address);
void EEPROM_readString(char* string, byte len, unsigned int address);
void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address);
void EEPROM_writeByte(byte val,unsigned int address);
void EEPROM_writeInt(unsigned int val,unsigned int address);
void EEPROM_writeLong(unsigned long val,unsigned int address);
void EEPROM_writeString(const char* string, byte len, unsigned int address);
void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address);

#endif //__EEPROM_H__
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\PinMappings.h"

//
// Useful Macros
//

#define setPinDir(p,d) {if(d){*digitalPinToDirectionReg((p)) |= _BV(digitalPinToBit((p)));}else{*digitalPinToDirectionReg((p)) &= ~_BV(digitalPinToBit((p)));}}
#define setPinValue(p,v) {if(v){*digitalPinToPortReg((p)) |= _BV(digitalPinToBit((p)));}else{*digitalPinToPortReg((p)) &= ~_BV(digitalPinToBit((p)));}}
#define getPinValue(p) (!!(*digitalPinToPinReg((p)) & _BV(digitalPinToBit((p)))))
#define togglePin(p) {*digitalPinToPortReg((p)) ^= _BV(digitalPinToBit((p)));}


//
// Pin Mappings
//

#if defined(__AVR_ATmega162__)

//----- User Configurable Pin Definitions for ATMega162 Variants -----
//Warning: D20 to D27 inclusive are NOT allowed

//GPIO Header:
                             //VCC (Header Pin 5)
#define gpioPin_0_Define 2   //IO0 (Header Pin 4) [ATMega PD2] - Interrupt Capable (INT0)
#define gpioPin_1_Define 29  //IO1 (Header Pin 3) [ATMega PE1] - GPIO Pin
#define gpioPin_2_Define 28  //IO2 (Header Pin 2) [ATMega PE0] - GPIO Pin
                             //GND (Header Pin 1)

//Status Pins:
#define statusPin_Define 13 

//Motor Driver Pins:
#define resetPin_0_Define 15
#define resetPin_1_Define 14

#define dirPin_0_Define 3
#define dirPin_1_Define 7

#define enablePin_0_Define 4
#define enablePin_1_Define 8

#define stepPin_0_Define 5
#define stepPin_1_Define 30

#define modePins0_0_Define 6
#define modePins1_0_Define 17
#define modePins2_0_Define 16
#define modePins0_1_Define 10
#define modePins1_1_Define 18
#define modePins2_1_Define 19

//ST4 Pins:
#define ST4AddPin_0_Define 34
#define ST4AddPin_1_Define 33
#define ST4SubPin_0_Define 31
#define ST4SubPin_1_Define 32

//SPI Pins:
#define SPIClockPin_Define 32 //(13)
#define SPIMISOPin_Define  34 //(12) - Comments are hardware SPI pin. These are sadly partly used for other things.
#define SPIMOSIPin_Define  33 //(11) - Instead we are currently doing software SPI on same pins as ST4.
#define SPISSnPin_Define   31 //(6)


#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)

//---- User Configurable Pin Definitions for ATMegaXXX0 Variants -----
//Warning: D30 to D37 inclusive are NOT allowed

//GPIO Pins:
#define gpioPin_0_Define 21  //IO0 [ATMega PD0] - Interrupt Capable (INT0)
#define gpioPin_1_Define 22  //IO1 [ATMega PA0] - GPIO Pin
#define gpioPin_2_Define 23  //IO2 [ATMega PA1] - GPIO Pin

//Status Pins:
#define statusPin_Define 13

//Motor Driver Pins:
#define resetPin_0_Define 55 //Analog 1
#define resetPin_1_Define 54 //Analog 0

#define dirPin_0_Define 3
#define dirPin_1_Define 7

#define enablePin_0_Define 4
#define enablePin_1_Define 8

#define stepPin_0_Define 5
#define stepPin_1_Define 12

#define modePins0_0_Define 15
#define modePins1_0_Define 16
#define modePins2_0_Define 17
#define modePins0_1_Define 20
#define modePins1_1_Define 19
#define modePins2_1_Define 18

//ST4 Pins:
//#define ALTERNATE_ST4 //Uncomment this line to use the alternate mapping for the ST4 port, using A8 to A11 instead of 50 to 53

//You only have a choice between two locations for the ST4 pins as controlled by the above #define.
#ifdef ALTERNATE_ST4
#define ST4AddPin_0_Define 62 //Analog 8
#define ST4AddPin_1_Define 63 //Analog 9
#define ST4SubPin_0_Define 64 //Analog 10
#define ST4SubPin_1_Define 65 //Analog 11
#else
#define ST4AddPin_0_Define 50
#define ST4AddPin_1_Define 51
#define ST4SubPin_0_Define 53
#define ST4SubPin_1_Define 52
#endif

//SPI Pins:
#define SPIClockPin_Define 52
#define SPIMISOPin_Define  50
#define SPIMOSIPin_Define  51
#define SPISSnPin_Define   53


#endif








// Do not modify anything below this line! ---------------------------------------


#if (CS10 != CS30) || (CS11 != CS31) || (CS12 != CS32)
#error incorrect assumption about prescale bits being equal between timer 1 and 3.
#endif
#define CSn0 CS10
#define CSn1 CS11
#define CSn2 CS12



#if defined(__AVR_ATmega162__)


#ifndef USART0_TX_vect
#define USART0_TX_vect USART0_TXC_vect
#endif
#ifndef USART0_RX_vect
#define USART0_RX_vect USART0_RXC_vect
#endif

#ifndef USART1_TX_vect
#define USART1_TX_vect USART1_TXC_vect
#endif
#ifndef USART1_RX_vect
#define USART1_RX_vect USART1_RXC_vect
#endif

//Pick some registers we are not going use for GPIOR
#define GPIOR0 PORTC
#define GPIOR1 OCR0
#define GPIOR2 TCNT0

#define PCICR GICR

#ifndef TIMSK3
#define TIMSK3 ETIMSK
#endif
#ifndef TIMSK1
#define TIMSK1 TIMSK
#endif
#ifndef ICIE3
#define ICIE3 TICIE3
#endif
#ifndef ICIE1
#define ICIE1 TICIE1
#endif

#define digitalPinToPortReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &PORTA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &PORTB : \
((((P) >= 20 && (P) <= 27)                            ) ? &PORTC : \
((((P) <= 7              )                            ) ? &PORTD : &PORTE ))))

#define digitalPinToDirectionReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &DDRA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &DDRB : \
((((P) >= 20 && (P) <= 27)                            ) ? &DDRC : \
((((P) <= 7              )                            ) ? &DDRD : &DDRE ))))

#define digitalPinToPinReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &PINA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &PINB : \
((((P) >= 20 && (P) <= 27)                            ) ? &PINC : \
((((P) <= 7              )                            ) ? &PIND : &PINE ))))

#define digitalPinToBit(P) \
(((P) >=  0 && (P) <=  3) ? (P)      : \
(((P) >= 10 && (P) <= 13) ? (P) - 6  : \
(((P) >=  8 && (P) <=  9) ? (P) - 8  : \
(((P) >= 18 && (P) <= 19) ? 21 - (P) : \
(((P) >= 20 && (P) <= 27) ? (P) - 20 : \
(((P) >= 28 && (P) <= 30) ? (P) - 28 : \
(((P) >= 31 && (P) <= 34) ? (P) - 27 : \
(((P) >= 14 && (P) <= 17) ? (P) - 14 : \
(((P) >=  5 && (P) <=  6) ? (P) - 1  : \
(((P) == 7              ) ? (P)      : 6 ))))))))))


#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)


#define digitalPinToPortReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &PORTA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PORTB : \
((((P) >= 30 && (P) <= 37)                            ) ? &PORTC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &PORTD : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &PORTE : \
((((P) >= 54 && (P) <= 61)                            ) ? &PORTF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &PORTG : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &PORTH : \
((((P) >= 14 && (P) <= 15)                            ) ? &PORTJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &PORTK : &PORTL))))))))))

#define digitalPinToDirectionReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &DDRA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &DDRB : \
((((P) >= 30 && (P) <= 37)                            ) ? &DDRC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &DDRD : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &DDRE : \
((((P) >= 54 && (P) <= 61)                            ) ? &DDRF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &DDRG : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &DDRH : \
((((P) >= 14 && (P) <= 15)                            ) ? &DDRJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &DDRK : &DDRL))))))))))

#define digitalPinToPinReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &PINA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PINB : \
((((P) >= 30 && (P) <= 37)                            ) ? &PINC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &PIND : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &PINE : \
((((P) >= 54 && (P) <= 61)                            ) ? &PINF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &PING : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &PINH : \
((((P) >= 14 && (P) <= 15)                            ) ? &PINJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &PINK : &PINL))))))))))

#define digitalPinToBit(P) \
(((P) >=  7 && (P) <=  9) ? (P) - 3 : \
(((P) >= 10 && (P) <= 13) ? (P) - 6 : \
(((P) >= 22 && (P) <= 29) ? (P) - 22 : \
(((P) >= 30 && (P) <= 37) ? 37 - (P) : \
(((P) >= 39 && (P) <= 41) ? 41 - (P) : \
(((P) >= 42 && (P) <= 49) ? 49 - (P) : \
(((P) >= 50 && (P) <= 53) ? 53 - (P) : \
(((P) >= 54 && (P) <= 61) ? (P) - 54 : \
(((P) >= 62 && (P) <= 69) ? (P) - 62 : \
(((P) >= 0  && (P) <= 1 ) ? (P)      : \
(((P) >= 14 && (P) <= 15) ? 15 - (P) : \
(((P) >= 16 && (P) <= 17) ? 17 - (P) : \
(((P) >= 20 && (P) <= 21) ? 21 - (P) : \
(((P) == 19             ) ?       2  : \
(((P) >= 5  && (P) <= 6 ) ?       3  : \
(((P) == 18             ) ?       3  : \
(((P) == 2              ) ?       4  : \
(((P) >= 3  && (P) <= 4 ) ?       5  : 7))))))))))))))))))



#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\SerialLink.cpp"

#include "SerialLink.h"
#include <avr/io.h>
#include <avr/interrupt.h>

//This stuff is needed for GCC to correctly append in the value from SERIALn above
#define __REGnD(r,n,d) r##n##d
#define __REGn(r,n) r##n
#define _REGnD(r,n,d) __REGnD(r,n,d)
#define _REGn(r,n) __REGn(r,n)

//Two macros to make things like UCSRA0A and U2X0
#define REGnD(r,d) _REGnD(r,SERIALn,d)
#define REGn(r) _REGn(r,SERIALn)

//Registers
#define UCSRnA REGnD(UCSR,A)
#define UCSRnB REGnD(UCSR,B)
#define UBRRnH REGnD(UBRR,H)
#define UBRRnL REGnD(UBRR,L)
#define UDRn REGn(UDR)

//Bits
#define U2Xn REGn(U2X)
#define RXENn REGn(RXEN)
#define TXENn REGn(TXEN)
#define RXCIEn REGn(RXCIE)
#define UDRIEn REGn(UDRIE)

//Vectors
#define USARTn_RX_vect REGnD(USART,_RX_vect)
#define USARTn_UDRE_vect REGnD(USART,_UDRE_vect)

#define SPI_NULL 0xFF //NULL means ignore
#define SPI_DATA 0x7F //And-ed with all outgoing write packets. An incoming byte is ignored if bits outside this mask are set.
#define SPI_READ 0x81 //SPI read request command
#define SPI_RESP 0x80 //SPI read response request command
#define SPI_ISDATA(a) (!((a) & (~SPI_DATA))) //Returns true if SPI_DATA
#define SPI_ISREAD(a) ( ((a) == ( SPI_READ))) //Returns true if SPI_READ

#define BUFFER_SIZE 32 //Must be power of 2!
#define BUFFER_PTR_MASK (BUFFER_SIZE - 1)
typedef struct {
    unsigned char buffer[BUFFER_SIZE];
    volatile unsigned char head;
    volatile unsigned char tail;
} 
RingBuffer;

RingBuffer txBuf = {{0},0,0};
RingBuffer rxBuf = {{0},0,0};

bool softSPIEnabled = false;

//Initialise the hardware UART port and set baud rate.
void Serial_initialise(const unsigned long baud) {
    Byter baud_setting;

    UCSRnA = _BV(U2Xn);
    baud_setting.integer = (F_CPU / 4 / baud - 1) / 2;

    if (baud_setting.high & 0xF0) {
        UCSRnA = 0;
        baud_setting.integer = (F_CPU / 8 / baud - 1) / 2;
    }

    // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
    UBRRnH = baud_setting.high & 0x0F;
    UBRRnL = baud_setting.low;

    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.

    //And enable
    sbi(UCSRnB, RXENn);
    sbi(UCSRnB, TXENn);
    sbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
}

//Disable the hardware UART port
void Serial_disable() {
    cbi(UCSRnB, RXENn);
    cbi(UCSRnB, TXENn);
    cbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    cli();
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    txBuf.tail = 0;
    rxBuf.head = 0;
    rxBuf.tail = 0;
    SREG = oldSREG;
}

//Initialise the Software SPI by setting ports to correct direction and state.
void SPI_initialise() {
    //Set all SPI pins to idle levels
    setPinDir  (SPIClockPin_Define,OUTPUT); //Clock is output idle high
    setPinValue(SPIClockPin_Define,  HIGH);
    setPinDir  (SPIMISOPin_Define,  INPUT); //MISO is input pull-up
    setPinValue(SPIMISOPin_Define,   HIGH);
    setPinDir  (SPIMOSIPin_Define, OUTPUT); //MOSI is output idle high
    setPinValue(SPIMOSIPin_Define,   HIGH);
    setPinDir  (SPISSnPin_Define,  OUTPUT); //SSn is output idle high
    setPinValue(SPISSnPin_Define,    HIGH);
    //Standalone pin is switching to SPI ready, so ensure we out pull-up is to high.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.
    
    //Now enabled
    softSPIEnabled = true;
}

//Disable the Software SPI by setting all ports back to input pull-up
void SPI_disable() {
    //Set all SPI pins to High-Z
    setPinDir  (SPIClockPin_Define, INPUT);
    setPinValue(SPIClockPin_Define,  HIGH);
    setPinDir  (SPIMISOPin_Define,  INPUT);
    setPinValue(SPIMISOPin_Define,   HIGH);
    setPinDir  (SPIMOSIPin_Define,  INPUT);
    setPinValue(SPIMOSIPin_Define,   HIGH);
    setPinDir  (SPISSnPin_Define,   INPUT);
    setPinValue(SPISSnPin_Define,    HIGH);
    //Now disabled
    softSPIEnabled = false;
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
        setPinValue(SPIClockPin_Define,LOW); //Falling Edge   //--     2 cycles         .
        if (data & 0x80) { //Send MSB first                   //-- 2 cycles | 1 cycle    |
            setPinValue(SPIMOSIPin_Define,HIGH);              //-- 2 cycles | -          |
        } else {                                              //--          | 2 cycles    > 8 cycles for both paths
            nop();                                            //--          | 1 cycle    |
            setPinValue(SPIMOSIPin_Define,LOW);               //--          | 2 cycles   |
        }                                                     //-- 2 cycles | -         '
        setPinValue(SPIClockPin_Define,HIGH); //Rising Edge   //--      2 cycles        .
        data = data << 1; //Shift MSB-1 to MSB                //--      1 cycle          |
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
        }                                                     //--       3 cycles       '
    }                                                         //-- Total Path is 16 cycles = 1MHz @ 16MHz clock
    return data; //Return shifted in data.                    //-- 5 Cycles on entry (including CALL), 3 cycles on exit (including RET)
}

//Performs an SPI read request and stores the data in the RX buffer.
// - If there is no space in the buffer, a read request will *not* be performed
//   The buffer should be first emptied by using Serial_read()
void SPI_read(void) {
    //First we check if there is space in the buffer, and that the slave has data to send
    if ((rxBuf.tail != rxBuf.head) && !(getPinValue(standalonePin[STANDALONE_IRQ]))) {
        //If there is, then do a read request  
        setPinValue(SPISSnPin_Define,LOW); //Select the slave
        SPI_transfer(SPI_READ); //First send a read request
        while(!getPinValue(standalonePin[STANDALONE_IRQ])); //Wait for the slave to have loaded its data
        byte data = SPI_transfer(SPI_RESP); //Then send a response request (clocks data from slave to master and informs slave that transfer is done)
        if (SPI_ISDATA(data)) {
            //If the slave had data available (indicated by the MSB being clear)
            rxBuf.buffer[rxBuf.head] = data; //Store the data
            rxBuf.head++; //And increment the head
        }
        setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    }
}

//Performs an SPI write request.
void SPI_write(byte data) {
    setPinValue(SPISSnPin_Define,LOW); //Select the slave
    SPI_transfer(data & SPI_DATA); 
    setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
}

//Checks if there is any data available in the RX buffer.
// - If in SPI mode, this will also perform an SPI read transfer to see if there is any valid data.
byte Serial_available(void) {
    if (softSPIEnabled) {
        //If SPI is enabled, we do a read to check if there is any data.
        SPI_read();
    }
    return ((rxBuf.head - rxBuf.tail) & BUFFER_PTR_MASK); //number of bytes available
}

//Returns the next available data byte in the buffer
// - If there is nothing there, -1 is returned.
char Serial_read(void) {
    //If UART is enabled
    byte tail = rxBuf.tail;
    if (rxBuf.head == tail) {
        return -1;
    } else {
        char c = rxBuf.buffer[tail];
        rxBuf.tail = ((tail + 1) & BUFFER_PTR_MASK);
        return c;
    }
}

//Write a byte of data
// - If in UART mode, the byte is stored into the TX buffer when there is space.
// - If in SPI mode, a write transfer is performed.
void Serial_write(char ch) {
    if (UCSRnB & _BV(TXENn)) { 
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
        if (head == txBuf.tail) {
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
            while (head == txBuf.tail); //wait for buffer to have some space
        }
        
        txBuf.buffer[txBuf.head] = ch; //Load the new data into the buffer
        txBuf.head = head; //And store the new head.
        sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled if not already
    } else if (softSPIEnabled) {
        //If SPI is enabled, we do an SPI write.
        SPI_write(ch);
    }
}

//Flushes data from TX buffer
void Serial_flush() {
    if (UCSRnB & _BV(TXENn)) { 
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
        if (head == txBuf.tail) {
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
            while (head == txBuf.tail); //wait for buffer to have some space
        }
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    while (*str) {
        Serial_write(*str++);
    }
}

//Convert array to bytes
void Serial_writeArr(char* arr, byte len) {
    while (len--) {
        Serial_write(*arr++);
    }
}

//UART RX IRQ
// - Stores data from UART port into RX ring buffer
ISR(USARTn_RX_vect,ISR_NAKED) {
    register unsigned char c asm("r18");
    register unsigned char head asm("r25");
    register unsigned char tail asm("r24");
    asm volatile (
        "push %0     \n\t"
        "in   %0, %3 \n\t" 
        "push %0     \n\t"
        "push %1     \n\t"
        "push %2     \n\t"
        "push r30    \n\t"
        "push r31    \n\t"
        :
        : "a" (c), "r" (head), "r" (tail), "I" (_SFR_IO_ADDR(SREG))
        :
    );

    //Read in from the serial data register
    c = UDRn;
    //get the current head
    head = rxBuf.head;
    head++;
    head &= BUFFER_PTR_MASK;
    tail = rxBuf.tail;

    if (head != tail) {
        rxBuf.buffer[rxBuf.head] = c;
        rxBuf.head = head;
    } 

    asm volatile (
        "pop r31    \n\t"
        "pop r30    \n\t"
        "pop %2     \n\t"
        "pop %1     \n\t"
        "pop %0     \n\t"
        "out %3, %0 \n\t"
        "pop %0     \n\t"
        "reti       \n\t"
        : "=a" (c), "=r" (head), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
}

//UART TX IRQ
// - Writes data to UART port from TX ring buffer
ISR(USARTn_UDRE_vect, ISR_NAKED)
{
    register unsigned char tail asm("r25");
    register unsigned char temp asm("r24");
    asm volatile (
        "push %0       \n\t"
        "in   %0, %2   \n\t" 
        "push %0       \n\t"
        "push %1       \n\t"
        "push r30      \n\t"
        "push r31      \n\t"
        :: "r" (temp), "r" (tail), "I" (_SFR_IO_ADDR(SREG)):
    );
    tail = txBuf.tail;
    temp = txBuf.head;
    if (temp == tail) {
        // Buffer empty, so disable interrupts
        cbi(UCSRnB, UDRIEn);
    } else {
        // There is more data in the output buffer. Send the next byte
        temp = txBuf.buffer[tail];
        tail++;
        tail &= BUFFER_PTR_MASK;
        txBuf.tail = tail;
        UDRn = temp;
    }

    asm volatile (
        "pop r31    \n\t"
        "pop r30    \n\t"
        "pop %1     \n\t"
        "pop %0     \n\t"
        "out %2, %0 \n\t"
        "pop %0     \n\t"
        "reti       \n\t"
        : "=r" (temp), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
}
ELF          S            @     4     ( : 7 %RU  $ >   :;I  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  I  ! I/  5 I  .?:;   4 :;I  .?:;@@
   :;I  4 :;I  1XY  4 1
  & I  .1@
  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\SerialLink.h"
#ifndef __SERIAL_LINK_H__
#define __SERIAL_LINK_H__

#include "AstroEQ.h"

//Serial Defines
//Select the required serial port with the #define below.
//For ATMega162, valid options are 0. USART1 on the ATMega162 variants must not be used for AstroEQ.
//For Arduino Mega, valid options are 0,1,(2,3) the latter two are untested but should work.
#define SERIALn 0

//Serial Functions
void Serial_initialise(const unsigned long baud);
void Serial_disable();

//SPI Functions
void SPI_initialise();
void SPI_disable();

//Common Functions
byte Serial_available(void);
void Serial_clear(void);
char Serial_read(void);
void Serial_flush(void);
void Serial_write(char ch);
void Serial_writeStr(char* str);
void Serial_writeArr(char* arr, byte len);

#endif //__SERIAL_LINK_H__

/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\synta.cpp"

#include "synta.h"
#include <string.h>


bool validateCommand(byte len);
bool validPacket;
char commandString[11];
byte commandIndex;

byte _axis;
char _command;

void synta_initialise(unsigned long eVal, byte gVal){
    validPacket = 0;
    commandIndex = 0;
    memset(commandString,0,sizeof(commandString));
    _axis = 0;
    Commands_init(eVal, gVal);
}

const char startInChar = ':';
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
        nibble += (('A'-'0')-0xA);
    }
    *hex = (nibble + '0');
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
}

void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData){
    char replyLength = (commandOrError == '\0') ? -1 : Commands_getLength(commandOrError,0); //get the number of data bytes for response

    if (replyLength < 0) {
        replyLength = 0;
        dataPacket[0] = errorChar;  
    } else {
        dataPacket[0] = startOutChar;

        if (replyLength == 2) {
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
        } else if (replyLength == 6) {
            Inter inter = Inter(responseData);
            private_byteToHex(dataPacket+6,dataPacket+5,inter.highByter.lowNibbler);
            private_byteToHex(dataPacket+4,dataPacket+3,inter.lowByter.highNibbler);
            private_byteToHex(dataPacket+2,dataPacket+1,inter.lowByter.lowNibbler);
        }

    }

    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    _command = commandString[0]; //first byte is command
    _axis = commandString[1] - 49; //second byte is axis
    if(_axis > 1){
        return false; //incorrect axis
    }
    char requiredLength = Commands_getLength(_command,1); //get the required length of this command
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
        decoded[i] = commandString[i + 2];
    }
    decoded[i] = '\0'; //Null
    return true;
}

char synta_recieveCommand(char* dataPacket, char character){
    if(validPacket){
        if (character == startInChar){
            dataPacket[0] = errorChar;
            dataPacket[1] = endChar;
            dataPacket[2] = '\0';
            validPacket = 0; //new command without old finishing! (dataPacket contains error message)
            return -2;
        }

        commandString[commandIndex++] = character; //Add character to current string build

        if(character == endChar){
            if(synta_validateCommand(commandIndex, dataPacket)){
                validPacket = 0;
                return _command; //Successful decode (dataPacket contains decoded packet, return value is the current command)
            } else {
                goto error; //Decode Failed (dataPacket contains error message)
            }
        } else if (commandIndex == sizeof(commandString)){
            goto error; //Message too long! (dataPacket contains error message)
        }
    } else if (character == startInChar){
        //Begin new command
        commandIndex = 0;
        validPacket = 1;
        commandString[0] = '\0';
    }
    return 0; //Decode not finished (dataPacket unchanged)
error:
    dataPacket[0] = errorChar;
    dataPacket[1] = endChar;
    dataPacket[2] = '\0';
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    }
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
}

byte synta_hexToByte(char* hex){
    return hexToByte(hex);
}
unsigned long synta_hexToLong(char* hex){
    //  char *boo; //waste point for strtol
    //  char str[7]; //Destination of rearranged hex
    //  strncpy(str,&hex[4],2); //Lower Byte
    //  strncpy(str+2,&hex[2],2); //Middle Byte
    //  strncpy(str+4,hex,2); //Upper Byte
    //  str[6] = 0;
    //  return strtol(str,&boo,16); //convert hex to long integer

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    return inter.integer; //and convert it to an integer
}

char synta_command(){
    return _command;
}

byte synta_axis(byte axis){
    if(axis < 2){
        _axis = axis;
    }
    return _axis;
}

ELF          S            "     4     ( . + %RU  $ >   :;I  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  .?:;<   I4   I  .?:;<   I  :;  I  ! I/  5 I  .?:;    :;I   :;I  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\synta.h"

#ifndef synta_h
#define synta_h

#include "AstroEQ.h"
#include "commands.h"

void synta_initialise(unsigned long version, byte gVal);
void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData);
char synta_recieveCommand(char* dataPacket, char character);
byte synta_axis(byte axis = 2); //make target readonly to outside world.
char synta_command(); //make current command readonly to outside world.
unsigned long synta_hexToLong(char* hex);
byte synta_hexToByte(char* hex);

//Methods for accessing command variables - now in commands.h
//void cmd_setDir(byte target, byte _dir);
//void cmd_updateStepDir(byte target, byte stepSize);
//unsigned int cmd_fVal(byte target);
//void cmd_setStopped(byte target, byte _stopped);
//void cmd_setGotoEn(byte target, byte _gotoEn);
//void cmd_setFVal(byte target, byte _FVal);
//void cmd_setjVal(byte target, unsigned long _jVal);
//void cmd_setIVal(byte target, unsigned int _IVal);
//void cmd_setHVal(byte target, unsigned long _HVal);
//void cmd_setGVal(byte target, byte _GVal);
  
#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\UnionHelpers.h"

#ifndef __UNION_HELPERS_H__
#define __UNION_HELPERS_H__

#include <inttypes.h>
typedef uint8_t byte;

typedef union {
    uint16_t integer;
    uint8_t array[2];
} TwoBytes;

typedef union {
    uint32_t integer;
    uint16_t array[2];
    uint8_t bytes[4];
} FourBytes;

typedef union{
    byte integer;
    struct {
        byte low:4;
        byte high:4;
    };
} Nibbler;

typedef union{
    unsigned int integer;
    struct {
        byte low;
        byte high;
    };
    struct {
        Nibbler lowNibbler;
        Nibbler highNibbler;
    };
} Byter;

typedef union InterMaker{
    unsigned long integer;
    struct {
        byte low;
        byte mid;
        byte high;
        byte top;
    };
    struct {
        Byter lowByter;
        Byter highByter;
    };
    InterMaker(unsigned long _integer){
        integer = _integer;
    }
    InterMaker(byte _top, byte _high, byte _mid, byte _low){
        low = _low;
        mid = _mid;
        high = _high;
        top = _top;
    }
} Inter;

typedef union{
    unsigned int integer;
    struct {
        unsigned int low:4;
        unsigned int mid:4;
        unsigned int high:4;
        unsigned int:4;
    };
    struct {
        Nibbler lowNibbler;
        Nibbler highNibbler;
    };
} DoubleNibbler;

#endif //__UNION_HELPERS_H__
