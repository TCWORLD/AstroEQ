/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ.cpp"
/*
  Code written by Thomas Carpenter 2012-2017
  
  With thanks Chris over at the EQMOD Yahoo group for assisting decoding the Skywatcher protocol
  
  
  Equatorial mount tracking system for integration with EQMOD using the Skywatcher/Synta
  communication protocol.
 
  Works with EQ5, HEQ5, and EQ6 mounts, and also a great many custom mount configurations.
 
  Current Verison: 8.0.2
*/

//Only works with ATmega162, and Arduino Mega boards (1280 and 2560)
#if defined(__AVR_ATmega162__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)


/*
 * Include headers
 */
 
#include "AstroEQ.h" //AstroEQ header

#include "EEPROMReader.h" //Read config file
#include "SerialLink.h" //Serial Port
#include "UnionHelpers.h" //Union prototypes
#include "synta.h" //Synta Communications Protocol.
#include <util/delay.h>    
#include <util/delay_basic.h>
#include <avr/wdt.h>

// Watchdog disable on boot.
void wdt_init(void) __attribute__((naked)) __attribute__((section(".init3")));
void wdt_init(void)
{
    wdt_disable();
    return;
}

/*
 * Defines
 */
//Define the version number
#define ASTROEQ_VER 802

/*
 * Global Variables
 */
byte stepIncrement[2];
byte readyToGo[2] = {0,0};
unsigned long gotoPosn[2] = {0UL,0UL}; //where to slew to
bool encodeDirection[2];
byte progMode = RUNMODE; //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
byte microstepConf;
byte driverVersion;
bool standaloneMode = false; //Initially not in standalone mode (EQMOD mode)
bool syntaMode = true; //And synta processing is enabled.

#define timerCountRate 8000000

#define DecimalDistnWidth 32
unsigned int timerOVF[2][DecimalDistnWidth];
bool canJumpToHighspeed = false;
bool defaultSpeedState = SPEEDNORM;
bool disableGearChange = false;
bool allowAdvancedHCDetection = false;
unsigned int gotoDecelerationLength[2];
byte accelTableRepeatsLeft[2] = {0,0};
byte accelTableIndex[2] = {0,0};

/*
 * Helper Macros
 */
#define distributionSegment(m)      (m ? GPIOR1     : GPIOR2    )
#define currentMotorSpeed(m)        (m ? OCR3A      : OCR3B     )
#define irqToNextStep(m)            (m ? OCR1A      : OCR1B     )
#define interruptOVFCount(m)        (m ? ICR3       : ICR1      )
#define interruptControlRegister(m) (m ? TIMSK3     : TIMSK1    )
#define interruptControlBitMask(m)  (m ? _BV(ICIE3) : _BV(ICIE1))
#define timerCountRegister(m)       (m ? TCNT3      : TCNT1     )
#define timerPrescalarRegister(m)   (m ? TCCR3B     : TCCR1B    )
#define gotoDeceleratingBitMask(m)  (m ? _BV(3)     : _BV(2)    )
#define gotoRunningBitMask(m)       (m ? _BV(1)     : _BV(0)    )
#define gotoControlRegister GPIOR0




/*
 * Inline functions
 */
inline bool gotoRunning(const byte axis) {
    return (gotoControlRegister & gotoRunningBitMask(axis));
}
inline bool gotoDecelerating(const byte axis) {
    return (gotoControlRegister & gotoDeceleratingBitMask(axis));
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
}
inline void clearGotoDecelerating(const byte axis) {
    gotoControlRegister &= ~gotoDeceleratingBitMask(axis);
}



/*
 * Generate Mode Mappings
 */

#define MODE0 0
#define MODE1 1
#define MODE2 2
#define MODE0DIR 3
#define MODE1DIR 4
#define MODE2DIR 5
byte modeState[2] = {((LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0)), (( LOW << MODE2) | ( LOW << MODE1) | (LOW << MODE0))}; //Default to 1/8th stepping as that is the same for all

void buildModeMapping(byte microsteps, byte driverVersion){
    //For microstep modes less than 8, we cannot jump to high speed, so we use the SPEEDFAST mode maps. Given that the SPEEDFAST maps are generated for the microstepping modes >=8
    //anyway, we can simply multiply the number of microsteps by 8 if it is less than 8 and thus reduce the number of cases in the mode generation switch statement below 
    if (microsteps < 8){
        microsteps *= 8;
    }
    //Generate the mode mapping for the current driver version and microstepping modes.
    switch (microsteps) {
        case 8:
            // 1/8
            modeState[SPEEDNORM] =                                                                                       (( LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/1
            modeState[SPEEDFAST] =                                                                                       (( LOW << MODE2) | ( LOW << MODE1) | ( LOW << MODE0));
            break;
        case 32:
            // 1/32
            modeState[SPEEDNORM] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | (HIGH << MODE1) | ( LOW << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/4
            modeState[SPEEDFAST] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | (HIGH << MODE1) | ( LOW << MODE0));
            break;
        case 16:
        default:  //Unknown. Default to half/sixteenth stepping
            // 1/16
            modeState[SPEEDNORM] = (driverVersion == DRV882x) ? ((  LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/2
            modeState[SPEEDFAST] = (driverVersion == DRV882x) ? (( HIGH << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0));
            break;
    }
}




/*
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
}

void calculateRate(byte axis){
  
    unsigned long rate;
    unsigned long remainder;
    float floatRemainder;
    unsigned long divisor = cmd.bVal[axis];
    byte distWidth = DecimalDistnWidth;
    
    //When dividing a very large number by a much smaller on, float accuracy is abismal. So firstly we use integer math to split the division into quotient and remainder
    rate = timerCountRate / divisor; //Calculate the quotient
    remainder = timerCountRate % divisor; //Calculate the remainder
    
    //Then convert the remainder into a decimal number (division of a small number by a larger one, improving accuracy)
    floatRemainder = (float)remainder/(float)divisor; //Convert the remainder to a decimal.
    
    //Multiply the remainder by distributionWidth to work out an approximate number of extra clocks needed per full step (each step is 'distributionWidth' microsteps)
    floatRemainder *= (float)distWidth; 
    //This many extra cycles are needed:
    remainder = (unsigned long)(floatRemainder+0.5f); 
    
    //Now truncate to an unsigned int with a sensible max value (the int is to avoid register issues with the 16 bit timer)
    if((unsigned int)(rate >> 16)){
        rate = 65535UL;
    } else if (rate < 128UL) {
        rate = 128UL;
    }
#if defined(__AVR_ATmega162__)
    rate--;
#endif
  
    for (byte i = 0; i < distWidth; i++){
#if defined(__AVR_ATmega162__)
        timerOVF[axis][i] = rate; //Subtract 1 as timer is 0 indexed.
#else
        timerOVF[axis][i] = rate; //Hmm, for some reason this one doesn't need 1 subtracting???
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
        distn *= (float)distWidth;
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    }
    
}

void systemInitialiser(){    
    
    encodeDirection[RA] = EEPROM_readByte(RAReverse_Address) ? CMD_REVERSE : CMD_FORWARD;  //reverse the right ascension if 1
    encodeDirection[DC] = EEPROM_readByte(DECReverse_Address) ? CMD_REVERSE : CMD_FORWARD; //reverse the declination if 1
    
    driverVersion = EEPROM_readByte(Driver_Address);
    microstepConf = EEPROM_readByte(Microstep_Address);

    allowAdvancedHCDetection = !EEPROM_readByte(AdvHCEnable_Address);
    
    defaultSpeedState = (microstepConf >= 8) ? SPEEDNORM : SPEEDFAST;
    disableGearChange = !EEPROM_readByte(GearEnable_Address);
    canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
        
    synta_initialise(ASTROEQ_VER,(canJumpToHighspeed ? 8 : 1)); //initialise mount instance, specify version!
    
    buildModeMapping(microstepConf, driverVersion);
    
    if(!checkEEPROM()){
        progMode = PROGMODE; //prevent AstroEQ startup if EEPROM is blank.
    }

    calculateRate(RA); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateDecelerationLength(RA);
    calculateDecelerationLength(DC);
    
    //Status pin to output low
    setPinDir  (statusPin,OUTPUT);
    setPinValue(statusPin,   LOW);

    //Standalone Speed/IRQ pin to input no-pullup
    setPinDir  (standalonePin[  STANDALONE_IRQ], INPUT);
    setPinValue(standalonePin[  STANDALONE_IRQ],  HIGH); //enable pull-up to pull IRQ high.

    //Standalone Pullup/Pulldown pin to output high
    setPinDir  (standalonePin[ STANDALONE_PULL],OUTPUT);
    setPinValue(standalonePin[ STANDALONE_PULL],  HIGH);
    
    //ST4 pins to input with pullup
    setPinDir  (st4Pins[RA][ST4P],INPUT);
    setPinValue(st4Pins[RA][ST4P],HIGH );
    setPinDir  (st4Pins[RA][ST4N],INPUT);
    setPinValue(st4Pins[RA][ST4N],HIGH );
    setPinDir  (st4Pins[DC][ST4P],INPUT);
    setPinValue(st4Pins[DC][ST4P],HIGH );
    setPinDir  (st4Pins[DC][ST4N],INPUT);
    setPinValue(st4Pins[DC][ST4N],HIGH );
    
    //Reset pins to output
    setPinDir  (resetPin[RA],OUTPUT);
    setPinValue(resetPin[RA],   LOW);  //Motor driver in Reset
    setPinDir  (resetPin[DC],OUTPUT);
    setPinValue(resetPin[DC],   LOW);  //Motor driver in Reset 
    
    //Enable pins to output
    setPinDir  (enablePin[RA],OUTPUT);
    setPinValue(enablePin[RA],  HIGH); //Motor Driver Disabled
    setPinDir  (enablePin[DC],OUTPUT);
    setPinValue(enablePin[DC],  HIGH); //Motor Driver Disabled
    
    //Step pins to output
    setPinDir  (stepPin[RA],OUTPUT);
    setPinValue(stepPin[RA],   LOW);
    setPinDir  (stepPin[DC],OUTPUT);
    setPinValue(stepPin[DC],   LOW);
    
    //Direction pins to output
    setPinDir  (dirPin[RA],OUTPUT);
    setPinValue(dirPin[RA],   LOW);
    setPinDir  (dirPin[DC],OUTPUT);
    setPinValue(dirPin[DC],   LOW);
    
    //Load the correct mode
    byte state = modeState[defaultSpeedState]; //Extract the default mode - If the microstep mode is >= then we start in NORMAL mode, otherwise we use FAST mode

    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    setPinDir  (modePins[RA][MODE0],  OUTPUT                      ); 
    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    setPinDir  (modePins[DC][MODE0],  OUTPUT                      );
    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    setPinDir  (modePins[RA][MODE1],  OUTPUT                      );
    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    setPinDir  (modePins[DC][MODE1],  OUTPUT                      );
    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    setPinDir  (modePins[RA][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    setPinDir  (modePins[DC][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.

    //Give some time for the Motor Drivers to reset.
    _delay_ms(1);

    //Then bring them out of reset.
    setPinValue(resetPin[RA],HIGH);
    setPinValue(resetPin[DC],HIGH);
    
#if defined(__AVR_ATmega162__)
    //Disable Timer 0
    //Timer 0 registers are being used as general purpose data storage for high efficency
    //interrupt routines. So timer must be fully disabled. The ATMegaxxx0 has three of these
    //registers, but the ATMega162 doesn't, so I've had to improvise and use other registers
    //instead. See PinMappings.h for the ATMega162 to see which registers have been #defined
    //as GPIORx.
    TIMSK &= ~(_BV(TOIE0) | _BV(OCIE0));
    TCCR0 = 0;
#endif

    //Ensure SPI is disabled
    SPI_disable();
    
    //Initialise the Serial port:
    Serial_initialise(BAUD_RATE); //SyncScan runs at 9600Baud, use a serial port of your choice as defined in SerialLink.h
      
}




/*
 * EEPROM Validation and Programming Routines
 */

bool checkEEPROM(){
    char temp[9] = {0};
    EEPROM_readString(temp,8,AstroEQID_Address);
    if(strncmp(temp,"AstroEQ",8)){
        return false;
    }
    if (driverVersion > DRV8834){
        return false; //invalid value.
    }
    if ((driverVersion == A498x) && microstepConf > 16){
        return false; //invalid value.
    } else if (microstepConf > 32){
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[RA] > 1200) || (cmd.siderealIVal[RA] < MIN_IVAL)) {
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[DC] > 1200) || (cmd.siderealIVal[DC] < MIN_IVAL)) {
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[RA] == 0){
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[DC] == 0){
        return false; //invalid value.
    }
    if((cmd.st4SpeedFactor < 1) || (cmd.st4SpeedFactor > 19)){
        return false; //invalid value
    }
    return true;
}

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
}

void storeEEPROM(){
    EEPROM_writeLong(cmd.aVal[RA],aVal1_Address);
    EEPROM_writeLong(cmd.aVal[DC],aVal2_Address);
    EEPROM_writeLong(cmd.bVal[RA],bVal1_Address);
    EEPROM_writeLong(cmd.bVal[DC],bVal2_Address);
    EEPROM_writeLong(cmd.sVal[RA],sVal1_Address);
    EEPROM_writeLong(cmd.sVal[DC],sVal2_Address);
    EEPROM_writeByte(encodeDirection[RA],RAReverse_Address);
    EEPROM_writeByte(encodeDirection[DC],DECReverse_Address);
    EEPROM_writeByte(driverVersion,Driver_Address);
    EEPROM_writeByte(microstepConf,Microstep_Address);
    EEPROM_writeByte(cmd.normalGotoSpeed[RA],RAGoto_Address);
    EEPROM_writeByte(cmd.normalGotoSpeed[DC],DECGoto_Address);
    EEPROM_writeInt(cmd.siderealIVal[RA],IVal1_Address);
    EEPROM_writeInt(cmd.siderealIVal[DC],IVal2_Address);
    EEPROM_writeByte(!disableGearChange, GearEnable_Address);
    EEPROM_writeByte(!allowAdvancedHCDetection, AdvHCEnable_Address);
    EEPROM_writeInt(cmd.st4DecBacklash, DecBacklash_Address);
    EEPROM_writeByte(cmd.st4SpeedFactor, SpeedFactor_Address);
    EEPROM_writeAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address);
    EEPROM_writeAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address);
}









/*
 * Standalone Helpers
 */

byte standaloneModeTest() {
    //We need to test what sort of controller is attached.
    //The IRQ pin on the ST4 connector is used to determine this. It has the following
    //states:
    //   FLOAT      | No handcontroller
    //   DRIVE LOW  | Basic handcontroller
    //   DRIVE HIGH | Advanced handcontroller
    //We can test for each of these states by virtue of having a controllable pull up/down
    //resistor on that pin.
    //If we pull down and the pin stays high, then pin must be driven high (DRIVE HIGH)
    //If we pull up and the pin stays low, then pin must be driven low (DRIVE LOW)
    //Otherwise if pin follows us then it must be floating.

    //To start we check for an advanced controller
    setPinValue(standalonePin[STANDALONE_PULL],LOW); //Pull low
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(allowAdvancedHCDetection && getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Note: Must be an advanced controller as pin stayed high and we are allowing HC detection. (If HC detection is disallowed its because we have no external pull down available)
        return ADVANCED_HC_MODE;
    }
    //Otherwise we check for a basic controller
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Convert to external pull-up of IRQ
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Must be a basic controller as pin stayed low.
        return BASIC_HC_MODE;
    }


    //If we get this far then it is floating, so we assume EQMOD mode
    return EQMOD_MODE;
}


byte checkBasicHCSpeed() {
    //Here we check what the speed is for the basic hand controller.
    //
    //By using both external and internal pull-ups, the following three speeds are possible:
    // +-----------+-----+-----+
    // |  Pull-Up: | Ext | Int |
    // +-----------+-----+-----+
    // | ST-4 Rate |  0  |  0  |
    // |   2x Rate |  1  |  0  |
    // | GoTo Rate |  1  |  1  |
    // +-----------+-----+-----+
    //
    //Note: if we don't have an external pull-up resistor, this function will return either ST-4 Rate (0,0) or GoTo Rate (1,1)
    //
    byte speed;
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Must be a ST-4 rate as IRQ pin is low when external pull-up enabled
        speed = CMD_ST4_DEFAULT;
    } else {
        //Otherwise check which high-speed mode it is
        setPinDir  (standalonePin[STANDALONE_PULL],INPUT); //Disable external resistor by switching to input
        setPinValue(standalonePin[STANDALONE_PULL],LOW);   //with no internal pull-up (we are using the IRQ pin internal pull-up)
        nop(); // Input synchroniser takes a couple of cycles
        nop();
        nop();
        nop();
        
        if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
            //Must be a 2x rate as IRQ pin goes low when external pull-up disabled
            speed = CMD_ST4_STANDALONE;
        } else {
            speed = CMD_ST4_HIGHSPEED;
        }
    }
    setPinDir  (standalonePin[STANDALONE_PULL],OUTPUT); //Ensure we leave an external pull-up of IRQ.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH);
    //And return the new speed
    return speed;
}



/*
 * AstroEQ firmware main() function
 */

int main(void) {
    //Enable global interrupt flag
    sei();
    //Initialise global variables from the EEPROM
    systemInitialiser();
    
    bool mcuReset = false; //Not resetting the MCU after programming command
    
    bool isST4Move[2] = {false, false};
    
    unsigned int loopCount = 0;
    char recievedChar = 0; //last character we received
    int8_t decoded = 0; //Whether we have decoded the packet
    char decodedPacket[11]; //temporary store for completed command ready to be processed
    
    for(;;){ //Run loop

        loopCount++; //Counter used to time events based on number of loops.

        if (!standaloneMode && (loopCount == 0)) { 
            //If we are not in standalone mode, periodically check if we have just entered it
            byte mode = standaloneModeTest();
            if (mode != EQMOD_MODE) {
                //If we have just entered stand-alone mode, then we enable the motors and configure the mount
                motorStop(RA, true); //Ensure both motors are stopped
                motorStop(DC, true);
                
                //This next bit needs to be atomic
                byte oldSREG = SREG; 
                cli();  
                cmd_setjVal(RA, 0x800000); //set the current position to the middle
                cmd_setjVal(DC, 0x800000); //set the current position to the middle
                SREG = oldSREG;
                //End atomic
                //Disable Serial
                Serial_disable();
    
                //We are now in standalone mode.
                standaloneMode = true; 
                
                //Next check what type of hand controller we have
                if (mode == ADVANCED_HC_MODE) {
                    //We pulled low, but pin stayed high
                    //This means we must have an advanced controller actively pulling the line high
                    syntaMode = true; 
                    
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
                    Serial_writeStr(welcome); //Send error packet to trigger controller state machine.
                    
                } else {
                    //Pin either is being pulled low by us or by something else
                    //This means we might have a basic controller actively pulling the line low
                    //Even if we don't we would default to basic mode.
                    syntaMode = false;
                    
                    //High speed not supported in Basic HC
                    canJumpToHighspeed = false;
                    
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
                    
                    Commands_configureST4Speed(CMD_ST4_DEFAULT); //Change the ST4 speeds to default
                    
                    motorEnable(RA); //Ensure the motors are enabled
                    motorEnable(DC);
                    
                    cmd_setGVal      (RA, 1); //Set both axes to slew mode.
                    cmd_setGVal      (DC, 1);
                    cmd_setDir       (RA, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA ,1);
                    cmd_setDir       (DC, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA,1);
                    cmd_setIVal      (RA, cmd.siderealIVal[RA]); //Set RA speed to sidereal
                    
                    readyToGo[RA] = 1; //Signal we are ready to go on the RA axis to start sideral tracking
                }
            }
            //If we end up in standalone mode, we don't exit until a reset.
        }

        /////////////
        if (syntaMode) {
        //
        // EQMOD or Advanced Hand Controller Synta Mode
        //
            //Check if we need to run the command parser
            
            if ((decoded == -2) || Serial_available()) { //is there a byte in buffer or we still need to process the previous byte?
                //Toggle on the LED to indicate activity.
                togglePin(statusPin);
                //See what character we need to parse
                if (decoded != -2) {
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
                //Once full command packet recieved, synta_recieveCommand populates either an error packet (and returns -1), or data packet (returns 1). If incomplete, decodedPacket is unchanged and 0 is returned
                if (decoded != 0){ //Send a response
                    if (decoded > 0){ //Valid Packet, current command is in decoded variable.
                        mcuReset = !decodeCommand(decoded,decodedPacket); //decode the valid packet and populate response.
                    }
                    Serial_writeStr(decodedPacket); //send the response packet (recieveCommand() generated the error packet, or decodeCommand() a valid response)
                } //otherwise command not yet fully recieved, so wait for next byte
                
                if (mcuReset) {
                    //Special case. We were asked to reset the MCU.
                    Serial_flush(); //Flush out last response.
                    wdt_enable(WDTO_120MS); //WDT has been set to reset MCU.
                    exit(0); //Done
                }
            }
            if (loopCount == 0) {
                setPinValue(statusPin, 0);
            }
            
            //
            //ST4 button handling
            //
            if (!standaloneMode && ((loopCount & 0xFF) == 0)){
                //We only check the ST-4 buttons in EQMOD mode when not doing Go-To, and only every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //In Synta mode, we only allow the ST-4 port to move forward, and only if EQMOD has configured us previously to be in tracking mode
                    if ((cmd.dir[RA] == CMD_FORWARD) && (readyToGo[RA] == 2)) {
                        //Determine which ST4 pin if any
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                        //Update target speed.
                        if (st4Pin != ST4O) {
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
                            isST4Move[RA] = true; //Now doing ST4 movement
                        }
                        else if (isST4Move[RA]) { 
                            //Only return to sidereal speed if we are in an ST4 move.
                            cmd_setIVal(RA,cmd.siderealIVal[RA]);
                            motorStartRA();
                            isST4Move[RA] = false; //No longer ST4 movement
                        }
                    }
                }//End RA
                
                if (!cmd.gotoEn[DC]) {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir)) {
                        //If we are currently moving in the wrong direction
                        motorStopDC(false); //Stop the Dec motor
                        readyToGo[DC]=0;    //No longer ready to go as we have now deleted any pre-running EQMOD movement.
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
                            isST4Move[DC] = true; //Now doing ST4 movement
                        } else if (isST4Move[DC]) {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
                            isST4Move[DC] = false; //No longer ST4 movement
                        }
                    }
                }//End DEC
            }
            
            //Check both axes - loop unravelled for speed efficiency - lots of Flash available.
            if(readyToGo[RA]==1){
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[RA] == CMD_STOPPED){
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[RA];
                    if (canJumpToHighspeed){
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
                            cmd_updateStepDir(RA,1);
                            cmd.highSpeedMode[RA] = false;
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
                            cmd_updateStepDir(RA,cmd.gVal[RA]);
                            cmd.highSpeedMode[RA] = true;
                        }
                        setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0)));
                        setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1)));
                        setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2)));
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(RA,1); //Just move along at one step per step
                        cmd.highSpeedMode[RA] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(RA); //Slew type
                        readyToGo[RA] = 2;
                    } else {
                        //This is the function for goto mode. You may need to customise it for a different motor driver
                        gotoMode(RA); //Goto Mode
                        readyToGo[RA] = 0;
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
            if(readyToGo[DC]==1){
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[DC] == CMD_STOPPED){
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[DC];
                    if (canJumpToHighspeed){
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
                            cmd_updateStepDir(DC,1);
                            cmd.highSpeedMode[DC] = false;
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
                            cmd_updateStepDir(DC,cmd.gVal[DC]);
                            cmd.highSpeedMode[DC] = true;
                        }
                        setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0)));
                        setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1)));
                        setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2)));
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(DC,1); //Just move along at one step per step
                        cmd.highSpeedMode[DC] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(DC); //Slew type
                        readyToGo[DC] = 2; //We are now in a running mode which speed can be changed without stopping motor (unless a command changes the direction)
                    } else {
                        //This is the function for goto mode.
                        gotoMode(DC); //Goto Mode
                        readyToGo[DC] = 0; //We are now in a mode where no further changes can be made to the motor (apart from requesting a stop) until the go-to movement is done.
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
        //////////
        } else {
        //
        // ST4 Basic Hand Controller Mode
        //
            if (loopCount == 0) {
                //we run these checks every so often, not all the time.
                
                //Update status LED
                togglePin(statusPin); //Toggle status pin at roughly constant rate in basic mode as indicator
                
                //Check the speed
                byte newBasicHCSpeed = checkBasicHCSpeed();
                if (newBasicHCSpeed != cmd.st4Mode) {
                    //Only update speed if changed.
                    Commands_configureST4Speed(newBasicHCSpeed); //Change the ST4 speeds
                }
            }
            
            //
            //NESW button handling - uses ST4 pins
            //
            if ((loopCount & 0xFF) == 0){
                //We only check the buttons every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
                    if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] != dir) && (currentMotorSpeed(RA) < cmd.minSpeed[RA])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
                        cmd_setDir(RA,dir);
                        cmd_updateStepDir(RA,1);
                        if ((st4Pin == ST4O) && (cmd.st4Mode == CMD_ST4_HIGHSPEED)) {
                            motorStopRA(false); //If no buttons pressed and in high speed mode, we stop entirely rather than going to tracking
                                                //This ensures that the motors stop if the handcontroller is subsequently unplugged.
                        } else {
                            motorStartRA(); //If the motor is currently stopped at this point, this will automatically start them.
                        }
                    }
                    SREG = oldSREG; //End atomic
                }//End RA
                
                {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopDC(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
                        } else {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
                        }
                    }
                    SREG = oldSREG; //End atomic
                }//End DEC
            }
        ///////////
        }
        
        
    }//End of run loop
}

/*
#ifdef ALTERNATE_ST4
ISR(PCINT2_vect)
#else
ISR(PCINT0_vect)
#endif
{
    //ST4 Pin Change Interrupt Handler.
    if(!cmd.gotoEn[RA] && !cmd.gotoEn[DC]){
        //Only allow when not it goto mode.
        {//Start RA
            //Determine which if any ST4 Pin
            char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
            if (syntaMode) {
                //In Synta mode, we only allow the ST-4 port to move forward, and not to automatically start moving
                if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] == CMD_FORWARD)) {
                    //If we are not stopped and we are moving in the correct direction, update speed.
                    cmd.currentIVal[RA] = (st4Pin != ST4O) ? cmd.st4RAIVal[st4Pin] :  cmd.siderealIVal[RA];
                    //Ensure that if the new speed is slower than the stopping speed that we don't stop
                    cmd.stopSpeed[RA] = (cmd.currentIVal[RA] < cmd.minSpeed[RA]) ? cmd.minSpeed[RA] : cmd.currentIVal[RA];
                }
            } 
        }//End RA

        {//Start DEC
            //Determine which if any ST4 Pin
            char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
            //Determine the new direction
            byte dir = CMD_FORWARD;
            char stepDir = 1;
            if (st4Pin == ST4N) {
                //If requested reverse, switch direction
                dir = CMD_REVERSE;
                stepDir = -1;
            }
            if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//make our target >stopSpeed so that ISRs bring us to a halt.
            } else {
                //Otherwise we are now free to change to the new required speed.
                //Set to correct direction
                cmd.stepDir[DC] = stepDir; //set step direction
                cmd.dir[DC] = dir; //set direction
                //Then update speed
                if (st4Pin != ST4O) {
                    //If an ST4 Dec pin is pressed
                    if (cmd.stopped[DC] != CMD_STOPPED) {
                        //If running, update to new required speed directly
                        cmd.currentIVal[DC] = cmd.st4DecIVal;
                        //Ensure that if the new speed is slower than the stopping speed that we don't stop
                        cmd.stopSpeed[DC] = (cmd.currentIVal[DC] < cmd.minSpeed[DC]) ? cmd.minSpeed[DC] : cmd.currentIVal[DC];
                    } else  {
                        //Otherwise we are stopped when we should be moving.
                        //First lets update global IVal
                        cmd.IVal[DC] = cmd.st4DecIVal;
                        //Then trigger main() loop to start us moving
                        readyToGo[DC]=1;
                    }
                } else {
                    //Otherwise stop
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;
                }
                //If the motor is currently stopped at this point when it should be moving, the main() function will automatically start it at the IVal.
            }
        }//End DEC
    }
}
*/

/*
 * Decode and Perform the Command
 */

bool decodeCommand(char command, char* buffer){ //each command is axis specific. The axis being modified can be retrieved by calling synta_axis()
    unsigned long responseData = 0; //data for response
    bool success = true;
    byte axis = synta_axis();
    unsigned int correction;
    byte oldSREG;
    switch(command) {
        case 'e': //readonly, return the eVal (version number)
            responseData = cmd.eVal[axis]; //response to the e command is stored in the eVal function for that axis.
            break;
        case 'a': //readonly, return the aVal (steps per axis)
            responseData = cmd.aVal[axis]; //response to the a command is stored in the aVal function for that axis.
            break;
        case 'b': //readonly, return the bVal (sidereal step rate)
            responseData = cmd.bVal[axis]; //response to the b command is stored in the bVal function for that axis.
            if (!progMode) {
                //If not in programming mode, we need to apply a correction factor to ensure that calculations in EQMOD round correctly
                correction = (cmd.siderealIVal[axis] << 1);
                responseData = (responseData * (correction+1))/correction; //account for rounding inside Skywatcher DLL.
            }
            break;
        case 'g': //readonly, return the gVal (high speed multiplier)
            responseData = cmd.gVal[axis]; //response to the g command is stored in the gVal function for that axis.
            break;
        case 's': //readonly, return the sVal (steps per worm rotation)
            responseData = cmd.sVal[axis]; //response to the s command is stored in the sVal function for that axis.
            break;
        case 'f': //readonly, return the fVal (axis status)
            responseData = cmd_fVal(axis); //response to the f command is stored in the fVal function for that axis.
            break;
        case 'j': //readonly, return the jVal (current position)
            oldSREG = SREG; 
            cli();  //The next bit needs to be atomic, just in case the motors are running
            responseData = cmd.jVal[axis]; //response to the j command is stored in the jVal function for that axis.
            SREG = oldSREG;
            break;
        case 'K': //stop the motor, return empty response
            motorStop(axis,0); //normal ISR based decelleration trigger.
            readyToGo[axis] = 0;
            break;
        case 'L':
            motorStop(axis,1); //emergency axis stop.
            motorDisable(axis); //shutdown driver power.
            break;
        case 'G': //set mode and direction, return empty response
            /*if (packetIn[0] == '0'){
              packetIn[0] = '2'; //don't allow a high torque goto. But do allow a high torque slew.
            }*/
            cmd_setGVal(axis, (buffer[0] - '0')); //Store the current mode for the axis
            cmd_setDir(axis, (buffer[1] != '0') ? CMD_REVERSE : CMD_FORWARD); //Store the current direction for that axis
            readyToGo[axis] = 0;
            break;
        case 'H': //set goto position, return empty response (this sets the number of steps to move from cuurent position if in goto mode)
            cmd_setHVal(axis, synta_hexToLong(buffer)); //set the goto position container (convert string to long first)
            readyToGo[axis] = 0;
            break;
        case 'I': //set slew speed, return empty response (this sets the speed to move at if in slew mode)
            responseData = synta_hexToLong(buffer); //convert string to long first
            if (responseData < cmd.accelTable[axis][AccelTableLength-1].speed) {
                //Limit the IVal to the largest speed in the acceleration table to prevent sudden rapid acceleration at the end.
                responseData = cmd.accelTable[axis][AccelTableLength-1].speed; 
            }
            cmd_setIVal(axis, responseData); //set the speed container
            responseData = 0;
            if (readyToGo[axis] == 2) {
                //If we are in a running mode which allows speed update without motor reconfiguration
                motorStart(axis); //Simply update the speed.
            } else {
                //Otherwise we are no longer ready to go until the next :J command is received
                readyToGo[axis] = 0;
            }
            break;
        case 'E': //set the current position, return empty response
            oldSREG = SREG; 
            cli();  //The next bit needs to be atomic, just in case the motors are running
            cmd_setjVal(axis, synta_hexToLong(buffer)); //set the current position (used to sync to what EQMOD thinks is the current position at startup
            SREG = oldSREG;
            break;
        case 'F': //Enable the motor driver, return empty response
            if (progMode == 0) { //only allow motors to be enabled outside of programming mode.
                motorEnable(axis); //This enables the motors - gives the motor driver board power
            } else {
                command = 0; //force sending of error packet!.
            }
            break;
            
        //Command required for entering programming mode. All other programming commands cannot be used when progMode = 0 (normal ops)
        case 'O': //set the programming mode.
            progMode = buffer[0] - '0';              //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
            if (progMode != 0) {
                motorStop(RA,1); //emergency axis stop.
                motorDisable(RA); //shutdown driver power.
                motorStop(DC,1); //emergency axis stop.
                motorDisable(DC); //shutdown driver power.
                readyToGo[RA] = 0;
                readyToGo[DC] = 0;
            } else { //reset the uC to return to normal ops mode.
                success = false;
            }
            break;

        default:
            //Prevent any chance of accidentally running configuration commands when not in programming mode.
            if (progMode != 0) {
                //The following are used for configuration ----------
                switch(command) {
                    case 'A': //store the aVal (steps per axis)
                        cmd_setaVal(axis, synta_hexToLong(buffer)); //store aVal for that axis.
                        break;
                    case 'B': //store the bVal (sidereal rate)
                        cmd_setbVal(axis, synta_hexToLong(buffer)); //store bVal for that axis.
                        break;
                    case 'S': //store the sVal (steps per worm rotation)
                        cmd_setsVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
                        break;
                    case 'n': //return the IVal (EQMOD Speed at sidereal)
                        responseData = cmd.siderealIVal[axis];
                        break;
                    case 'N': //store the IVal (EQMOD Speed at sidereal)
                        cmd_setsideIVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
                        break;
                    case 'd': //return the driver version or step mode
                        if (axis) {
                            responseData = microstepConf; 
                        } else {
                            responseData = driverVersion;
                        }
                        break;
                    case 'D': //store the driver verison and step modes
                        if (axis) {
                            microstepConf = synta_hexToByte(buffer); //store step mode.
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
                        } else {
                            driverVersion = synta_hexToByte(buffer); //store driver version.
                        }
                        break;
                    case 'r': //return the dec backlash or st4 speed factor
                        if (axis) {
                            responseData = cmd.st4DecBacklash; 
                        } else {
                            responseData = cmd.st4SpeedFactor;
                        }
                        break;
                    case 'R': //store the dec backlash or st4 speed factor
                        if (axis) {
                            unsigned long dataIn = synta_hexToLong(buffer); //store step mode.
                            if (dataIn > 65535) {
                                command = '\0'; //If the step rate is out of range, force an error response packet.
                            } else {
                                cmd_setst4DecBacklash(dataIn); //store st4 speed factor
                            }
                        } else {
                            byte factor = synta_hexToByte(buffer);
                            if ((factor > 19) || (factor < 1)) {
                                command = '\0'; //If the factor is out of range, force an error response packet.
                            } else {
                                cmd_setst4SpeedFactor(factor); //store st4 speed factor
                            }
                        }
                        break;
                    case 'z': //return the Goto speed
                        responseData = cmd.normalGotoSpeed[axis];
                        break;
                    case 'Z': //return the Goto speed factor
                        cmd.normalGotoSpeed[axis] = synta_hexToByte(buffer); //store the goto speed factor
                        break;
                    case 'c': //return the axisDirectionReverse
                        responseData = encodeDirection[axis];
                        break;
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
                            responseData = disableGearChange; 
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
                        } else {
                            responseData = allowAdvancedHCDetection;
                        }
                        break;
                    case 'Q': //store the disableGearChange/allowAdvancedHCDetection setting
                        if (axis) {
                            disableGearChange = synta_hexToByte(buffer); //store whether we can change gear
                        } else {
                            allowAdvancedHCDetection = synta_hexToByte(buffer); //store whether to allow advanced hand controller detection
                        }
                        break;
                    case 'x': {  //return the accelTable
                        Inter responsePack = InterMaker(0);
                        responsePack.lowByter.integer = cmd.accelTable[axis][accelTableIndex[axis]].speed;
                        responsePack.highByter.low = cmd.accelTable[axis][accelTableIndex[axis]].repeats; 
                        responseData = responsePack.integer;
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if reading sequentially.
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            accelTableIndex[axis] = 0; //Wrap around
                        }
                        break;
                    }
                    case 'X': { //store the accelTable value for address set by 'Y', or next address after last 'X'
                        unsigned long dataIn = synta_hexToLong(buffer);
                        cmd.accelTable[axis][accelTableIndex[axis]].speed = (unsigned int)dataIn; //lower two bytes is speed
                        cmd.accelTable[axis][accelTableIndex[axis]].repeats = (byte)(dataIn>>16); //upper byte is repeats.
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if programming sequentially.
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            accelTableIndex[axis] = 0; //Wrap around
                        }
                        break;
                    }
                    case 'Y': //store the accelTableIndex value
                        //Use axis=0 to set which address we are accessing (we'll repurpose accelTableIndex[RA] in prog mode for this)
                        accelTableIndex[axis] = synta_hexToByte(buffer);
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            command = '\0'; //If the address out of range, force an error response packet.
                        }
                        break;
                    case 'T': //set mode, return empty response
                        if (progMode & 2) {
                        //proceed with eeprom write
                            if (progMode & 1) {
                                buildEEPROM();
                            } else {
                                storeEEPROM();
                            }
                        } else if (progMode & 1) {
                            if (!checkEEPROM()) { //check if EEPROM contains valid data.
                                command = 0; //force sending of an error packet.
                            }
                        }
                        break;
                    //---------------------------------------------------
                    default: //Return empty response (deals with commands that don't do anything before the response sent (i.e 'J', 'R'), or do nothing at all (e.g. 'M') )
                        break;
                }
            }
            break;
    }
  
    synta_assembleResponse(buffer, command, responseData); //generate correct response (this is required as is)
    
    if ((command == 'J') && (progMode == 0)) { //J tells us we are ready to begin the requested movement.
        readyToGo[axis] = 1; //So signal we are ready to go and when the last movement complets this one will execute.
        if (!(cmd.GVal[axis] & 1)){
            //If go-to mode requested
            cmd_setGotoEn(axis,CMD_ENABLED);
        }
    }
    return success;
}










void motorEnable(byte axis){
    if (axis == RA){
        setPinValue(enablePin[RA],LOW); //IC enabled
        cmd_setFVal(RA,CMD_ENABLED);
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
        cmd_setFVal(DC,CMD_ENABLED);
    }
    configureTimer(); //setup the motor pulse timers.
}

void motorDisable(byte axis){
    if (axis == RA){
        setPinValue(enablePin[RA],HIGH); //IC enabled
        cmd_setFVal(RA,CMD_DISABLED);
    } else {
        setPinValue(enablePin[DC],HIGH); //IC enabled
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
}

void gotoMode(byte axis){
    unsigned int decelerationLength = gotoDecelerationLength[axis];
    
    if (cmd.highSpeedMode[axis]) {
        //Additionally in order to maintain the same speed profile in high-speed mode, we actually increase the profile repeats by a factor of sqrt(8)
        //compared with running in normal-speed mode. See Atmel AVR466 app note for calculation.
        decelerationLength = decelerationLength * 3; //multiply by 3 as it is approx sqrt(8)
    }
    
    byte dirMagnitude = abs(cmd.stepDir[axis]);
    byte dir = cmd.dir[axis];

    if (cmd.HVal[axis] < 2*dirMagnitude){
        cmd_setHVal(axis,2*dirMagnitude);
    }

    decelerationLength = decelerationLength * dirMagnitude;
    //decelleration length is here a multiple of stepDir.
    unsigned long HVal = cmd.HVal[axis];
    unsigned long halfHVal = (HVal >> 1);
    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    if(dirMagnitude == 8){
        HVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
    }
    if(dirMagnitude == 8){
        halfHVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
    }
    //HVal and halfHVal are here a multiple of stepDir
    if (halfHVal < decelerationLength) {
        decelerationLength = halfHVal;
    }
    HVal -= decelerationLength;
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
    
    cmd_setIVal(axis, gotoSpeed);
    clearGotoDecelerating(axis);
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStart functions (one for RA and one for DEC)
void motorStart(byte motor){
    if (motor == RA) {
        motorStartRA();
    } else {
        motorStartDC();
    }
}

void motorStartRA(){
    unsigned int IVal = cmd.IVal[RA];
    unsigned int currentIVal;
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
    currentIVal = currentMotorSpeed(RA);
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    
    if (IVal > cmd.minSpeed[RA]){
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[RA];
    }
    if(cmd.stopped[RA]) {
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[RA]) {
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
    cmd.currentIVal[RA] = cmd.IVal[RA];
    currentMotorSpeed(RA) = startSpeed;
    cmd.stopSpeed[RA] = stoppingSpeed;
    setPinValue(dirPin[RA],(encodeDirection[RA] != cmd.dir[RA]));
    
    if(cmd.stopped[RA]) { //if stopped, configure timers
        irqToNextStep(RA) = 1;
        accelTableRepeatsLeft[RA] = cmd.accelTable[RA][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
        accelTableIndex[RA] = 0;
        distributionSegment(RA) = 0;
        timerCountRegister(RA) = 0;
        interruptOVFCount(RA) = timerOVF[RA][0];
        timerEnable(RA);
        cmd_setStopped(RA, CMD_RUNNING);
    }
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
}

void motorStartDC(){
    unsigned int IVal = cmd.IVal[DC];
    unsigned int currentIVal;
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
    currentIVal = currentMotorSpeed(DC);
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
    
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    if (IVal > cmd.minSpeed[DC]){
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[DC];
    }
    if(cmd.stopped[DC]) {
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[DC]) {
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
    cmd.currentIVal[DC] = cmd.IVal[DC];
    currentMotorSpeed(DC) = startSpeed;
    cmd.stopSpeed[DC] = stoppingSpeed;
    setPinValue(dirPin[DC],(encodeDirection[DC] != cmd.dir[DC]));
    
    if(cmd.stopped[DC]) { //if stopped, configure timers
        irqToNextStep(DC) = 1;
        accelTableRepeatsLeft[DC] = cmd.accelTable[DC][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
        accelTableIndex[DC] = 0;
        distributionSegment(DC) = 0;
        timerCountRegister(DC) = 0;
        interruptOVFCount(DC) = timerOVF[DC][0];
        timerEnable(DC);
        cmd_setStopped(DC, CMD_RUNNING);
    }
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStop functions (one for RA and one for DEC)
void motorStop(byte motor, byte emergency){
    if (motor == RA) {
        motorStopRA(emergency);
    } else {
        motorStopDC(emergency);
    }
}

void motorStopRA(bool emergency){
    if (emergency) {
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(RA);
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
        clearGotoRunning(RA);
    } else if (!cmd.stopped[RA]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
        //trigger ISR based decelleration
        //readyToGo[RA] = 0;
        byte oldSREG = SREG;
        cli();
        cmd_setGotoEn(RA,CMD_DISABLED); //No longer in goto mode.
        clearGotoRunning(RA);
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        //interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
        if(cmd.currentIVal[RA] < cmd.minSpeed[RA]){
            if(cmd.stopSpeed[RA] > cmd.minSpeed[RA]){
                cmd.stopSpeed[RA] = cmd.minSpeed[RA];
            }
        }/* else {
            stopSpeed[RA] = cmd.currentIVal[RA];
        }*/
        cmd.currentIVal[RA] = cmd.stopSpeed[RA] + 1;//cmd.stepIncrement[motor];
        SREG = oldSREG;
        //interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    }
}

void motorStopDC(bool emergency){
    if (emergency) {
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(DC);
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
        clearGotoRunning(DC);
    } else if (!cmd.stopped[DC]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
        //trigger ISR based decelleration
        //readyToGo[motor] = 0;
        byte oldSREG = SREG;
        cli();
        cmd_setGotoEn(DC,CMD_DISABLED); //No longer in goto mode.
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        clearGotoRunning(DC);
        //interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
        if(cmd.currentIVal[DC] < cmd.minSpeed[DC]){
            if(cmd.stopSpeed[DC] > cmd.minSpeed[DC]){
                cmd.stopSpeed[DC] = cmd.minSpeed[DC];
            }
        }/* else {
        stopSpeed[DC] = cmd.currentIVal[DC];
        }*/
        cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//cmd.stepIncrement[motor];
        SREG = oldSREG;
        //interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
    }
}

//Timer Interrupt-----------------------------------------------------------------------------
void configureTimer(){
    interruptControlRegister(DC) = 0; //disable all timer interrupts.
#if defined(__AVR_ATmega162__)
    interruptControlRegister(RA) &= 0b00000011; //for 162, the lower 2 bits of the declination register control another timer, so leave them alone.
#else
    interruptControlRegister(RA) = 0;
#endif
    //set to ctc mode (0100)
    TCCR1A = 0;//~((1<<WGM11) | (1<<WGM10));
    TCCR1B = ((1<<WGM12) | (1<<WGM13));
    TCCR3A = 0;//~((1<<WGM31) | (1<<WGM30));
    TCCR3B = ((1<<WGM32) | (1<<WGM33));
}



/*Timer Interrupt Vector*/
ISR(TIMER3_CAPT_vect) {
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(DC)-1;
    //Check if we are ready to step
    if (irqToNext == 0) {
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(DC); //Get the current time segement
        
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(DC) = timerOVF[DC][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(DC) = *(int*)((byte*)timerOVF[DC] + index); //Update interrupt base rate.
        
        distributionSegment(DC) = timeSegment + 1; //Increment time segement for next time.

        unsigned int currentSpeed = currentMotorSpeed(DC); //Get the current motor speed
        irqToNextStep(DC) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
        
        if (getPinValue(stepPin[DC])){
            //If the step pin is currently high...
            
            setPinValue(stepPin[DC],LOW); //set step pin low to complete step
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[DC]; 
            jVal = jVal + cmd.stepDir[DC];
            cmd.jVal[DC] = jVal;
            
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(DC); //Mark that we have started decelleration.
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
                    accelTableRepeatsLeft[DC] = 0;
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[DC]) {
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(DC)){ 
                    //if we are currently running a goto... 
                    cmd_setGotoEn(DC,CMD_DISABLED); //Switch back to slew mode 
                    clearGotoRunning(DC); //And mark goto status as complete
                } //otherwise don't as it cancels a 'goto ready' state 
                
                cmd_setStopped(DC,CMD_STOPPED); //mark as stopped 
                timerDisable(DC);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[DC],HIGH); //Set it high to start next step.
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[DC]; //load the number of repeats left for this accel table entry
            if (repeatsReqd == 0) { 
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[DC]; //Get the target speed
                if (currentSpeed > targetSpeed) {
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
                    if (accelIndex >= AccelTableLength-1) {
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
                        accelTableIndex[DC] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed <= targetSpeed) {
                            //If the new value is too fast
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
                    if (accelIndex == 0) {
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
                        accelTableIndex[DC] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed >= targetSpeed) {
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                }
                currentMotorSpeed(DC) = currentSpeed; //Update the current speed in case it has changed.
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[DC] = repeatsReqd - 1;
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(DC) = irqToNext; //Update the number of IRQs remaining until the next step.
    }   


}






/*Timer Interrupt Vector*/
ISR(TIMER1_CAPT_vect) {
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(RA)-1;
    //Check if we are ready to step
    if (irqToNext == 0) {
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(RA); //Get the current time segement
        
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(RA) = timerOVF[RA][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(RA) = *(int*)((byte*)timerOVF[RA] + index); //Update interrupt base rate.
        
        distributionSegment(RA) = timeSegment + 1; //Increment time segement for next time.

        unsigned int currentSpeed = currentMotorSpeed(RA); //Get the current motor speed
        irqToNextStep(RA) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
        
        if (getPinValue(stepPin[RA])){
            //If the step pin is currently high...
            
            setPinValue(stepPin[RA],LOW); //set step pin low to complete step
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[RA]; 
            jVal = jVal + cmd.stepDir[RA];
            cmd.jVal[RA] = jVal;
            
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(RA); //Mark that we have started decelleration.
                    cmd.currentIVal[RA] = cmd.stopSpeed[RA]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
                    accelTableRepeatsLeft[RA] = 0;
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[RA]) {
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(RA)){ 
                    //if we are currently running a goto... 
                    cmd_setGotoEn(RA,CMD_DISABLED); //Switch back to slew mode 
                    clearGotoRunning(RA); //And mark goto status as complete
                } //otherwise don't as it cancels a 'goto ready' state 
                
                cmd_setStopped(RA,CMD_STOPPED); //mark as stopped 
                timerDisable(RA);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[RA],HIGH); //Set it high to start next step.
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[RA]; //load the number of repeats left for this accel table entry
            if (repeatsReqd == 0) { 
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[RA]; //Get the target speed
                if (currentSpeed > targetSpeed) {
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
                    if (accelIndex >= AccelTableLength-1) {
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
                        accelTableIndex[RA] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed <= targetSpeed) {
                            //If the new value is too fast
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
                    if (accelIndex == 0) {
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
                        accelTableIndex[RA] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed >= targetSpeed) {
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                }
                currentMotorSpeed(RA) = currentSpeed; //Update the current speed in case it has changed.
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[RA] = repeatsReqd - 1;
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(RA) = irqToNext; //Update the number of IRQs remaining until the next step.
    }   


}

#else
#error Unsupported Part! Please use an Arduino Mega, or ATMega162
#endif

ELF          S            X     4     ( [ X AstroEQ %RU   :;I  $ >  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  .?:;<   I4   I  .?:;<   I  :;  I  ! I/  5 I  .:;    :;I  .?:;   /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ.h"
/*
  Code written by Thomas Carpenter 2012
  
  With thanks Chris over at the EQMOD Yahoo group for explaining the Skywatcher protocol
  
  
  Equatorial mount tracking system for integration with EQMOD using the Skywatcher/Synta
  communication protocol.
 
  Works with EQ5, HEQ5, and EQ6 mounts, and also a great many custom mount configurations.
 
  Current Verison: 7.5
*/

//Only works with ATmega162, and Arduino Mega boards (1280 and 2560)
#if defined(__AVR_ATmega162__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)

#ifndef __ASTROEQ_H__
#define __ASTROEQ_H__

#ifdef __cplusplus
extern "C"{
#endif

/*
 * File Includes
 */
 
#include "PinMappings.h" //Read Pin Mappings
#include "EEPROMAddresses.h" //Config file addresses
#include "UnionHelpers.h"

#include <string.h>
#include <stdlib.h>
#include <math.h>

#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/interrupt.h>

#include <inttypes.h>

/*
 * Useful Defines
 */
 
#ifndef sbi
  #define sbi(r,b) r |= _BV(b)
#endif
#ifndef cbi
  #define cbi(r,b) r &= ~_BV(b)
#endif

#define FLOAT (1<<3)
#define HIGH 1
#define LOW 0

#define OUTPUT 1
#define INPUT 0

#define A498x 0
#define DRV882x 1
#define DRV8834 2

#define SPEEDNORM 0
#define SPEEDFAST 1

#define REBUILDMODE 3
#define STOREMODE 2
#define PROGMODE 1
#define RUNMODE 0

#ifdef abs
#undef abs
#endif

#define abs(x) ((x)>0?(x):-(x))

#ifndef max
#define max(a,b) ((a > b) ? a : b)
#endif

typedef uint8_t byte;

#define RA 0 //Right Ascension is AstroEQ axis 0 (Synta axis '1')
#define DC 1 //Declination is AstroEQ axis 1 (Synta axis '2')

#define ST4P (0)  //Positive ST4 Pin
#define ST4N (1)  //Negative ST4 Pin
#define ST4O (-1) //Neither ST4 Pin

#define MIN_IVAL 50

#define BAUD_RATE 9600

#define nop() __asm__ __volatile__ ("nop \n\t")


/*
 * Standalone Pin Names
 */

#define STANDALONE_IRQ   0
#define STANDALONE_PULL  1

#define EQMOD_MODE 0
#define BASIC_HC_MODE 1
#define ADVANCED_HC_MODE 2

typedef struct {
    unsigned int speed;
    byte repeats;
} AccelTableStruct;

/*
 * Declare constant arrays of pin numbers
 */
 
const byte standalonePin[2] = {gpioPin_0_Define,gpioPin_2_Define};
const byte statusPin = statusPin_Define;
const byte resetPin[2] = {resetPin_0_Define,resetPin_1_Define};
const byte dirPin[2] = {dirPin_0_Define,dirPin_1_Define};
const byte enablePin[2] = {enablePin_0_Define,enablePin_1_Define};
const byte stepPin[2] = {stepPin_0_Define,stepPin_1_Define};
const byte st4Pins[2][2] = {{ST4AddPin_0_Define,ST4SubPin_0_Define},{ST4AddPin_1_Define,ST4SubPin_1_Define}};
const byte modePins[2][3] = {{modePins0_0_Define,modePins1_0_Define,modePins2_0_Define},{modePins0_1_Define,modePins1_1_Define,modePins2_1_Define}};


/*
 * Function Prototypes
 */
 
bool checkEEPROM();
void buildEEPROM();
void storeEEPROM();
void systemInitialiser();
byte standaloneModeTest();
int main(void);
bool decodeCommand(char command, char* packetIn);
void calculateRate(byte axis);
void calculateDecelerationLength (byte axis);
void motorEnable(byte axis);
void motorDisable(byte axis);
void slewMode(byte axis);
void gotoMode(byte axis);
void motorStart(byte motor);
void motorStartRA();
void motorStartDC();
void motorStop(byte motor, byte emergency);
void motorStopRA(bool emergency);
void motorStopDC(bool emergency);
void configureTimer();
void buildModeMapping(byte microsteps, byte driverVersion);


#ifdef __cplusplus
} // extern "C"
#endif


#endif


#else
#error Unsupported Part! Please use an Arduino Mega, or ATMega162
#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE INO OR *
 * PDE FILE THIS FILE IS GENERATED FROM!!!         *
 ***************************************************/

#include <Arduino.h>
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ6.ino"
ELF          S                 4     (  
 %  $ >  $ >   :;I  $ >  4 :;I  & I  4 :;I                                  int             zH                                   SS #   5=       $   3    %   2SCK &   4SDA (   SCL )       *   A0 ,   6A1 -   7A2 .   8A3 /   9A4 0   :A5 1   ;A6 2   <A7 3   =A8 4   >A9 5   ?A10 6   @A11 7   AA12 8   BA13 9   CA14 :   DA15 ;   E        
    e:/thomas/downloads/programs/exe/uecide/hardware/compilers/avr-gcc/lib/gcc/../../avr/include E:\Thomas\Downloads\Programs\EXE\uecide\hardware\boards\Arduino\mega2560  pins_arduino.h   stdint.h                         LED_BUILTIN bool GNU C++ 4.3.2 float unsigned char double MISO MOSI long unsigned int unsigned int long long unsigned int uint8_t long long int char C:\Users\Thomas\AppData\Local\Temp\build-257f0514-347c-4697-aed5-e6694d4cdfa1\AstroEQ6.cpp long int signed char  .symtab .strtab .shstrtab .text .data .bss .debug_abbrev .rela.debug_info .rela.debug_line .debug_str                                                         4                      !             4                      '             4                      ,              4   c                  ?                                  :                                P              ,                   K              	                 \      0       1                                6  g                                                	                h                                                                                           ?            >             =         )   4         1             =                                                                   	 J              Y               AstroEQ6.cpp __SREG__ __SP_H__ __SP_L__ __CCP__ __tmp_reg__ __zero_reg__ __do_copy_data __do_clear_bss                                                     $     V   2        9        >     z   K     %   R     D   Y        `     c   m        t        {     3                ?        :                     :00000001FF
ELF          S        4        4    (                 -  -           H.    -  z   z            .  z z                                                                  gw												3					x										
																		M		$ ` `  75  APP@0  002	
b0	b0a0	a0
        #!H        pH	        H	#)4}5q o     #!4b5@Po }o   o bo  q0rr/i/$5t/i/8#)//o }o Pn@m0   py`z2uu#)         ` 8o bo @ P!q }q   q bq  s0tr/i/$5t/i/9#)//q }q Pp@o0   p{`|3!a~#)  ?:100000000C94AC000C94D6000C94D6000C94D60042
:100010000C94D6000C94D6000C94D6000C94D60008
:100020000C94D6000C94D6000C94D6000C94D600F8
:100030000C94D6000C94D6000C94D6000C94D600E8
:100040000C94B8040C94D6000C94D6000C94D600F2
:100050000C94D6000C94D6000C94D6000C94D600C8
:100060000C94D6000C94D3120C94F4120C94D60079
:100070000C94D6000C94D6000C94D6000C94BE03BD
:100080000C94D6000C94D6000C94D6000C94D60098
:100090000C94D6000C94D6000C94D6000C94D60088
:1000A0000C94D6000C94D6000C94D6000C94D60078
:1000B0000C94D6000C94D6000C94D6000C94D60068
:1000C0000C94D6000C94D6000C94D6000C94D60058
:1000D0000C94D6000C94D6000C94D6000C94D60048
:1000E0000C94D600670877081209B708C509C50936
:1000F000C509C509C509C509C509C509C509A308B3
:10010000C509C5093309D9088708AF09C509C50953
:10011000C5097809A409FE08C509C509C509C509A5
:10012000C509C509C509C5090A09AF08C509C50931
:10013000C509C509C509C509C509C509C50997087E
:10014000C509C5091E09CF08C509C509C509C509DD
:10015000C5094D09C509F70811241FBECFEFD1E22B
:10016000DEBFCDBF00E00CBF88E10FB6F8948093EE
:100170006000109260000FBE12E0A0E0B2E0E4EB7D
:10018000FDE200E00BBF02C007900D92AA37B10755
:10019000D9F71BBE15E0AAE7B2E001C01D92A13558
:1001A000B107E1F70E94ED0B0C94D8160C940000F7
:1001B000FB01DC014150504030F08D9101908019DD
:1001C00019F40020B9F7881B990B0895883018F4AA
:1001D000880F880F880F883019F08032A1F406C08C
:1001E00083E08093090210920A020895623011F0B0
:1001F00087E001C082E280930902623011F082E060
:100200000EC080E20CC0613011F087E001C081E0D7
:1002100080930902613011F081E001C084E0809395
:100220000A0208951198000000000000000080916B
:100230000D03882321F0489B02C082E00895119AA3
:10024000000000000000000089B1809581700895D1
:10025000489902C080E00BC0099811980000000086
:1002600000000000489B02C082E001C081E0099AC2
:10027000119A0895882329F4A59881E08093340386
:1002800008C0809102018F7D8093020181E08093FC
:1002900035031092710010926F001092800088E177
:1002A000809381001092900080939100089588239C
:1002B00021F4A59A1092340308958091020180627E
:1002C0008093020110923503089540911E035091CE
:1002D0001F0380916F008F7D80936F00E0919A00E3
:1002E000F0919B0080916F00806280936F0020915D
:1002F000710330917203C901722F692F24173507DA
:1003000018F4CA01742F692FA0913803AA2329F485
:10031000E217F30710F49F0103C0872F962F9C016B
:1003200080916F008F7D80936F0050936E03409398
:100330006D0330939B0020939A0070937903609330
:100340007A039091840280913203981711F0759A84
:1003500001C07598AA2329F181E090E090938B0069
:1003600080938A0080917F0380931203109214037C
:100370001BBC109285001092840080918A0290919B
:100380008B02909387008093860080918100897F03
:100390008093810080918100816080938100109220
:1003A000380380916F00806280936F0008954091C0
:1003B000200350912103809171008F7D8093710003
:1003C000E0919800F0919900809171008062809393
:1003D00071002091730330917403C901722F692F4A
:1003E0002417350718F4CA01742F692FA091390317
:1003F000AA2329F4E217F30710F49F0103C0872F03
:10040000962F9C01809171008F7D80937100509395
:10041000700340936F03309399002093980070937A
:100420007B0360937C03909185028091330398173E
:1004300021F080910201806103C0809102018F7ED2
:1004400080930201AA2329F181E090E09093890032
:100450008093880080913F048093130310921503CA
:100460001ABC10929500109294008091CA0290914B
:10047000CB02909397008093960080919100897FA2
:1004800080939100809191008160809391001092FF
:1004900039038091710080628093710008958823F0
:1004A00019F40E94650108950E94D70108959F9252
:1004B000AF92BF92CF92DF92EF92FF920F931F9372
:1004C000CF93DF93C82EC82FD0E0FE01EE0FFF1FA1
:1004D000E25FFC4F00811181FE01EA5EFC4F84A1C6
:1004E000882329F0C801880F991F080F191FFE01E2
:1004F000EA5EFC4F828D181614F4D28C02C0D28CA6
:10050000D194FE01EA5EFC4F948C8D2D90E0880F13
:10051000991F9C01442737FD4095542FFE01EE0F93
:10052000FF1FEE0FFF1FEA5EFC4F82899389A489AB
:10053000B58982179307A407B50720F4228B338B64
:10054000448B558B8D2D90E0809FB001819F700D65
:10055000909F700D1124FE01EE0FFF1FEE0FFF1F85
:10056000EA5EFC4FE288F38804891589A8019701A7
:100570005695479537952795FE01EE0FFF1FEB58CF
:10058000FC4FA080B18088E0D81649F488EF9FEF37
:10059000AFEFBFEFE822F9220A231B23287FCB010C
:1005A000A0E0B0E0281739074A075B0708F4B90153
:1005B000CB01A0E0B0E0A8019701281B390B4A0B42
:1005C0005B0BDA01C901FE01EE0FFF1FEE0FFF1FEB
:1005D000EA5EFC4F2081318142815381992039F0BC
:1005E000B095A095909581959F4FAF4FBF4FFE015D
:1005F000EE0FFF1FEE0FFF1FE458FD4F820F931FFA
:10060000A41FB51F80839183A283B383CC0FDD1F0A
:10061000C25EDC4FB982A8829EB3CC2011F48BEF6E
:1006200001C087EF89238EBB9EB3CC2011F481E0FB
:1006300001C082E0892B8EBB8C2D0E944F02DF917E
:10064000CF911F910F91FF90EF90DF90CF90BF90CF
:10065000AF909F9008958823A9F080916F008F7DBF
:1006600080936F0080918100887F80938100109239
:10067000360381E0809338031092260310927A02A9
:10068000F098089580913803882339F54FB7F8948E
:1006900010923603F0981092260320917103309146
:1006A000720380916D0390916E038217930758F443
:1006B0008091790390917A032817390720F43093B9
:1006C0007A03209379038091790390917A030196BC
:1006D00090936E0380936D034FBF08958823A9F014
:1006E000809171008F7D8093710080919100887F4F
:1006F000809391001092370381E080933903109228
:10070000270310927B02F198089580913903882382
:1007100039F54FB7F8941092370310922703F198E8
:10072000209173033091740380916F039091700353
:100730008217930758F480917B0390917C032817CC
:10074000390720F430937C0320937B0380917B0353
:1007500090917C0301969093700380936F034FBF39
:100760000895882329F4611181E00E942B030895E4
:1007700080E0611181E00E946E0308951F920F9244
:100780000FB60F920BB60F9211242F933F934F93F6
:100790005F936F937F938F939F93AF93BF93EF93E9
:1007A000FF938091880090918900019709F0C9C05A
:1007B0008AB5E82FEE73F0E0E653FD4F20813181DA
:1007C00030939700209396008F5F8ABD60919800C8
:1007D0007091990070938900609388001E9B54C0AB
:1007E0002E9880911A0390911B03A0911C03B09145
:1007F0001D0320913103332727FD3095432F532FBD
:10080000280F391F4A1F5B1F20931A0330931B03C5
:1008100040931C0350931D03F19B1BC0F39919C017
:100820008091800290918102A0918202B091830216
:1008300082179307A407B50761F4F39A80917B03AD
:1008400090917C0301969093700380936F031092B4
:10085000130380917B0390917C038617970708F020
:1008600074C0F19B03C010923703F19881E080932C
:100870003903809171008F7D809371008091910088
:10088000887F8093910061C02E9A80911303882302
:1008900009F053C020916F0330917003261737077A
:1008A000D0F4809115038F3308F041C08F5F80939F
:1008B000150390E0FC01EE0FFF1FE80FF91FEA5E41
:1008C000FC4FE95DFE4F60817181E752F1402617D0
:1008D0003707E0F02CC06217730750F580911503BD
:1008E000882329F181508093150390E0FC01EE0FDD
:1008F000FF1FE80FF91FEA5EFC4FE95DFE4F6081C4
:100900007181E752F1406217730788F480913B03CD
:10091000E75DFE4F882339F0808123E0829FC0018C
:1009200011248E5F01C080818093130301C0B9013F
:10093000709399006093980008C0815080931303CE
:1009400004C09093890080938800FF91EF91BF913C
:10095000AF919F918F917F916F915F914F913F9157
:100960002F910F900BBE0F900FBE0F901F901895F8
:100970001F920F920FB60F920BB60F9211242F9366
:100980003F934F935F936F937F938F939F93AF9317
:10099000BF93EF93FF9380918A0090918B00019712
:1009A00009F0C9C08BB5E82FEE73F0E0E657FD4FB4
:1009B0002081318130938700209386008F5F8BBD2B
:1009C00060919A0070919B0070938B0060938A00F5
:1009D000639B54C073988091160390911703A09164
:1009E0001803B091190320913003332727FD309568
:1009F000432F532F280F391F4A1F5B1F20931603C5
:100A0000309317034093180350931903F09B1BC0B6
:100A1000F29919C080917C0290917D02A0917E0292
:100A2000B0917F0282179307A407B50761F4F29A89
:100A30008091790390917A03019690936E0380934D
:100A40006D03109212038091790390917A038617B7
:100A5000970708F074C0F09B03C010923603F0981B
:100A600081E08093380380916F008F7D80936F00C9
:100A700080918100887F8093810061C0739A80910A
:100A80001203882309F053C020916D0330916E0347
:100A900026173707D0F4809114038F3308F041C034
:100AA0008F5F8093140390E0FC01EE0FFF1FE80FAF
:100AB000F91FEA5EFC4FE959FF4F60817181E756EB
:100AC000F04026173707E0F02CC06217730750F587
:100AD00080911403882329F181508093140390E0BE
:100AE000FC01EE0FFF1FE80FF91FEA5EFC4FE9590A
:100AF000FF4F60817181E756F0406217730788F4F9
:100B000080913A03E759FF4F882339F0808123E031
:100B1000829FC00111248E5F01C0808180931203E7
:100B200001C0B90170939B0060939A0008C0815086
:100B30008093120304C090938B0080938A00FF91EE
:100B4000EF91BF91AF919F918F917F916F915F9145
:100B50004F913F912F910F900BBE0F900FBE0F90B2
:100B60001F9018951F9360914403709145038091E5
:100B70004603909147034EE050E00E94321160918D
:100B800048037091490380914A0390914B0342E1DD
:100B900050E00E94321160914C0370914D0380919E
:100BA0004E0390914F0346E150E00E943211609154
:100BB00050037091510380915203909153034AE185
:100BC00050E00E943211609156037091570380915A
:100BD0005803909159034EE150E00E943211609108
:100BE0005A0370915B0380915C0390915D0342E234
:100BF00050E00E9432118091840269E070E00E940E
:100C00000B11809185026AE070E00E940B118091C7
:100C100088026BE070E00E940B118091870268E00F
:100C200070E00E940B11809175036CE070E00E94EF
:100C30000B11809177036DE070E00E940B118091A1
:100C4000690390916A0366E270E00E941711809137
:100C50006B0390916C0368E270E00E941711809121
:100C60000C0311E081276AE270E00E940B11809171
:100C70000D0381276BE270E00E940B1180916703E6
:100C8000909168036CE270E00E94171180915F03FD
:100C90006EE270E00E940B118DE793E060E444E6A1
:100CA00050E00E9462118DE394E060E444E251E080
:100CB0000E9462111F91089580E092E068E040E098
:100CC00050E00E94491108950F931F93DF93CF9333
:100CD000CDB7DEB729970FB6F894DEBF0FBECDBFF4
:100CE0008E010F5F1F4F89E0F80111928A95E9F795
:100CF000C80168E040E050E00E94CD10C80160E00B
:100D000072E048E050E00E94D800009791F5809191
:100D10008802833070F5882321F480918702813125
:100D200040F580918702813220F58091690390918E
:100D30006A03C2978F579440E0F480916B039091BF
:100D40006C03C2978F579440A0F4809175039091E3
:100D50007603892B71F08091770390917803892B2A
:100D600041F090E080915F038150833118F491E06D
:100D700001C090E0892F29960FB6F894DEBF0FBE10
:100D8000CDBFCF91DF911F910F9108958F929F92C8
:100D9000AF92BF92CF92DF92EF92FF920F931F9389
:100DA000CF93DF93A82E4B0182E00E944313B82E0D
:100DB0000FE4A01609F451C10A15FCF018E4A116BD
:100DC00009F4EAC01A1564F026E4A21609F43CC13D
:100DD0002A150CF4CBC085E4A81609F05EC121C128
:100DE000ABE4AA1609F4B5C0BCE4AB1609F4B7C06D
:100DF000E9E4AE1609F051C1E3C0F6E6AF1609F416
:100E000076C0FA155CF002E6A01679F115E6A11697
:100E100091F021E6A21609F040C11AC08AE6A81690
:100E200009F487C0A3E7AA1609F454C0B7E6AB16C5
:100E300009F033C14AC0E82FF0E0EE0FFF1FEE0FBC
:100E4000FF1FEA5EFC4F26A137A140A551A5A1C214
:100E5000E82FF0E0EE0FFF1FEE0FFF1FEA5EFC4FE2
:100E600026A537A540A951A994C2A82FB0E0FD013D
:100E7000EE0FFF1FEE0FFF1FEA5EFC4F26A937A9FA
:100E800040AD51AD80918602882309F082C2AA0F3D
:100E9000BB1FA759BC4FED90FC90EE0CFF1C0894B3
:100EA000E11CF11CB70180E090E00894E108F10832
:100EB0000E94831600E010E0A80197010E94B61678
:100EC000C901DA019C01AD0164C2EB2DF0E0EC5ADE
:100ED000FC4FA4C1EB2DF0E0EE0FFF1FEE0FFF1F44
:100EE000EA5AFC4F208131814281538152C2A82F9E
:100EF000B0E0FD01EA5EFC4F848D882319F020E00C
:100F000032E002C020E030E0FD01EA5EFC4F82A149
:100F100081113160FD01EA5EFC4F80A181112061E9
:100F2000AA5EBC4F5E968C91882309F409C12160AA
:100F300007C18FB7F894EB2DF0E0EE0FFF1FEE0F17
:100F4000FF1FEA5EFC4F20813181428153818FBFB8
:100F500020C260E00E94B103EB2DF0E019C061E017
:100F60000E94B1038B2D0E9457010FC2E82FF0E0C1
:100F7000DF01AA5EBC4FE4018881805350968C93B8
:100F8000509790E08981803309F091E05C969C93C2
:100F9000E658FD4F1082F9C1C4010E942913AB2D00
:100FA000B0E0FD01EE0FFF1FEE0FFF1FEA5EFC4FEA
:100FB000628B738B848B958BA658BD4F1C92E5C1B9
:100FC000C4010E942913CB2CDD24E601CC0FDD1FC8
:100FD000C25EDC4F20EC30E0C29EF001C39EF00DFB
:100FE000D29EF00D1124E65CFB4F20813181790106
:100FF00000E010E0AC01CB01DA018E159F05A007DF
:10100000B10710F4D801C70199838883F601E65827
:10101000FD4F8081823009F0BDCF8B2D0E944F02A1
:10102000B4C11FB7F894C4010E942913EB2DF0E05E
:10103000EE0FFF1FEE0FFF1FEA5EFC4F6083718310
:10104000828393831FBFA1C180918602882309F008
:101050009BC18B2D0E943A0198C1F401808180537D
:1010600080938602882331F420E030E040E050E0B5
:1010700010E090C180E061E00E94B10380E00E9436
:10108000570181E061E00E94B10381E00E945701B5
:1010900010927A0210927B0278C12091860222235C
:1010A00009F473C18A2D992787FD9095A92FB92F2F
:1010B000FC01E154F040EA33F10508F066C1EE5856
:1010C000FF4FEE0FFF1F0590F491E02D1994C4011E
:1010D0000E942913EB2DF0E0EE0FFF1FEE0FFF1F14
:1010E000EA5EFC4F66A777A780AB91AB4EC1C40107
:1010F0000E942913EB2DF0E0EE0FFF1FEE0FFF1FF4
:10110000EA5EFC4F66AB77AB80AF91AF3EC1C401E6
:101110000E942913EB2DF0E0EE0FFF1FEE0FFF1FD3
:10112000EA5AFC4F60837183828393832EC1EB2D37
:10113000F0E0EE0FFF1FE759FC4F808191819C0189
:1011400040E050E026C1C4010E942913EB2DF0E0DD
:10115000EE0FFF1FE759FC4F7183608316C1BB2060
:1011600019F0809187025BC08091880258C0BB2033
:1011700081F0C4010E94261380938702883010F406
:1011800090E004C090910C0381E0982790930A03AB
:10119000FCC0C4010E94261380938802F6C0BB20C5
:1011A00029F08091670390916803C9CF80915F0314
:1011B00036C0BB2089F0C4010E9429136030F0E0E2
:1011C0007F07F1E08F07F0E09F0708F0DDC0709324
:1011D000680360936703D9C0C4010E942613982F47
:1011E0008150833108F0D0C090935F03CEC0EB2DC7
:1011F000F0E0EE0FFF1FEB58FC4F9FCFC4010E94A1
:101200002613EB2DF0E0EE0FFF1FEB58FC4F808311
:101210001182BBC0EB2DF0E0EC57FD4F8081282FF1
:1012200030E08ECFEB2DF0E0EC57FD4F90E0D40195
:101230008C91803309F091E09083A7C0BB2081F0AE
:1012400020910C0380918702883010F480E002C066
:1012500081E0822730E040E050E080930A0399C0AB
:1012600080910D03DCCFBB2061F0C4010E942613E6
:1012700010920C03882309F488C081E080930C034A
:1012800084C0C4010E94261310920D03882309F420
:101290007CC081E080930D0378C020E030E040E026
:1012A00050E06B2D70E0EB01CC5EDC4FA8818A2F03
:1012B00090E0FC01EE0FFF1FE80FF91F80EC90E0BB
:1012C0008C01609FC001619F900D709F900D112453
:1012D000E80FF91FEA5EFC4FE959FF4F2191319168
:1012E0004081AF5FA883A03408F453C0188251C076
:1012F000C4010E9429134B2D50E0EA01CC5EDC4F63
:10130000A8812A2F30E0F901EE0FFF1FE20FF31F33
:1013100020EC30E08901409F9001419F300D509FAB
:10132000300D1124E20FF31FEA5EFC4FE959FF4F25
:1013300061937193BC01882799276083AF5FA8836D
:10134000A03418F1188221C0C4010E942613EB2D8D
:10135000F0E0EC5EFC4F80838034B0F416C0822F46
:1013600090E09C012170307081FF08C0232B19F0A0
:101370000E945C060AC00E94B20507C0232B29F018
:101380000E946406882309F4AA2420E030E040E0AB
:1013900050E011E0C4016A2D0E94C4132AE4A21691
:1013A00089F480918602882369F48B2D90E0FC01FA
:1013B000E658FD4F21E02083FC01EA5EFC4F808966
:1013C00080FF20A3812FDF91CF911F910F91FF907C
:1013D000EF90DF90CF90BF90AF909F908F90089547
:1013E0002F923F924F925F926F927F928F929F9235
:1013F000AF92BF92CF92DF92EF92FF920F931F9323
:10140000CF93DF93C82FD0E0FE01EE0FFF1FEE0F4A
:10141000FF1FEA5EFC4FA6A8B7A8C0ACD1AC60E045
:1014200072E18AE790E0A60195010E94B616C90113
:10143000DA013C014D0160E072E18AE790E0A6012B
:1014400095010E94B6160E9450157B018C01C601C1
:10145000B5010E9450159B01AC01C801B7010E9463
:10146000BC1420E030E040E052E40E94201620E06E
:1014700030E040E05FE30E9445140E9424151B0108
:101480002C01C401AA27BB27892B39F05FEF652EF9
:101490005FEF752E812C912C0BC080E868167104CB
:1014A0008104910428F440E8642E712C812C912C45
:1014B000FE0136E0EE0FFF1F3A95E1F7E657FD4FCC
:1014C00080E0619271928F5F8032D9F7AA24BB24A9
:1014D000650125E0CC0FDD1F2A95E1F72BC0C60181
:1014E000B5010E94501520E030E040E052E40E9437
:1014F00020167B018C01C201B1010E9450159B0195
:10150000AC01C801B7010E94BC140E94A9140E943A
:101510002415FE01E60FF11DEE0FFF1FE657FD4FEC
:10152000808191810196918380830894A11CB11CD4
:10153000C11CD11CA214B304C404D50480F2DF91F1
:10154000CF911F910F91FF90EF90DF90CF90BF90C0
:10155000AF909F908F907F906F905F904F903F9053
:101560002F90089589E090E00E94991010928402D3
:10157000882319F081E0809384028AE090E00E9441
:10158000991010928502882319F081E080938502DA
:101590008BE090E00E9499108093880288E090E0B0
:1015A0000E949910809387028BE290E00E9499102C
:1015B00010920D03882319F481E080930D0310929B
:1015C0000B0380918702883018F481E080930B032D
:1015D0008AE290E00E94991090E0882309F491E05B
:1015E00090930C0380918702883010F480E002C051
:1015F00081E0892780930A03882311F441E001C028
:1016000048E062E273E080E090E00E943414809150
:101610008702609188020E94E6000E946406882387
:1016200019F481E08093860280E00E94F00981E055
:101630000E94F0094091750350917603EDE7F3E0C5
:1016400020E030E0808191814817590750F4828171
:1016500090E00196280F391F339684E0ED33F807A8
:1016600089F730930F0320930E0340917703509135
:101670007803EDE3F4E020E030E0808191814817C9
:10168000590750F4828190E00196280F391F339654
:1016900084E0ED3FF80789F730931103209310039E
:1016A000279A2F985098589A099A119A23982B9A0A
:1016B0002098289A22982A9A2198299A819A89987A
:1016C000809A88989D9AA59A809101018062809362
:1016D0000101809102018062809302016B9A7398EC
:1016E000269A2E986D9A7598809101018061809359
:1016F0000101809102018F7E80930201E0910B0332
:10170000F0E0E75FFD4F8081282F30E0A9014170B4
:10171000507080FF04C080910501816003C08091FA
:1017200005018E7F80930501809104018160809383
:101730000401452B11F0599A01C05998519AA901F9
:101740004270507021FF04C080910201826003C08A
:10175000809102018D7F809302018091010182605E
:1017600080930101452B11F05A9A01C05A98529A60
:10177000B9016470707022FF04C080910201816021
:1017800003C0809102018E7F80930201A901407203
:10179000507025FD04C080910101816003C08091DB
:1017A00001018E7F80930101672B11F05B9A01C0CC
:1017B0005B98452B11F4539A01C0539880EA9FE03F
:1017C0000197F1F7899A889A0E941A1260E875E2E7
:1017D00080E090E00E948D1108952F923F924F92E9
:1017E0005F926F927F928F929F92AF92BF92CF92B1
:1017F000DF92EF92FF920F931F93DF93CF93CDB7BA
:10180000DEB72E970FB6F894DEBF0FBECDBF78942B
:101810000E94B20AEE24FF24AA2400E0CC24BB24B8
:10182000412C512C80E8682E712C1E010894211C3B
:10183000311CDD24DA9414E0812E912C8C0E9D1E37
:101840000894E11CF11C80918902882309F095C05D
:10185000E114F10409F091C00E941201182F8823AD
:1018600009F48BC080E061E00E94B10381E061E097
:101870000E94B1038FB7F894409216035092170359
:10188000609218037092190340921A0350921B033E
:1018900060921C0370921D038FBF0E94E81181E0CB
:1018A00080938902123081F4809308020E94021210
:1018B000C10160E020E030E040E050E00E94C4134D
:1018C000C1010E94C61259C01092080210920A0368
:1018D000119AE0910B03F0E0E75FFD4F8081982FB4
:1018E00080FF07C080910501816080930501599AAE
:1018F00006C0809105018E7F80930501599891FF64
:1019000007C0809102018260809302015A9A06C04A
:10191000809102018D7F809302015A9892FF07C047
:10192000809102018160809302015B9A06C08091E0
:1019300002018E7F809302015B9880E00E94F80E86
:1019400080E00E943A0181E00E943A0121E0209368
:101950002603209327031092320320933003109222
:101960003303209330038091690390916A0390932D
:101970001F0380931E0320937A028091080288231C
:1019800009F465C10E3F21F00E946512882371F1B0
:1019900085B1805885B90E3F19F00E947212A82EA9
:1019A000C4016A2D0E948213082F8823F9F01816AB
:1019B00014F010E005C0B4010E94C60611E018271B
:1019C000C4010E94C612112389F00E94B0122BE0BC
:1019D00088E190E00FB6F894A895809360000FBE60
:1019E0002093600080E090E00E94D816E114F1049A
:1019F00009F42F9880918902882309F062C0EE20B3
:101A000009F05FC0809132038823B9F480917A0293
:101A1000823099F4199902C0E1E0C6C11A9BC3C192
:101A2000BB2059F08091690390916A0390931F0342
:101A300080931E030E946501BB2480913703882395
:101A400009F03FC0199903C051E041E006C01A9B5C
:101A500002C04FEF01C040E050E08091390388237D
:101A600071F48091330390E0252F30E082179307C3
:101A700031F080E00E946E0310927B0222C04F3F43
:101A8000D1F0809165039091660390932103809338
:101A90002003252F511121E020933303222319F035
:101AA000D092310303C081E0809331030E94D701BB
:101AB000CC24C39406C0CC2021F080E00E946E03A9
:101AC000CC2490917A02913009F067C0809138035C
:101AD000882309F462C03091260380910A03882389
:101AE00009F442C0832F8150823070F420910902A2
:101AF00080913203882319F0D092300302C0909372
:101B0000300310923A030DC020910A0290915403C1
:101B100080913203811191959093300381E08093FD
:101B20003A03922F20FF04C080910501816003C019
:101B3000809105018E7F8093050191FF04C0809103
:101B40000201826003C0809102018D7F80930201B7
:101B500092FF04C080910201816003C08091020164
:101B60008E7F809302010BC080913203882319F08D
:101B7000D092300302C09093300310923A0330FFAA
:101B800007C080E00E944F0282E080937A0205C085
:101B900080E00E94570210927A0290917B0291306D
:101BA00009F04ECE80913903882309F449CE309153
:101BB000270380910A03882381F1832F815082308B
:101BC00070F42091090280913303882319F0D09298
:101BD000310302C09093310310923B030DC020915A
:101BE0000A0290915503809133038111919590934E
:101BF000310381E080933B03822F20FF02C0599A7A
:101C000001C0599881FF02C05A9A01C05A9882FFB8
:101C100002C05B9A0DC05B980BC080913303882390
:101C200019F0D092310302C09093310310923B031C
:101C300030FF07C081E00E944F0282E080937B0268
:101C4000FFCD81E00E94570210927B02F9CDE11492
:101C5000F10471F485B1805885B90E942801982F4C
:101C600080915E03981739F0892F0E94F80E03C007
:101C7000EE2009F0E5CD189BAAC01B9B02C04FEFD8
:101C800001C040E050E01FB7F894809138038823EA
:101C900009F0A6C08091320390E0252F30E0821732
:101CA000930709F49DC020919A0030919B00809188
:101CB0007103909172032817390708F091C027C06B
:101CC000E0916903F0916A030BC0E42FFF27E7FD61
:101CD000F095EE0FFF1FE05AFC4F0190F081E02DD0
:101CE000F0931F03E0931E03252F511121E0209351
:101CF0003203222319F0D092300303C081E0809395
:101D000030034F3F41F480915E03823021F480E044
:101D10000E942B0302C00E9465011FBF199903C0D6
:101D200051E041E006C01A9B02C04FEF01C040E005
:101D300050E01FB7F89480913903882309F054C00C
:101D40008091330390E0252F30E08217930709F448
:101D50004BC020919800309199008091730390912D
:101D600074032817390708F03FC018C08091650335
:101D7000909166039093210380932003252F5111A6
:101D800021E020933303222319F0D092310303C0C2
:101D900081E0809331030E94D70103C080E00E945C
:101DA0006E031FBF4DCDE0E0FF27E7FDF095B59630
:101DB000EE0FFF1FEA5EFC4F8081918190931F031D
:101DC00080931E030E946501BB24B39436CE80919C
:101DD0006403882311F051E001C050E041E053CF8B
:101DE0004F3F09F072CF6CCF4F3F09F0BFCFD6CF36
:101DF0000F931F93482F80935E038230A1F480914C
:101E000075039091760390936103809360039093A0
:101E100063038093620381E080936403809177037E
:101E2000909178031BC08130F1F4209169033091C7
:101E30006A03C90163E070E00E94A2167093610317
:101E400060936003309363032093620340936403C1
:101E500080916B0390916C039695879590936603A0
:101E6000809365033BC08091690390916A0324E1EC
:101E700030E0829F8001839F100D929F100D1124EE
:101E800040915F03E42FF0E0BF016C5E7F4FC8011B
:101E90000E94A2167093610360936003B9016E1BE8
:101EA0007F0BC8010E94A2167093630360936203C4
:101EB0001092640380916B0390916C03BC01629F4C
:101EC000C001639F900D729F900D1124642F70E0EC
:101ED0000E94A21670936603609365031F910F9191
:101EE0000895982FEBE0F2E020E030E08081891740
:101EF00089F4F901EE0FFF1F662331F0E20FF31FA3
:101F0000E55FFD4F81810895E20FF31FE55FFD4F0F
:101F1000828108952F5F3F4F33962532310531F787
:101F20008FEF08954F925F926F927F928F929F9260
:101F3000AF92BF92CF92DF92EF92FF920F931F93D7
:101F4000CF93DF933B014C01442E8EE090E00E9442
:101F5000AF106093440370934503809346039093BE
:101F6000470382E190E00E94AF10609348037093B2
:101F7000490380934A0390934B0386E190E00E94CB
:101F8000AF1060934C0370934D0380934E03909376
:101F90004F038AE190E00E94AF106093500370936A
:101FA000510380935203909353038EE190E00E947B
:101FB000AF10609356037093570380935803909328
:101FC000590382E290E00E94AF1060935A0370932D
:101FD0005B0380935C0390935D0386E290E00E9434
:101FE000A01090936A038093690388E290E00E94B6
:101FF000A01090936C0380936B038CE090E00E94A0
:10200000991005E713E080937503109276038DE035
:1020100090E00E94991080937703F80113828EE27A
:1020200090E00E94991080935F038CE290E00E9400
:10203000A0109093680380936703C801089660E43A
:1020400044E650E00E94DF108DE394E060E444E257
:1020500051E00E94DF1026E133E079016DE773E083
:1020600009E713E0E901D90140E050E05524539419
:10207000A12CB12CE0E8CE2ED12C1C8EFA01EA5E08
:10208000FC4F528E1CA25AA218A21E8EF701A192DA
:10209000B192C192D1927F01AD5ABF4F8D919C9167
:1020A0001197A355B04019969C938E931897188A50
:1020B000F901128A138A148A158A66A277A280A669
:1020C00091A64EAEFB0180819181A55ABF4F11961A
:1020D0009C938E93F801819391938F0114970196AD
:1020E00011969C938E93A755B0401D969C938E930A
:1020F0001C974F5F5F4F219612962C5F3F4F6054A5
:102100007F4F4230510509F0B8CF80E00E94F80EB1
:10211000DF91CF911F910F91FF90EF90DF90CF90C3
:10212000BF90AF909F908F907F906F905F904F90F7
:102130000895F999FECF92BD81BDF89A80B50895B2
:10214000F999FECF92BD81BDF89A20B5F999FECFDD
:10215000019692BD81BDF89A90B5822F0895F999A4
:10216000FECF92BD81BDF89A20B5F999FECF0196B8
:1021700092BD81BDF89A70B50196F999FECF92BDD6
:1021800081BDF89A30B5F999FECF019692BD81BD17
:10219000F89A90B5622F832F0895FC0190E00CC04F
:1021A000F999FECF9A012F5F3F4F52BD41BDF89A7A
:1021B00080B581939F5FA901961790F30895FC0164
:1021C00020E025C0F999FECF52BD41BDF89A90B5E7
:1021D000F999FECF4F5F5F4F52BD41BD4150504016
:1021E000F89A80B590838183CA010296F999FECF4F
:1021F00092BD81BDF89A80B54D5F5F4FF999FECFD2
:1022000052BD41BDF89A90B582832F5F3396261751
:1022100008F4D8CF0895F999FECF1FBA72BD61BDF9
:1022200080BD0FB6F894FA9AF99A0FBE08959C01F2
:10223000F999FECF1FBA72BD61BD20BD0FB6F894EB
:10224000FA9AF99A0FBE932FF999FECF1FBA6F5FD2
:102250007F4F72BD61BD90BD0FB6F894FA9AF99A9E
:102260000FBE0895EF92FF920F931F938A01F82EED
:10227000E92ECB01BA010E9417110E5F1F4F8F2D5F
:102280009E2DB8010E9417111F910F91FF90EF90A2
:102290000895FC0120E030E012C07081F999FECF72
:1022A0001FBAC901840F951F92BD81BD70BD0FB6C5
:1022B000F894FA9AF99A0FBE2F5F3F4F319626177E
:1022C00060F30895EF92FF920F931F93CF93DF93E4
:1022D000E62E8A01EC01FF2417C088819981B8019C
:1022E0000E941711C80102962A81F999FECF1FBAE0
:1022F00092BD81BD20BD0FB6F894FA9AF99A0FBE2F
:102300000D5F1F4FF3942396FE1438F3DF91CF91A6
:102310001F910F91FF90EF900895EF92FF920F930E
:102320001F937B018C0182E08093C00060E079E024
:102330008DE390E0A80197010E94B616215030402D
:10234000404050405695479537952795922F232F1B
:10235000832F807FA1F01092C00060E874E88EE1C6
:1023600090E0A80197010E94B616215030404040ED
:1023700050405695479537952795922F232F2F70CC
:102380002093C5009093C4008FB7F89410921D0558
:1023900010921E0510923F05109240058FBF80914C
:1023A000C10080618093C1008091C10088608093EA
:1023B000C1008091C10080688093C1008091C100FC
:1023C0008F7D8093C1001F910F91FF90EF90089532
:1023D000E1ECF0E080818F7E80838081877F808345
:1023E00080818F77808380818F7D80838FB7F89401
:1023F00010921D0510921E0510923F051092400587
:102400008FBF0895219A299A23982B9A229A2A9A63
:10241000209A289A119A8FB7F89410921D0510925D
:102420001E0510923F05109240058FBF81E08093FA
:10243000410508952198299A23982B9A22982A9A3F
:102440002098289A109241058FB7F89410921D0594
:1024500010921E0510923F05109240058FBF0895FF
:1024600098E0299887FF02C02A9A02C000002A98A3
:10247000299A880F1B998F5F915099F70895909131
:10248000400580913F059817C9F0489917C02898D2
:1024900081E80E943012489BFECF80E80E943012F3
:1024A00087FD0BC0E0913F05F0E0E15EFA4F8083CD
:1024B00080913F058F5F80933F05289A0895289863
:1024C0008F770E943012289A0895809141058823C1
:1024D00011F00E943F1280913F0590914005891BA9
:1024E0008F7108959091400580913F05891711F4EF
:1024F0008FEF0895E92FF0E0E15EFA4F80819F5F52
:102500009F71909340050895282F8091C10083FF0B
:102510001FC090911D059F5F9F7180911E059817A8
:1025200049F48091C10080628093C10080911E05B2
:102530009817E1F3E0911D05F0E0E350FB4F208395
:1025400090931D058091C10080628093C100089521
:1025500080914105882319F0822F0E945F1208950F
:102560008091C10083FF11C090911D059F5F9F71F5
:1025700080911E05981749F48091C1008062809374
:10258000C10080911E059817E1F30895CF93DF9362
:10259000EC0103C021960E94841288818823D1F720
:1025A000DF91CF9108952F932FB72F939F938F9300
:1025B000EF93FF932091C60090913F059F5F9F711D
:1025C00080914005981741F0E0913F05F0E0E15E11
:1025D000FA4F208390933F05FF91EF918F919F9148
:1025E0002F912FBF2F9118958F938FB78F939F9314
:1025F000EF93FF9390911E0580911D05891731F48B
:102600008091C1008F7D8093C1000BC0E92FF0E065
:10261000E350FB4F80819F5F9F7190931E058093D5
:10262000C600FF91EF919F918F918FBF8F91189569
:10263000FC0191819A330CF0975080818A330CF021
:1026400087508295807F9F70892B08950E94181370
:102650000895EF92FF920F931F938C0104960E94AE
:102660001813E82EC80102960E941813F82EC8010C
:102670000E941813682F7F2D8E2D90E01F910F91CF
:10268000FF90EF900895823010F480934F05809171
:102690004F050895EF92FF921F93CF93DF93182F6A
:1026A0007B0190914305909350058091440581539F
:1026B00080934F058230F8F4892F61E00E94710FFA
:1026C0001350282F332727FD3095812F90E02817AE
:1026D000390789F4A5E4B5E0E701F9012A0F3B1FAA
:1026E00002C08D918993A217B307D9F7EE0DFF1D94
:1026F000108281E001C080E0DF91CF911F91FF90B7
:10270000EF900895CF93DF93EC01809142058823E9
:1027100021F16A3349F481E288838DE089831A824A
:10272000109242058EEF2DC080914E05E82FF0E00B
:10273000ED5BFA4F60838F5F80934E056D3051F4EF
:10274000BE010E944A13882391F0109242058091A5
:10275000500517C08B30A1F40AC06A3389F4109277
:102760004E0581E0809342051092430509C081E245
:1027700088838DE089831A82109242058FEF01C011
:1027800080E0DF91CF910895FF920F931F93CF9335
:10279000DF93EC01122F032FF42E662339F0862FDE
:1027A00060E00E94710F982F87FF04C081E2888348
:1027B00090E04EC08DE388839230D9F19330C9F414
:1027C000212F302F812F8F708A3008F0895F805D34
:1027D0008B83822F82958F708A3008F0895F805DAD
:1027E0008A83832F8F708A3008F0895F805D8983A8
:1027F0002FC0963069F58F2D8F708A3008F0895F71
:10280000805D8E834F2D42954F704A3008F0495FAE
:10281000405D4D83802F8F708A3008F0895F805D26
:102820008C83302F32953F703A3008F0395F305D3D
:102830003B83812F8F708A3008F0895F805D8A83A7
:10284000212F22952F702A3008F0295F205D2983DF
:10285000FE01E90FF11D8DE081831282DF91CF919E
:102860001F910F91FF9008951092420510924E050E
:102870002BE0E3E4F5E0DF011D922A95E9F71092E1
:102880004F050E94920F08955058BB27AA270ED0DB
:1028900086C177D130F07CD120F031F49F3F11F424
:1028A0001EF46CC10EF4E095E7FB37C1E92F88D127
:1028B00080F3BA17620773078407950718F071F45D
:1028C0009EF5B7C10EF4E0950B2EBA2FA02D0B018B
:1028D000B90190010C01CA01A0011124FF27591B65
:1028E00099F0593F50F4503E68F11A16F040A22F6B
:1028F000232F342F4427585FF3CF469537952795DC
:10290000A795F0405395C9F77EF41F16BA0B620BDA
:10291000730B840BBAF09150A1F0FF0FBB1F661F21
:10292000771F881FC2F70EC0BA0F621F731F841F64
:1029300048F4879577956795B795F7959E3F08F08A
:10294000B3CF9395880F08F09927EE0F9795879549
:10295000089558D180F09F3740F491110EF46AC168
:1029600060E070E080E89FE3089526F01B16611D8B
:10297000711D811DD8C0F2C00CD011C109D140F029
:1029800000D130F021F45F3F19F0C7C0511152C19E
:10299000F5C016D198F39923C9F35523B1F3951BCC
:1029A000550BBB27AA2762177307840738F09F5F70
:1029B0005F4F220F331F441FAA1FA9F333D00E2EDF
:1029C0003AF0E0E830D091505040E695001CCAF74C
:1029D00029D0FE2F27D0660F771F881FBB1F261711
:1029E00037074807AB07B0E809F0BB0B802DBF01E4
:1029F000FF2793585F4F2AF09E3F510568F08DC026
:102A000019C15F3FECF3983EDCF3869577956795A7
:102A1000B795F7959F5FC9F7880F911D9695879594
:102A200097F90895E1E0660F771F881FBB1F6217B3
:102A300073078407BA0720F0621B730B840BBA0B71
:102A4000EE1F88F7E0950895C3D088F09F5790F067
:102A5000B92F9927B751A0F0D1F0660F771F881FC3
:102A6000991F1AF0BA95C9F712C0B13081F0E1D0C0
:102A7000B1E00895DEC0672F782F8827B85F39F05E
:102A8000B93FCCF3869577956795B395D9F73EF422
:102A900090958095709561957F4F8F4F9F4F0895CA
:102AA000E89409C097FB3EF49095809570956195E8
:102AB0007F4F8F4F9F4F9923A9F0F92F96E9BB279E
:102AC0009395F695879577956795B795F111F8CF1A
:102AD000FAF4BB0F11F460FF1BC06F5F7F4F8F4F85
:102AE0009F4F16C0882311F096E911C0772321F07B
:102AF0009EE8872F762F05C0662371F096E8862F13
:102B000070E060E02AF09A95660F771F881FDAF769
:102B1000880F9695879597F9089597F99F6780E8AC
:102B200070E060E00895882371F4772321F09850D5
:102B3000872B762F07C0662311F499270DC090517B
:102B4000862B70E060E02AF09A95660F771F881F49
:102B5000DAF7880F9695879597F908959F3F49F082
:102B6000915028F4869577956795B7959F5F803843
:102B70009F4F880F9695879597F908959FEF80EC62
:102B8000089500240A9416161706180609060895D3
:102B900000240A9412161306140605060895092E39
:102BA0000394000C11F4882352F0BB0F40F4BF2BA8
:102BB00011F460FF04C06F5F7F4F8F4F9F4F0895E8
:102BC00057FD9058440F551F59F05F3F71F04795DE
:102BD000880F97FB991F61F09F3F79F087950895C3
:102BE000121613061406551FF2CF4695F1DF08C0E2
:102BF000161617061806991FF1CF869571056105FF
:102C000008940895E5DFA0F0BEE7B91788F4BB2764
:102C10009F3860F41616B11D672F782F8827985FAC
:102C2000F7CF869577956795B11D93959639C8F33B
:102C30000895E894BB2766277727CB0197F9089575
:102C40000BD0ADCF9EDF28F0A3DF18F0952309F05D
:102C500064CF94CF1124EECFB3DFA0F3959FD1F3CF
:102C6000950F50E0551F629FF001729FBB27F00D3A
:102C7000B11D639FAA27F00DB11DAA1F649F66278F
:102C8000B00DA11D661F829F2227B00DA11D621FDE
:102C9000739FB00DA11D621F839FA00D611D221F98
:102CA000749F3327A00D611D231F849F600D211D7C
:102CB000822F762F6A2F11249F5750408AF0E1F01F
:102CC00088234AF0EE0FFF1FBB1F661F771F881F68
:102CD00091505040A9F79E3F510570F01ECFAACFEA
:102CE0005F3FECF3983EDCF3869577956795B79553
:102CF000F795E7959F5FC1F7FE2B880F911D96957D
:102D0000879597F90895629FD001739FF001829F84
:102D1000E00DF11D649FE00DF11D929FF00D839F6A
:102D2000F00D749FF00D659FF00D9927729FB00D07
:102D3000E11DF91F639FB00DE11DF91FBD01CF011A
:102D400011240895AA1BBB1B51E107C0AA1FBB1F7A
:102D5000A617B70710F0A61BB70B881F991F5A9527
:102D6000A9F780959095BC01CD010895A1E21A2E96
:102D7000AA1BBB1BFD010DC0AA1FBB1FEE1FFF1F1F
:102D8000A217B307E407F50720F0A21BB30BE40B6F
:102D9000F50B661F771F881F991F1A9469F76095B6
:102DA0007095809590959B01AC01BD01CF01089570
:042DB000F894FFCFC5
:102DB400417374726F4551000103006A0006660096
:102DC400034906004702004A00004B000048060081
:102DD4004D06006500066100066200066700027386
:102DE40000064506005001004600004C0000410664
:102DF400004206005306006E00064E060044020020
:102E04006400024301006300025A02007A00025285
:102E140006007200064F01005102007100025806BC
:0A2E24000078000659020054000077
:00000001FF

C:\Users\Thomas\AppData\Local\Temp\build-257f0514-347c-4697-aed5-e6694d4cdfa1/AstroEQ6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007a  00800200  00002db4  00002e48  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002db4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002d7  0080027a  0080027a  00002ec2  2**0
                  ALLOC
  3 .debug_aranges 00000270  00000000  00000000  00002ec2  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000006ce  00000000  00000000  00003132  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003dd2  00000000  00000000  00003800  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000cc7  00000000  00000000  000075d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000315d  00000000  00000000  00008299  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000440  00000000  00000000  0000b3f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001135  00000000  00000000  0000b838  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001a73  00000000  00000000  0000c96d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000400  00000000  00000000  0000e3e0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

/*
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){
       0:	0c 94 ac 00 	jmp	0x158	; 0x158 <__ctors_end>
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
       4:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    return inter.integer; //and convert it to an integer
}

char synta_command(){
       8:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
       c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      10:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      14:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      18:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      1c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      20:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      24:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      28:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      2c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      30:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      34:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      38:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      3c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      40:	0c 94 b8 04 	jmp	0x970	; 0x970 <__vector_16>
      44:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      48:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      4c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      50:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      54:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      58:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      5c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      60:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      64:	0c 94 d3 12 	jmp	0x25a6	; 0x25a6 <__vector_25>
      68:	0c 94 f4 12 	jmp	0x25e8	; 0x25e8 <__vector_26>
      6c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      70:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      74:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      78:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      7c:	0c 94 be 03 	jmp	0x77c	; 0x77c <__vector_31>
      80:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      84:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      88:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      8c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      90:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      94:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      98:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      9c:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      a0:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      a4:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      a8:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      ac:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      b0:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      b4:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      b8:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      bc:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      c0:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      c4:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      c8:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      cc:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      d0:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      d4:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      d8:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      dc:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      e0:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__bad_interrupt>
      e4:	67 08       	sbc	r6, r7
      e6:	77 08       	sbc	r7, r7
      e8:	12 09       	sbc	r17, r2
      ea:	b7 08       	sbc	r11, r7
      ec:	c5 09       	sbc	r28, r5
      ee:	c5 09       	sbc	r28, r5
      f0:	c5 09       	sbc	r28, r5
      f2:	c5 09       	sbc	r28, r5
      f4:	c5 09       	sbc	r28, r5
      f6:	c5 09       	sbc	r28, r5
      f8:	c5 09       	sbc	r28, r5
      fa:	c5 09       	sbc	r28, r5
      fc:	c5 09       	sbc	r28, r5
      fe:	a3 08       	sbc	r10, r3
     100:	c5 09       	sbc	r28, r5
     102:	c5 09       	sbc	r28, r5
     104:	33 09       	sbc	r19, r3
     106:	d9 08       	sbc	r13, r9
     108:	87 08       	sbc	r8, r7
     10a:	af 09       	sbc	r26, r15
     10c:	c5 09       	sbc	r28, r5
     10e:	c5 09       	sbc	r28, r5
     110:	c5 09       	sbc	r28, r5
     112:	78 09       	sbc	r23, r8
     114:	a4 09       	sbc	r26, r4
     116:	fe 08       	sbc	r15, r14
     118:	c5 09       	sbc	r28, r5
     11a:	c5 09       	sbc	r28, r5
     11c:	c5 09       	sbc	r28, r5
     11e:	c5 09       	sbc	r28, r5
     120:	c5 09       	sbc	r28, r5
     122:	c5 09       	sbc	r28, r5
     124:	c5 09       	sbc	r28, r5
     126:	c5 09       	sbc	r28, r5
     128:	0a 09       	sbc	r16, r10
     12a:	af 08       	sbc	r10, r15
     12c:	c5 09       	sbc	r28, r5
     12e:	c5 09       	sbc	r28, r5
     130:	c5 09       	sbc	r28, r5
     132:	c5 09       	sbc	r28, r5
     134:	c5 09       	sbc	r28, r5
     136:	c5 09       	sbc	r28, r5
     138:	c5 09       	sbc	r28, r5
     13a:	c5 09       	sbc	r28, r5
     13c:	c5 09       	sbc	r28, r5
     13e:	97 08       	sbc	r9, r7
     140:	c5 09       	sbc	r28, r5
     142:	c5 09       	sbc	r28, r5
     144:	1e 09       	sbc	r17, r14
     146:	cf 08       	sbc	r12, r15
     148:	c5 09       	sbc	r28, r5
     14a:	c5 09       	sbc	r28, r5
     14c:	c5 09       	sbc	r28, r5
     14e:	c5 09       	sbc	r28, r5
     150:	c5 09       	sbc	r28, r5
     152:	4d 09       	sbc	r20, r13
     154:	c5 09       	sbc	r28, r5
     156:	f7 08       	sbc	r15, r7

00000158 <__ctors_end>:
     158:	11 24       	eor	r1, r1
     15a:	1f be       	out	0x3f, r1	; 63
     15c:	cf ef       	ldi	r28, 0xFF	; 255
     15e:	d1 e2       	ldi	r29, 0x21	; 33
     160:	de bf       	out	0x3e, r29	; 62
     162:	cd bf       	out	0x3d, r28	; 61
     164:	00 e0       	ldi	r16, 0x00	; 0
     166:	0c bf       	out	0x3c, r16	; 60

00000168 <_Z8wdt_initv>:

// Watchdog disable on boot.
void wdt_init(void) __attribute__((naked)) __attribute__((section(".init3")));
void wdt_init(void)
{
    wdt_disable();
     168:	88 e1       	ldi	r24, 0x18	; 24
     16a:	0f b6       	in	r0, 0x3f	; 63
     16c:	f8 94       	cli
     16e:	80 93 60 00 	sts	0x0060, r24
     172:	10 92 60 00 	sts	0x0060, r1
     176:	0f be       	out	0x3f, r0	; 63

00000178 <__do_copy_data>:
     178:	12 e0       	ldi	r17, 0x02	; 2
     17a:	a0 e0       	ldi	r26, 0x00	; 0
     17c:	b2 e0       	ldi	r27, 0x02	; 2
     17e:	e4 eb       	ldi	r30, 0xB4	; 180
     180:	fd e2       	ldi	r31, 0x2D	; 45
     182:	00 e0       	ldi	r16, 0x00	; 0
     184:	0b bf       	out	0x3b, r16	; 59
     186:	02 c0       	rjmp	.+4      	; 0x18c <__do_copy_data+0x14>
     188:	07 90       	elpm	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	aa 37       	cpi	r26, 0x7A	; 122
     18e:	b1 07       	cpc	r27, r17
     190:	d9 f7       	brne	.-10     	; 0x188 <__do_copy_data+0x10>
     192:	1b be       	out	0x3b, r1	; 59

00000194 <__do_clear_bss>:
     194:	15 e0       	ldi	r17, 0x05	; 5
     196:	aa e7       	ldi	r26, 0x7A	; 122
     198:	b2 e0       	ldi	r27, 0x02	; 2
     19a:	01 c0       	rjmp	.+2      	; 0x19e <.do_clear_bss_start>

0000019c <.do_clear_bss_loop>:
     19c:	1d 92       	st	X+, r1

0000019e <.do_clear_bss_start>:
     19e:	a1 35       	cpi	r26, 0x51	; 81
     1a0:	b1 07       	cpc	r27, r17
     1a2:	e1 f7       	brne	.-8      	; 0x19c <.do_clear_bss_loop>
     1a4:	0e 94 ed 0b 	call	0x17da	; 0x17da <main>
     1a8:	0c 94 d8 16 	jmp	0x2db0	; 0x2db0 <_exit>

000001ac <__bad_interrupt>:
     1ac:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001b0 <strncmp>:
     1b0:	fb 01       	movw	r30, r22
     1b2:	dc 01       	movw	r26, r24
     1b4:	41 50       	subi	r20, 0x01	; 1
     1b6:	50 40       	sbci	r21, 0x00	; 0
     1b8:	30 f0       	brcs	.+12     	; 0x1c6 <strncmp+0x16>
     1ba:	8d 91       	ld	r24, X+
     1bc:	01 90       	ld	r0, Z+
     1be:	80 19       	sub	r24, r0
     1c0:	19 f4       	brne	.+6      	; 0x1c8 <strncmp+0x18>
     1c2:	00 20       	and	r0, r0
     1c4:	b9 f7       	brne	.-18     	; 0x1b4 <strncmp+0x4>
     1c6:	88 1b       	sub	r24, r24
     1c8:	99 0b       	sbc	r25, r25
     1ca:	08 95       	ret

000001cc <buildModeMapping>:
byte modeState[2] = {((LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0)), (( LOW << MODE2) | ( LOW << MODE1) | (LOW << MODE0))}; //Default to 1/8th stepping as that is the same for all

void buildModeMapping(byte microsteps, byte driverVersion){
    //For microstep modes less than 8, we cannot jump to high speed, so we use the SPEEDFAST mode maps. Given that the SPEEDFAST maps are generated for the microstepping modes >=8
    //anyway, we can simply multiply the number of microsteps by 8 if it is less than 8 and thus reduce the number of cases in the mode generation switch statement below 
    if (microsteps < 8){
     1cc:	88 30       	cpi	r24, 0x08	; 8
     1ce:	18 f4       	brcc	.+6      	; 0x1d6 <buildModeMapping+0xa>
        microsteps *= 8;
     1d0:	88 0f       	add	r24, r24
     1d2:	88 0f       	add	r24, r24
     1d4:	88 0f       	add	r24, r24
    }
    //Generate the mode mapping for the current driver version and microstepping modes.
    switch (microsteps) {
     1d6:	88 30       	cpi	r24, 0x08	; 8
     1d8:	19 f0       	breq	.+6      	; 0x1e0 <buildModeMapping+0x14>
     1da:	80 32       	cpi	r24, 0x20	; 32
     1dc:	a1 f4       	brne	.+40     	; 0x206 <buildModeMapping+0x3a>
     1de:	06 c0       	rjmp	.+12     	; 0x1ec <buildModeMapping+0x20>
        case 8:
            // 1/8
            modeState[SPEEDNORM] =                                                                                       (( LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     1e0:	83 e0       	ldi	r24, 0x03	; 3
     1e2:	80 93 09 02 	sts	0x0209, r24
            // 1/1
            modeState[SPEEDFAST] =                                                                                       (( LOW << MODE2) | ( LOW << MODE1) | ( LOW << MODE0));
     1e6:	10 92 0a 02 	sts	0x020A, r1
     1ea:	08 95       	ret
            break;
        case 32:
            // 1/32
            modeState[SPEEDNORM] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | (HIGH << MODE1) | ( LOW << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     1ec:	62 30       	cpi	r22, 0x02	; 2
     1ee:	11 f0       	breq	.+4      	; 0x1f4 <buildModeMapping+0x28>
     1f0:	87 e0       	ldi	r24, 0x07	; 7
     1f2:	01 c0       	rjmp	.+2      	; 0x1f6 <buildModeMapping+0x2a>
     1f4:	82 e2       	ldi	r24, 0x22	; 34
     1f6:	80 93 09 02 	sts	0x0209, r24
            // 1/4
            modeState[SPEEDFAST] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | (HIGH << MODE1) | ( LOW << MODE0));
     1fa:	62 30       	cpi	r22, 0x02	; 2
     1fc:	11 f0       	breq	.+4      	; 0x202 <buildModeMapping+0x36>
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	0e c0       	rjmp	.+28     	; 0x21e <buildModeMapping+0x52>
     202:	80 e2       	ldi	r24, 0x20	; 32
     204:	0c c0       	rjmp	.+24     	; 0x21e <buildModeMapping+0x52>
            break;
        case 16:
        default:  //Unknown. Default to half/sixteenth stepping
            // 1/16
            modeState[SPEEDNORM] = (driverVersion == DRV882x) ? ((  LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     206:	61 30       	cpi	r22, 0x01	; 1
     208:	11 f0       	breq	.+4      	; 0x20e <buildModeMapping+0x42>
     20a:	87 e0       	ldi	r24, 0x07	; 7
     20c:	01 c0       	rjmp	.+2      	; 0x210 <buildModeMapping+0x44>
     20e:	81 e0       	ldi	r24, 0x01	; 1
     210:	80 93 09 02 	sts	0x0209, r24
            // 1/2
            modeState[SPEEDFAST] = (driverVersion == DRV882x) ? (( HIGH << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0));
     214:	61 30       	cpi	r22, 0x01	; 1
     216:	11 f0       	breq	.+4      	; 0x21c <buildModeMapping+0x50>
     218:	81 e0       	ldi	r24, 0x01	; 1
     21a:	01 c0       	rjmp	.+2      	; 0x21e <buildModeMapping+0x52>
     21c:	84 e0       	ldi	r24, 0x04	; 4
     21e:	80 93 0a 02 	sts	0x020A, r24
     222:	08 95       	ret

00000224 <standaloneModeTest>:
    //If we pull down and the pin stays high, then pin must be driven high (DRIVE HIGH)
    //If we pull up and the pin stays low, then pin must be driven low (DRIVE LOW)
    //Otherwise if pin follows us then it must be floating.

    //To start we check for an advanced controller
    setPinValue(standalonePin[STANDALONE_PULL],LOW); //Pull low
     224:	11 98       	cbi	0x02, 1	; 2
	...
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(allowAdvancedHCDetection && getPinValue(standalonePin[STANDALONE_IRQ])) {
     22e:	80 91 0d 03 	lds	r24, 0x030D
     232:	88 23       	and	r24, r24
     234:	21 f0       	breq	.+8      	; 0x23e <standaloneModeTest+0x1a>
     236:	48 9b       	sbis	0x09, 0	; 9
     238:	02 c0       	rjmp	.+4      	; 0x23e <standaloneModeTest+0x1a>
     23a:	82 e0       	ldi	r24, 0x02	; 2
     23c:	08 95       	ret
        //Note: Must be an advanced controller as pin stayed high and we are allowing HC detection. (If HC detection is disallowed its because we have no external pull down available)
        return ADVANCED_HC_MODE;
    }
    //Otherwise we check for a basic controller
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Convert to external pull-up of IRQ
     23e:	11 9a       	sbi	0x02, 1	; 2
	...
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     248:	89 b1       	in	r24, 0x09	; 9
     24a:	80 95       	com	r24
     24c:	81 70       	andi	r24, 0x01	; 1
    }


    //If we get this far then it is floating, so we assume EQMOD mode
    return EQMOD_MODE;
}
     24e:	08 95       	ret

00000250 <_Z17checkBasicHCSpeedv>:
    // +-----------+-----+-----+
    //
    //Note: if we don't have an external pull-up resistor, this function will return either ST-4 Rate (0,0) or GoTo Rate (1,1)
    //
    byte speed;
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     250:	48 99       	sbic	0x09, 0	; 9
     252:	02 c0       	rjmp	.+4      	; 0x258 <_Z17checkBasicHCSpeedv+0x8>
     254:	80 e0       	ldi	r24, 0x00	; 0
     256:	0b c0       	rjmp	.+22     	; 0x26e <_Z17checkBasicHCSpeedv+0x1e>
        //Must be a ST-4 rate as IRQ pin is low when external pull-up enabled
        speed = CMD_ST4_DEFAULT;
    } else {
        //Otherwise check which high-speed mode it is
        setPinDir  (standalonePin[STANDALONE_PULL],INPUT); //Disable external resistor by switching to input
     258:	09 98       	cbi	0x01, 1	; 1
        setPinValue(standalonePin[STANDALONE_PULL],LOW);   //with no internal pull-up (we are using the IRQ pin internal pull-up)
     25a:	11 98       	cbi	0x02, 1	; 2
	...
        nop(); // Input synchroniser takes a couple of cycles
        nop();
        nop();
        nop();
        
        if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     264:	48 9b       	sbis	0x09, 0	; 9
     266:	02 c0       	rjmp	.+4      	; 0x26c <_Z17checkBasicHCSpeedv+0x1c>
     268:	82 e0       	ldi	r24, 0x02	; 2
     26a:	01 c0       	rjmp	.+2      	; 0x26e <_Z17checkBasicHCSpeedv+0x1e>
     26c:	81 e0       	ldi	r24, 0x01	; 1
            speed = CMD_ST4_STANDALONE;
        } else {
            speed = CMD_ST4_HIGHSPEED;
        }
    }
    setPinDir  (standalonePin[STANDALONE_PULL],OUTPUT); //Ensure we leave an external pull-up of IRQ.
     26e:	09 9a       	sbi	0x01, 1	; 1
    setPinValue(standalonePin[STANDALONE_PULL],HIGH);
     270:	11 9a       	sbi	0x02, 1	; 2
    //And return the new speed
    return speed;
}
     272:	08 95       	ret

00000274 <motorEnable>:




void motorEnable(byte axis){
    if (axis == RA){
     274:	88 23       	and	r24, r24
     276:	29 f4       	brne	.+10     	; 0x282 <motorEnable+0xe>
        setPinValue(enablePin[RA],LOW); //IC enabled
     278:	a5 98       	cbi	0x14, 5	; 20
inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
}

inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	80 93 34 03 	sts	0x0334, r24
     280:	08 c0       	rjmp	.+16     	; 0x292 <motorEnable+0x1e>
        cmd_setFVal(RA,CMD_ENABLED);
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
     282:	80 91 02 01 	lds	r24, 0x0102
     286:	8f 7d       	andi	r24, 0xDF	; 223
     288:	80 93 02 01 	sts	0x0102, r24
     28c:	81 e0       	ldi	r24, 0x01	; 1
     28e:	80 93 35 03 	sts	0x0335, r24
    }
}

//Timer Interrupt-----------------------------------------------------------------------------
void configureTimer(){
    interruptControlRegister(DC) = 0; //disable all timer interrupts.
     292:	10 92 71 00 	sts	0x0071, r1
#if defined(__AVR_ATmega162__)
    interruptControlRegister(RA) &= 0b00000011; //for 162, the lower 2 bits of the declination register control another timer, so leave them alone.
#else
    interruptControlRegister(RA) = 0;
     296:	10 92 6f 00 	sts	0x006F, r1
#endif
    //set to ctc mode (0100)
    TCCR1A = 0;//~((1<<WGM11) | (1<<WGM10));
     29a:	10 92 80 00 	sts	0x0080, r1
    TCCR1B = ((1<<WGM12) | (1<<WGM13));
     29e:	88 e1       	ldi	r24, 0x18	; 24
     2a0:	80 93 81 00 	sts	0x0081, r24
    TCCR3A = 0;//~((1<<WGM31) | (1<<WGM30));
     2a4:	10 92 90 00 	sts	0x0090, r1
    TCCR3B = ((1<<WGM32) | (1<<WGM33));
     2a8:	80 93 91 00 	sts	0x0091, r24
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
        cmd_setFVal(DC,CMD_ENABLED);
    }
    configureTimer(); //setup the motor pulse timers.
}
     2ac:	08 95       	ret

000002ae <motorDisable>:

void motorDisable(byte axis){
    if (axis == RA){
     2ae:	88 23       	and	r24, r24
     2b0:	21 f4       	brne	.+8      	; 0x2ba <motorDisable+0xc>
        setPinValue(enablePin[RA],HIGH); //IC enabled
     2b2:	a5 9a       	sbi	0x14, 5	; 20
     2b4:	10 92 34 03 	sts	0x0334, r1
     2b8:	08 95       	ret
        cmd_setFVal(RA,CMD_DISABLED);
    } else {
        setPinValue(enablePin[DC],HIGH); //IC enabled
     2ba:	80 91 02 01 	lds	r24, 0x0102
     2be:	80 62       	ori	r24, 0x20	; 32
     2c0:	80 93 02 01 	sts	0x0102, r24
     2c4:	10 92 35 03 	sts	0x0335, r1
     2c8:	08 95       	ret

000002ca <motorStartRA>:
        motorStartDC();
    }
}

void motorStartRA(){
    unsigned int IVal = cmd.IVal[RA];
     2ca:	40 91 1e 03 	lds	r20, 0x031E
     2ce:	50 91 1f 03 	lds	r21, 0x031F
    unsigned int currentIVal;
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
     2d2:	80 91 6f 00 	lds	r24, 0x006F
     2d6:	8f 7d       	andi	r24, 0xDF	; 223
     2d8:	80 93 6f 00 	sts	0x006F, r24
    currentIVal = currentMotorSpeed(RA);
     2dc:	e0 91 9a 00 	lds	r30, 0x009A
     2e0:	f0 91 9b 00 	lds	r31, 0x009B
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
     2e4:	80 91 6f 00 	lds	r24, 0x006F
     2e8:	80 62       	ori	r24, 0x20	; 32
     2ea:	80 93 6f 00 	sts	0x006F, r24
    
    if (IVal > cmd.minSpeed[RA]){
     2ee:	20 91 71 03 	lds	r18, 0x0371
     2f2:	30 91 72 03 	lds	r19, 0x0372
     2f6:	c9 01       	movw	r24, r18
     2f8:	72 2f       	mov	r23, r18
     2fa:	69 2f       	mov	r22, r25
     2fc:	24 17       	cp	r18, r20
     2fe:	35 07       	cpc	r19, r21
     300:	18 f4       	brcc	.+6      	; 0x308 <motorStartRA+0x3e>
     302:	ca 01       	movw	r24, r20
     304:	74 2f       	mov	r23, r20
     306:	69 2f       	mov	r22, r25
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[RA];
    }
    if(cmd.stopped[RA]) {
     308:	a0 91 38 03 	lds	r26, 0x0338
     30c:	aa 23       	and	r26, r26
     30e:	29 f4       	brne	.+10     	; 0x31a <motorStartRA+0x50>
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[RA]) {
     310:	e2 17       	cp	r30, r18
     312:	f3 07       	cpc	r31, r19
     314:	10 f4       	brcc	.+4      	; 0x31a <motorStartRA+0x50>
     316:	9f 01       	movw	r18, r30
     318:	03 c0       	rjmp	.+6      	; 0x320 <motorStartRA+0x56>
     31a:	87 2f       	mov	r24, r23
     31c:	96 2f       	mov	r25, r22
     31e:	9c 01       	movw	r18, r24
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
     320:	80 91 6f 00 	lds	r24, 0x006F
     324:	8f 7d       	andi	r24, 0xDF	; 223
     326:	80 93 6f 00 	sts	0x006F, r24
    cmd.currentIVal[RA] = cmd.IVal[RA];
     32a:	50 93 6e 03 	sts	0x036E, r21
     32e:	40 93 6d 03 	sts	0x036D, r20
    currentMotorSpeed(RA) = startSpeed;
     332:	30 93 9b 00 	sts	0x009B, r19
     336:	20 93 9a 00 	sts	0x009A, r18
    cmd.stopSpeed[RA] = stoppingSpeed;
     33a:	70 93 79 03 	sts	0x0379, r23
     33e:	60 93 7a 03 	sts	0x037A, r22
    setPinValue(dirPin[RA],(encodeDirection[RA] != cmd.dir[RA]));
     342:	90 91 84 02 	lds	r25, 0x0284
     346:	80 91 32 03 	lds	r24, 0x0332
     34a:	98 17       	cp	r25, r24
     34c:	11 f0       	breq	.+4      	; 0x352 <motorStartRA+0x88>
     34e:	75 9a       	sbi	0x0e, 5	; 14
     350:	01 c0       	rjmp	.+2      	; 0x354 <motorStartRA+0x8a>
     352:	75 98       	cbi	0x0e, 5	; 14
    
    if(cmd.stopped[RA]) { //if stopped, configure timers
     354:	aa 23       	and	r26, r26
     356:	29 f1       	breq	.+74     	; 0x3a2 <motorStartRA+0xd8>
        irqToNextStep(RA) = 1;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	90 e0       	ldi	r25, 0x00	; 0
     35c:	90 93 8b 00 	sts	0x008B, r25
     360:	80 93 8a 00 	sts	0x008A, r24
        accelTableRepeatsLeft[RA] = cmd.accelTable[RA][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
     364:	80 91 7f 03 	lds	r24, 0x037F
     368:	80 93 12 03 	sts	0x0312, r24
        accelTableIndex[RA] = 0;
     36c:	10 92 14 03 	sts	0x0314, r1
        distributionSegment(RA) = 0;
     370:	1b bc       	out	0x2b, r1	; 43
        timerCountRegister(RA) = 0;
     372:	10 92 85 00 	sts	0x0085, r1
     376:	10 92 84 00 	sts	0x0084, r1
        interruptOVFCount(RA) = timerOVF[RA][0];
     37a:	80 91 8a 02 	lds	r24, 0x028A
     37e:	90 91 8b 02 	lds	r25, 0x028B
     382:	90 93 87 00 	sts	0x0087, r25
     386:	80 93 86 00 	sts	0x0086, r24
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
     38a:	80 91 81 00 	lds	r24, 0x0081
     38e:	89 7f       	andi	r24, 0xF9	; 249
     390:	80 93 81 00 	sts	0x0081, r24
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
     394:	80 91 81 00 	lds	r24, 0x0081
     398:	81 60       	ori	r24, 0x01	; 1
     39a:	80 93 81 00 	sts	0x0081, r24
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     39e:	10 92 38 03 	sts	0x0338, r1
        timerCountRegister(RA) = 0;
        interruptOVFCount(RA) = timerOVF[RA][0];
        timerEnable(RA);
        cmd_setStopped(RA, CMD_RUNNING);
    }
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
     3a2:	80 91 6f 00 	lds	r24, 0x006F
     3a6:	80 62       	ori	r24, 0x20	; 32
     3a8:	80 93 6f 00 	sts	0x006F, r24
}
     3ac:	08 95       	ret

000003ae <motorStartDC>:

void motorStartDC(){
    unsigned int IVal = cmd.IVal[DC];
     3ae:	40 91 20 03 	lds	r20, 0x0320
     3b2:	50 91 21 03 	lds	r21, 0x0321
    unsigned int currentIVal;
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
     3b6:	80 91 71 00 	lds	r24, 0x0071
     3ba:	8f 7d       	andi	r24, 0xDF	; 223
     3bc:	80 93 71 00 	sts	0x0071, r24
    currentIVal = currentMotorSpeed(DC);
     3c0:	e0 91 98 00 	lds	r30, 0x0098
     3c4:	f0 91 99 00 	lds	r31, 0x0099
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
     3c8:	80 91 71 00 	lds	r24, 0x0071
     3cc:	80 62       	ori	r24, 0x20	; 32
     3ce:	80 93 71 00 	sts	0x0071, r24
    
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    if (IVal > cmd.minSpeed[DC]){
     3d2:	20 91 73 03 	lds	r18, 0x0373
     3d6:	30 91 74 03 	lds	r19, 0x0374
     3da:	c9 01       	movw	r24, r18
     3dc:	72 2f       	mov	r23, r18
     3de:	69 2f       	mov	r22, r25
     3e0:	24 17       	cp	r18, r20
     3e2:	35 07       	cpc	r19, r21
     3e4:	18 f4       	brcc	.+6      	; 0x3ec <motorStartDC+0x3e>
     3e6:	ca 01       	movw	r24, r20
     3e8:	74 2f       	mov	r23, r20
     3ea:	69 2f       	mov	r22, r25
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[DC];
    }
    if(cmd.stopped[DC]) {
     3ec:	a0 91 39 03 	lds	r26, 0x0339
     3f0:	aa 23       	and	r26, r26
     3f2:	29 f4       	brne	.+10     	; 0x3fe <motorStartDC+0x50>
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[DC]) {
     3f4:	e2 17       	cp	r30, r18
     3f6:	f3 07       	cpc	r31, r19
     3f8:	10 f4       	brcc	.+4      	; 0x3fe <motorStartDC+0x50>
     3fa:	9f 01       	movw	r18, r30
     3fc:	03 c0       	rjmp	.+6      	; 0x404 <motorStartDC+0x56>
     3fe:	87 2f       	mov	r24, r23
     400:	96 2f       	mov	r25, r22
     402:	9c 01       	movw	r18, r24
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
     404:	80 91 71 00 	lds	r24, 0x0071
     408:	8f 7d       	andi	r24, 0xDF	; 223
     40a:	80 93 71 00 	sts	0x0071, r24
    cmd.currentIVal[DC] = cmd.IVal[DC];
     40e:	50 93 70 03 	sts	0x0370, r21
     412:	40 93 6f 03 	sts	0x036F, r20
    currentMotorSpeed(DC) = startSpeed;
     416:	30 93 99 00 	sts	0x0099, r19
     41a:	20 93 98 00 	sts	0x0098, r18
    cmd.stopSpeed[DC] = stoppingSpeed;
     41e:	70 93 7b 03 	sts	0x037B, r23
     422:	60 93 7c 03 	sts	0x037C, r22
    setPinValue(dirPin[DC],(encodeDirection[DC] != cmd.dir[DC]));
     426:	90 91 85 02 	lds	r25, 0x0285
     42a:	80 91 33 03 	lds	r24, 0x0333
     42e:	98 17       	cp	r25, r24
     430:	21 f0       	breq	.+8      	; 0x43a <motorStartDC+0x8c>
     432:	80 91 02 01 	lds	r24, 0x0102
     436:	80 61       	ori	r24, 0x10	; 16
     438:	03 c0       	rjmp	.+6      	; 0x440 <motorStartDC+0x92>
     43a:	80 91 02 01 	lds	r24, 0x0102
     43e:	8f 7e       	andi	r24, 0xEF	; 239
     440:	80 93 02 01 	sts	0x0102, r24
    
    if(cmd.stopped[DC]) { //if stopped, configure timers
     444:	aa 23       	and	r26, r26
     446:	29 f1       	breq	.+74     	; 0x492 <motorStartDC+0xe4>
        irqToNextStep(DC) = 1;
     448:	81 e0       	ldi	r24, 0x01	; 1
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	90 93 89 00 	sts	0x0089, r25
     450:	80 93 88 00 	sts	0x0088, r24
        accelTableRepeatsLeft[DC] = cmd.accelTable[DC][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
     454:	80 91 3f 04 	lds	r24, 0x043F
     458:	80 93 13 03 	sts	0x0313, r24
        accelTableIndex[DC] = 0;
     45c:	10 92 15 03 	sts	0x0315, r1
        distributionSegment(DC) = 0;
     460:	1a bc       	out	0x2a, r1	; 42
        timerCountRegister(DC) = 0;
     462:	10 92 95 00 	sts	0x0095, r1
     466:	10 92 94 00 	sts	0x0094, r1
        interruptOVFCount(DC) = timerOVF[DC][0];
     46a:	80 91 ca 02 	lds	r24, 0x02CA
     46e:	90 91 cb 02 	lds	r25, 0x02CB
     472:	90 93 97 00 	sts	0x0097, r25
     476:	80 93 96 00 	sts	0x0096, r24
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
     47a:	80 91 91 00 	lds	r24, 0x0091
     47e:	89 7f       	andi	r24, 0xF9	; 249
     480:	80 93 91 00 	sts	0x0091, r24
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
     484:	80 91 91 00 	lds	r24, 0x0091
     488:	81 60       	ori	r24, 0x01	; 1
     48a:	80 93 91 00 	sts	0x0091, r24
     48e:	10 92 39 03 	sts	0x0339, r1
        timerCountRegister(DC) = 0;
        interruptOVFCount(DC) = timerOVF[DC][0];
        timerEnable(DC);
        cmd_setStopped(DC, CMD_RUNNING);
    }
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
     492:	80 91 71 00 	lds	r24, 0x0071
     496:	80 62       	ori	r24, 0x20	; 32
     498:	80 93 71 00 	sts	0x0071, r24
}
     49c:	08 95       	ret

0000049e <motorStart>:
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStart functions (one for RA and one for DEC)
void motorStart(byte motor){
    if (motor == RA) {
     49e:	88 23       	and	r24, r24
     4a0:	19 f4       	brne	.+6      	; 0x4a8 <motorStart+0xa>
        motorStartRA();
     4a2:	0e 94 65 01 	call	0x2ca	; 0x2ca <motorStartRA>
     4a6:	08 95       	ret
    } else {
        motorStartDC();
     4a8:	0e 94 d7 01 	call	0x3ae	; 0x3ae <motorStartDC>
     4ac:	08 95       	ret

000004ae <gotoMode>:

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
}

void gotoMode(byte axis){
     4ae:	9f 92       	push	r9
     4b0:	af 92       	push	r10
     4b2:	bf 92       	push	r11
     4b4:	cf 92       	push	r12
     4b6:	df 92       	push	r13
     4b8:	ef 92       	push	r14
     4ba:	ff 92       	push	r15
     4bc:	0f 93       	push	r16
     4be:	1f 93       	push	r17
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	c8 2e       	mov	r12, r24
    unsigned int decelerationLength = gotoDecelerationLength[axis];
     4c6:	c8 2f       	mov	r28, r24
     4c8:	d0 e0       	ldi	r29, 0x00	; 0
     4ca:	fe 01       	movw	r30, r28
     4cc:	ee 0f       	add	r30, r30
     4ce:	ff 1f       	adc	r31, r31
     4d0:	e2 5f       	subi	r30, 0xF2	; 242
     4d2:	fc 4f       	sbci	r31, 0xFC	; 252
     4d4:	00 81       	ld	r16, Z
     4d6:	11 81       	ldd	r17, Z+1	; 0x01
    
    if (cmd.highSpeedMode[axis]) {
     4d8:	fe 01       	movw	r30, r28
     4da:	ea 5e       	subi	r30, 0xEA	; 234
     4dc:	fc 4f       	sbci	r31, 0xFC	; 252
     4de:	84 a1       	ldd	r24, Z+36	; 0x24
     4e0:	88 23       	and	r24, r24
     4e2:	29 f0       	breq	.+10     	; 0x4ee <gotoMode+0x40>
        //Additionally in order to maintain the same speed profile in high-speed mode, we actually increase the profile repeats by a factor of sqrt(8)
        //compared with running in normal-speed mode. See Atmel AVR466 app note for calculation.
        decelerationLength = decelerationLength * 3; //multiply by 3 as it is approx sqrt(8)
     4e4:	c8 01       	movw	r24, r16
     4e6:	88 0f       	add	r24, r24
     4e8:	99 1f       	adc	r25, r25
     4ea:	08 0f       	add	r16, r24
     4ec:	19 1f       	adc	r17, r25
    }
    
    byte dirMagnitude = abs(cmd.stepDir[axis]);
     4ee:	fe 01       	movw	r30, r28
     4f0:	ea 5e       	subi	r30, 0xEA	; 234
     4f2:	fc 4f       	sbci	r31, 0xFC	; 252
     4f4:	82 8d       	ldd	r24, Z+26	; 0x1a
     4f6:	18 16       	cp	r1, r24
     4f8:	14 f4       	brge	.+4      	; 0x4fe <gotoMode+0x50>
     4fa:	d2 8c       	ldd	r13, Z+26	; 0x1a
     4fc:	02 c0       	rjmp	.+4      	; 0x502 <gotoMode+0x54>
     4fe:	d2 8c       	ldd	r13, Z+26	; 0x1a
     500:	d1 94       	neg	r13
    byte dir = cmd.dir[axis];
     502:	fe 01       	movw	r30, r28
     504:	ea 5e       	subi	r30, 0xEA	; 234
     506:	fc 4f       	sbci	r31, 0xFC	; 252
     508:	94 8c       	ldd	r9, Z+28	; 0x1c

    if (cmd.HVal[axis] < 2*dirMagnitude){
     50a:	8d 2d       	mov	r24, r13
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	88 0f       	add	r24, r24
     510:	99 1f       	adc	r25, r25
     512:	9c 01       	movw	r18, r24
     514:	44 27       	eor	r20, r20
     516:	37 fd       	sbrc	r19, 7
     518:	40 95       	com	r20
     51a:	54 2f       	mov	r21, r20
     51c:	fe 01       	movw	r30, r28
     51e:	ee 0f       	add	r30, r30
     520:	ff 1f       	adc	r31, r31
     522:	ee 0f       	add	r30, r30
     524:	ff 1f       	adc	r31, r31
     526:	ea 5e       	subi	r30, 0xEA	; 234
     528:	fc 4f       	sbci	r31, 0xFC	; 252
     52a:	82 89       	ldd	r24, Z+18	; 0x12
     52c:	93 89       	ldd	r25, Z+19	; 0x13
     52e:	a4 89       	ldd	r26, Z+20	; 0x14
     530:	b5 89       	ldd	r27, Z+21	; 0x15
     532:	82 17       	cp	r24, r18
     534:	93 07       	cpc	r25, r19
     536:	a4 07       	cpc	r26, r20
     538:	b5 07       	cpc	r27, r21
     53a:	20 f4       	brcc	.+8      	; 0x544 <gotoMode+0x96>
inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
     53c:	22 8b       	std	Z+18, r18	; 0x12
     53e:	33 8b       	std	Z+19, r19	; 0x13
     540:	44 8b       	std	Z+20, r20	; 0x14
     542:	55 8b       	std	Z+21, r21	; 0x15
        cmd_setHVal(axis,2*dirMagnitude);
    }

    decelerationLength = decelerationLength * dirMagnitude;
     544:	8d 2d       	mov	r24, r13
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	80 9f       	mul	r24, r16
     54a:	b0 01       	movw	r22, r0
     54c:	81 9f       	mul	r24, r17
     54e:	70 0d       	add	r23, r0
     550:	90 9f       	mul	r25, r16
     552:	70 0d       	add	r23, r0
     554:	11 24       	eor	r1, r1
    //decelleration length is here a multiple of stepDir.
    unsigned long HVal = cmd.HVal[axis];
     556:	fe 01       	movw	r30, r28
     558:	ee 0f       	add	r30, r30
     55a:	ff 1f       	adc	r31, r31
     55c:	ee 0f       	add	r30, r30
     55e:	ff 1f       	adc	r31, r31
     560:	ea 5e       	subi	r30, 0xEA	; 234
     562:	fc 4f       	sbci	r31, 0xFC	; 252
     564:	e2 88       	ldd	r14, Z+18	; 0x12
     566:	f3 88       	ldd	r15, Z+19	; 0x13
     568:	04 89       	ldd	r16, Z+20	; 0x14
     56a:	15 89       	ldd	r17, Z+21	; 0x15
    unsigned long halfHVal = (HVal >> 1);
     56c:	a8 01       	movw	r20, r16
     56e:	97 01       	movw	r18, r14
     570:	56 95       	lsr	r21
     572:	47 95       	ror	r20
     574:	37 95       	ror	r19
     576:	27 95       	ror	r18
    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
     578:	fe 01       	movw	r30, r28
     57a:	ee 0f       	add	r30, r30
     57c:	ff 1f       	adc	r31, r31
     57e:	eb 58       	subi	r30, 0x8B	; 139
     580:	fc 4f       	sbci	r31, 0xFC	; 252
     582:	a0 80       	ld	r10, Z
     584:	b1 80       	ldd	r11, Z+1	; 0x01
    if(dirMagnitude == 8){
     586:	88 e0       	ldi	r24, 0x08	; 8
     588:	d8 16       	cp	r13, r24
     58a:	49 f4       	brne	.+18     	; 0x59e <gotoMode+0xf0>
        HVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
     58c:	88 ef       	ldi	r24, 0xF8	; 248
     58e:	9f ef       	ldi	r25, 0xFF	; 255
     590:	af ef       	ldi	r26, 0xFF	; 255
     592:	bf ef       	ldi	r27, 0xFF	; 255
     594:	e8 22       	and	r14, r24
     596:	f9 22       	and	r15, r25
     598:	0a 23       	and	r16, r26
     59a:	1b 23       	and	r17, r27
    }
    if(dirMagnitude == 8){
        halfHVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
     59c:	28 7f       	andi	r18, 0xF8	; 248
    }
    //HVal and halfHVal are here a multiple of stepDir
    if (halfHVal < decelerationLength) {
     59e:	cb 01       	movw	r24, r22
     5a0:	a0 e0       	ldi	r26, 0x00	; 0
     5a2:	b0 e0       	ldi	r27, 0x00	; 0
     5a4:	28 17       	cp	r18, r24
     5a6:	39 07       	cpc	r19, r25
     5a8:	4a 07       	cpc	r20, r26
     5aa:	5b 07       	cpc	r21, r27
     5ac:	08 f4       	brcc	.+2      	; 0x5b0 <gotoMode+0x102>
        decelerationLength = halfHVal;
     5ae:	b9 01       	movw	r22, r18
    }
    HVal -= decelerationLength;
     5b0:	cb 01       	movw	r24, r22
     5b2:	a0 e0       	ldi	r26, 0x00	; 0
     5b4:	b0 e0       	ldi	r27, 0x00	; 0
     5b6:	a8 01       	movw	r20, r16
     5b8:	97 01       	movw	r18, r14
     5ba:	28 1b       	sub	r18, r24
     5bc:	39 0b       	sbc	r19, r25
     5be:	4a 0b       	sbc	r20, r26
     5c0:	5b 0b       	sbc	r21, r27
     5c2:	da 01       	movw	r26, r20
     5c4:	c9 01       	movw	r24, r18
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
     5c6:	fe 01       	movw	r30, r28
     5c8:	ee 0f       	add	r30, r30
     5ca:	ff 1f       	adc	r31, r31
     5cc:	ee 0f       	add	r30, r30
     5ce:	ff 1f       	adc	r31, r31
     5d0:	ea 5e       	subi	r30, 0xEA	; 234
     5d2:	fc 4f       	sbci	r31, 0xFC	; 252
     5d4:	20 81       	ld	r18, Z
     5d6:	31 81       	ldd	r19, Z+1	; 0x01
     5d8:	42 81       	ldd	r20, Z+2	; 0x02
     5da:	53 81       	ldd	r21, Z+3	; 0x03
     5dc:	99 20       	and	r9, r9
     5de:	39 f0       	breq	.+14     	; 0x5ee <gotoMode+0x140>
     5e0:	b0 95       	com	r27
     5e2:	a0 95       	com	r26
     5e4:	90 95       	com	r25
     5e6:	81 95       	neg	r24
     5e8:	9f 4f       	sbci	r25, 0xFF	; 255
     5ea:	af 4f       	sbci	r26, 0xFF	; 255
     5ec:	bf 4f       	sbci	r27, 0xFF	; 255
     5ee:	fe 01       	movw	r30, r28
     5f0:	ee 0f       	add	r30, r30
     5f2:	ff 1f       	adc	r31, r31
     5f4:	ee 0f       	add	r30, r30
     5f6:	ff 1f       	adc	r31, r31
     5f8:	e4 58       	subi	r30, 0x84	; 132
     5fa:	fd 4f       	sbci	r31, 0xFD	; 253
     5fc:	82 0f       	add	r24, r18
     5fe:	93 1f       	adc	r25, r19
     600:	a4 1f       	adc	r26, r20
     602:	b5 1f       	adc	r27, r21
     604:	80 83       	st	Z, r24
     606:	91 83       	std	Z+1, r25	; 0x01
     608:	a2 83       	std	Z+2, r26	; 0x02
     60a:	b3 83       	std	Z+3, r27	; 0x03
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
     60c:	cc 0f       	add	r28, r28
     60e:	dd 1f       	adc	r29, r29
     610:	c2 5e       	subi	r28, 0xE2	; 226
     612:	dc 4f       	sbci	r29, 0xFC	; 252
     614:	b9 82       	std	Y+1, r11	; 0x01
     616:	a8 82       	st	Y, r10
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
}
inline void clearGotoDecelerating(const byte axis) {
    gotoControlRegister &= ~gotoDeceleratingBitMask(axis);
     618:	9e b3       	in	r25, 0x1e	; 30
     61a:	cc 20       	and	r12, r12
     61c:	11 f4       	brne	.+4      	; 0x622 <gotoMode+0x174>
     61e:	8b ef       	ldi	r24, 0xFB	; 251
     620:	01 c0       	rjmp	.+2      	; 0x624 <gotoMode+0x176>
     622:	87 ef       	ldi	r24, 0xF7	; 247
     624:	89 23       	and	r24, r25
     626:	8e bb       	out	0x1e, r24	; 30
}
inline bool gotoDecelerating(const byte axis) {
    return (gotoControlRegister & gotoDeceleratingBitMask(axis));
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
     628:	9e b3       	in	r25, 0x1e	; 30
     62a:	cc 20       	and	r12, r12
     62c:	11 f4       	brne	.+4      	; 0x632 <gotoMode+0x184>
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	01 c0       	rjmp	.+2      	; 0x634 <gotoMode+0x186>
     632:	82 e0       	ldi	r24, 0x02	; 2
     634:	89 2b       	or	r24, r25
     636:	8e bb       	out	0x1e, r24	; 30
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
    
    cmd_setIVal(axis, gotoSpeed);
    clearGotoDecelerating(axis);
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
     638:	8c 2d       	mov	r24, r12
     63a:	0e 94 4f 02 	call	0x49e	; 0x49e <motorStart>
}
     63e:	df 91       	pop	r29
     640:	cf 91       	pop	r28
     642:	1f 91       	pop	r17
     644:	0f 91       	pop	r16
     646:	ff 90       	pop	r15
     648:	ef 90       	pop	r14
     64a:	df 90       	pop	r13
     64c:	cf 90       	pop	r12
     64e:	bf 90       	pop	r11
     650:	af 90       	pop	r10
     652:	9f 90       	pop	r9
     654:	08 95       	ret

00000656 <motorStopRA>:
        motorStopDC(emergency);
    }
}

void motorStopRA(bool emergency){
    if (emergency) {
     656:	88 23       	and	r24, r24
     658:	a9 f0       	breq	.+42     	; 0x684 <motorStopRA+0x2e>
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     65a:	80 91 6f 00 	lds	r24, 0x006F
     65e:	8f 7d       	andi	r24, 0xDF	; 223
     660:	80 93 6f 00 	sts	0x006F, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     664:	80 91 81 00 	lds	r24, 0x0081
     668:	88 7f       	andi	r24, 0xF8	; 248
     66a:	80 93 81 00 	sts	0x0081, r24
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     66e:	10 92 36 03 	sts	0x0336, r1
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     672:	81 e0       	ldi	r24, 0x01	; 1
     674:	80 93 38 03 	sts	0x0338, r24
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     678:	10 92 26 03 	sts	0x0326, r1
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(RA);
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
     67c:	10 92 7a 02 	sts	0x027A, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     680:	f0 98       	cbi	0x1e, 0	; 30
     682:	08 95       	ret
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
        clearGotoRunning(RA);
    } else if (!cmd.stopped[RA]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
     684:	80 91 38 03 	lds	r24, 0x0338
     688:	88 23       	and	r24, r24
     68a:	39 f5       	brne	.+78     	; 0x6da <motorStopRA+0x84>
        //trigger ISR based decelleration
        //readyToGo[RA] = 0;
        byte oldSREG = SREG;
     68c:	4f b7       	in	r20, 0x3f	; 63
        cli();
     68e:	f8 94       	cli
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     690:	10 92 36 03 	sts	0x0336, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     694:	f0 98       	cbi	0x1e, 0	; 30
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     696:	10 92 26 03 	sts	0x0326, r1
        cli();
        cmd_setGotoEn(RA,CMD_DISABLED); //No longer in goto mode.
        clearGotoRunning(RA);
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        //interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
        if(cmd.currentIVal[RA] < cmd.minSpeed[RA]){
     69a:	20 91 71 03 	lds	r18, 0x0371
     69e:	30 91 72 03 	lds	r19, 0x0372
     6a2:	80 91 6d 03 	lds	r24, 0x036D
     6a6:	90 91 6e 03 	lds	r25, 0x036E
     6aa:	82 17       	cp	r24, r18
     6ac:	93 07       	cpc	r25, r19
     6ae:	58 f4       	brcc	.+22     	; 0x6c6 <motorStopRA+0x70>
            if(cmd.stopSpeed[RA] > cmd.minSpeed[RA]){
     6b0:	80 91 79 03 	lds	r24, 0x0379
     6b4:	90 91 7a 03 	lds	r25, 0x037A
     6b8:	28 17       	cp	r18, r24
     6ba:	39 07       	cpc	r19, r25
     6bc:	20 f4       	brcc	.+8      	; 0x6c6 <motorStopRA+0x70>
                cmd.stopSpeed[RA] = cmd.minSpeed[RA];
     6be:	30 93 7a 03 	sts	0x037A, r19
     6c2:	20 93 79 03 	sts	0x0379, r18
            }
        }/* else {
            stopSpeed[RA] = cmd.currentIVal[RA];
        }*/
        cmd.currentIVal[RA] = cmd.stopSpeed[RA] + 1;//cmd.stepIncrement[motor];
     6c6:	80 91 79 03 	lds	r24, 0x0379
     6ca:	90 91 7a 03 	lds	r25, 0x037A
     6ce:	01 96       	adiw	r24, 0x01	; 1
     6d0:	90 93 6e 03 	sts	0x036E, r25
     6d4:	80 93 6d 03 	sts	0x036D, r24
        SREG = oldSREG;
     6d8:	4f bf       	out	0x3f, r20	; 63
     6da:	08 95       	ret

000006dc <motorStopDC>:
        //interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    }
}

void motorStopDC(bool emergency){
    if (emergency) {
     6dc:	88 23       	and	r24, r24
     6de:	a9 f0       	breq	.+42     	; 0x70a <motorStopDC+0x2e>
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     6e0:	80 91 71 00 	lds	r24, 0x0071
     6e4:	8f 7d       	andi	r24, 0xDF	; 223
     6e6:	80 93 71 00 	sts	0x0071, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     6ea:	80 91 91 00 	lds	r24, 0x0091
     6ee:	88 7f       	andi	r24, 0xF8	; 248
     6f0:	80 93 91 00 	sts	0x0091, r24
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     6f4:	10 92 37 03 	sts	0x0337, r1
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     6f8:	81 e0       	ldi	r24, 0x01	; 1
     6fa:	80 93 39 03 	sts	0x0339, r24
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     6fe:	10 92 27 03 	sts	0x0327, r1
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(DC);
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
     702:	10 92 7b 02 	sts	0x027B, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     706:	f1 98       	cbi	0x1e, 1	; 30
     708:	08 95       	ret
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
        clearGotoRunning(DC);
    } else if (!cmd.stopped[DC]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
     70a:	80 91 39 03 	lds	r24, 0x0339
     70e:	88 23       	and	r24, r24
     710:	39 f5       	brne	.+78     	; 0x760 <motorStopDC+0x84>
        //trigger ISR based decelleration
        //readyToGo[motor] = 0;
        byte oldSREG = SREG;
     712:	4f b7       	in	r20, 0x3f	; 63
        cli();
     714:	f8 94       	cli
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     716:	10 92 37 03 	sts	0x0337, r1
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     71a:	10 92 27 03 	sts	0x0327, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     71e:	f1 98       	cbi	0x1e, 1	; 30
        cli();
        cmd_setGotoEn(DC,CMD_DISABLED); //No longer in goto mode.
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        clearGotoRunning(DC);
        //interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
        if(cmd.currentIVal[DC] < cmd.minSpeed[DC]){
     720:	20 91 73 03 	lds	r18, 0x0373
     724:	30 91 74 03 	lds	r19, 0x0374
     728:	80 91 6f 03 	lds	r24, 0x036F
     72c:	90 91 70 03 	lds	r25, 0x0370
     730:	82 17       	cp	r24, r18
     732:	93 07       	cpc	r25, r19
     734:	58 f4       	brcc	.+22     	; 0x74c <motorStopDC+0x70>
            if(cmd.stopSpeed[DC] > cmd.minSpeed[DC]){
     736:	80 91 7b 03 	lds	r24, 0x037B
     73a:	90 91 7c 03 	lds	r25, 0x037C
     73e:	28 17       	cp	r18, r24
     740:	39 07       	cpc	r19, r25
     742:	20 f4       	brcc	.+8      	; 0x74c <motorStopDC+0x70>
                cmd.stopSpeed[DC] = cmd.minSpeed[DC];
     744:	30 93 7c 03 	sts	0x037C, r19
     748:	20 93 7b 03 	sts	0x037B, r18
            }
        }/* else {
        stopSpeed[DC] = cmd.currentIVal[DC];
        }*/
        cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//cmd.stepIncrement[motor];
     74c:	80 91 7b 03 	lds	r24, 0x037B
     750:	90 91 7c 03 	lds	r25, 0x037C
     754:	01 96       	adiw	r24, 0x01	; 1
     756:	90 93 70 03 	sts	0x0370, r25
     75a:	80 93 6f 03 	sts	0x036F, r24
        SREG = oldSREG;
     75e:	4f bf       	out	0x3f, r20	; 63
     760:	08 95       	ret

00000762 <motorStop>:
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStop functions (one for RA and one for DEC)
void motorStop(byte motor, byte emergency){
    if (motor == RA) {
     762:	88 23       	and	r24, r24
     764:	29 f4       	brne	.+10     	; 0x770 <motorStop+0xe>
        motorStopRA(emergency);
     766:	61 11       	cpse	r22, r1
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	0e 94 2b 03 	call	0x656	; 0x656 <motorStopRA>
     76e:	08 95       	ret
    } else {
        motorStopDC(emergency);
     770:	80 e0       	ldi	r24, 0x00	; 0
     772:	61 11       	cpse	r22, r1
     774:	81 e0       	ldi	r24, 0x01	; 1
     776:	0e 94 6e 03 	call	0x6dc	; 0x6dc <motorStopDC>
     77a:	08 95       	ret

0000077c <__vector_31>:
}



/*Timer Interrupt Vector*/
ISR(TIMER3_CAPT_vect) {
     77c:	1f 92       	push	r1
     77e:	0f 92       	push	r0
     780:	0f b6       	in	r0, 0x3f	; 63
     782:	0f 92       	push	r0
     784:	0b b6       	in	r0, 0x3b	; 59
     786:	0f 92       	push	r0
     788:	11 24       	eor	r1, r1
     78a:	2f 93       	push	r18
     78c:	3f 93       	push	r19
     78e:	4f 93       	push	r20
     790:	5f 93       	push	r21
     792:	6f 93       	push	r22
     794:	7f 93       	push	r23
     796:	8f 93       	push	r24
     798:	9f 93       	push	r25
     79a:	af 93       	push	r26
     79c:	bf 93       	push	r27
     79e:	ef 93       	push	r30
     7a0:	ff 93       	push	r31
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(DC)-1;
     7a2:	80 91 88 00 	lds	r24, 0x0088
     7a6:	90 91 89 00 	lds	r25, 0x0089
     7aa:	01 97       	sbiw	r24, 0x01	; 1
    //Check if we are ready to step
    if (irqToNext == 0) {
     7ac:	09 f0       	breq	.+2      	; 0x7b0 <__vector_31+0x34>
     7ae:	c9 c0       	rjmp	.+402    	; 0x942 <__vector_31+0x1c6>
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(DC); //Get the current time segement
     7b0:	8a b5       	in	r24, 0x2a	; 42
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(DC) = timerOVF[DC][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(DC) = *(int*)((byte*)timerOVF[DC] + index); //Update interrupt base rate.
     7b2:	e8 2f       	mov	r30, r24
     7b4:	ee 73       	andi	r30, 0x3E	; 62
     7b6:	f0 e0       	ldi	r31, 0x00	; 0
     7b8:	e6 53       	subi	r30, 0x36	; 54
     7ba:	fd 4f       	sbci	r31, 0xFD	; 253
     7bc:	20 81       	ld	r18, Z
     7be:	31 81       	ldd	r19, Z+1	; 0x01
     7c0:	30 93 97 00 	sts	0x0097, r19
     7c4:	20 93 96 00 	sts	0x0096, r18
        
        distributionSegment(DC) = timeSegment + 1; //Increment time segement for next time.
     7c8:	8f 5f       	subi	r24, 0xFF	; 255
     7ca:	8a bd       	out	0x2a, r24	; 42

        unsigned int currentSpeed = currentMotorSpeed(DC); //Get the current motor speed
     7cc:	60 91 98 00 	lds	r22, 0x0098
     7d0:	70 91 99 00 	lds	r23, 0x0099
        irqToNextStep(DC) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
     7d4:	70 93 89 00 	sts	0x0089, r23
     7d8:	60 93 88 00 	sts	0x0088, r22
        
        if (getPinValue(stepPin[DC])){
     7dc:	1e 9b       	sbis	0x03, 6	; 3
     7de:	54 c0       	rjmp	.+168    	; 0x888 <__vector_31+0x10c>
            //If the step pin is currently high...
            
            setPinValue(stepPin[DC],LOW); //set step pin low to complete step
     7e0:	2e 98       	cbi	0x05, 6	; 5
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[DC]; 
     7e2:	80 91 1a 03 	lds	r24, 0x031A
     7e6:	90 91 1b 03 	lds	r25, 0x031B
     7ea:	a0 91 1c 03 	lds	r26, 0x031C
     7ee:	b0 91 1d 03 	lds	r27, 0x031D
            jVal = jVal + cmd.stepDir[DC];
     7f2:	20 91 31 03 	lds	r18, 0x0331
     7f6:	33 27       	eor	r19, r19
     7f8:	27 fd       	sbrc	r18, 7
     7fa:	30 95       	com	r19
     7fc:	43 2f       	mov	r20, r19
     7fe:	53 2f       	mov	r21, r19
     800:	28 0f       	add	r18, r24
     802:	39 1f       	adc	r19, r25
     804:	4a 1f       	adc	r20, r26
     806:	5b 1f       	adc	r21, r27
            cmd.jVal[DC] = jVal;
     808:	20 93 1a 03 	sts	0x031A, r18
     80c:	30 93 1b 03 	sts	0x031B, r19
     810:	40 93 1c 03 	sts	0x031C, r20
     814:	50 93 1d 03 	sts	0x031D, r21
            
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
     818:	f1 9b       	sbis	0x1e, 1	; 30
     81a:	1b c0       	rjmp	.+54     	; 0x852 <__vector_31+0xd6>
     81c:	f3 99       	sbic	0x1e, 3	; 30
     81e:	19 c0       	rjmp	.+50     	; 0x852 <__vector_31+0xd6>
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
     820:	80 91 80 02 	lds	r24, 0x0280
     824:	90 91 81 02 	lds	r25, 0x0281
     828:	a0 91 82 02 	lds	r26, 0x0282
     82c:	b0 91 83 02 	lds	r27, 0x0283
     830:	82 17       	cp	r24, r18
     832:	93 07       	cpc	r25, r19
     834:	a4 07       	cpc	r26, r20
     836:	b5 07       	cpc	r27, r21
     838:	61 f4       	brne	.+24     	; 0x852 <__vector_31+0xd6>
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
     83a:	f3 9a       	sbi	0x1e, 3	; 30
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(DC); //Mark that we have started decelleration.
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
     83c:	80 91 7b 03 	lds	r24, 0x037B
     840:	90 91 7c 03 	lds	r25, 0x037C
     844:	01 96       	adiw	r24, 0x01	; 1
     846:	90 93 70 03 	sts	0x0370, r25
     84a:	80 93 6f 03 	sts	0x036F, r24
                    accelTableRepeatsLeft[DC] = 0;
     84e:	10 92 13 03 	sts	0x0313, r1
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[DC]) {
     852:	80 91 7b 03 	lds	r24, 0x037B
     856:	90 91 7c 03 	lds	r25, 0x037C
     85a:	86 17       	cp	r24, r22
     85c:	97 07       	cpc	r25, r23
     85e:	08 f0       	brcs	.+2      	; 0x862 <__vector_31+0xe6>
     860:	74 c0       	rjmp	.+232    	; 0x94a <__vector_31+0x1ce>
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(DC)){ 
     862:	f1 9b       	sbis	0x1e, 1	; 30
     864:	03 c0       	rjmp	.+6      	; 0x86c <__vector_31+0xf0>
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     866:	10 92 37 03 	sts	0x0337, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     86a:	f1 98       	cbi	0x1e, 1	; 30
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     86c:	81 e0       	ldi	r24, 0x01	; 1
     86e:	80 93 39 03 	sts	0x0339, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     872:	80 91 71 00 	lds	r24, 0x0071
     876:	8f 7d       	andi	r24, 0xDF	; 223
     878:	80 93 71 00 	sts	0x0071, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     87c:	80 91 91 00 	lds	r24, 0x0091
     880:	88 7f       	andi	r24, 0xF8	; 248
     882:	80 93 91 00 	sts	0x0091, r24
     886:	61 c0       	rjmp	.+194    	; 0x94a <__vector_31+0x1ce>
                cmd_setStopped(DC,CMD_STOPPED); //mark as stopped 
                timerDisable(DC);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[DC],HIGH); //Set it high to start next step.
     888:	2e 9a       	sbi	0x05, 6	; 5
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[DC]; //load the number of repeats left for this accel table entry
     88a:	80 91 13 03 	lds	r24, 0x0313
            if (repeatsReqd == 0) { 
     88e:	88 23       	and	r24, r24
     890:	09 f0       	breq	.+2      	; 0x894 <__vector_31+0x118>
     892:	53 c0       	rjmp	.+166    	; 0x93a <__vector_31+0x1be>
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[DC]; //Get the target speed
     894:	20 91 6f 03 	lds	r18, 0x036F
     898:	30 91 70 03 	lds	r19, 0x0370
                if (currentSpeed > targetSpeed) {
     89c:	26 17       	cp	r18, r22
     89e:	37 07       	cpc	r19, r23
     8a0:	d0 f4       	brcc	.+52     	; 0x8d6 <__vector_31+0x15a>
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
     8a2:	80 91 15 03 	lds	r24, 0x0315
                    if (accelIndex >= AccelTableLength-1) {
     8a6:	8f 33       	cpi	r24, 0x3F	; 63
     8a8:	08 f0       	brcs	.+2      	; 0x8ac <__vector_31+0x130>
     8aa:	41 c0       	rjmp	.+130    	; 0x92e <__vector_31+0x1b2>
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
     8ac:	8f 5f       	subi	r24, 0xFF	; 255
                        accelTableIndex[DC] = accelIndex; //Save the new index back
     8ae:	80 93 15 03 	sts	0x0315, r24
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	fc 01       	movw	r30, r24
     8b6:	ee 0f       	add	r30, r30
     8b8:	ff 1f       	adc	r31, r31
     8ba:	e8 0f       	add	r30, r24
     8bc:	f9 1f       	adc	r31, r25
     8be:	ea 5e       	subi	r30, 0xEA	; 234
     8c0:	fc 4f       	sbci	r31, 0xFC	; 252
     8c2:	e9 5d       	subi	r30, 0xD9	; 217
     8c4:	fe 4f       	sbci	r31, 0xFE	; 254
     8c6:	60 81       	ld	r22, Z
     8c8:	71 81       	ldd	r23, Z+1	; 0x01
     8ca:	e7 52       	subi	r30, 0x27	; 39
     8cc:	f1 40       	sbci	r31, 0x01	; 1
                        if (currentSpeed <= targetSpeed) {
     8ce:	26 17       	cp	r18, r22
     8d0:	37 07       	cpc	r19, r23
     8d2:	e0 f0       	brcs	.+56     	; 0x90c <__vector_31+0x190>
     8d4:	2c c0       	rjmp	.+88     	; 0x92e <__vector_31+0x1b2>
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
     8d6:	62 17       	cp	r22, r18
     8d8:	73 07       	cpc	r23, r19
     8da:	50 f5       	brcc	.+84     	; 0x930 <__vector_31+0x1b4>
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
     8dc:	80 91 15 03 	lds	r24, 0x0315
                    if (accelIndex == 0) {
     8e0:	88 23       	and	r24, r24
     8e2:	29 f1       	breq	.+74     	; 0x92e <__vector_31+0x1b2>
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
     8e4:	81 50       	subi	r24, 0x01	; 1
                        accelTableIndex[DC] = accelIndex; //Save the new index back
     8e6:	80 93 15 03 	sts	0x0315, r24
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	fc 01       	movw	r30, r24
     8ee:	ee 0f       	add	r30, r30
     8f0:	ff 1f       	adc	r31, r31
     8f2:	e8 0f       	add	r30, r24
     8f4:	f9 1f       	adc	r31, r25
     8f6:	ea 5e       	subi	r30, 0xEA	; 234
     8f8:	fc 4f       	sbci	r31, 0xFC	; 252
     8fa:	e9 5d       	subi	r30, 0xD9	; 217
     8fc:	fe 4f       	sbci	r31, 0xFE	; 254
     8fe:	60 81       	ld	r22, Z
     900:	71 81       	ldd	r23, Z+1	; 0x01
     902:	e7 52       	subi	r30, 0x27	; 39
     904:	f1 40       	sbci	r31, 0x01	; 1
                        if (currentSpeed >= targetSpeed) {
     906:	62 17       	cp	r22, r18
     908:	73 07       	cpc	r23, r19
     90a:	88 f4       	brcc	.+34     	; 0x92e <__vector_31+0x1b2>
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
     90c:	80 91 3b 03 	lds	r24, 0x033B
     910:	e7 5d       	subi	r30, 0xD7	; 215
     912:	fe 4f       	sbci	r31, 0xFE	; 254
     914:	88 23       	and	r24, r24
     916:	39 f0       	breq	.+14     	; 0x926 <__vector_31+0x1aa>
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
     918:	80 81       	ld	r24, Z
     91a:	23 e0       	ldi	r18, 0x03	; 3
     91c:	82 9f       	mul	r24, r18
     91e:	c0 01       	movw	r24, r0
     920:	11 24       	eor	r1, r1
     922:	8e 5f       	subi	r24, 0xFE	; 254
     924:	01 c0       	rjmp	.+2      	; 0x928 <__vector_31+0x1ac>
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
     926:	80 81       	ld	r24, Z
     928:	80 93 13 03 	sts	0x0313, r24
     92c:	01 c0       	rjmp	.+2      	; 0x930 <__vector_31+0x1b4>
     92e:	b9 01       	movw	r22, r18
                            }
                        }
                    }
                }
                currentMotorSpeed(DC) = currentSpeed; //Update the current speed in case it has changed.
     930:	70 93 99 00 	sts	0x0099, r23
     934:	60 93 98 00 	sts	0x0098, r22
     938:	08 c0       	rjmp	.+16     	; 0x94a <__vector_31+0x1ce>
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[DC] = repeatsReqd - 1;
     93a:	81 50       	subi	r24, 0x01	; 1
     93c:	80 93 13 03 	sts	0x0313, r24
     940:	04 c0       	rjmp	.+8      	; 0x94a <__vector_31+0x1ce>
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(DC) = irqToNext; //Update the number of IRQs remaining until the next step.
     942:	90 93 89 00 	sts	0x0089, r25
     946:	80 93 88 00 	sts	0x0088, r24
    }   


}
     94a:	ff 91       	pop	r31
     94c:	ef 91       	pop	r30
     94e:	bf 91       	pop	r27
     950:	af 91       	pop	r26
     952:	9f 91       	pop	r25
     954:	8f 91       	pop	r24
     956:	7f 91       	pop	r23
     958:	6f 91       	pop	r22
     95a:	5f 91       	pop	r21
     95c:	4f 91       	pop	r20
     95e:	3f 91       	pop	r19
     960:	2f 91       	pop	r18
     962:	0f 90       	pop	r0
     964:	0b be       	out	0x3b, r0	; 59
     966:	0f 90       	pop	r0
     968:	0f be       	out	0x3f, r0	; 63
     96a:	0f 90       	pop	r0
     96c:	1f 90       	pop	r1
     96e:	18 95       	reti

00000970 <__vector_16>:




/*Timer Interrupt Vector*/
ISR(TIMER1_CAPT_vect) {
     970:	1f 92       	push	r1
     972:	0f 92       	push	r0
     974:	0f b6       	in	r0, 0x3f	; 63
     976:	0f 92       	push	r0
     978:	0b b6       	in	r0, 0x3b	; 59
     97a:	0f 92       	push	r0
     97c:	11 24       	eor	r1, r1
     97e:	2f 93       	push	r18
     980:	3f 93       	push	r19
     982:	4f 93       	push	r20
     984:	5f 93       	push	r21
     986:	6f 93       	push	r22
     988:	7f 93       	push	r23
     98a:	8f 93       	push	r24
     98c:	9f 93       	push	r25
     98e:	af 93       	push	r26
     990:	bf 93       	push	r27
     992:	ef 93       	push	r30
     994:	ff 93       	push	r31
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(RA)-1;
     996:	80 91 8a 00 	lds	r24, 0x008A
     99a:	90 91 8b 00 	lds	r25, 0x008B
     99e:	01 97       	sbiw	r24, 0x01	; 1
    //Check if we are ready to step
    if (irqToNext == 0) {
     9a0:	09 f0       	breq	.+2      	; 0x9a4 <__vector_16+0x34>
     9a2:	c9 c0       	rjmp	.+402    	; 0xb36 <__vector_16+0x1c6>
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(RA); //Get the current time segement
     9a4:	8b b5       	in	r24, 0x2b	; 43
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(RA) = timerOVF[RA][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(RA) = *(int*)((byte*)timerOVF[RA] + index); //Update interrupt base rate.
     9a6:	e8 2f       	mov	r30, r24
     9a8:	ee 73       	andi	r30, 0x3E	; 62
     9aa:	f0 e0       	ldi	r31, 0x00	; 0
     9ac:	e6 57       	subi	r30, 0x76	; 118
     9ae:	fd 4f       	sbci	r31, 0xFD	; 253
     9b0:	20 81       	ld	r18, Z
     9b2:	31 81       	ldd	r19, Z+1	; 0x01
     9b4:	30 93 87 00 	sts	0x0087, r19
     9b8:	20 93 86 00 	sts	0x0086, r18
        
        distributionSegment(RA) = timeSegment + 1; //Increment time segement for next time.
     9bc:	8f 5f       	subi	r24, 0xFF	; 255
     9be:	8b bd       	out	0x2b, r24	; 43

        unsigned int currentSpeed = currentMotorSpeed(RA); //Get the current motor speed
     9c0:	60 91 9a 00 	lds	r22, 0x009A
     9c4:	70 91 9b 00 	lds	r23, 0x009B
        irqToNextStep(RA) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
     9c8:	70 93 8b 00 	sts	0x008B, r23
     9cc:	60 93 8a 00 	sts	0x008A, r22
        
        if (getPinValue(stepPin[RA])){
     9d0:	63 9b       	sbis	0x0c, 3	; 12
     9d2:	54 c0       	rjmp	.+168    	; 0xa7c <__vector_16+0x10c>
            //If the step pin is currently high...
            
            setPinValue(stepPin[RA],LOW); //set step pin low to complete step
     9d4:	73 98       	cbi	0x0e, 3	; 14
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[RA]; 
     9d6:	80 91 16 03 	lds	r24, 0x0316
     9da:	90 91 17 03 	lds	r25, 0x0317
     9de:	a0 91 18 03 	lds	r26, 0x0318
     9e2:	b0 91 19 03 	lds	r27, 0x0319
            jVal = jVal + cmd.stepDir[RA];
     9e6:	20 91 30 03 	lds	r18, 0x0330
     9ea:	33 27       	eor	r19, r19
     9ec:	27 fd       	sbrc	r18, 7
     9ee:	30 95       	com	r19
     9f0:	43 2f       	mov	r20, r19
     9f2:	53 2f       	mov	r21, r19
     9f4:	28 0f       	add	r18, r24
     9f6:	39 1f       	adc	r19, r25
     9f8:	4a 1f       	adc	r20, r26
     9fa:	5b 1f       	adc	r21, r27
            cmd.jVal[RA] = jVal;
     9fc:	20 93 16 03 	sts	0x0316, r18
     a00:	30 93 17 03 	sts	0x0317, r19
     a04:	40 93 18 03 	sts	0x0318, r20
     a08:	50 93 19 03 	sts	0x0319, r21
            
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
     a0c:	f0 9b       	sbis	0x1e, 0	; 30
     a0e:	1b c0       	rjmp	.+54     	; 0xa46 <__vector_16+0xd6>
     a10:	f2 99       	sbic	0x1e, 2	; 30
     a12:	19 c0       	rjmp	.+50     	; 0xa46 <__vector_16+0xd6>
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
     a14:	80 91 7c 02 	lds	r24, 0x027C
     a18:	90 91 7d 02 	lds	r25, 0x027D
     a1c:	a0 91 7e 02 	lds	r26, 0x027E
     a20:	b0 91 7f 02 	lds	r27, 0x027F
     a24:	82 17       	cp	r24, r18
     a26:	93 07       	cpc	r25, r19
     a28:	a4 07       	cpc	r26, r20
     a2a:	b5 07       	cpc	r27, r21
     a2c:	61 f4       	brne	.+24     	; 0xa46 <__vector_16+0xd6>
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
     a2e:	f2 9a       	sbi	0x1e, 2	; 30
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(RA); //Mark that we have started decelleration.
                    cmd.currentIVal[RA] = cmd.stopSpeed[RA]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
     a30:	80 91 79 03 	lds	r24, 0x0379
     a34:	90 91 7a 03 	lds	r25, 0x037A
     a38:	01 96       	adiw	r24, 0x01	; 1
     a3a:	90 93 6e 03 	sts	0x036E, r25
     a3e:	80 93 6d 03 	sts	0x036D, r24
                    accelTableRepeatsLeft[RA] = 0;
     a42:	10 92 12 03 	sts	0x0312, r1
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[RA]) {
     a46:	80 91 79 03 	lds	r24, 0x0379
     a4a:	90 91 7a 03 	lds	r25, 0x037A
     a4e:	86 17       	cp	r24, r22
     a50:	97 07       	cpc	r25, r23
     a52:	08 f0       	brcs	.+2      	; 0xa56 <__vector_16+0xe6>
     a54:	74 c0       	rjmp	.+232    	; 0xb3e <__vector_16+0x1ce>
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(RA)){ 
     a56:	f0 9b       	sbis	0x1e, 0	; 30
     a58:	03 c0       	rjmp	.+6      	; 0xa60 <__vector_16+0xf0>
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     a5a:	10 92 36 03 	sts	0x0336, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     a5e:	f0 98       	cbi	0x1e, 0	; 30
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     a60:	81 e0       	ldi	r24, 0x01	; 1
     a62:	80 93 38 03 	sts	0x0338, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     a66:	80 91 6f 00 	lds	r24, 0x006F
     a6a:	8f 7d       	andi	r24, 0xDF	; 223
     a6c:	80 93 6f 00 	sts	0x006F, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     a70:	80 91 81 00 	lds	r24, 0x0081
     a74:	88 7f       	andi	r24, 0xF8	; 248
     a76:	80 93 81 00 	sts	0x0081, r24
     a7a:	61 c0       	rjmp	.+194    	; 0xb3e <__vector_16+0x1ce>
                cmd_setStopped(RA,CMD_STOPPED); //mark as stopped 
                timerDisable(RA);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[RA],HIGH); //Set it high to start next step.
     a7c:	73 9a       	sbi	0x0e, 3	; 14
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[RA]; //load the number of repeats left for this accel table entry
     a7e:	80 91 12 03 	lds	r24, 0x0312
            if (repeatsReqd == 0) { 
     a82:	88 23       	and	r24, r24
     a84:	09 f0       	breq	.+2      	; 0xa88 <__vector_16+0x118>
     a86:	53 c0       	rjmp	.+166    	; 0xb2e <__vector_16+0x1be>
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[RA]; //Get the target speed
     a88:	20 91 6d 03 	lds	r18, 0x036D
     a8c:	30 91 6e 03 	lds	r19, 0x036E
                if (currentSpeed > targetSpeed) {
     a90:	26 17       	cp	r18, r22
     a92:	37 07       	cpc	r19, r23
     a94:	d0 f4       	brcc	.+52     	; 0xaca <__vector_16+0x15a>
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
     a96:	80 91 14 03 	lds	r24, 0x0314
                    if (accelIndex >= AccelTableLength-1) {
     a9a:	8f 33       	cpi	r24, 0x3F	; 63
     a9c:	08 f0       	brcs	.+2      	; 0xaa0 <__vector_16+0x130>
     a9e:	41 c0       	rjmp	.+130    	; 0xb22 <__vector_16+0x1b2>
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
     aa0:	8f 5f       	subi	r24, 0xFF	; 255
                        accelTableIndex[RA] = accelIndex; //Save the new index back
     aa2:	80 93 14 03 	sts	0x0314, r24
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
     aa6:	90 e0       	ldi	r25, 0x00	; 0
     aa8:	fc 01       	movw	r30, r24
     aaa:	ee 0f       	add	r30, r30
     aac:	ff 1f       	adc	r31, r31
     aae:	e8 0f       	add	r30, r24
     ab0:	f9 1f       	adc	r31, r25
     ab2:	ea 5e       	subi	r30, 0xEA	; 234
     ab4:	fc 4f       	sbci	r31, 0xFC	; 252
     ab6:	e9 59       	subi	r30, 0x99	; 153
     ab8:	ff 4f       	sbci	r31, 0xFF	; 255
     aba:	60 81       	ld	r22, Z
     abc:	71 81       	ldd	r23, Z+1	; 0x01
     abe:	e7 56       	subi	r30, 0x67	; 103
     ac0:	f0 40       	sbci	r31, 0x00	; 0
                        if (currentSpeed <= targetSpeed) {
     ac2:	26 17       	cp	r18, r22
     ac4:	37 07       	cpc	r19, r23
     ac6:	e0 f0       	brcs	.+56     	; 0xb00 <__vector_16+0x190>
     ac8:	2c c0       	rjmp	.+88     	; 0xb22 <__vector_16+0x1b2>
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
     aca:	62 17       	cp	r22, r18
     acc:	73 07       	cpc	r23, r19
     ace:	50 f5       	brcc	.+84     	; 0xb24 <__vector_16+0x1b4>
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
     ad0:	80 91 14 03 	lds	r24, 0x0314
                    if (accelIndex == 0) {
     ad4:	88 23       	and	r24, r24
     ad6:	29 f1       	breq	.+74     	; 0xb22 <__vector_16+0x1b2>
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
     ad8:	81 50       	subi	r24, 0x01	; 1
                        accelTableIndex[RA] = accelIndex; //Save the new index back
     ada:	80 93 14 03 	sts	0x0314, r24
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	fc 01       	movw	r30, r24
     ae2:	ee 0f       	add	r30, r30
     ae4:	ff 1f       	adc	r31, r31
     ae6:	e8 0f       	add	r30, r24
     ae8:	f9 1f       	adc	r31, r25
     aea:	ea 5e       	subi	r30, 0xEA	; 234
     aec:	fc 4f       	sbci	r31, 0xFC	; 252
     aee:	e9 59       	subi	r30, 0x99	; 153
     af0:	ff 4f       	sbci	r31, 0xFF	; 255
     af2:	60 81       	ld	r22, Z
     af4:	71 81       	ldd	r23, Z+1	; 0x01
     af6:	e7 56       	subi	r30, 0x67	; 103
     af8:	f0 40       	sbci	r31, 0x00	; 0
                        if (currentSpeed >= targetSpeed) {
     afa:	62 17       	cp	r22, r18
     afc:	73 07       	cpc	r23, r19
     afe:	88 f4       	brcc	.+34     	; 0xb22 <__vector_16+0x1b2>
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
     b00:	80 91 3a 03 	lds	r24, 0x033A
     b04:	e7 59       	subi	r30, 0x97	; 151
     b06:	ff 4f       	sbci	r31, 0xFF	; 255
     b08:	88 23       	and	r24, r24
     b0a:	39 f0       	breq	.+14     	; 0xb1a <__vector_16+0x1aa>
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
     b0c:	80 81       	ld	r24, Z
     b0e:	23 e0       	ldi	r18, 0x03	; 3
     b10:	82 9f       	mul	r24, r18
     b12:	c0 01       	movw	r24, r0
     b14:	11 24       	eor	r1, r1
     b16:	8e 5f       	subi	r24, 0xFE	; 254
     b18:	01 c0       	rjmp	.+2      	; 0xb1c <__vector_16+0x1ac>
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
     b1a:	80 81       	ld	r24, Z
     b1c:	80 93 12 03 	sts	0x0312, r24
     b20:	01 c0       	rjmp	.+2      	; 0xb24 <__vector_16+0x1b4>
     b22:	b9 01       	movw	r22, r18
                            }
                        }
                    }
                }
                currentMotorSpeed(RA) = currentSpeed; //Update the current speed in case it has changed.
     b24:	70 93 9b 00 	sts	0x009B, r23
     b28:	60 93 9a 00 	sts	0x009A, r22
     b2c:	08 c0       	rjmp	.+16     	; 0xb3e <__vector_16+0x1ce>
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[RA] = repeatsReqd - 1;
     b2e:	81 50       	subi	r24, 0x01	; 1
     b30:	80 93 12 03 	sts	0x0312, r24
     b34:	04 c0       	rjmp	.+8      	; 0xb3e <__vector_16+0x1ce>
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(RA) = irqToNext; //Update the number of IRQs remaining until the next step.
     b36:	90 93 8b 00 	sts	0x008B, r25
     b3a:	80 93 8a 00 	sts	0x008A, r24
    }   


}
     b3e:	ff 91       	pop	r31
     b40:	ef 91       	pop	r30
     b42:	bf 91       	pop	r27
     b44:	af 91       	pop	r26
     b46:	9f 91       	pop	r25
     b48:	8f 91       	pop	r24
     b4a:	7f 91       	pop	r23
     b4c:	6f 91       	pop	r22
     b4e:	5f 91       	pop	r21
     b50:	4f 91       	pop	r20
     b52:	3f 91       	pop	r19
     b54:	2f 91       	pop	r18
     b56:	0f 90       	pop	r0
     b58:	0b be       	out	0x3b, r0	; 59
     b5a:	0f 90       	pop	r0
     b5c:	0f be       	out	0x3f, r0	; 63
     b5e:	0f 90       	pop	r0
     b60:	1f 90       	pop	r1
     b62:	18 95       	reti

00000b64 <storeEEPROM>:

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
}

void storeEEPROM(){
     b64:	1f 93       	push	r17
    EEPROM_writeLong(cmd.aVal[RA],aVal1_Address);
     b66:	60 91 44 03 	lds	r22, 0x0344
     b6a:	70 91 45 03 	lds	r23, 0x0345
     b6e:	80 91 46 03 	lds	r24, 0x0346
     b72:	90 91 47 03 	lds	r25, 0x0347
     b76:	4e e0       	ldi	r20, 0x0E	; 14
     b78:	50 e0       	ldi	r21, 0x00	; 0
     b7a:	0e 94 32 11 	call	0x2264	; 0x2264 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.aVal[DC],aVal2_Address);
     b7e:	60 91 48 03 	lds	r22, 0x0348
     b82:	70 91 49 03 	lds	r23, 0x0349
     b86:	80 91 4a 03 	lds	r24, 0x034A
     b8a:	90 91 4b 03 	lds	r25, 0x034B
     b8e:	42 e1       	ldi	r20, 0x12	; 18
     b90:	50 e0       	ldi	r21, 0x00	; 0
     b92:	0e 94 32 11 	call	0x2264	; 0x2264 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.bVal[RA],bVal1_Address);
     b96:	60 91 4c 03 	lds	r22, 0x034C
     b9a:	70 91 4d 03 	lds	r23, 0x034D
     b9e:	80 91 4e 03 	lds	r24, 0x034E
     ba2:	90 91 4f 03 	lds	r25, 0x034F
     ba6:	46 e1       	ldi	r20, 0x16	; 22
     ba8:	50 e0       	ldi	r21, 0x00	; 0
     baa:	0e 94 32 11 	call	0x2264	; 0x2264 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.bVal[DC],bVal2_Address);
     bae:	60 91 50 03 	lds	r22, 0x0350
     bb2:	70 91 51 03 	lds	r23, 0x0351
     bb6:	80 91 52 03 	lds	r24, 0x0352
     bba:	90 91 53 03 	lds	r25, 0x0353
     bbe:	4a e1       	ldi	r20, 0x1A	; 26
     bc0:	50 e0       	ldi	r21, 0x00	; 0
     bc2:	0e 94 32 11 	call	0x2264	; 0x2264 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.sVal[RA],sVal1_Address);
     bc6:	60 91 56 03 	lds	r22, 0x0356
     bca:	70 91 57 03 	lds	r23, 0x0357
     bce:	80 91 58 03 	lds	r24, 0x0358
     bd2:	90 91 59 03 	lds	r25, 0x0359
     bd6:	4e e1       	ldi	r20, 0x1E	; 30
     bd8:	50 e0       	ldi	r21, 0x00	; 0
     bda:	0e 94 32 11 	call	0x2264	; 0x2264 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.sVal[DC],sVal2_Address);
     bde:	60 91 5a 03 	lds	r22, 0x035A
     be2:	70 91 5b 03 	lds	r23, 0x035B
     be6:	80 91 5c 03 	lds	r24, 0x035C
     bea:	90 91 5d 03 	lds	r25, 0x035D
     bee:	42 e2       	ldi	r20, 0x22	; 34
     bf0:	50 e0       	ldi	r21, 0x00	; 0
     bf2:	0e 94 32 11 	call	0x2264	; 0x2264 <_Z16EEPROM_writeLongmj>
    EEPROM_writeByte(encodeDirection[RA],RAReverse_Address);
     bf6:	80 91 84 02 	lds	r24, 0x0284
     bfa:	69 e0       	ldi	r22, 0x09	; 9
     bfc:	70 e0       	ldi	r23, 0x00	; 0
     bfe:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(encodeDirection[DC],DECReverse_Address);
     c02:	80 91 85 02 	lds	r24, 0x0285
     c06:	6a e0       	ldi	r22, 0x0A	; 10
     c08:	70 e0       	ldi	r23, 0x00	; 0
     c0a:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(driverVersion,Driver_Address);
     c0e:	80 91 88 02 	lds	r24, 0x0288
     c12:	6b e0       	ldi	r22, 0x0B	; 11
     c14:	70 e0       	ldi	r23, 0x00	; 0
     c16:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(microstepConf,Microstep_Address);
     c1a:	80 91 87 02 	lds	r24, 0x0287
     c1e:	68 e0       	ldi	r22, 0x08	; 8
     c20:	70 e0       	ldi	r23, 0x00	; 0
     c22:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(cmd.normalGotoSpeed[RA],RAGoto_Address);
     c26:	80 91 75 03 	lds	r24, 0x0375
     c2a:	6c e0       	ldi	r22, 0x0C	; 12
     c2c:	70 e0       	ldi	r23, 0x00	; 0
     c2e:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(cmd.normalGotoSpeed[DC],DECGoto_Address);
     c32:	80 91 77 03 	lds	r24, 0x0377
     c36:	6d e0       	ldi	r22, 0x0D	; 13
     c38:	70 e0       	ldi	r23, 0x00	; 0
     c3a:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeInt(cmd.siderealIVal[RA],IVal1_Address);
     c3e:	80 91 69 03 	lds	r24, 0x0369
     c42:	90 91 6a 03 	lds	r25, 0x036A
     c46:	66 e2       	ldi	r22, 0x26	; 38
     c48:	70 e0       	ldi	r23, 0x00	; 0
     c4a:	0e 94 17 11 	call	0x222e	; 0x222e <_Z15EEPROM_writeIntjj>
    EEPROM_writeInt(cmd.siderealIVal[DC],IVal2_Address);
     c4e:	80 91 6b 03 	lds	r24, 0x036B
     c52:	90 91 6c 03 	lds	r25, 0x036C
     c56:	68 e2       	ldi	r22, 0x28	; 40
     c58:	70 e0       	ldi	r23, 0x00	; 0
     c5a:	0e 94 17 11 	call	0x222e	; 0x222e <_Z15EEPROM_writeIntjj>
    EEPROM_writeByte(!disableGearChange, GearEnable_Address);
     c5e:	80 91 0c 03 	lds	r24, 0x030C
     c62:	11 e0       	ldi	r17, 0x01	; 1
     c64:	81 27       	eor	r24, r17
     c66:	6a e2       	ldi	r22, 0x2A	; 42
     c68:	70 e0       	ldi	r23, 0x00	; 0
     c6a:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(!allowAdvancedHCDetection, AdvHCEnable_Address);
     c6e:	80 91 0d 03 	lds	r24, 0x030D
     c72:	81 27       	eor	r24, r17
     c74:	6b e2       	ldi	r22, 0x2B	; 43
     c76:	70 e0       	ldi	r23, 0x00	; 0
     c78:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeInt(cmd.st4DecBacklash, DecBacklash_Address);
     c7c:	80 91 67 03 	lds	r24, 0x0367
     c80:	90 91 68 03 	lds	r25, 0x0368
     c84:	6c e2       	ldi	r22, 0x2C	; 44
     c86:	70 e0       	ldi	r23, 0x00	; 0
     c88:	0e 94 17 11 	call	0x222e	; 0x222e <_Z15EEPROM_writeIntjj>
    EEPROM_writeByte(cmd.st4SpeedFactor, SpeedFactor_Address);
     c8c:	80 91 5f 03 	lds	r24, 0x035F
     c90:	6e e2       	ldi	r22, 0x2E	; 46
     c92:	70 e0       	ldi	r23, 0x00	; 0
     c94:	0e 94 0b 11 	call	0x2216	; 0x2216 <_Z16EEPROM_writeBytehj>
    EEPROM_writeAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address);
     c98:	8d e7       	ldi	r24, 0x7D	; 125
     c9a:	93 e0       	ldi	r25, 0x03	; 3
     c9c:	60 e4       	ldi	r22, 0x40	; 64
     c9e:	44 e6       	ldi	r20, 0x64	; 100
     ca0:	50 e0       	ldi	r21, 0x00	; 0
     ca2:	0e 94 62 11 	call	0x22c4	; 0x22c4 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>
    EEPROM_writeAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address);
     ca6:	8d e3       	ldi	r24, 0x3D	; 61
     ca8:	94 e0       	ldi	r25, 0x04	; 4
     caa:	60 e4       	ldi	r22, 0x40	; 64
     cac:	44 e2       	ldi	r20, 0x24	; 36
     cae:	51 e0       	ldi	r21, 0x01	; 1
     cb0:	0e 94 62 11 	call	0x22c4	; 0x22c4 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>
}
     cb4:	1f 91       	pop	r17
     cb6:	08 95       	ret

00000cb8 <buildEEPROM>:
    }
    return true;
}

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	92 e0       	ldi	r25, 0x02	; 2
     cbc:	68 e0       	ldi	r22, 0x08	; 8
     cbe:	40 e0       	ldi	r20, 0x00	; 0
     cc0:	50 e0       	ldi	r21, 0x00	; 0
     cc2:	0e 94 49 11 	call	0x2292	; 0x2292 <_Z18EEPROM_writeStringPKchj>
}
     cc6:	08 95       	ret

00000cc8 <checkEEPROM>:

/*
 * EEPROM Validation and Programming Routines
 */

bool checkEEPROM(){
     cc8:	0f 93       	push	r16
     cca:	1f 93       	push	r17
     ccc:	df 93       	push	r29
     cce:	cf 93       	push	r28
     cd0:	cd b7       	in	r28, 0x3d	; 61
     cd2:	de b7       	in	r29, 0x3e	; 62
     cd4:	29 97       	sbiw	r28, 0x09	; 9
     cd6:	0f b6       	in	r0, 0x3f	; 63
     cd8:	f8 94       	cli
     cda:	de bf       	out	0x3e, r29	; 62
     cdc:	0f be       	out	0x3f, r0	; 63
     cde:	cd bf       	out	0x3d, r28	; 61
    char temp[9] = {0};
     ce0:	8e 01       	movw	r16, r28
     ce2:	0f 5f       	subi	r16, 0xFF	; 255
     ce4:	1f 4f       	sbci	r17, 0xFF	; 255
     ce6:	89 e0       	ldi	r24, 0x09	; 9
     ce8:	f8 01       	movw	r30, r16
     cea:	11 92       	st	Z+, r1
     cec:	8a 95       	dec	r24
     cee:	e9 f7       	brne	.-6      	; 0xcea <checkEEPROM+0x22>
    EEPROM_readString(temp,8,AstroEQID_Address);
     cf0:	c8 01       	movw	r24, r16
     cf2:	68 e0       	ldi	r22, 0x08	; 8
     cf4:	40 e0       	ldi	r20, 0x00	; 0
     cf6:	50 e0       	ldi	r21, 0x00	; 0
     cf8:	0e 94 cd 10 	call	0x219a	; 0x219a <_Z17EEPROM_readStringPchj>
    if(strncmp(temp,"AstroEQ",8)){
     cfc:	c8 01       	movw	r24, r16
     cfe:	60 e0       	ldi	r22, 0x00	; 0
     d00:	72 e0       	ldi	r23, 0x02	; 2
     d02:	48 e0       	ldi	r20, 0x08	; 8
     d04:	50 e0       	ldi	r21, 0x00	; 0
     d06:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <strncmp>
     d0a:	00 97       	sbiw	r24, 0x00	; 0
     d0c:	91 f5       	brne	.+100    	; 0xd72 <checkEEPROM+0xaa>
        return false;
    }
    if (driverVersion > DRV8834){
     d0e:	80 91 88 02 	lds	r24, 0x0288
     d12:	83 30       	cpi	r24, 0x03	; 3
     d14:	70 f5       	brcc	.+92     	; 0xd72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((driverVersion == A498x) && microstepConf > 16){
     d16:	88 23       	and	r24, r24
     d18:	21 f4       	brne	.+8      	; 0xd22 <checkEEPROM+0x5a>
     d1a:	80 91 87 02 	lds	r24, 0x0287
     d1e:	81 31       	cpi	r24, 0x11	; 17
     d20:	40 f5       	brcc	.+80     	; 0xd72 <checkEEPROM+0xaa>
        return false; //invalid value.
    } else if (microstepConf > 32){
     d22:	80 91 87 02 	lds	r24, 0x0287
     d26:	81 32       	cpi	r24, 0x21	; 33
     d28:	20 f5       	brcc	.+72     	; 0xd72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[RA] > 1200) || (cmd.siderealIVal[RA] < MIN_IVAL)) {
     d2a:	80 91 69 03 	lds	r24, 0x0369
     d2e:	90 91 6a 03 	lds	r25, 0x036A
     d32:	c2 97       	sbiw	r24, 0x32	; 50
     d34:	8f 57       	subi	r24, 0x7F	; 127
     d36:	94 40       	sbci	r25, 0x04	; 4
     d38:	e0 f4       	brcc	.+56     	; 0xd72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[DC] > 1200) || (cmd.siderealIVal[DC] < MIN_IVAL)) {
     d3a:	80 91 6b 03 	lds	r24, 0x036B
     d3e:	90 91 6c 03 	lds	r25, 0x036C
     d42:	c2 97       	sbiw	r24, 0x32	; 50
     d44:	8f 57       	subi	r24, 0x7F	; 127
     d46:	94 40       	sbci	r25, 0x04	; 4
     d48:	a0 f4       	brcc	.+40     	; 0xd72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[RA] == 0){
     d4a:	80 91 75 03 	lds	r24, 0x0375
     d4e:	90 91 76 03 	lds	r25, 0x0376
     d52:	89 2b       	or	r24, r25
     d54:	71 f0       	breq	.+28     	; 0xd72 <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[DC] == 0){
     d56:	80 91 77 03 	lds	r24, 0x0377
     d5a:	90 91 78 03 	lds	r25, 0x0378
     d5e:	89 2b       	or	r24, r25
     d60:	41 f0       	breq	.+16     	; 0xd72 <checkEEPROM+0xaa>
     d62:	90 e0       	ldi	r25, 0x00	; 0
     d64:	80 91 5f 03 	lds	r24, 0x035F
     d68:	81 50       	subi	r24, 0x01	; 1
     d6a:	83 31       	cpi	r24, 0x13	; 19
     d6c:	18 f4       	brcc	.+6      	; 0xd74 <checkEEPROM+0xac>
     d6e:	91 e0       	ldi	r25, 0x01	; 1
     d70:	01 c0       	rjmp	.+2      	; 0xd74 <checkEEPROM+0xac>
     d72:	90 e0       	ldi	r25, 0x00	; 0
    }
    if((cmd.st4SpeedFactor < 1) || (cmd.st4SpeedFactor > 19)){
        return false; //invalid value
    }
    return true;
}
     d74:	89 2f       	mov	r24, r25
     d76:	29 96       	adiw	r28, 0x09	; 9
     d78:	0f b6       	in	r0, 0x3f	; 63
     d7a:	f8 94       	cli
     d7c:	de bf       	out	0x3e, r29	; 62
     d7e:	0f be       	out	0x3f, r0	; 63
     d80:	cd bf       	out	0x3d, r28	; 61
     d82:	cf 91       	pop	r28
     d84:	df 91       	pop	r29
     d86:	1f 91       	pop	r17
     d88:	0f 91       	pop	r16
     d8a:	08 95       	ret

00000d8c <decodeCommand>:

/*
 * Decode and Perform the Command
 */

bool decodeCommand(char command, char* buffer){ //each command is axis specific. The axis being modified can be retrieved by calling synta_axis()
     d8c:	8f 92       	push	r8
     d8e:	9f 92       	push	r9
     d90:	af 92       	push	r10
     d92:	bf 92       	push	r11
     d94:	cf 92       	push	r12
     d96:	df 92       	push	r13
     d98:	ef 92       	push	r14
     d9a:	ff 92       	push	r15
     d9c:	0f 93       	push	r16
     d9e:	1f 93       	push	r17
     da0:	cf 93       	push	r28
     da2:	df 93       	push	r29
     da4:	a8 2e       	mov	r10, r24
     da6:	4b 01       	movw	r8, r22
    unsigned long responseData = 0; //data for response
    bool success = true;
    byte axis = synta_axis();
     da8:	82 e0       	ldi	r24, 0x02	; 2
     daa:	0e 94 43 13 	call	0x2686	; 0x2686 <_Z10synta_axish>
     dae:	b8 2e       	mov	r11, r24
    unsigned int correction;
    byte oldSREG;
    switch(command) {
     db0:	0f e4       	ldi	r16, 0x4F	; 79
     db2:	a0 16       	cp	r10, r16
     db4:	09 f4       	brne	.+2      	; 0xdb8 <decodeCommand+0x2c>
     db6:	51 c1       	rjmp	.+674    	; 0x105a <decodeCommand+0x2ce>
     db8:	0a 15       	cp	r16, r10
     dba:	fc f0       	brlt	.+62     	; 0xdfa <decodeCommand+0x6e>
     dbc:	18 e4       	ldi	r17, 0x48	; 72
     dbe:	a1 16       	cp	r10, r17
     dc0:	09 f4       	brne	.+2      	; 0xdc4 <decodeCommand+0x38>
     dc2:	ea c0       	rjmp	.+468    	; 0xf98 <decodeCommand+0x20c>
     dc4:	1a 15       	cp	r17, r10
     dc6:	64 f0       	brlt	.+24     	; 0xde0 <decodeCommand+0x54>
     dc8:	26 e4       	ldi	r18, 0x46	; 70
     dca:	a2 16       	cp	r10, r18
     dcc:	09 f4       	brne	.+2      	; 0xdd0 <decodeCommand+0x44>
     dce:	3c c1       	rjmp	.+632    	; 0x1048 <decodeCommand+0x2bc>
     dd0:	2a 15       	cp	r18, r10
     dd2:	0c f4       	brge	.+2      	; 0xdd6 <decodeCommand+0x4a>
     dd4:	cb c0       	rjmp	.+406    	; 0xf6c <decodeCommand+0x1e0>
     dd6:	85 e4       	ldi	r24, 0x45	; 69
     dd8:	a8 16       	cp	r10, r24
     dda:	09 f0       	breq	.+2      	; 0xdde <decodeCommand+0x52>
     ddc:	5e c1       	rjmp	.+700    	; 0x109a <decodeCommand+0x30e>
     dde:	21 c1       	rjmp	.+578    	; 0x1022 <decodeCommand+0x296>
     de0:	ab e4       	ldi	r26, 0x4B	; 75
     de2:	aa 16       	cp	r10, r26
     de4:	09 f4       	brne	.+2      	; 0xde8 <decodeCommand+0x5c>
     de6:	b5 c0       	rjmp	.+362    	; 0xf52 <decodeCommand+0x1c6>
     de8:	bc e4       	ldi	r27, 0x4C	; 76
     dea:	ab 16       	cp	r10, r27
     dec:	09 f4       	brne	.+2      	; 0xdf0 <decodeCommand+0x64>
     dee:	b7 c0       	rjmp	.+366    	; 0xf5e <decodeCommand+0x1d2>
     df0:	e9 e4       	ldi	r30, 0x49	; 73
     df2:	ae 16       	cp	r10, r30
     df4:	09 f0       	breq	.+2      	; 0xdf8 <decodeCommand+0x6c>
     df6:	51 c1       	rjmp	.+674    	; 0x109a <decodeCommand+0x30e>
     df8:	e3 c0       	rjmp	.+454    	; 0xfc0 <decodeCommand+0x234>
     dfa:	f6 e6       	ldi	r31, 0x66	; 102
     dfc:	af 16       	cp	r10, r31
     dfe:	09 f4       	brne	.+2      	; 0xe02 <decodeCommand+0x76>
     e00:	76 c0       	rjmp	.+236    	; 0xeee <decodeCommand+0x162>
     e02:	fa 15       	cp	r31, r10
     e04:	5c f0       	brlt	.+22     	; 0xe1c <decodeCommand+0x90>
     e06:	02 e6       	ldi	r16, 0x62	; 98
     e08:	a0 16       	cp	r10, r16
     e0a:	79 f1       	breq	.+94     	; 0xe6a <decodeCommand+0xde>
     e0c:	15 e6       	ldi	r17, 0x65	; 101
     e0e:	a1 16       	cp	r10, r17
     e10:	91 f0       	breq	.+36     	; 0xe36 <decodeCommand+0xaa>
     e12:	21 e6       	ldi	r18, 0x61	; 97
     e14:	a2 16       	cp	r10, r18
     e16:	09 f0       	breq	.+2      	; 0xe1a <decodeCommand+0x8e>
     e18:	40 c1       	rjmp	.+640    	; 0x109a <decodeCommand+0x30e>
     e1a:	1a c0       	rjmp	.+52     	; 0xe50 <decodeCommand+0xc4>
     e1c:	8a e6       	ldi	r24, 0x6A	; 106
     e1e:	a8 16       	cp	r10, r24
     e20:	09 f4       	brne	.+2      	; 0xe24 <decodeCommand+0x98>
     e22:	87 c0       	rjmp	.+270    	; 0xf32 <decodeCommand+0x1a6>
     e24:	a3 e7       	ldi	r26, 0x73	; 115
     e26:	aa 16       	cp	r10, r26
     e28:	09 f4       	brne	.+2      	; 0xe2c <decodeCommand+0xa0>
     e2a:	54 c0       	rjmp	.+168    	; 0xed4 <decodeCommand+0x148>
     e2c:	b7 e6       	ldi	r27, 0x67	; 103
     e2e:	ab 16       	cp	r10, r27
     e30:	09 f0       	breq	.+2      	; 0xe34 <decodeCommand+0xa8>
     e32:	33 c1       	rjmp	.+614    	; 0x109a <decodeCommand+0x30e>
     e34:	4a c0       	rjmp	.+148    	; 0xeca <decodeCommand+0x13e>
        case 'e': //readonly, return the eVal (version number)
            responseData = cmd.eVal[axis]; //response to the e command is stored in the eVal function for that axis.
     e36:	e8 2f       	mov	r30, r24
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	ee 0f       	add	r30, r30
     e3c:	ff 1f       	adc	r31, r31
     e3e:	ee 0f       	add	r30, r30
     e40:	ff 1f       	adc	r31, r31
     e42:	ea 5e       	subi	r30, 0xEA	; 234
     e44:	fc 4f       	sbci	r31, 0xFC	; 252
     e46:	26 a1       	ldd	r18, Z+38	; 0x26
     e48:	37 a1       	ldd	r19, Z+39	; 0x27
     e4a:	40 a5       	ldd	r20, Z+40	; 0x28
     e4c:	51 a5       	ldd	r21, Z+41	; 0x29
     e4e:	a1 c2       	rjmp	.+1346   	; 0x1392 <decodeCommand+0x606>
            break;
        case 'a': //readonly, return the aVal (steps per axis)
            responseData = cmd.aVal[axis]; //response to the a command is stored in the aVal function for that axis.
     e50:	e8 2f       	mov	r30, r24
     e52:	f0 e0       	ldi	r31, 0x00	; 0
     e54:	ee 0f       	add	r30, r30
     e56:	ff 1f       	adc	r31, r31
     e58:	ee 0f       	add	r30, r30
     e5a:	ff 1f       	adc	r31, r31
     e5c:	ea 5e       	subi	r30, 0xEA	; 234
     e5e:	fc 4f       	sbci	r31, 0xFC	; 252
     e60:	26 a5       	ldd	r18, Z+46	; 0x2e
     e62:	37 a5       	ldd	r19, Z+47	; 0x2f
     e64:	40 a9       	ldd	r20, Z+48	; 0x30
     e66:	51 a9       	ldd	r21, Z+49	; 0x31
     e68:	94 c2       	rjmp	.+1320   	; 0x1392 <decodeCommand+0x606>
            break;
        case 'b': //readonly, return the bVal (sidereal step rate)
            responseData = cmd.bVal[axis]; //response to the b command is stored in the bVal function for that axis.
     e6a:	a8 2f       	mov	r26, r24
     e6c:	b0 e0       	ldi	r27, 0x00	; 0
     e6e:	fd 01       	movw	r30, r26
     e70:	ee 0f       	add	r30, r30
     e72:	ff 1f       	adc	r31, r31
     e74:	ee 0f       	add	r30, r30
     e76:	ff 1f       	adc	r31, r31
     e78:	ea 5e       	subi	r30, 0xEA	; 234
     e7a:	fc 4f       	sbci	r31, 0xFC	; 252
     e7c:	26 a9       	ldd	r18, Z+54	; 0x36
     e7e:	37 a9       	ldd	r19, Z+55	; 0x37
     e80:	40 ad       	ldd	r20, Z+56	; 0x38
     e82:	51 ad       	ldd	r21, Z+57	; 0x39
            if (!progMode) {
     e84:	80 91 86 02 	lds	r24, 0x0286
     e88:	88 23       	and	r24, r24
     e8a:	09 f0       	breq	.+2      	; 0xe8e <decodeCommand+0x102>
     e8c:	82 c2       	rjmp	.+1284   	; 0x1392 <decodeCommand+0x606>
                //If not in programming mode, we need to apply a correction factor to ensure that calculations in EQMOD round correctly
                correction = (cmd.siderealIVal[axis] << 1);
     e8e:	aa 0f       	add	r26, r26
     e90:	bb 1f       	adc	r27, r27
     e92:	a7 59       	subi	r26, 0x97	; 151
     e94:	bc 4f       	sbci	r27, 0xFC	; 252
     e96:	ed 90       	ld	r14, X+
     e98:	fc 90       	ld	r15, X
     e9a:	ee 0c       	add	r14, r14
     e9c:	ff 1c       	adc	r15, r15
                responseData = (responseData * (correction+1))/correction; //account for rounding inside Skywatcher DLL.
     e9e:	08 94       	sec
     ea0:	e1 1c       	adc	r14, r1
     ea2:	f1 1c       	adc	r15, r1
     ea4:	b7 01       	movw	r22, r14
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	90 e0       	ldi	r25, 0x00	; 0
     eaa:	08 94       	sec
     eac:	e1 08       	sbc	r14, r1
     eae:	f1 08       	sbc	r15, r1
     eb0:	0e 94 83 16 	call	0x2d06	; 0x2d06 <__mulsi3>
     eb4:	00 e0       	ldi	r16, 0x00	; 0
     eb6:	10 e0       	ldi	r17, 0x00	; 0
     eb8:	a8 01       	movw	r20, r16
     eba:	97 01       	movw	r18, r14
     ebc:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__udivmodsi4>
     ec0:	c9 01       	movw	r24, r18
     ec2:	da 01       	movw	r26, r20
     ec4:	9c 01       	movw	r18, r24
     ec6:	ad 01       	movw	r20, r26
     ec8:	64 c2       	rjmp	.+1224   	; 0x1392 <decodeCommand+0x606>
            }
            break;
        case 'g': //readonly, return the gVal (high speed multiplier)
            responseData = cmd.gVal[axis]; //response to the g command is stored in the gVal function for that axis.
     eca:	eb 2d       	mov	r30, r11
     ecc:	f0 e0       	ldi	r31, 0x00	; 0
     ece:	ec 5a       	subi	r30, 0xAC	; 172
     ed0:	fc 4f       	sbci	r31, 0xFC	; 252
     ed2:	a4 c1       	rjmp	.+840    	; 0x121c <decodeCommand+0x490>
            break;
        case 's': //readonly, return the sVal (steps per worm rotation)
            responseData = cmd.sVal[axis]; //response to the s command is stored in the sVal function for that axis.
     ed4:	eb 2d       	mov	r30, r11
     ed6:	f0 e0       	ldi	r31, 0x00	; 0
     ed8:	ee 0f       	add	r30, r30
     eda:	ff 1f       	adc	r31, r31
     edc:	ee 0f       	add	r30, r30
     ede:	ff 1f       	adc	r31, r31
     ee0:	ea 5a       	subi	r30, 0xAA	; 170
     ee2:	fc 4f       	sbci	r31, 0xFC	; 252
     ee4:	20 81       	ld	r18, Z
     ee6:	31 81       	ldd	r19, Z+1	; 0x01
     ee8:	42 81       	ldd	r20, Z+2	; 0x02
     eea:	53 81       	ldd	r21, Z+3	; 0x03
     eec:	52 c2       	rjmp	.+1188   	; 0x1392 <decodeCommand+0x606>
    }
}

inline unsigned int cmd_fVal(byte target){ //_fVal: 00ds000g000f; d = dir, s = stopped, g = goto, f = energised
    unsigned int fVal = 0;
    if (cmd.dir[target]) {
     eee:	a8 2f       	mov	r26, r24
     ef0:	b0 e0       	ldi	r27, 0x00	; 0
     ef2:	fd 01       	movw	r30, r26
     ef4:	ea 5e       	subi	r30, 0xEA	; 234
     ef6:	fc 4f       	sbci	r31, 0xFC	; 252
     ef8:	84 8d       	ldd	r24, Z+28	; 0x1c
     efa:	88 23       	and	r24, r24
     efc:	19 f0       	breq	.+6      	; 0xf04 <decodeCommand+0x178>
     efe:	20 e0       	ldi	r18, 0x00	; 0
     f00:	32 e0       	ldi	r19, 0x02	; 2
     f02:	02 c0       	rjmp	.+4      	; 0xf08 <decodeCommand+0x17c>
     f04:	20 e0       	ldi	r18, 0x00	; 0
     f06:	30 e0       	ldi	r19, 0x00	; 0
        fVal |= (1 << 9);
    }
    if (cmd.stopped[target]) {
     f08:	fd 01       	movw	r30, r26
     f0a:	ea 5e       	subi	r30, 0xEA	; 234
     f0c:	fc 4f       	sbci	r31, 0xFC	; 252
     f0e:	82 a1       	ldd	r24, Z+34	; 0x22
     f10:	81 11       	cpse	r24, r1
        fVal |= (1 << 8);
     f12:	31 60       	ori	r19, 0x01	; 1
    }
    if (cmd.gotoEn[target]) {
     f14:	fd 01       	movw	r30, r26
     f16:	ea 5e       	subi	r30, 0xEA	; 234
     f18:	fc 4f       	sbci	r31, 0xFC	; 252
     f1a:	80 a1       	ldd	r24, Z+32	; 0x20
     f1c:	81 11       	cpse	r24, r1
        fVal |= (1 << 4);
     f1e:	20 61       	ori	r18, 0x10	; 16
    }
    if (cmd.FVal[target]){
     f20:	aa 5e       	subi	r26, 0xEA	; 234
     f22:	bc 4f       	sbci	r27, 0xFC	; 252
     f24:	5e 96       	adiw	r26, 0x1e	; 30
     f26:	8c 91       	ld	r24, X
     f28:	88 23       	and	r24, r24
     f2a:	09 f4       	brne	.+2      	; 0xf2e <decodeCommand+0x1a2>
     f2c:	09 c1       	rjmp	.+530    	; 0x1140 <decodeCommand+0x3b4>
        fVal |= (1 << 0);
     f2e:	21 60       	ori	r18, 0x01	; 1
     f30:	07 c1       	rjmp	.+526    	; 0x1140 <decodeCommand+0x3b4>
            break;
        case 'f': //readonly, return the fVal (axis status)
            responseData = cmd_fVal(axis); //response to the f command is stored in the fVal function for that axis.
            break;
        case 'j': //readonly, return the jVal (current position)
            oldSREG = SREG; 
     f32:	8f b7       	in	r24, 0x3f	; 63
            cli();  //The next bit needs to be atomic, just in case the motors are running
     f34:	f8 94       	cli
            responseData = cmd.jVal[axis]; //response to the j command is stored in the jVal function for that axis.
     f36:	eb 2d       	mov	r30, r11
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	ee 0f       	add	r30, r30
     f3c:	ff 1f       	adc	r31, r31
     f3e:	ee 0f       	add	r30, r30
     f40:	ff 1f       	adc	r31, r31
     f42:	ea 5e       	subi	r30, 0xEA	; 234
     f44:	fc 4f       	sbci	r31, 0xFC	; 252
     f46:	20 81       	ld	r18, Z
     f48:	31 81       	ldd	r19, Z+1	; 0x01
     f4a:	42 81       	ldd	r20, Z+2	; 0x02
     f4c:	53 81       	ldd	r21, Z+3	; 0x03
            SREG = oldSREG;
     f4e:	8f bf       	out	0x3f, r24	; 63
     f50:	20 c2       	rjmp	.+1088   	; 0x1392 <decodeCommand+0x606>
            break;
        case 'K': //stop the motor, return empty response
            motorStop(axis,0); //normal ISR based decelleration trigger.
     f52:	60 e0       	ldi	r22, 0x00	; 0
     f54:	0e 94 b1 03 	call	0x762	; 0x762 <motorStop>
            readyToGo[axis] = 0;
     f58:	eb 2d       	mov	r30, r11
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	19 c0       	rjmp	.+50     	; 0xf90 <decodeCommand+0x204>
            break;
        case 'L':
            motorStop(axis,1); //emergency axis stop.
     f5e:	61 e0       	ldi	r22, 0x01	; 1
     f60:	0e 94 b1 03 	call	0x762	; 0x762 <motorStop>
            motorDisable(axis); //shutdown driver power.
     f64:	8b 2d       	mov	r24, r11
     f66:	0e 94 57 01 	call	0x2ae	; 0x2ae <motorDisable>
     f6a:	0f c2       	rjmp	.+1054   	; 0x138a <decodeCommand+0x5fe>
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     f6c:	e8 2f       	mov	r30, r24
     f6e:	f0 e0       	ldi	r31, 0x00	; 0
     f70:	df 01       	movw	r26, r30
     f72:	aa 5e       	subi	r26, 0xEA	; 234
     f74:	bc 4f       	sbci	r27, 0xFC	; 252
     f76:	e4 01       	movw	r28, r8
     f78:	88 81       	ld	r24, Y
     f7a:	80 53       	subi	r24, 0x30	; 48
     f7c:	50 96       	adiw	r26, 0x10	; 16
     f7e:	8c 93       	st	X, r24
     f80:	50 97       	sbiw	r26, 0x10	; 16
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
     f82:	90 e0       	ldi	r25, 0x00	; 0
     f84:	89 81       	ldd	r24, Y+1	; 0x01
     f86:	80 33       	cpi	r24, 0x30	; 48
     f88:	09 f0       	breq	.+2      	; 0xf8c <decodeCommand+0x200>
     f8a:	91 e0       	ldi	r25, 0x01	; 1
     f8c:	5c 96       	adiw	r26, 0x1c	; 28
     f8e:	9c 93       	st	X, r25
            /*if (packetIn[0] == '0'){
              packetIn[0] = '2'; //don't allow a high torque goto. But do allow a high torque slew.
            }*/
            cmd_setGVal(axis, (buffer[0] - '0')); //Store the current mode for the axis
            cmd_setDir(axis, (buffer[1] != '0') ? CMD_REVERSE : CMD_FORWARD); //Store the current direction for that axis
            readyToGo[axis] = 0;
     f90:	e6 58       	subi	r30, 0x86	; 134
     f92:	fd 4f       	sbci	r31, 0xFD	; 253
     f94:	10 82       	st	Z, r1
     f96:	f9 c1       	rjmp	.+1010   	; 0x138a <decodeCommand+0x5fe>
            break;
        case 'H': //set goto position, return empty response (this sets the number of steps to move from cuurent position if in goto mode)
            cmd_setHVal(axis, synta_hexToLong(buffer)); //set the goto position container (convert string to long first)
     f98:	c4 01       	movw	r24, r8
     f9a:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
     f9e:	ab 2d       	mov	r26, r11
     fa0:	b0 e0       	ldi	r27, 0x00	; 0
     fa2:	fd 01       	movw	r30, r26
     fa4:	ee 0f       	add	r30, r30
     fa6:	ff 1f       	adc	r31, r31
     fa8:	ee 0f       	add	r30, r30
     faa:	ff 1f       	adc	r31, r31
     fac:	ea 5e       	subi	r30, 0xEA	; 234
     fae:	fc 4f       	sbci	r31, 0xFC	; 252
     fb0:	62 8b       	std	Z+18, r22	; 0x12
     fb2:	73 8b       	std	Z+19, r23	; 0x13
     fb4:	84 8b       	std	Z+20, r24	; 0x14
     fb6:	95 8b       	std	Z+21, r25	; 0x15
            readyToGo[axis] = 0;
     fb8:	a6 58       	subi	r26, 0x86	; 134
     fba:	bd 4f       	sbci	r27, 0xFD	; 253
     fbc:	1c 92       	st	X, r1
     fbe:	e5 c1       	rjmp	.+970    	; 0x138a <decodeCommand+0x5fe>
            break;
        case 'I': //set slew speed, return empty response (this sets the speed to move at if in slew mode)
            responseData = synta_hexToLong(buffer); //convert string to long first
     fc0:	c4 01       	movw	r24, r8
     fc2:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
            if (responseData < cmd.accelTable[axis][AccelTableLength-1].speed) {
     fc6:	cb 2c       	mov	r12, r11
     fc8:	dd 24       	eor	r13, r13
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
     fca:	e6 01       	movw	r28, r12
     fcc:	cc 0f       	add	r28, r28
     fce:	dd 1f       	adc	r29, r29
     fd0:	c2 5e       	subi	r28, 0xE2	; 226
     fd2:	dc 4f       	sbci	r29, 0xFC	; 252
     fd4:	20 ec       	ldi	r18, 0xC0	; 192
     fd6:	30 e0       	ldi	r19, 0x00	; 0
     fd8:	c2 9e       	mul	r12, r18
     fda:	f0 01       	movw	r30, r0
     fdc:	c3 9e       	mul	r12, r19
     fde:	f0 0d       	add	r31, r0
     fe0:	d2 9e       	mul	r13, r18
     fe2:	f0 0d       	add	r31, r0
     fe4:	11 24       	eor	r1, r1
     fe6:	e6 5c       	subi	r30, 0xC6	; 198
     fe8:	fb 4f       	sbci	r31, 0xFB	; 251
     fea:	20 81       	ld	r18, Z
     fec:	31 81       	ldd	r19, Z+1	; 0x01
     fee:	79 01       	movw	r14, r18
     ff0:	00 e0       	ldi	r16, 0x00	; 0
     ff2:	10 e0       	ldi	r17, 0x00	; 0
     ff4:	ac 01       	movw	r20, r24
     ff6:	cb 01       	movw	r24, r22
     ff8:	da 01       	movw	r26, r20
     ffa:	8e 15       	cp	r24, r14
     ffc:	9f 05       	cpc	r25, r15
     ffe:	a0 07       	cpc	r26, r16
    1000:	b1 07       	cpc	r27, r17
    1002:	10 f4       	brcc	.+4      	; 0x1008 <decodeCommand+0x27c>
    1004:	d8 01       	movw	r26, r16
    1006:	c7 01       	movw	r24, r14
    1008:	99 83       	std	Y+1, r25	; 0x01
    100a:	88 83       	st	Y, r24
                //Limit the IVal to the largest speed in the acceleration table to prevent sudden rapid acceleration at the end.
                responseData = cmd.accelTable[axis][AccelTableLength-1].speed; 
            }
            cmd_setIVal(axis, responseData); //set the speed container
            responseData = 0;
            if (readyToGo[axis] == 2) {
    100c:	f6 01       	movw	r30, r12
    100e:	e6 58       	subi	r30, 0x86	; 134
    1010:	fd 4f       	sbci	r31, 0xFD	; 253
    1012:	80 81       	ld	r24, Z
    1014:	82 30       	cpi	r24, 0x02	; 2
    1016:	09 f0       	breq	.+2      	; 0x101a <decodeCommand+0x28e>
    1018:	bd cf       	rjmp	.-134    	; 0xf94 <decodeCommand+0x208>
                //If we are in a running mode which allows speed update without motor reconfiguration
                motorStart(axis); //Simply update the speed.
    101a:	8b 2d       	mov	r24, r11
    101c:	0e 94 4f 02 	call	0x49e	; 0x49e <motorStart>
    1020:	b4 c1       	rjmp	.+872    	; 0x138a <decodeCommand+0x5fe>
                //Otherwise we are no longer ready to go until the next :J command is received
                readyToGo[axis] = 0;
            }
            break;
        case 'E': //set the current position, return empty response
            oldSREG = SREG; 
    1022:	1f b7       	in	r17, 0x3f	; 63
            cli();  //The next bit needs to be atomic, just in case the motors are running
    1024:	f8 94       	cli
            cmd_setjVal(axis, synta_hexToLong(buffer)); //set the current position (used to sync to what EQMOD thinks is the current position at startup
    1026:	c4 01       	movw	r24, r8
    1028:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
    102c:	eb 2d       	mov	r30, r11
    102e:	f0 e0       	ldi	r31, 0x00	; 0
    1030:	ee 0f       	add	r30, r30
    1032:	ff 1f       	adc	r31, r31
    1034:	ee 0f       	add	r30, r30
    1036:	ff 1f       	adc	r31, r31
    1038:	ea 5e       	subi	r30, 0xEA	; 234
    103a:	fc 4f       	sbci	r31, 0xFC	; 252
    103c:	60 83       	st	Z, r22
    103e:	71 83       	std	Z+1, r23	; 0x01
    1040:	82 83       	std	Z+2, r24	; 0x02
    1042:	93 83       	std	Z+3, r25	; 0x03
            SREG = oldSREG;
    1044:	1f bf       	out	0x3f, r17	; 63
    1046:	a1 c1       	rjmp	.+834    	; 0x138a <decodeCommand+0x5fe>
            break;
        case 'F': //Enable the motor driver, return empty response
            if (progMode == 0) { //only allow motors to be enabled outside of programming mode.
    1048:	80 91 86 02 	lds	r24, 0x0286
    104c:	88 23       	and	r24, r24
    104e:	09 f0       	breq	.+2      	; 0x1052 <decodeCommand+0x2c6>
    1050:	9b c1       	rjmp	.+822    	; 0x1388 <decodeCommand+0x5fc>
                motorEnable(axis); //This enables the motors - gives the motor driver board power
    1052:	8b 2d       	mov	r24, r11
    1054:	0e 94 3a 01 	call	0x274	; 0x274 <motorEnable>
    1058:	98 c1       	rjmp	.+816    	; 0x138a <decodeCommand+0x5fe>
            }
            break;
            
        //Command required for entering programming mode. All other programming commands cannot be used when progMode = 0 (normal ops)
        case 'O': //set the programming mode.
            progMode = buffer[0] - '0';              //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
    105a:	f4 01       	movw	r30, r8
    105c:	80 81       	ld	r24, Z
    105e:	80 53       	subi	r24, 0x30	; 48
    1060:	80 93 86 02 	sts	0x0286, r24
            if (progMode != 0) {
    1064:	88 23       	and	r24, r24
    1066:	31 f4       	brne	.+12     	; 0x1074 <decodeCommand+0x2e8>
    1068:	20 e0       	ldi	r18, 0x00	; 0
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	40 e0       	ldi	r20, 0x00	; 0
    106e:	50 e0       	ldi	r21, 0x00	; 0
    1070:	10 e0       	ldi	r17, 0x00	; 0
    1072:	90 c1       	rjmp	.+800    	; 0x1394 <decodeCommand+0x608>
                motorStop(RA,1); //emergency axis stop.
    1074:	80 e0       	ldi	r24, 0x00	; 0
    1076:	61 e0       	ldi	r22, 0x01	; 1
    1078:	0e 94 b1 03 	call	0x762	; 0x762 <motorStop>
                motorDisable(RA); //shutdown driver power.
    107c:	80 e0       	ldi	r24, 0x00	; 0
    107e:	0e 94 57 01 	call	0x2ae	; 0x2ae <motorDisable>
                motorStop(DC,1); //emergency axis stop.
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	61 e0       	ldi	r22, 0x01	; 1
    1086:	0e 94 b1 03 	call	0x762	; 0x762 <motorStop>
                motorDisable(DC); //shutdown driver power.
    108a:	81 e0       	ldi	r24, 0x01	; 1
    108c:	0e 94 57 01 	call	0x2ae	; 0x2ae <motorDisable>
                readyToGo[RA] = 0;
    1090:	10 92 7a 02 	sts	0x027A, r1
                readyToGo[DC] = 0;
    1094:	10 92 7b 02 	sts	0x027B, r1
    1098:	78 c1       	rjmp	.+752    	; 0x138a <decodeCommand+0x5fe>
            }
            break;

        default:
            //Prevent any chance of accidentally running configuration commands when not in programming mode.
            if (progMode != 0) {
    109a:	20 91 86 02 	lds	r18, 0x0286
    109e:	22 23       	and	r18, r18
    10a0:	09 f4       	brne	.+2      	; 0x10a4 <decodeCommand+0x318>
    10a2:	73 c1       	rjmp	.+742    	; 0x138a <decodeCommand+0x5fe>
                //The following are used for configuration ----------
                switch(command) {
    10a4:	8a 2d       	mov	r24, r10
    10a6:	99 27       	eor	r25, r25
    10a8:	87 fd       	sbrc	r24, 7
    10aa:	90 95       	com	r25
    10ac:	a9 2f       	mov	r26, r25
    10ae:	b9 2f       	mov	r27, r25
    10b0:	fc 01       	movw	r30, r24
    10b2:	e1 54       	subi	r30, 0x41	; 65
    10b4:	f0 40       	sbci	r31, 0x00	; 0
    10b6:	ea 33       	cpi	r30, 0x3A	; 58
    10b8:	f1 05       	cpc	r31, r1
    10ba:	08 f0       	brcs	.+2      	; 0x10be <decodeCommand+0x332>
    10bc:	66 c1       	rjmp	.+716    	; 0x138a <decodeCommand+0x5fe>
    10be:	ee 58       	subi	r30, 0x8E	; 142
    10c0:	ff 4f       	sbci	r31, 0xFF	; 255
    10c2:	ee 0f       	add	r30, r30
    10c4:	ff 1f       	adc	r31, r31
    10c6:	05 90       	lpm	r0, Z+
    10c8:	f4 91       	lpm	r31, Z+
    10ca:	e0 2d       	mov	r30, r0
    10cc:	19 94       	eijmp
                    case 'A': //store the aVal (steps per axis)
                        cmd_setaVal(axis, synta_hexToLong(buffer)); //store aVal for that axis.
    10ce:	c4 01       	movw	r24, r8
    10d0:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
}

inline void cmd_setaVal(byte target, unsigned long _aVal){ //Set Method
    cmd.aVal[target] = _aVal;
    10d4:	eb 2d       	mov	r30, r11
    10d6:	f0 e0       	ldi	r31, 0x00	; 0
    10d8:	ee 0f       	add	r30, r30
    10da:	ff 1f       	adc	r31, r31
    10dc:	ee 0f       	add	r30, r30
    10de:	ff 1f       	adc	r31, r31
    10e0:	ea 5e       	subi	r30, 0xEA	; 234
    10e2:	fc 4f       	sbci	r31, 0xFC	; 252
    10e4:	66 a7       	std	Z+46, r22	; 0x2e
    10e6:	77 a7       	std	Z+47, r23	; 0x2f
    10e8:	80 ab       	std	Z+48, r24	; 0x30
    10ea:	91 ab       	std	Z+49, r25	; 0x31
    10ec:	4e c1       	rjmp	.+668    	; 0x138a <decodeCommand+0x5fe>
                        break;
                    case 'B': //store the bVal (sidereal rate)
                        cmd_setbVal(axis, synta_hexToLong(buffer)); //store bVal for that axis.
    10ee:	c4 01       	movw	r24, r8
    10f0:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
}

inline void cmd_setbVal(byte target, unsigned long _bVal){ //Set Method
    cmd.bVal[target] = _bVal;
    10f4:	eb 2d       	mov	r30, r11
    10f6:	f0 e0       	ldi	r31, 0x00	; 0
    10f8:	ee 0f       	add	r30, r30
    10fa:	ff 1f       	adc	r31, r31
    10fc:	ee 0f       	add	r30, r30
    10fe:	ff 1f       	adc	r31, r31
    1100:	ea 5e       	subi	r30, 0xEA	; 234
    1102:	fc 4f       	sbci	r31, 0xFC	; 252
    1104:	66 ab       	std	Z+54, r22	; 0x36
    1106:	77 ab       	std	Z+55, r23	; 0x37
    1108:	80 af       	std	Z+56, r24	; 0x38
    110a:	91 af       	std	Z+57, r25	; 0x39
    110c:	3e c1       	rjmp	.+636    	; 0x138a <decodeCommand+0x5fe>
                        break;
                    case 'S': //store the sVal (steps per worm rotation)
                        cmd_setsVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
    110e:	c4 01       	movw	r24, r8
    1110:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
}

inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
    1114:	eb 2d       	mov	r30, r11
    1116:	f0 e0       	ldi	r31, 0x00	; 0
    1118:	ee 0f       	add	r30, r30
    111a:	ff 1f       	adc	r31, r31
    111c:	ee 0f       	add	r30, r30
    111e:	ff 1f       	adc	r31, r31
    1120:	ea 5a       	subi	r30, 0xAA	; 170
    1122:	fc 4f       	sbci	r31, 0xFC	; 252
    1124:	60 83       	st	Z, r22
    1126:	71 83       	std	Z+1, r23	; 0x01
    1128:	82 83       	std	Z+2, r24	; 0x02
    112a:	93 83       	std	Z+3, r25	; 0x03
    112c:	2e c1       	rjmp	.+604    	; 0x138a <decodeCommand+0x5fe>
                        break;
                    case 'n': //return the IVal (EQMOD Speed at sidereal)
                        responseData = cmd.siderealIVal[axis];
    112e:	eb 2d       	mov	r30, r11
    1130:	f0 e0       	ldi	r31, 0x00	; 0
    1132:	ee 0f       	add	r30, r30
    1134:	ff 1f       	adc	r31, r31
    1136:	e7 59       	subi	r30, 0x97	; 151
    1138:	fc 4f       	sbci	r31, 0xFC	; 252
    113a:	80 81       	ld	r24, Z
    113c:	91 81       	ldd	r25, Z+1	; 0x01
    113e:	9c 01       	movw	r18, r24
    1140:	40 e0       	ldi	r20, 0x00	; 0
    1142:	50 e0       	ldi	r21, 0x00	; 0
    1144:	26 c1       	rjmp	.+588    	; 0x1392 <decodeCommand+0x606>
                        break;
                    case 'N': //store the IVal (EQMOD Speed at sidereal)
                        cmd_setsideIVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
    1146:	c4 01       	movw	r24, r8
    1148:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
    }
    return fVal;
}

inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
    114c:	eb 2d       	mov	r30, r11
    114e:	f0 e0       	ldi	r31, 0x00	; 0
    1150:	ee 0f       	add	r30, r30
    1152:	ff 1f       	adc	r31, r31
    1154:	e7 59       	subi	r30, 0x97	; 151
    1156:	fc 4f       	sbci	r31, 0xFC	; 252
    1158:	71 83       	std	Z+1, r23	; 0x01
    115a:	60 83       	st	Z, r22
    115c:	16 c1       	rjmp	.+556    	; 0x138a <decodeCommand+0x5fe>
                        break;
                    case 'd': //return the driver version or step mode
                        if (axis) {
    115e:	bb 20       	and	r11, r11
    1160:	19 f0       	breq	.+6      	; 0x1168 <decodeCommand+0x3dc>
                            responseData = microstepConf; 
    1162:	80 91 87 02 	lds	r24, 0x0287
    1166:	5b c0       	rjmp	.+182    	; 0x121e <decodeCommand+0x492>
                        } else {
                            responseData = driverVersion;
    1168:	80 91 88 02 	lds	r24, 0x0288
    116c:	58 c0       	rjmp	.+176    	; 0x121e <decodeCommand+0x492>
                        }
                        break;
                    case 'D': //store the driver verison and step modes
                        if (axis) {
    116e:	bb 20       	and	r11, r11
    1170:	81 f0       	breq	.+32     	; 0x1192 <decodeCommand+0x406>
                            microstepConf = synta_hexToByte(buffer); //store step mode.
    1172:	c4 01       	movw	r24, r8
    1174:	0e 94 26 13 	call	0x264c	; 0x264c <_Z15synta_hexToBytePc>
    1178:	80 93 87 02 	sts	0x0287, r24
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    117c:	88 30       	cpi	r24, 0x08	; 8
    117e:	10 f4       	brcc	.+4      	; 0x1184 <decodeCommand+0x3f8>
    1180:	90 e0       	ldi	r25, 0x00	; 0
    1182:	04 c0       	rjmp	.+8      	; 0x118c <decodeCommand+0x400>
    1184:	90 91 0c 03 	lds	r25, 0x030C
    1188:	81 e0       	ldi	r24, 0x01	; 1
    118a:	98 27       	eor	r25, r24
    118c:	90 93 0a 03 	sts	0x030A, r25
    1190:	fc c0       	rjmp	.+504    	; 0x138a <decodeCommand+0x5fe>
                        } else {
                            driverVersion = synta_hexToByte(buffer); //store driver version.
    1192:	c4 01       	movw	r24, r8
    1194:	0e 94 26 13 	call	0x264c	; 0x264c <_Z15synta_hexToBytePc>
    1198:	80 93 88 02 	sts	0x0288, r24
    119c:	f6 c0       	rjmp	.+492    	; 0x138a <decodeCommand+0x5fe>
                        }
                        break;
                    case 'r': //return the dec backlash or st4 speed factor
                        if (axis) {
    119e:	bb 20       	and	r11, r11
    11a0:	29 f0       	breq	.+10     	; 0x11ac <decodeCommand+0x420>
                            responseData = cmd.st4DecBacklash; 
    11a2:	80 91 67 03 	lds	r24, 0x0367
    11a6:	90 91 68 03 	lds	r25, 0x0368
    11aa:	c9 cf       	rjmp	.-110    	; 0x113e <decodeCommand+0x3b2>
                        } else {
                            responseData = cmd.st4SpeedFactor;
    11ac:	80 91 5f 03 	lds	r24, 0x035F
    11b0:	36 c0       	rjmp	.+108    	; 0x121e <decodeCommand+0x492>
                        }
                        break;
                    case 'R': //store the dec backlash or st4 speed factor
                        if (axis) {
    11b2:	bb 20       	and	r11, r11
    11b4:	89 f0       	breq	.+34     	; 0x11d8 <decodeCommand+0x44c>
                            unsigned long dataIn = synta_hexToLong(buffer); //store step mode.
    11b6:	c4 01       	movw	r24, r8
    11b8:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
                            if (dataIn > 65535) {
    11bc:	60 30       	cpi	r22, 0x00	; 0
    11be:	f0 e0       	ldi	r31, 0x00	; 0
    11c0:	7f 07       	cpc	r23, r31
    11c2:	f1 e0       	ldi	r31, 0x01	; 1
    11c4:	8f 07       	cpc	r24, r31
    11c6:	f0 e0       	ldi	r31, 0x00	; 0
    11c8:	9f 07       	cpc	r25, r31
    11ca:	08 f0       	brcs	.+2      	; 0x11ce <decodeCommand+0x442>
    11cc:	dd c0       	rjmp	.+442    	; 0x1388 <decodeCommand+0x5fc>
inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
}

inline void cmd_setst4DecBacklash(unsigned int _backlash){ //Set Method
    cmd.st4DecBacklash = _backlash;
    11ce:	70 93 68 03 	sts	0x0368, r23
    11d2:	60 93 67 03 	sts	0x0367, r22
    11d6:	d9 c0       	rjmp	.+434    	; 0x138a <decodeCommand+0x5fe>
                                command = '\0'; //If the step rate is out of range, force an error response packet.
                            } else {
                                cmd_setst4DecBacklash(dataIn); //store st4 speed factor
                            }
                        } else {
                            byte factor = synta_hexToByte(buffer);
    11d8:	c4 01       	movw	r24, r8
    11da:	0e 94 26 13 	call	0x264c	; 0x264c <_Z15synta_hexToBytePc>
    11de:	98 2f       	mov	r25, r24
                            if ((factor > 19) || (factor < 1)) {
    11e0:	81 50       	subi	r24, 0x01	; 1
    11e2:	83 31       	cpi	r24, 0x13	; 19
    11e4:	08 f0       	brcs	.+2      	; 0x11e8 <decodeCommand+0x45c>
    11e6:	d0 c0       	rjmp	.+416    	; 0x1388 <decodeCommand+0x5fc>
inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
}

inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
    11e8:	90 93 5f 03 	sts	0x035F, r25
    11ec:	ce c0       	rjmp	.+412    	; 0x138a <decodeCommand+0x5fe>
                                cmd_setst4SpeedFactor(factor); //store st4 speed factor
                            }
                        }
                        break;
                    case 'z': //return the Goto speed
                        responseData = cmd.normalGotoSpeed[axis];
    11ee:	eb 2d       	mov	r30, r11
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	ee 0f       	add	r30, r30
    11f4:	ff 1f       	adc	r31, r31
    11f6:	eb 58       	subi	r30, 0x8B	; 139
    11f8:	fc 4f       	sbci	r31, 0xFC	; 252
    11fa:	9f cf       	rjmp	.-194    	; 0x113a <decodeCommand+0x3ae>
                        break;
                    case 'Z': //return the Goto speed factor
                        cmd.normalGotoSpeed[axis] = synta_hexToByte(buffer); //store the goto speed factor
    11fc:	c4 01       	movw	r24, r8
    11fe:	0e 94 26 13 	call	0x264c	; 0x264c <_Z15synta_hexToBytePc>
    1202:	eb 2d       	mov	r30, r11
    1204:	f0 e0       	ldi	r31, 0x00	; 0
    1206:	ee 0f       	add	r30, r30
    1208:	ff 1f       	adc	r31, r31
    120a:	eb 58       	subi	r30, 0x8B	; 139
    120c:	fc 4f       	sbci	r31, 0xFC	; 252
    120e:	80 83       	st	Z, r24
    1210:	11 82       	std	Z+1, r1	; 0x01
    1212:	bb c0       	rjmp	.+374    	; 0x138a <decodeCommand+0x5fe>
                        break;
                    case 'c': //return the axisDirectionReverse
                        responseData = encodeDirection[axis];
    1214:	eb 2d       	mov	r30, r11
    1216:	f0 e0       	ldi	r31, 0x00	; 0
    1218:	ec 57       	subi	r30, 0x7C	; 124
    121a:	fd 4f       	sbci	r31, 0xFD	; 253
    121c:	80 81       	ld	r24, Z
    121e:	28 2f       	mov	r18, r24
    1220:	30 e0       	ldi	r19, 0x00	; 0
    1222:	8e cf       	rjmp	.-228    	; 0x1140 <decodeCommand+0x3b4>
                        break;
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
    1224:	eb 2d       	mov	r30, r11
    1226:	f0 e0       	ldi	r31, 0x00	; 0
    1228:	ec 57       	subi	r30, 0x7C	; 124
    122a:	fd 4f       	sbci	r31, 0xFD	; 253
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	d4 01       	movw	r26, r8
    1230:	8c 91       	ld	r24, X
    1232:	80 33       	cpi	r24, 0x30	; 48
    1234:	09 f0       	breq	.+2      	; 0x1238 <decodeCommand+0x4ac>
    1236:	91 e0       	ldi	r25, 0x01	; 1
    1238:	90 83       	st	Z, r25
    123a:	a7 c0       	rjmp	.+334    	; 0x138a <decodeCommand+0x5fe>
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
    123c:	bb 20       	and	r11, r11
    123e:	81 f0       	breq	.+32     	; 0x1260 <decodeCommand+0x4d4>
                            responseData = disableGearChange; 
    1240:	20 91 0c 03 	lds	r18, 0x030C
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    1244:	80 91 87 02 	lds	r24, 0x0287
    1248:	88 30       	cpi	r24, 0x08	; 8
    124a:	10 f4       	brcc	.+4      	; 0x1250 <decodeCommand+0x4c4>
    124c:	80 e0       	ldi	r24, 0x00	; 0
    124e:	02 c0       	rjmp	.+4      	; 0x1254 <decodeCommand+0x4c8>
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	82 27       	eor	r24, r18
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
                            responseData = disableGearChange; 
    1254:	30 e0       	ldi	r19, 0x00	; 0
    1256:	40 e0       	ldi	r20, 0x00	; 0
    1258:	50 e0       	ldi	r21, 0x00	; 0
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    125a:	80 93 0a 03 	sts	0x030A, r24
    125e:	99 c0       	rjmp	.+306    	; 0x1392 <decodeCommand+0x606>
                        } else {
                            responseData = allowAdvancedHCDetection;
    1260:	80 91 0d 03 	lds	r24, 0x030D
    1264:	dc cf       	rjmp	.-72     	; 0x121e <decodeCommand+0x492>
                        }
                        break;
                    case 'Q': //store the disableGearChange/allowAdvancedHCDetection setting
                        if (axis) {
    1266:	bb 20       	and	r11, r11
    1268:	61 f0       	breq	.+24     	; 0x1282 <decodeCommand+0x4f6>
                            disableGearChange = synta_hexToByte(buffer); //store whether we can change gear
    126a:	c4 01       	movw	r24, r8
    126c:	0e 94 26 13 	call	0x264c	; 0x264c <_Z15synta_hexToBytePc>
    1270:	10 92 0c 03 	sts	0x030C, r1
    1274:	88 23       	and	r24, r24
    1276:	09 f4       	brne	.+2      	; 0x127a <decodeCommand+0x4ee>
    1278:	88 c0       	rjmp	.+272    	; 0x138a <decodeCommand+0x5fe>
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	80 93 0c 03 	sts	0x030C, r24
    1280:	84 c0       	rjmp	.+264    	; 0x138a <decodeCommand+0x5fe>
                        } else {
                            allowAdvancedHCDetection = synta_hexToByte(buffer); //store whether to allow advanced hand controller detection
    1282:	c4 01       	movw	r24, r8
    1284:	0e 94 26 13 	call	0x264c	; 0x264c <_Z15synta_hexToBytePc>
    1288:	10 92 0d 03 	sts	0x030D, r1
    128c:	88 23       	and	r24, r24
    128e:	09 f4       	brne	.+2      	; 0x1292 <decodeCommand+0x506>
    1290:	7c c0       	rjmp	.+248    	; 0x138a <decodeCommand+0x5fe>
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	80 93 0d 03 	sts	0x030D, r24
    1298:	78 c0       	rjmp	.+240    	; 0x138a <decodeCommand+0x5fe>
    struct {
        Byter lowByter;
        Byter highByter;
    };
    InterMaker(unsigned long _integer){
        integer = _integer;
    129a:	20 e0       	ldi	r18, 0x00	; 0
    129c:	30 e0       	ldi	r19, 0x00	; 0
    129e:	40 e0       	ldi	r20, 0x00	; 0
    12a0:	50 e0       	ldi	r21, 0x00	; 0
                        }
                        break;
                    case 'x': {  //return the accelTable
                        Inter responsePack = InterMaker(0);
                        responsePack.lowByter.integer = cmd.accelTable[axis][accelTableIndex[axis]].speed;
    12a2:	6b 2d       	mov	r22, r11
    12a4:	70 e0       	ldi	r23, 0x00	; 0
    12a6:	eb 01       	movw	r28, r22
    12a8:	cc 5e       	subi	r28, 0xEC	; 236
    12aa:	dc 4f       	sbci	r29, 0xFC	; 252
    12ac:	a8 81       	ld	r26, Y
    12ae:	8a 2f       	mov	r24, r26
    12b0:	90 e0       	ldi	r25, 0x00	; 0
    12b2:	fc 01       	movw	r30, r24
    12b4:	ee 0f       	add	r30, r30
    12b6:	ff 1f       	adc	r31, r31
    12b8:	e8 0f       	add	r30, r24
    12ba:	f9 1f       	adc	r31, r25
    12bc:	80 ec       	ldi	r24, 0xC0	; 192
    12be:	90 e0       	ldi	r25, 0x00	; 0
    12c0:	8c 01       	movw	r16, r24
    12c2:	60 9f       	mul	r22, r16
    12c4:	c0 01       	movw	r24, r0
    12c6:	61 9f       	mul	r22, r17
    12c8:	90 0d       	add	r25, r0
    12ca:	70 9f       	mul	r23, r16
    12cc:	90 0d       	add	r25, r0
    12ce:	11 24       	eor	r1, r1
    12d0:	e8 0f       	add	r30, r24
    12d2:	f9 1f       	adc	r31, r25
    12d4:	ea 5e       	subi	r30, 0xEA	; 234
    12d6:	fc 4f       	sbci	r31, 0xFC	; 252
    12d8:	e9 59       	subi	r30, 0x99	; 153
    12da:	ff 4f       	sbci	r31, 0xFF	; 255
    12dc:	21 91       	ld	r18, Z+
    12de:	31 91       	ld	r19, Z+
                        responsePack.highByter.low = cmd.accelTable[axis][accelTableIndex[axis]].repeats; 
    12e0:	40 81       	ld	r20, Z
                        responseData = responsePack.integer;
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if reading sequentially.
    12e2:	af 5f       	subi	r26, 0xFF	; 255
    12e4:	a8 83       	st	Y, r26
                        if (accelTableIndex[axis] >= AccelTableLength) {
    12e6:	a0 34       	cpi	r26, 0x40	; 64
    12e8:	08 f4       	brcc	.+2      	; 0x12ec <decodeCommand+0x560>
    12ea:	53 c0       	rjmp	.+166    	; 0x1392 <decodeCommand+0x606>
                            accelTableIndex[axis] = 0; //Wrap around
    12ec:	18 82       	st	Y, r1
    12ee:	51 c0       	rjmp	.+162    	; 0x1392 <decodeCommand+0x606>
                        }
                        break;
                    }
                    case 'X': { //store the accelTable value for address set by 'Y', or next address after last 'X'
                        unsigned long dataIn = synta_hexToLong(buffer);
    12f0:	c4 01       	movw	r24, r8
    12f2:	0e 94 29 13 	call	0x2652	; 0x2652 <_Z15synta_hexToLongPc>
                        cmd.accelTable[axis][accelTableIndex[axis]].speed = (unsigned int)dataIn; //lower two bytes is speed
    12f6:	4b 2d       	mov	r20, r11
    12f8:	50 e0       	ldi	r21, 0x00	; 0
    12fa:	ea 01       	movw	r28, r20
    12fc:	cc 5e       	subi	r28, 0xEC	; 236
    12fe:	dc 4f       	sbci	r29, 0xFC	; 252
    1300:	a8 81       	ld	r26, Y
    1302:	2a 2f       	mov	r18, r26
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	f9 01       	movw	r30, r18
    1308:	ee 0f       	add	r30, r30
    130a:	ff 1f       	adc	r31, r31
    130c:	e2 0f       	add	r30, r18
    130e:	f3 1f       	adc	r31, r19
    1310:	20 ec       	ldi	r18, 0xC0	; 192
    1312:	30 e0       	ldi	r19, 0x00	; 0
    1314:	89 01       	movw	r16, r18
    1316:	40 9f       	mul	r20, r16
    1318:	90 01       	movw	r18, r0
    131a:	41 9f       	mul	r20, r17
    131c:	30 0d       	add	r19, r0
    131e:	50 9f       	mul	r21, r16
    1320:	30 0d       	add	r19, r0
    1322:	11 24       	eor	r1, r1
    1324:	e2 0f       	add	r30, r18
    1326:	f3 1f       	adc	r31, r19
    1328:	ea 5e       	subi	r30, 0xEA	; 234
    132a:	fc 4f       	sbci	r31, 0xFC	; 252
    132c:	e9 59       	subi	r30, 0x99	; 153
    132e:	ff 4f       	sbci	r31, 0xFF	; 255
    1330:	61 93       	st	Z+, r22
    1332:	71 93       	st	Z+, r23
                        cmd.accelTable[axis][accelTableIndex[axis]].repeats = (byte)(dataIn>>16); //upper byte is repeats.
    1334:	bc 01       	movw	r22, r24
    1336:	88 27       	eor	r24, r24
    1338:	99 27       	eor	r25, r25
    133a:	60 83       	st	Z, r22
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if programming sequentially.
    133c:	af 5f       	subi	r26, 0xFF	; 255
    133e:	a8 83       	st	Y, r26
                        if (accelTableIndex[axis] >= AccelTableLength) {
    1340:	a0 34       	cpi	r26, 0x40	; 64
    1342:	18 f1       	brcs	.+70     	; 0x138a <decodeCommand+0x5fe>
                            accelTableIndex[axis] = 0; //Wrap around
    1344:	18 82       	st	Y, r1
    1346:	21 c0       	rjmp	.+66     	; 0x138a <decodeCommand+0x5fe>
                        }
                        break;
                    }
                    case 'Y': //store the accelTableIndex value
                        //Use axis=0 to set which address we are accessing (we'll repurpose accelTableIndex[RA] in prog mode for this)
                        accelTableIndex[axis] = synta_hexToByte(buffer);
    1348:	c4 01       	movw	r24, r8
    134a:	0e 94 26 13 	call	0x264c	; 0x264c <_Z15synta_hexToBytePc>
    134e:	eb 2d       	mov	r30, r11
    1350:	f0 e0       	ldi	r31, 0x00	; 0
    1352:	ec 5e       	subi	r30, 0xEC	; 236
    1354:	fc 4f       	sbci	r31, 0xFC	; 252
    1356:	80 83       	st	Z, r24
                        if (accelTableIndex[axis] >= AccelTableLength) {
    1358:	80 34       	cpi	r24, 0x40	; 64
    135a:	b0 f4       	brcc	.+44     	; 0x1388 <decodeCommand+0x5fc>
    135c:	16 c0       	rjmp	.+44     	; 0x138a <decodeCommand+0x5fe>
                            command = '\0'; //If the address out of range, force an error response packet.
                        }
                        break;
                    case 'T': //set mode, return empty response
                        if (progMode & 2) {
    135e:	82 2f       	mov	r24, r18
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	9c 01       	movw	r18, r24
    1364:	21 70       	andi	r18, 0x01	; 1
    1366:	30 70       	andi	r19, 0x00	; 0
    1368:	81 ff       	sbrs	r24, 1
    136a:	08 c0       	rjmp	.+16     	; 0x137c <decodeCommand+0x5f0>
                        //proceed with eeprom write
                            if (progMode & 1) {
    136c:	23 2b       	or	r18, r19
    136e:	19 f0       	breq	.+6      	; 0x1376 <decodeCommand+0x5ea>
                                buildEEPROM();
    1370:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <buildEEPROM>
    1374:	0a c0       	rjmp	.+20     	; 0x138a <decodeCommand+0x5fe>
                            } else {
                                storeEEPROM();
    1376:	0e 94 b2 05 	call	0xb64	; 0xb64 <storeEEPROM>
    137a:	07 c0       	rjmp	.+14     	; 0x138a <decodeCommand+0x5fe>
                            }
                        } else if (progMode & 1) {
    137c:	23 2b       	or	r18, r19
    137e:	29 f0       	breq	.+10     	; 0x138a <decodeCommand+0x5fe>
                            if (!checkEEPROM()) { //check if EEPROM contains valid data.
    1380:	0e 94 64 06 	call	0xcc8	; 0xcc8 <checkEEPROM>
    1384:	88 23       	and	r24, r24
    1386:	09 f4       	brne	.+2      	; 0x138a <decodeCommand+0x5fe>
    1388:	aa 24       	eor	r10, r10
    138a:	20 e0       	ldi	r18, 0x00	; 0
    138c:	30 e0       	ldi	r19, 0x00	; 0
    138e:	40 e0       	ldi	r20, 0x00	; 0
    1390:	50 e0       	ldi	r21, 0x00	; 0
    1392:	11 e0       	ldi	r17, 0x01	; 1
                }
            }
            break;
    }
  
    synta_assembleResponse(buffer, command, responseData); //generate correct response (this is required as is)
    1394:	c4 01       	movw	r24, r8
    1396:	6a 2d       	mov	r22, r10
    1398:	0e 94 c4 13 	call	0x2788	; 0x2788 <_Z22synta_assembleResponsePccm>
    
    if ((command == 'J') && (progMode == 0)) { //J tells us we are ready to begin the requested movement.
    139c:	2a e4       	ldi	r18, 0x4A	; 74
    139e:	a2 16       	cp	r10, r18
    13a0:	89 f4       	brne	.+34     	; 0x13c4 <decodeCommand+0x638>
    13a2:	80 91 86 02 	lds	r24, 0x0286
    13a6:	88 23       	and	r24, r24
    13a8:	69 f4       	brne	.+26     	; 0x13c4 <decodeCommand+0x638>
        readyToGo[axis] = 1; //So signal we are ready to go and when the last movement complets this one will execute.
    13aa:	8b 2d       	mov	r24, r11
    13ac:	90 e0       	ldi	r25, 0x00	; 0
    13ae:	fc 01       	movw	r30, r24
    13b0:	e6 58       	subi	r30, 0x86	; 134
    13b2:	fd 4f       	sbci	r31, 0xFD	; 253
    13b4:	21 e0       	ldi	r18, 0x01	; 1
    13b6:	20 83       	st	Z, r18
        if (!(cmd.GVal[axis] & 1)){
    13b8:	fc 01       	movw	r30, r24
    13ba:	ea 5e       	subi	r30, 0xEA	; 234
    13bc:	fc 4f       	sbci	r31, 0xFC	; 252
    13be:	80 89       	ldd	r24, Z+16	; 0x10
    13c0:	80 ff       	sbrs	r24, 0
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
    13c2:	20 a3       	std	Z+32, r18	; 0x20
            //If go-to mode requested
            cmd_setGotoEn(axis,CMD_ENABLED);
        }
    }
    return success;
}
    13c4:	81 2f       	mov	r24, r17
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	1f 91       	pop	r17
    13cc:	0f 91       	pop	r16
    13ce:	ff 90       	pop	r15
    13d0:	ef 90       	pop	r14
    13d2:	df 90       	pop	r13
    13d4:	cf 90       	pop	r12
    13d6:	bf 90       	pop	r11
    13d8:	af 90       	pop	r10
    13da:	9f 90       	pop	r9
    13dc:	8f 90       	pop	r8
    13de:	08 95       	ret

000013e0 <calculateRate>:
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
}

void calculateRate(byte axis){
    13e0:	2f 92       	push	r2
    13e2:	3f 92       	push	r3
    13e4:	4f 92       	push	r4
    13e6:	5f 92       	push	r5
    13e8:	6f 92       	push	r6
    13ea:	7f 92       	push	r7
    13ec:	8f 92       	push	r8
    13ee:	9f 92       	push	r9
    13f0:	af 92       	push	r10
    13f2:	bf 92       	push	r11
    13f4:	cf 92       	push	r12
    13f6:	df 92       	push	r13
    13f8:	ef 92       	push	r14
    13fa:	ff 92       	push	r15
    13fc:	0f 93       	push	r16
    13fe:	1f 93       	push	r17
    1400:	cf 93       	push	r28
    1402:	df 93       	push	r29
  
    unsigned long rate;
    unsigned long remainder;
    float floatRemainder;
    unsigned long divisor = cmd.bVal[axis];
    1404:	c8 2f       	mov	r28, r24
    1406:	d0 e0       	ldi	r29, 0x00	; 0
    1408:	fe 01       	movw	r30, r28
    140a:	ee 0f       	add	r30, r30
    140c:	ff 1f       	adc	r31, r31
    140e:	ee 0f       	add	r30, r30
    1410:	ff 1f       	adc	r31, r31
    1412:	ea 5e       	subi	r30, 0xEA	; 234
    1414:	fc 4f       	sbci	r31, 0xFC	; 252
    1416:	a6 a8       	ldd	r10, Z+54	; 0x36
    1418:	b7 a8       	ldd	r11, Z+55	; 0x37
    141a:	c0 ac       	ldd	r12, Z+56	; 0x38
    141c:	d1 ac       	ldd	r13, Z+57	; 0x39
    byte distWidth = DecimalDistnWidth;
    
    //When dividing a very large number by a much smaller on, float accuracy is abismal. So firstly we use integer math to split the division into quotient and remainder
    rate = timerCountRate / divisor; //Calculate the quotient
    141e:	60 e0       	ldi	r22, 0x00	; 0
    1420:	72 e1       	ldi	r23, 0x12	; 18
    1422:	8a e7       	ldi	r24, 0x7A	; 122
    1424:	90 e0       	ldi	r25, 0x00	; 0
    1426:	a6 01       	movw	r20, r12
    1428:	95 01       	movw	r18, r10
    142a:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__udivmodsi4>
    142e:	c9 01       	movw	r24, r18
    1430:	da 01       	movw	r26, r20
    1432:	3c 01       	movw	r6, r24
    1434:	4d 01       	movw	r8, r26
    remainder = timerCountRate % divisor; //Calculate the remainder
    
    //Then convert the remainder into a decimal number (division of a small number by a larger one, improving accuracy)
    floatRemainder = (float)remainder/(float)divisor; //Convert the remainder to a decimal.
    1436:	60 e0       	ldi	r22, 0x00	; 0
    1438:	72 e1       	ldi	r23, 0x12	; 18
    143a:	8a e7       	ldi	r24, 0x7A	; 122
    143c:	90 e0       	ldi	r25, 0x00	; 0
    143e:	a6 01       	movw	r20, r12
    1440:	95 01       	movw	r18, r10
    1442:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__udivmodsi4>
    1446:	0e 94 50 15 	call	0x2aa0	; 0x2aa0 <__floatunsisf>
    144a:	7b 01       	movw	r14, r22
    144c:	8c 01       	movw	r16, r24
    144e:	c6 01       	movw	r24, r12
    1450:	b5 01       	movw	r22, r10
    1452:	0e 94 50 15 	call	0x2aa0	; 0x2aa0 <__floatunsisf>
    1456:	9b 01       	movw	r18, r22
    1458:	ac 01       	movw	r20, r24
    145a:	c8 01       	movw	r24, r16
    145c:	b7 01       	movw	r22, r14
    145e:	0e 94 bc 14 	call	0x2978	; 0x2978 <__divsf3>
    
    //Multiply the remainder by distributionWidth to work out an approximate number of extra clocks needed per full step (each step is 'distributionWidth' microsteps)
    floatRemainder *= (float)distWidth; 
    //This many extra cycles are needed:
    remainder = (unsigned long)(floatRemainder+0.5f); 
    1462:	20 e0       	ldi	r18, 0x00	; 0
    1464:	30 e0       	ldi	r19, 0x00	; 0
    1466:	40 e0       	ldi	r20, 0x00	; 0
    1468:	52 e4       	ldi	r21, 0x42	; 66
    146a:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__mulsf3>
    146e:	20 e0       	ldi	r18, 0x00	; 0
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	40 e0       	ldi	r20, 0x00	; 0
    1474:	5f e3       	ldi	r21, 0x3F	; 63
    1476:	0e 94 45 14 	call	0x288a	; 0x288a <__addsf3>
    147a:	0e 94 24 15 	call	0x2a48	; 0x2a48 <__fixunssfsi>
    147e:	1b 01       	movw	r2, r22
    1480:	2c 01       	movw	r4, r24
    
    //Now truncate to an unsigned int with a sensible max value (the int is to avoid register issues with the 16 bit timer)
    if((unsigned int)(rate >> 16)){
    1482:	c4 01       	movw	r24, r8
    1484:	aa 27       	eor	r26, r26
    1486:	bb 27       	eor	r27, r27
    1488:	89 2b       	or	r24, r25
    148a:	39 f0       	breq	.+14     	; 0x149a <calculateRate+0xba>
    148c:	5f ef       	ldi	r21, 0xFF	; 255
    148e:	65 2e       	mov	r6, r21
    1490:	5f ef       	ldi	r21, 0xFF	; 255
    1492:	75 2e       	mov	r7, r21
    1494:	81 2c       	mov	r8, r1
    1496:	91 2c       	mov	r9, r1
    1498:	0b c0       	rjmp	.+22     	; 0x14b0 <calculateRate+0xd0>
        rate = 65535UL;
    } else if (rate < 128UL) {
    149a:	80 e8       	ldi	r24, 0x80	; 128
    149c:	68 16       	cp	r6, r24
    149e:	71 04       	cpc	r7, r1
    14a0:	81 04       	cpc	r8, r1
    14a2:	91 04       	cpc	r9, r1
    14a4:	28 f4       	brcc	.+10     	; 0x14b0 <calculateRate+0xd0>
    14a6:	40 e8       	ldi	r20, 0x80	; 128
    14a8:	64 2e       	mov	r6, r20
    14aa:	71 2c       	mov	r7, r1
    14ac:	81 2c       	mov	r8, r1
    14ae:	91 2c       	mov	r9, r1
    14b0:	fe 01       	movw	r30, r28
    14b2:	36 e0       	ldi	r19, 0x06	; 6
    14b4:	ee 0f       	add	r30, r30
    14b6:	ff 1f       	adc	r31, r31
    14b8:	3a 95       	dec	r19
    14ba:	e1 f7       	brne	.-8      	; 0x14b4 <calculateRate+0xd4>
    14bc:	e6 57       	subi	r30, 0x76	; 118
    14be:	fd 4f       	sbci	r31, 0xFD	; 253
    14c0:	80 e0       	ldi	r24, 0x00	; 0
  
    for (byte i = 0; i < distWidth; i++){
#if defined(__AVR_ATmega162__)
        timerOVF[axis][i] = rate; //Subtract 1 as timer is 0 indexed.
#else
        timerOVF[axis][i] = rate; //Hmm, for some reason this one doesn't need 1 subtracting???
    14c2:	61 92       	st	Z+, r6
    14c4:	71 92       	st	Z+, r7
    }
#if defined(__AVR_ATmega162__)
    rate--;
#endif
  
    for (byte i = 0; i < distWidth; i++){
    14c6:	8f 5f       	subi	r24, 0xFF	; 255
    14c8:	80 32       	cpi	r24, 0x20	; 32
    14ca:	d9 f7       	brne	.-10     	; 0x14c2 <calculateRate+0xe2>
    14cc:	aa 24       	eor	r10, r10
    14ce:	bb 24       	eor	r11, r11
    14d0:	65 01       	movw	r12, r10
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
        distn *= (float)distWidth;
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    14d2:	25 e0       	ldi	r18, 0x05	; 5
    14d4:	cc 0f       	add	r28, r28
    14d6:	dd 1f       	adc	r29, r29
    14d8:	2a 95       	dec	r18
    14da:	e1 f7       	brne	.-8      	; 0x14d4 <calculateRate+0xf4>
    14dc:	2b c0       	rjmp	.+86     	; 0x1534 <calculateRate+0x154>
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
    14de:	c6 01       	movw	r24, r12
    14e0:	b5 01       	movw	r22, r10
    14e2:	0e 94 50 15 	call	0x2aa0	; 0x2aa0 <__floatunsisf>
        distn *= (float)distWidth;
    14e6:	20 e0       	ldi	r18, 0x00	; 0
    14e8:	30 e0       	ldi	r19, 0x00	; 0
    14ea:	40 e0       	ldi	r20, 0x00	; 0
    14ec:	52 e4       	ldi	r21, 0x42	; 66
    14ee:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__mulsf3>
    14f2:	7b 01       	movw	r14, r22
    14f4:	8c 01       	movw	r16, r24
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
    14f6:	c2 01       	movw	r24, r4
    14f8:	b1 01       	movw	r22, r2
    14fa:	0e 94 50 15 	call	0x2aa0	; 0x2aa0 <__floatunsisf>
    14fe:	9b 01       	movw	r18, r22
    1500:	ac 01       	movw	r20, r24
    1502:	c8 01       	movw	r24, r16
    1504:	b7 01       	movw	r22, r14
    1506:	0e 94 bc 14 	call	0x2978	; 0x2978 <__divsf3>
    150a:	0e 94 a9 14 	call	0x2952	; 0x2952 <ceil>
        timerOVF[axis][index] += 1;
    150e:	0e 94 24 15 	call	0x2a48	; 0x2a48 <__fixunssfsi>
    1512:	fe 01       	movw	r30, r28
    1514:	e6 0f       	add	r30, r22
    1516:	f1 1d       	adc	r31, r1
    1518:	ee 0f       	add	r30, r30
    151a:	ff 1f       	adc	r31, r31
    151c:	e6 57       	subi	r30, 0x76	; 118
    151e:	fd 4f       	sbci	r31, 0xFD	; 253
    1520:	80 81       	ld	r24, Z
    1522:	91 81       	ldd	r25, Z+1	; 0x01
    1524:	01 96       	adiw	r24, 0x01	; 1
    1526:	91 83       	std	Z+1, r25	; 0x01
    1528:	80 83       	st	Z, r24
        timerOVF[axis][i] = rate; //Hmm, for some reason this one doesn't need 1 subtracting???
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
    152a:	08 94       	sec
    152c:	a1 1c       	adc	r10, r1
    152e:	b1 1c       	adc	r11, r1
    1530:	c1 1c       	adc	r12, r1
    1532:	d1 1c       	adc	r13, r1
    1534:	a2 14       	cp	r10, r2
    1536:	b3 04       	cpc	r11, r3
    1538:	c4 04       	cpc	r12, r4
    153a:	d5 04       	cpc	r13, r5
    153c:	80 f2       	brcs	.-96     	; 0x14de <calculateRate+0xfe>
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    }
    
}
    153e:	df 91       	pop	r29
    1540:	cf 91       	pop	r28
    1542:	1f 91       	pop	r17
    1544:	0f 91       	pop	r16
    1546:	ff 90       	pop	r15
    1548:	ef 90       	pop	r14
    154a:	df 90       	pop	r13
    154c:	cf 90       	pop	r12
    154e:	bf 90       	pop	r11
    1550:	af 90       	pop	r10
    1552:	9f 90       	pop	r9
    1554:	8f 90       	pop	r8
    1556:	7f 90       	pop	r7
    1558:	6f 90       	pop	r6
    155a:	5f 90       	pop	r5
    155c:	4f 90       	pop	r4
    155e:	3f 90       	pop	r3
    1560:	2f 90       	pop	r2
    1562:	08 95       	ret

00001564 <systemInitialiser>:

void systemInitialiser(){    
    
    encodeDirection[RA] = EEPROM_readByte(RAReverse_Address) ? CMD_REVERSE : CMD_FORWARD;  //reverse the right ascension if 1
    1564:	89 e0       	ldi	r24, 0x09	; 9
    1566:	90 e0       	ldi	r25, 0x00	; 0
    1568:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    156c:	10 92 84 02 	sts	0x0284, r1
    1570:	88 23       	and	r24, r24
    1572:	19 f0       	breq	.+6      	; 0x157a <systemInitialiser+0x16>
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	80 93 84 02 	sts	0x0284, r24
    encodeDirection[DC] = EEPROM_readByte(DECReverse_Address) ? CMD_REVERSE : CMD_FORWARD; //reverse the declination if 1
    157a:	8a e0       	ldi	r24, 0x0A	; 10
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    1582:	10 92 85 02 	sts	0x0285, r1
    1586:	88 23       	and	r24, r24
    1588:	19 f0       	breq	.+6      	; 0x1590 <systemInitialiser+0x2c>
    158a:	81 e0       	ldi	r24, 0x01	; 1
    158c:	80 93 85 02 	sts	0x0285, r24
    
    driverVersion = EEPROM_readByte(Driver_Address);
    1590:	8b e0       	ldi	r24, 0x0B	; 11
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    1598:	80 93 88 02 	sts	0x0288, r24
    microstepConf = EEPROM_readByte(Microstep_Address);
    159c:	88 e0       	ldi	r24, 0x08	; 8
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    15a4:	80 93 87 02 	sts	0x0287, r24

    allowAdvancedHCDetection = !EEPROM_readByte(AdvHCEnable_Address);
    15a8:	8b e2       	ldi	r24, 0x2B	; 43
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    15b0:	10 92 0d 03 	sts	0x030D, r1
    15b4:	88 23       	and	r24, r24
    15b6:	19 f4       	brne	.+6      	; 0x15be <systemInitialiser+0x5a>
    15b8:	81 e0       	ldi	r24, 0x01	; 1
    15ba:	80 93 0d 03 	sts	0x030D, r24
    
    defaultSpeedState = (microstepConf >= 8) ? SPEEDNORM : SPEEDFAST;
    15be:	10 92 0b 03 	sts	0x030B, r1
    15c2:	80 91 87 02 	lds	r24, 0x0287
    15c6:	88 30       	cpi	r24, 0x08	; 8
    15c8:	18 f4       	brcc	.+6      	; 0x15d0 <systemInitialiser+0x6c>
    15ca:	81 e0       	ldi	r24, 0x01	; 1
    15cc:	80 93 0b 03 	sts	0x030B, r24
    disableGearChange = !EEPROM_readByte(GearEnable_Address);
    15d0:	8a e2       	ldi	r24, 0x2A	; 42
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    15d8:	90 e0       	ldi	r25, 0x00	; 0
    15da:	88 23       	and	r24, r24
    15dc:	09 f4       	brne	.+2      	; 0x15e0 <systemInitialiser+0x7c>
    15de:	91 e0       	ldi	r25, 0x01	; 1
    15e0:	90 93 0c 03 	sts	0x030C, r25
    canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    15e4:	80 91 87 02 	lds	r24, 0x0287
    15e8:	88 30       	cpi	r24, 0x08	; 8
    15ea:	10 f4       	brcc	.+4      	; 0x15f0 <systemInitialiser+0x8c>
    15ec:	80 e0       	ldi	r24, 0x00	; 0
    15ee:	02 c0       	rjmp	.+4      	; 0x15f4 <systemInitialiser+0x90>
    15f0:	81 e0       	ldi	r24, 0x01	; 1
    15f2:	89 27       	eor	r24, r25
    15f4:	80 93 0a 03 	sts	0x030A, r24
        
    synta_initialise(ASTROEQ_VER,(canJumpToHighspeed ? 8 : 1)); //initialise mount instance, specify version!
    15f8:	88 23       	and	r24, r24
    15fa:	11 f4       	brne	.+4      	; 0x1600 <systemInitialiser+0x9c>
    15fc:	41 e0       	ldi	r20, 0x01	; 1
    15fe:	01 c0       	rjmp	.+2      	; 0x1602 <systemInitialiser+0x9e>
    1600:	48 e0       	ldi	r20, 0x08	; 8
    1602:	62 e2       	ldi	r22, 0x22	; 34
    1604:	73 e0       	ldi	r23, 0x03	; 3
    1606:	80 e0       	ldi	r24, 0x00	; 0
    1608:	90 e0       	ldi	r25, 0x00	; 0
    160a:	0e 94 34 14 	call	0x2868	; 0x2868 <_Z16synta_initialisemh>
    
    buildModeMapping(microstepConf, driverVersion);
    160e:	80 91 87 02 	lds	r24, 0x0287
    1612:	60 91 88 02 	lds	r22, 0x0288
    1616:	0e 94 e6 00 	call	0x1cc	; 0x1cc <buildModeMapping>
    
    if(!checkEEPROM()){
    161a:	0e 94 64 06 	call	0xcc8	; 0xcc8 <checkEEPROM>
    161e:	88 23       	and	r24, r24
    1620:	19 f4       	brne	.+6      	; 0x1628 <systemInitialiser+0xc4>
        progMode = PROGMODE; //prevent AstroEQ startup if EEPROM is blank.
    1622:	81 e0       	ldi	r24, 0x01	; 1
    1624:	80 93 86 02 	sts	0x0286, r24
    }

    calculateRate(RA); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    1628:	80 e0       	ldi	r24, 0x00	; 0
    162a:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <calculateRate>
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    162e:	81 e0       	ldi	r24, 0x01	; 1
    1630:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <calculateRate>
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    1634:	40 91 75 03 	lds	r20, 0x0375
    1638:	50 91 76 03 	lds	r21, 0x0376
    163c:	ed e7       	ldi	r30, 0x7D	; 125
    163e:	f3 e0       	ldi	r31, 0x03	; 3
    1640:	20 e0       	ldi	r18, 0x00	; 0
    1642:	30 e0       	ldi	r19, 0x00	; 0
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
    1644:	80 81       	ld	r24, Z
    1646:	91 81       	ldd	r25, Z+1	; 0x01
    1648:	48 17       	cp	r20, r24
    164a:	59 07       	cpc	r21, r25
    164c:	50 f4       	brcc	.+20     	; 0x1662 <systemInitialiser+0xfe>
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
    164e:	82 81       	ldd	r24, Z+2	; 0x02
    1650:	90 e0       	ldi	r25, 0x00	; 0
    1652:	01 96       	adiw	r24, 0x01	; 1
    1654:	28 0f       	add	r18, r24
    1656:	39 1f       	adc	r19, r25
    1658:	33 96       	adiw	r30, 0x03	; 3

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
    165a:	84 e0       	ldi	r24, 0x04	; 4
    165c:	ed 33       	cpi	r30, 0x3D	; 61
    165e:	f8 07       	cpc	r31, r24
    1660:	89 f7       	brne	.-30     	; 0x1644 <systemInitialiser+0xe0>
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
    1662:	30 93 0f 03 	sts	0x030F, r19
    1666:	20 93 0e 03 	sts	0x030E, r18
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    166a:	40 91 77 03 	lds	r20, 0x0377
    166e:	50 91 78 03 	lds	r21, 0x0378
    1672:	ed e3       	ldi	r30, 0x3D	; 61
    1674:	f4 e0       	ldi	r31, 0x04	; 4
    1676:	20 e0       	ldi	r18, 0x00	; 0
    1678:	30 e0       	ldi	r19, 0x00	; 0
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
    167a:	80 81       	ld	r24, Z
    167c:	91 81       	ldd	r25, Z+1	; 0x01
    167e:	48 17       	cp	r20, r24
    1680:	59 07       	cpc	r21, r25
    1682:	50 f4       	brcc	.+20     	; 0x1698 <systemInitialiser+0x134>
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
    1684:	82 81       	ldd	r24, Z+2	; 0x02
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	01 96       	adiw	r24, 0x01	; 1
    168a:	28 0f       	add	r18, r24
    168c:	39 1f       	adc	r19, r25
    168e:	33 96       	adiw	r30, 0x03	; 3

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
    1690:	84 e0       	ldi	r24, 0x04	; 4
    1692:	ed 3f       	cpi	r30, 0xFD	; 253
    1694:	f8 07       	cpc	r31, r24
    1696:	89 f7       	brne	.-30     	; 0x167a <systemInitialiser+0x116>
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
    1698:	30 93 11 03 	sts	0x0311, r19
    169c:	20 93 10 03 	sts	0x0310, r18
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateDecelerationLength(RA);
    calculateDecelerationLength(DC);
    
    //Status pin to output low
    setPinDir  (statusPin,OUTPUT);
    16a0:	27 9a       	sbi	0x04, 7	; 4
    setPinValue(statusPin,   LOW);
    16a2:	2f 98       	cbi	0x05, 7	; 5

    //Standalone Speed/IRQ pin to input no-pullup
    setPinDir  (standalonePin[  STANDALONE_IRQ], INPUT);
    16a4:	50 98       	cbi	0x0a, 0	; 10
    setPinValue(standalonePin[  STANDALONE_IRQ],  HIGH); //enable pull-up to pull IRQ high.
    16a6:	58 9a       	sbi	0x0b, 0	; 11

    //Standalone Pullup/Pulldown pin to output high
    setPinDir  (standalonePin[ STANDALONE_PULL],OUTPUT);
    16a8:	09 9a       	sbi	0x01, 1	; 1
    setPinValue(standalonePin[ STANDALONE_PULL],  HIGH);
    16aa:	11 9a       	sbi	0x02, 1	; 2
    
    //ST4 pins to input with pullup
    setPinDir  (st4Pins[RA][ST4P],INPUT);
    16ac:	23 98       	cbi	0x04, 3	; 4
    setPinValue(st4Pins[RA][ST4P],HIGH );
    16ae:	2b 9a       	sbi	0x05, 3	; 5
    setPinDir  (st4Pins[RA][ST4N],INPUT);
    16b0:	20 98       	cbi	0x04, 0	; 4
    setPinValue(st4Pins[RA][ST4N],HIGH );
    16b2:	28 9a       	sbi	0x05, 0	; 5
    setPinDir  (st4Pins[DC][ST4P],INPUT);
    16b4:	22 98       	cbi	0x04, 2	; 4
    setPinValue(st4Pins[DC][ST4P],HIGH );
    16b6:	2a 9a       	sbi	0x05, 2	; 5
    setPinDir  (st4Pins[DC][ST4N],INPUT);
    16b8:	21 98       	cbi	0x04, 1	; 4
    setPinValue(st4Pins[DC][ST4N],HIGH );
    16ba:	29 9a       	sbi	0x05, 1	; 5
    
    //Reset pins to output
    setPinDir  (resetPin[RA],OUTPUT);
    16bc:	81 9a       	sbi	0x10, 1	; 16
    setPinValue(resetPin[RA],   LOW);  //Motor driver in Reset
    16be:	89 98       	cbi	0x11, 1	; 17
    setPinDir  (resetPin[DC],OUTPUT);
    16c0:	80 9a       	sbi	0x10, 0	; 16
    setPinValue(resetPin[DC],   LOW);  //Motor driver in Reset 
    16c2:	88 98       	cbi	0x11, 0	; 17
    
    //Enable pins to output
    setPinDir  (enablePin[RA],OUTPUT);
    16c4:	9d 9a       	sbi	0x13, 5	; 19
    setPinValue(enablePin[RA],  HIGH); //Motor Driver Disabled
    16c6:	a5 9a       	sbi	0x14, 5	; 20
    setPinDir  (enablePin[DC],OUTPUT);
    16c8:	80 91 01 01 	lds	r24, 0x0101
    16cc:	80 62       	ori	r24, 0x20	; 32
    16ce:	80 93 01 01 	sts	0x0101, r24
    setPinValue(enablePin[DC],  HIGH); //Motor Driver Disabled
    16d2:	80 91 02 01 	lds	r24, 0x0102
    16d6:	80 62       	ori	r24, 0x20	; 32
    16d8:	80 93 02 01 	sts	0x0102, r24
    
    //Step pins to output
    setPinDir  (stepPin[RA],OUTPUT);
    16dc:	6b 9a       	sbi	0x0d, 3	; 13
    setPinValue(stepPin[RA],   LOW);
    16de:	73 98       	cbi	0x0e, 3	; 14
    setPinDir  (stepPin[DC],OUTPUT);
    16e0:	26 9a       	sbi	0x04, 6	; 4
    setPinValue(stepPin[DC],   LOW);
    16e2:	2e 98       	cbi	0x05, 6	; 5
    
    //Direction pins to output
    setPinDir  (dirPin[RA],OUTPUT);
    16e4:	6d 9a       	sbi	0x0d, 5	; 13
    setPinValue(dirPin[RA],   LOW);
    16e6:	75 98       	cbi	0x0e, 5	; 14
    setPinDir  (dirPin[DC],OUTPUT);
    16e8:	80 91 01 01 	lds	r24, 0x0101
    16ec:	80 61       	ori	r24, 0x10	; 16
    16ee:	80 93 01 01 	sts	0x0101, r24
    setPinValue(dirPin[DC],   LOW);
    16f2:	80 91 02 01 	lds	r24, 0x0102
    16f6:	8f 7e       	andi	r24, 0xEF	; 239
    16f8:	80 93 02 01 	sts	0x0102, r24
    
    //Load the correct mode
    byte state = modeState[defaultSpeedState]; //Extract the default mode - If the microstep mode is >= then we start in NORMAL mode, otherwise we use FAST mode

    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    16fc:	e0 91 0b 03 	lds	r30, 0x030B
    1700:	f0 e0       	ldi	r31, 0x00	; 0
    1702:	e7 5f       	subi	r30, 0xF7	; 247
    1704:	fd 4f       	sbci	r31, 0xFD	; 253
    1706:	80 81       	ld	r24, Z
    1708:	28 2f       	mov	r18, r24
    170a:	30 e0       	ldi	r19, 0x00	; 0
    170c:	a9 01       	movw	r20, r18
    170e:	41 70       	andi	r20, 0x01	; 1
    1710:	50 70       	andi	r21, 0x00	; 0
    1712:	80 ff       	sbrs	r24, 0
    1714:	04 c0       	rjmp	.+8      	; 0x171e <systemInitialiser+0x1ba>
    1716:	80 91 05 01 	lds	r24, 0x0105
    171a:	81 60       	ori	r24, 0x01	; 1
    171c:	03 c0       	rjmp	.+6      	; 0x1724 <systemInitialiser+0x1c0>
    171e:	80 91 05 01 	lds	r24, 0x0105
    1722:	8e 7f       	andi	r24, 0xFE	; 254
    1724:	80 93 05 01 	sts	0x0105, r24
    setPinDir  (modePins[RA][MODE0],  OUTPUT                      ); 
    1728:	80 91 04 01 	lds	r24, 0x0104
    172c:	81 60       	ori	r24, 0x01	; 1
    172e:	80 93 04 01 	sts	0x0104, r24
    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    1732:	45 2b       	or	r20, r21
    1734:	11 f0       	breq	.+4      	; 0x173a <systemInitialiser+0x1d6>
    1736:	59 9a       	sbi	0x0b, 1	; 11
    1738:	01 c0       	rjmp	.+2      	; 0x173c <systemInitialiser+0x1d8>
    173a:	59 98       	cbi	0x0b, 1	; 11
    setPinDir  (modePins[DC][MODE0],  OUTPUT                      );
    173c:	51 9a       	sbi	0x0a, 1	; 10
    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    173e:	a9 01       	movw	r20, r18
    1740:	42 70       	andi	r20, 0x02	; 2
    1742:	50 70       	andi	r21, 0x00	; 0
    1744:	21 ff       	sbrs	r18, 1
    1746:	04 c0       	rjmp	.+8      	; 0x1750 <systemInitialiser+0x1ec>
    1748:	80 91 02 01 	lds	r24, 0x0102
    174c:	82 60       	ori	r24, 0x02	; 2
    174e:	03 c0       	rjmp	.+6      	; 0x1756 <systemInitialiser+0x1f2>
    1750:	80 91 02 01 	lds	r24, 0x0102
    1754:	8d 7f       	andi	r24, 0xFD	; 253
    1756:	80 93 02 01 	sts	0x0102, r24
    setPinDir  (modePins[RA][MODE1],  OUTPUT                      );
    175a:	80 91 01 01 	lds	r24, 0x0101
    175e:	82 60       	ori	r24, 0x02	; 2
    1760:	80 93 01 01 	sts	0x0101, r24
    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    1764:	45 2b       	or	r20, r21
    1766:	11 f0       	breq	.+4      	; 0x176c <systemInitialiser+0x208>
    1768:	5a 9a       	sbi	0x0b, 2	; 11
    176a:	01 c0       	rjmp	.+2      	; 0x176e <systemInitialiser+0x20a>
    176c:	5a 98       	cbi	0x0b, 2	; 11
    setPinDir  (modePins[DC][MODE1],  OUTPUT                      );
    176e:	52 9a       	sbi	0x0a, 2	; 10
    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    1770:	b9 01       	movw	r22, r18
    1772:	64 70       	andi	r22, 0x04	; 4
    1774:	70 70       	andi	r23, 0x00	; 0
    1776:	22 ff       	sbrs	r18, 2
    1778:	04 c0       	rjmp	.+8      	; 0x1782 <systemInitialiser+0x21e>
    177a:	80 91 02 01 	lds	r24, 0x0102
    177e:	81 60       	ori	r24, 0x01	; 1
    1780:	03 c0       	rjmp	.+6      	; 0x1788 <systemInitialiser+0x224>
    1782:	80 91 02 01 	lds	r24, 0x0102
    1786:	8e 7f       	andi	r24, 0xFE	; 254
    1788:	80 93 02 01 	sts	0x0102, r24
    setPinDir  (modePins[RA][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    178c:	a9 01       	movw	r20, r18
    178e:	40 72       	andi	r20, 0x20	; 32
    1790:	50 70       	andi	r21, 0x00	; 0
    1792:	25 fd       	sbrc	r18, 5
    1794:	04 c0       	rjmp	.+8      	; 0x179e <systemInitialiser+0x23a>
    1796:	80 91 01 01 	lds	r24, 0x0101
    179a:	81 60       	ori	r24, 0x01	; 1
    179c:	03 c0       	rjmp	.+6      	; 0x17a4 <systemInitialiser+0x240>
    179e:	80 91 01 01 	lds	r24, 0x0101
    17a2:	8e 7f       	andi	r24, 0xFE	; 254
    17a4:	80 93 01 01 	sts	0x0101, r24
    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    17a8:	67 2b       	or	r22, r23
    17aa:	11 f0       	breq	.+4      	; 0x17b0 <systemInitialiser+0x24c>
    17ac:	5b 9a       	sbi	0x0b, 3	; 11
    17ae:	01 c0       	rjmp	.+2      	; 0x17b2 <systemInitialiser+0x24e>
    17b0:	5b 98       	cbi	0x0b, 3	; 11
    setPinDir  (modePins[DC][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    17b2:	45 2b       	or	r20, r21
    17b4:	11 f4       	brne	.+4      	; 0x17ba <systemInitialiser+0x256>
    17b6:	53 9a       	sbi	0x0a, 3	; 10
    17b8:	01 c0       	rjmp	.+2      	; 0x17bc <systemInitialiser+0x258>
    17ba:	53 98       	cbi	0x0a, 3	; 10
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    17bc:	80 ea       	ldi	r24, 0xA0	; 160
    17be:	9f e0       	ldi	r25, 0x0F	; 15
    17c0:	01 97       	sbiw	r24, 0x01	; 1
    17c2:	f1 f7       	brne	.-4      	; 0x17c0 <systemInitialiser+0x25c>

    //Give some time for the Motor Drivers to reset.
    _delay_ms(1);

    //Then bring them out of reset.
    setPinValue(resetPin[RA],HIGH);
    17c4:	89 9a       	sbi	0x11, 1	; 17
    setPinValue(resetPin[DC],HIGH);
    17c6:	88 9a       	sbi	0x11, 0	; 17
    TIMSK &= ~(_BV(TOIE0) | _BV(OCIE0));
    TCCR0 = 0;
#endif

    //Ensure SPI is disabled
    SPI_disable();
    17c8:	0e 94 1a 12 	call	0x2434	; 0x2434 <_Z11SPI_disablev>
    
    //Initialise the Serial port:
    Serial_initialise(BAUD_RATE); //SyncScan runs at 9600Baud, use a serial port of your choice as defined in SerialLink.h
    17cc:	60 e8       	ldi	r22, 0x80	; 128
    17ce:	75 e2       	ldi	r23, 0x25	; 37
    17d0:	80 e0       	ldi	r24, 0x00	; 0
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	0e 94 8d 11 	call	0x231a	; 0x231a <_Z17Serial_initialisem>
      
}
    17d8:	08 95       	ret

000017da <main>:

/*
 * AstroEQ firmware main() function
 */

int main(void) {
    17da:	2f 92       	push	r2
    17dc:	3f 92       	push	r3
    17de:	4f 92       	push	r4
    17e0:	5f 92       	push	r5
    17e2:	6f 92       	push	r6
    17e4:	7f 92       	push	r7
    17e6:	8f 92       	push	r8
    17e8:	9f 92       	push	r9
    17ea:	af 92       	push	r10
    17ec:	bf 92       	push	r11
    17ee:	cf 92       	push	r12
    17f0:	df 92       	push	r13
    17f2:	ef 92       	push	r14
    17f4:	ff 92       	push	r15
    17f6:	0f 93       	push	r16
    17f8:	1f 93       	push	r17
    17fa:	df 93       	push	r29
    17fc:	cf 93       	push	r28
    17fe:	cd b7       	in	r28, 0x3d	; 61
    1800:	de b7       	in	r29, 0x3e	; 62
    1802:	2e 97       	sbiw	r28, 0x0e	; 14
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	de bf       	out	0x3e, r29	; 62
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	cd bf       	out	0x3d, r28	; 61
    //Enable global interrupt flag
    sei();
    180e:	78 94       	sei
    //Initialise global variables from the EEPROM
    systemInitialiser();
    1810:	0e 94 b2 0a 	call	0x1564	; 0x1564 <systemInitialiser>
    1814:	ee 24       	eor	r14, r14
    1816:	ff 24       	eor	r15, r15
    1818:	aa 24       	eor	r10, r10
    181a:	00 e0       	ldi	r16, 0x00	; 0
    181c:	cc 24       	eor	r12, r12
    181e:	bb 24       	eor	r11, r11
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
    1820:	41 2c       	mov	r4, r1
    1822:	51 2c       	mov	r5, r1
    1824:	80 e8       	ldi	r24, 0x80	; 128
    1826:	68 2e       	mov	r6, r24
    1828:	71 2c       	mov	r7, r1
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
    182a:	1e 01       	movw	r2, r28
    182c:	08 94       	sec
    182e:	21 1c       	adc	r2, r1
    1830:	31 1c       	adc	r3, r1
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    1832:	dd 24       	eor	r13, r13
    1834:	da 94       	dec	r13
                if (decoded != -2) {
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
    1836:	14 e0       	ldi	r17, 0x04	; 4
    1838:	81 2e       	mov	r8, r17
    183a:	91 2c       	mov	r9, r1
    183c:	8c 0e       	add	r8, r28
    183e:	9d 1e       	adc	r9, r29
    int8_t decoded = 0; //Whether we have decoded the packet
    char decodedPacket[11]; //temporary store for completed command ready to be processed
    
    for(;;){ //Run loop

        loopCount++; //Counter used to time events based on number of loops.
    1840:	08 94       	sec
    1842:	e1 1c       	adc	r14, r1
    1844:	f1 1c       	adc	r15, r1

        if (!standaloneMode && (loopCount == 0)) { 
    1846:	80 91 89 02 	lds	r24, 0x0289
    184a:	88 23       	and	r24, r24
    184c:	09 f0       	breq	.+2      	; 0x1850 <main+0x76>
    184e:	95 c0       	rjmp	.+298    	; 0x197a <main+0x1a0>
    1850:	e1 14       	cp	r14, r1
    1852:	f1 04       	cpc	r15, r1
    1854:	09 f0       	breq	.+2      	; 0x1858 <main+0x7e>
    1856:	91 c0       	rjmp	.+290    	; 0x197a <main+0x1a0>
            //If we are not in standalone mode, periodically check if we have just entered it
            byte mode = standaloneModeTest();
    1858:	0e 94 12 01 	call	0x224	; 0x224 <standaloneModeTest>
    185c:	18 2f       	mov	r17, r24
            if (mode != EQMOD_MODE) {
    185e:	88 23       	and	r24, r24
    1860:	09 f4       	brne	.+2      	; 0x1864 <main+0x8a>
    1862:	8b c0       	rjmp	.+278    	; 0x197a <main+0x1a0>
                //If we have just entered stand-alone mode, then we enable the motors and configure the mount
                motorStop(RA, true); //Ensure both motors are stopped
    1864:	80 e0       	ldi	r24, 0x00	; 0
    1866:	61 e0       	ldi	r22, 0x01	; 1
    1868:	0e 94 b1 03 	call	0x762	; 0x762 <motorStop>
                motorStop(DC, true);
    186c:	81 e0       	ldi	r24, 0x01	; 1
    186e:	61 e0       	ldi	r22, 0x01	; 1
    1870:	0e 94 b1 03 	call	0x762	; 0x762 <motorStop>
                
                //This next bit needs to be atomic
                byte oldSREG = SREG; 
    1874:	8f b7       	in	r24, 0x3f	; 63
                cli();  
    1876:	f8 94       	cli
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
    1878:	40 92 16 03 	sts	0x0316, r4
    187c:	50 92 17 03 	sts	0x0317, r5
    1880:	60 92 18 03 	sts	0x0318, r6
    1884:	70 92 19 03 	sts	0x0319, r7
                cmd_setjVal(RA, 0x800000); //set the current position to the middle
                cmd_setjVal(DC, 0x800000); //set the current position to the middle
                SREG = oldSREG;
    1888:	40 92 1a 03 	sts	0x031A, r4
    188c:	50 92 1b 03 	sts	0x031B, r5
    1890:	60 92 1c 03 	sts	0x031C, r6
    1894:	70 92 1d 03 	sts	0x031D, r7
    1898:	8f bf       	out	0x3f, r24	; 63
                //End atomic
                //Disable Serial
                Serial_disable();
    189a:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <_Z14Serial_disablev>
    
                //We are now in standalone mode.
                standaloneMode = true; 
    189e:	81 e0       	ldi	r24, 0x01	; 1
    18a0:	80 93 89 02 	sts	0x0289, r24
                
                //Next check what type of hand controller we have
                if (mode == ADVANCED_HC_MODE) {
    18a4:	12 30       	cpi	r17, 0x02	; 2
    18a6:	81 f4       	brne	.+32     	; 0x18c8 <main+0xee>
                    //We pulled low, but pin stayed high
                    //This means we must have an advanced controller actively pulling the line high
                    syntaMode = true; 
    18a8:	80 93 08 02 	sts	0x0208, r24
                    
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    18ac:	0e 94 02 12 	call	0x2404	; 0x2404 <_Z14SPI_initialisev>
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
    18b0:	c1 01       	movw	r24, r2
    18b2:	60 e0       	ldi	r22, 0x00	; 0
    18b4:	20 e0       	ldi	r18, 0x00	; 0
    18b6:	30 e0       	ldi	r19, 0x00	; 0
    18b8:	40 e0       	ldi	r20, 0x00	; 0
    18ba:	50 e0       	ldi	r21, 0x00	; 0
    18bc:	0e 94 c4 13 	call	0x2788	; 0x2788 <_Z22synta_assembleResponsePccm>
                    Serial_writeStr(welcome); //Send error packet to trigger controller state machine.
    18c0:	c1 01       	movw	r24, r2
    18c2:	0e 94 c6 12 	call	0x258c	; 0x258c <_Z15Serial_writeStrPc>
    18c6:	59 c0       	rjmp	.+178    	; 0x197a <main+0x1a0>
                    
                } else {
                    //Pin either is being pulled low by us or by something else
                    //This means we might have a basic controller actively pulling the line low
                    //Even if we don't we would default to basic mode.
                    syntaMode = false;
    18c8:	10 92 08 02 	sts	0x0208, r1
                    
                    //High speed not supported in Basic HC
                    canJumpToHighspeed = false;
    18cc:	10 92 0a 03 	sts	0x030A, r1
                    
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    18d0:	11 9a       	sbi	0x02, 1	; 2
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    18d2:	e0 91 0b 03 	lds	r30, 0x030B
    18d6:	f0 e0       	ldi	r31, 0x00	; 0
    18d8:	e7 5f       	subi	r30, 0xF7	; 247
    18da:	fd 4f       	sbci	r31, 0xFD	; 253
    18dc:	80 81       	ld	r24, Z
    18de:	98 2f       	mov	r25, r24
    18e0:	80 ff       	sbrs	r24, 0
    18e2:	07 c0       	rjmp	.+14     	; 0x18f2 <main+0x118>
    18e4:	80 91 05 01 	lds	r24, 0x0105
    18e8:	81 60       	ori	r24, 0x01	; 1
    18ea:	80 93 05 01 	sts	0x0105, r24
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    18ee:	59 9a       	sbi	0x0b, 1	; 11
    18f0:	06 c0       	rjmp	.+12     	; 0x18fe <main+0x124>
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    18f2:	80 91 05 01 	lds	r24, 0x0105
    18f6:	8e 7f       	andi	r24, 0xFE	; 254
    18f8:	80 93 05 01 	sts	0x0105, r24
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    18fc:	59 98       	cbi	0x0b, 1	; 11
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    18fe:	91 ff       	sbrs	r25, 1
    1900:	07 c0       	rjmp	.+14     	; 0x1910 <main+0x136>
    1902:	80 91 02 01 	lds	r24, 0x0102
    1906:	82 60       	ori	r24, 0x02	; 2
    1908:	80 93 02 01 	sts	0x0102, r24
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    190c:	5a 9a       	sbi	0x0b, 2	; 11
    190e:	06 c0       	rjmp	.+12     	; 0x191c <main+0x142>
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    1910:	80 91 02 01 	lds	r24, 0x0102
    1914:	8d 7f       	andi	r24, 0xFD	; 253
    1916:	80 93 02 01 	sts	0x0102, r24
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    191a:	5a 98       	cbi	0x0b, 2	; 11
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    191c:	92 ff       	sbrs	r25, 2
    191e:	07 c0       	rjmp	.+14     	; 0x192e <main+0x154>
    1920:	80 91 02 01 	lds	r24, 0x0102
    1924:	81 60       	ori	r24, 0x01	; 1
    1926:	80 93 02 01 	sts	0x0102, r24
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    192a:	5b 9a       	sbi	0x0b, 3	; 11
    192c:	06 c0       	rjmp	.+12     	; 0x193a <main+0x160>
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    192e:	80 91 02 01 	lds	r24, 0x0102
    1932:	8e 7f       	andi	r24, 0xFE	; 254
    1934:	80 93 02 01 	sts	0x0102, r24
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    1938:	5b 98       	cbi	0x0b, 3	; 11
                    
                    Commands_configureST4Speed(CMD_ST4_DEFAULT); //Change the ST4 speeds to default
    193a:	80 e0       	ldi	r24, 0x00	; 0
    193c:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <_Z26Commands_configureST4Speedh>
                    
                    motorEnable(RA); //Ensure the motors are enabled
    1940:	80 e0       	ldi	r24, 0x00	; 0
    1942:	0e 94 3a 01 	call	0x274	; 0x274 <motorEnable>
                    motorEnable(DC);
    1946:	81 e0       	ldi	r24, 0x01	; 1
    1948:	0e 94 3a 01 	call	0x274	; 0x274 <motorEnable>
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
    194c:	21 e0       	ldi	r18, 0x01	; 1
    194e:	20 93 26 03 	sts	0x0326, r18
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1952:	20 93 27 03 	sts	0x0327, r18
    1956:	10 92 32 03 	sts	0x0332, r1

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    195a:	20 93 30 03 	sts	0x0330, r18
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    195e:	10 92 33 03 	sts	0x0333, r1

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1962:	20 93 30 03 	sts	0x0330, r18
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1966:	80 91 69 03 	lds	r24, 0x0369
    196a:	90 91 6a 03 	lds	r25, 0x036A
    196e:	90 93 1f 03 	sts	0x031F, r25
    1972:	80 93 1e 03 	sts	0x031E, r24
                    cmd_updateStepDir(RA ,1);
                    cmd_setDir       (DC, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA,1);
                    cmd_setIVal      (RA, cmd.siderealIVal[RA]); //Set RA speed to sidereal
                    
                    readyToGo[RA] = 1; //Signal we are ready to go on the RA axis to start sideral tracking
    1976:	20 93 7a 02 	sts	0x027A, r18
            }
            //If we end up in standalone mode, we don't exit until a reset.
        }

        /////////////
        if (syntaMode) {
    197a:	80 91 08 02 	lds	r24, 0x0208
    197e:	88 23       	and	r24, r24
    1980:	09 f4       	brne	.+2      	; 0x1984 <main+0x1aa>
    1982:	65 c1       	rjmp	.+714    	; 0x1c4e <main+0x474>
        //
        // EQMOD or Advanced Hand Controller Synta Mode
        //
            //Check if we need to run the command parser
            
            if ((decoded == -2) || Serial_available()) { //is there a byte in buffer or we still need to process the previous byte?
    1984:	0e 3f       	cpi	r16, 0xFE	; 254
    1986:	21 f0       	breq	.+8      	; 0x1990 <main+0x1b6>
    1988:	0e 94 65 12 	call	0x24ca	; 0x24ca <_Z16Serial_availablev>
    198c:	88 23       	and	r24, r24
    198e:	71 f1       	breq	.+92     	; 0x19ec <main+0x212>
                //Toggle on the LED to indicate activity.
                togglePin(statusPin);
    1990:	85 b1       	in	r24, 0x05	; 5
    1992:	80 58       	subi	r24, 0x80	; 128
    1994:	85 b9       	out	0x05, r24	; 5
                //See what character we need to parse
                if (decoded != -2) {
    1996:	0e 3f       	cpi	r16, 0xFE	; 254
    1998:	19 f0       	breq	.+6      	; 0x19a0 <main+0x1c6>
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
    199a:	0e 94 72 12 	call	0x24e4	; 0x24e4 <_Z11Serial_readv>
    199e:	a8 2e       	mov	r10, r24
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
    19a0:	c4 01       	movw	r24, r8
    19a2:	6a 2d       	mov	r22, r10
    19a4:	0e 94 82 13 	call	0x2704	; 0x2704 <_Z20synta_recieveCommandPcc>
    19a8:	08 2f       	mov	r16, r24
                //Once full command packet recieved, synta_recieveCommand populates either an error packet (and returns -1), or data packet (returns 1). If incomplete, decodedPacket is unchanged and 0 is returned
                if (decoded != 0){ //Send a response
    19aa:	88 23       	and	r24, r24
    19ac:	f9 f0       	breq	.+62     	; 0x19ec <main+0x212>
                    if (decoded > 0){ //Valid Packet, current command is in decoded variable.
    19ae:	18 16       	cp	r1, r24
    19b0:	14 f0       	brlt	.+4      	; 0x19b6 <main+0x1dc>
    19b2:	10 e0       	ldi	r17, 0x00	; 0
    19b4:	05 c0       	rjmp	.+10     	; 0x19c0 <main+0x1e6>
                        mcuReset = !decodeCommand(decoded,decodedPacket); //decode the valid packet and populate response.
    19b6:	b4 01       	movw	r22, r8
    19b8:	0e 94 c6 06 	call	0xd8c	; 0xd8c <decodeCommand>
    19bc:	11 e0       	ldi	r17, 0x01	; 1
    19be:	18 27       	eor	r17, r24
                    }
                    Serial_writeStr(decodedPacket); //send the response packet (recieveCommand() generated the error packet, or decodeCommand() a valid response)
    19c0:	c4 01       	movw	r24, r8
    19c2:	0e 94 c6 12 	call	0x258c	; 0x258c <_Z15Serial_writeStrPc>
                } //otherwise command not yet fully recieved, so wait for next byte
                
                if (mcuReset) {
    19c6:	11 23       	and	r17, r17
    19c8:	89 f0       	breq	.+34     	; 0x19ec <main+0x212>
                    //Special case. We were asked to reset the MCU.
                    Serial_flush(); //Flush out last response.
    19ca:	0e 94 b0 12 	call	0x2560	; 0x2560 <_Z12Serial_flushv>
                    wdt_enable(WDTO_120MS); //WDT has been set to reset MCU.
    19ce:	2b e0       	ldi	r18, 0x0B	; 11
    19d0:	88 e1       	ldi	r24, 0x18	; 24
    19d2:	90 e0       	ldi	r25, 0x00	; 0
    19d4:	0f b6       	in	r0, 0x3f	; 63
    19d6:	f8 94       	cli
    19d8:	a8 95       	wdr
    19da:	80 93 60 00 	sts	0x0060, r24
    19de:	0f be       	out	0x3f, r0	; 63
    19e0:	20 93 60 00 	sts	0x0060, r18
                    exit(0); //Done
    19e4:	80 e0       	ldi	r24, 0x00	; 0
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <_exit>
                }
            }
            if (loopCount == 0) {
    19ec:	e1 14       	cp	r14, r1
    19ee:	f1 04       	cpc	r15, r1
    19f0:	09 f4       	brne	.+2      	; 0x19f4 <main+0x21a>
                setPinValue(statusPin, 0);
    19f2:	2f 98       	cbi	0x05, 7	; 5
            }
            
            //
            //ST4 button handling
            //
            if (!standaloneMode && ((loopCount & 0xFF) == 0)){
    19f4:	80 91 89 02 	lds	r24, 0x0289
    19f8:	88 23       	and	r24, r24
    19fa:	09 f0       	breq	.+2      	; 0x19fe <main+0x224>
    19fc:	62 c0       	rjmp	.+196    	; 0x1ac2 <main+0x2e8>
    19fe:	ee 20       	and	r14, r14
    1a00:	09 f0       	breq	.+2      	; 0x1a04 <main+0x22a>
    1a02:	5f c0       	rjmp	.+190    	; 0x1ac2 <main+0x2e8>
                //We only check the ST-4 buttons in EQMOD mode when not doing Go-To, and only every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //In Synta mode, we only allow the ST-4 port to move forward, and only if EQMOD has configured us previously to be in tracking mode
                    if ((cmd.dir[RA] == CMD_FORWARD) && (readyToGo[RA] == 2)) {
    1a04:	80 91 32 03 	lds	r24, 0x0332
    1a08:	88 23       	and	r24, r24
    1a0a:	b9 f4       	brne	.+46     	; 0x1a3a <main+0x260>
    1a0c:	80 91 7a 02 	lds	r24, 0x027A
    1a10:	82 30       	cpi	r24, 0x02	; 2
    1a12:	99 f4       	brne	.+38     	; 0x1a3a <main+0x260>
                        //Determine which ST4 pin if any
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    1a14:	19 99       	sbic	0x03, 1	; 3
    1a16:	02 c0       	rjmp	.+4      	; 0x1a1c <main+0x242>
    1a18:	e1 e0       	ldi	r30, 0x01	; 1
    1a1a:	c6 c1       	rjmp	.+908    	; 0x1da8 <main+0x5ce>
    1a1c:	1a 9b       	sbis	0x03, 2	; 3
    1a1e:	c3 c1       	rjmp	.+902    	; 0x1da6 <main+0x5cc>
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
                            isST4Move[RA] = true; //Now doing ST4 movement
                        }
                        else if (isST4Move[RA]) { 
    1a20:	bb 20       	and	r11, r11
    1a22:	59 f0       	breq	.+22     	; 0x1a3a <main+0x260>
    1a24:	80 91 69 03 	lds	r24, 0x0369
    1a28:	90 91 6a 03 	lds	r25, 0x036A
    1a2c:	90 93 1f 03 	sts	0x031F, r25
    1a30:	80 93 1e 03 	sts	0x031E, r24
                            //Only return to sidereal speed if we are in an ST4 move.
                            cmd_setIVal(RA,cmd.siderealIVal[RA]);
                            motorStartRA();
    1a34:	0e 94 65 01 	call	0x2ca	; 0x2ca <motorStartRA>
    1a38:	bb 24       	eor	r11, r11
                            isST4Move[RA] = false; //No longer ST4 movement
                        }
                    }
                }//End RA
                
                if (!cmd.gotoEn[DC]) {//Start DEC
    1a3a:	80 91 37 03 	lds	r24, 0x0337
    1a3e:	88 23       	and	r24, r24
    1a40:	09 f0       	breq	.+2      	; 0x1a44 <main+0x26a>
    1a42:	3f c0       	rjmp	.+126    	; 0x1ac2 <main+0x2e8>
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    1a44:	19 99       	sbic	0x03, 1	; 3
    1a46:	03 c0       	rjmp	.+6      	; 0x1a4e <main+0x274>
    1a48:	51 e0       	ldi	r21, 0x01	; 1
    1a4a:	41 e0       	ldi	r20, 0x01	; 1
    1a4c:	06 c0       	rjmp	.+12     	; 0x1a5a <main+0x280>
    1a4e:	1a 9b       	sbis	0x03, 2	; 3
    1a50:	02 c0       	rjmp	.+4      	; 0x1a56 <main+0x27c>
    1a52:	4f ef       	ldi	r20, 0xFF	; 255
    1a54:	01 c0       	rjmp	.+2      	; 0x1a58 <main+0x27e>
    1a56:	40 e0       	ldi	r20, 0x00	; 0
    1a58:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir)) {
    1a5a:	80 91 39 03 	lds	r24, 0x0339
    1a5e:	88 23       	and	r24, r24
    1a60:	71 f4       	brne	.+28     	; 0x1a7e <main+0x2a4>
    1a62:	80 91 33 03 	lds	r24, 0x0333
    1a66:	90 e0       	ldi	r25, 0x00	; 0
    1a68:	25 2f       	mov	r18, r21
    1a6a:	30 e0       	ldi	r19, 0x00	; 0
    1a6c:	82 17       	cp	r24, r18
    1a6e:	93 07       	cpc	r25, r19
    1a70:	31 f0       	breq	.+12     	; 0x1a7e <main+0x2a4>
                        //If we are currently moving in the wrong direction
                        motorStopDC(false); //Stop the Dec motor
    1a72:	80 e0       	ldi	r24, 0x00	; 0
    1a74:	0e 94 6e 03 	call	0x6dc	; 0x6dc <motorStopDC>
                        readyToGo[DC]=0;    //No longer ready to go as we have now deleted any pre-running EQMOD movement.
    1a78:	10 92 7b 02 	sts	0x027B, r1
    1a7c:	22 c0       	rjmp	.+68     	; 0x1ac2 <main+0x2e8>
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
    1a7e:	4f 3f       	cpi	r20, 0xFF	; 255
    1a80:	d1 f0       	breq	.+52     	; 0x1ab6 <main+0x2dc>
    1a82:	80 91 65 03 	lds	r24, 0x0365
    1a86:	90 91 66 03 	lds	r25, 0x0366
    1a8a:	90 93 21 03 	sts	0x0321, r25
    1a8e:	80 93 20 03 	sts	0x0320, r24
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
    1a92:	25 2f       	mov	r18, r21
    1a94:	51 11       	cpse	r21, r1
    1a96:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1a98:	20 93 33 03 	sts	0x0333, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1a9c:	22 23       	and	r18, r18
    1a9e:	19 f0       	breq	.+6      	; 0x1aa6 <main+0x2cc>
        cmd.stepDir[target] = -stepSize; //set step direction
    1aa0:	d0 92 31 03 	sts	0x0331, r13
    1aa4:	03 c0       	rjmp	.+6      	; 0x1aac <main+0x2d2>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1aa6:	81 e0       	ldi	r24, 0x01	; 1
    1aa8:	80 93 31 03 	sts	0x0331, r24
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
    1aac:	0e 94 d7 01 	call	0x3ae	; 0x3ae <motorStartDC>
    1ab0:	cc 24       	eor	r12, r12
    1ab2:	c3 94       	inc	r12
    1ab4:	06 c0       	rjmp	.+12     	; 0x1ac2 <main+0x2e8>
                            isST4Move[DC] = true; //Now doing ST4 movement
                        } else if (isST4Move[DC]) {
    1ab6:	cc 20       	and	r12, r12
    1ab8:	21 f0       	breq	.+8      	; 0x1ac2 <main+0x2e8>
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
    1aba:	80 e0       	ldi	r24, 0x00	; 0
    1abc:	0e 94 6e 03 	call	0x6dc	; 0x6dc <motorStopDC>
    1ac0:	cc 24       	eor	r12, r12
                    }
                }//End DEC
            }
            
            //Check both axes - loop unravelled for speed efficiency - lots of Flash available.
            if(readyToGo[RA]==1){
    1ac2:	90 91 7a 02 	lds	r25, 0x027A
    1ac6:	91 30       	cpi	r25, 0x01	; 1
    1ac8:	09 f0       	breq	.+2      	; 0x1acc <main+0x2f2>
    1aca:	67 c0       	rjmp	.+206    	; 0x1b9a <main+0x3c0>
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[RA] == CMD_STOPPED){
    1acc:	80 91 38 03 	lds	r24, 0x0338
    1ad0:	88 23       	and	r24, r24
    1ad2:	09 f4       	brne	.+2      	; 0x1ad6 <main+0x2fc>
    1ad4:	62 c0       	rjmp	.+196    	; 0x1b9a <main+0x3c0>
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[RA];
    1ad6:	30 91 26 03 	lds	r19, 0x0326
                    if (canJumpToHighspeed){
    1ada:	80 91 0a 03 	lds	r24, 0x030A
    1ade:	88 23       	and	r24, r24
    1ae0:	09 f4       	brne	.+2      	; 0x1ae4 <main+0x30a>
    1ae2:	42 c0       	rjmp	.+132    	; 0x1b68 <main+0x38e>
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
    1ae4:	83 2f       	mov	r24, r19
    1ae6:	81 50       	subi	r24, 0x01	; 1
    1ae8:	82 30       	cpi	r24, 0x02	; 2
    1aea:	70 f4       	brcc	.+28     	; 0x1b08 <main+0x32e>
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
    1aec:	20 91 09 02 	lds	r18, 0x0209
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1af0:	80 91 32 03 	lds	r24, 0x0332
    1af4:	88 23       	and	r24, r24
    1af6:	19 f0       	breq	.+6      	; 0x1afe <main+0x324>
        cmd.stepDir[target] = -stepSize; //set step direction
    1af8:	d0 92 30 03 	sts	0x0330, r13
    1afc:	02 c0       	rjmp	.+4      	; 0x1b02 <main+0x328>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1afe:	90 93 30 03 	sts	0x0330, r25
                            cmd_updateStepDir(RA,1);
                            cmd.highSpeedMode[RA] = false;
    1b02:	10 92 3a 03 	sts	0x033A, r1
    1b06:	0d c0       	rjmp	.+26     	; 0x1b22 <main+0x348>
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
    1b08:	20 91 0a 02 	lds	r18, 0x020A
                            cmd_updateStepDir(RA,cmd.gVal[RA]);
    1b0c:	90 91 54 03 	lds	r25, 0x0354
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1b10:	80 91 32 03 	lds	r24, 0x0332
    1b14:	81 11       	cpse	r24, r1
        cmd.stepDir[target] = -stepSize; //set step direction
    1b16:	91 95       	neg	r25
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1b18:	90 93 30 03 	sts	0x0330, r25
                            cmd.highSpeedMode[RA] = true;
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
    1b1e:	80 93 3a 03 	sts	0x033A, r24
                        }
                        setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0)));
    1b22:	92 2f       	mov	r25, r18
    1b24:	20 ff       	sbrs	r18, 0
    1b26:	04 c0       	rjmp	.+8      	; 0x1b30 <main+0x356>
    1b28:	80 91 05 01 	lds	r24, 0x0105
    1b2c:	81 60       	ori	r24, 0x01	; 1
    1b2e:	03 c0       	rjmp	.+6      	; 0x1b36 <main+0x35c>
    1b30:	80 91 05 01 	lds	r24, 0x0105
    1b34:	8e 7f       	andi	r24, 0xFE	; 254
    1b36:	80 93 05 01 	sts	0x0105, r24
                        setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1)));
    1b3a:	91 ff       	sbrs	r25, 1
    1b3c:	04 c0       	rjmp	.+8      	; 0x1b46 <main+0x36c>
    1b3e:	80 91 02 01 	lds	r24, 0x0102
    1b42:	82 60       	ori	r24, 0x02	; 2
    1b44:	03 c0       	rjmp	.+6      	; 0x1b4c <main+0x372>
    1b46:	80 91 02 01 	lds	r24, 0x0102
    1b4a:	8d 7f       	andi	r24, 0xFD	; 253
    1b4c:	80 93 02 01 	sts	0x0102, r24
                        setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2)));
    1b50:	92 ff       	sbrs	r25, 2
    1b52:	04 c0       	rjmp	.+8      	; 0x1b5c <main+0x382>
    1b54:	80 91 02 01 	lds	r24, 0x0102
    1b58:	81 60       	ori	r24, 0x01	; 1
    1b5a:	03 c0       	rjmp	.+6      	; 0x1b62 <main+0x388>
    1b5c:	80 91 02 01 	lds	r24, 0x0102
    1b60:	8e 7f       	andi	r24, 0xFE	; 254
    1b62:	80 93 02 01 	sts	0x0102, r24
    1b66:	0b c0       	rjmp	.+22     	; 0x1b7e <main+0x3a4>
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1b68:	80 91 32 03 	lds	r24, 0x0332
    1b6c:	88 23       	and	r24, r24
    1b6e:	19 f0       	breq	.+6      	; 0x1b76 <main+0x39c>
        cmd.stepDir[target] = -stepSize; //set step direction
    1b70:	d0 92 30 03 	sts	0x0330, r13
    1b74:	02 c0       	rjmp	.+4      	; 0x1b7a <main+0x3a0>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1b76:	90 93 30 03 	sts	0x0330, r25
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(RA,1); //Just move along at one step per step
                        cmd.highSpeedMode[RA] = false;
    1b7a:	10 92 3a 03 	sts	0x033A, r1
                    }
                    if(GVal & 1){
    1b7e:	30 ff       	sbrs	r19, 0
    1b80:	07 c0       	rjmp	.+14     	; 0x1b90 <main+0x3b6>
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	0e 94 4f 02 	call	0x49e	; 0x49e <motorStart>
                        cmd.highSpeedMode[RA] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(RA); //Slew type
                        readyToGo[RA] = 2;
    1b88:	82 e0       	ldi	r24, 0x02	; 2
    1b8a:	80 93 7a 02 	sts	0x027A, r24
    1b8e:	05 c0       	rjmp	.+10     	; 0x1b9a <main+0x3c0>
                    } else {
                        //This is the function for goto mode. You may need to customise it for a different motor driver
                        gotoMode(RA); //Goto Mode
    1b90:	80 e0       	ldi	r24, 0x00	; 0
    1b92:	0e 94 57 02 	call	0x4ae	; 0x4ae <gotoMode>
                        readyToGo[RA] = 0;
    1b96:	10 92 7a 02 	sts	0x027A, r1
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
            if(readyToGo[DC]==1){
    1b9a:	90 91 7b 02 	lds	r25, 0x027B
    1b9e:	91 30       	cpi	r25, 0x01	; 1
    1ba0:	09 f0       	breq	.+2      	; 0x1ba4 <main+0x3ca>
    1ba2:	4e ce       	rjmp	.-868    	; 0x1840 <main+0x66>
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[DC] == CMD_STOPPED){
    1ba4:	80 91 39 03 	lds	r24, 0x0339
    1ba8:	88 23       	and	r24, r24
    1baa:	09 f4       	brne	.+2      	; 0x1bae <main+0x3d4>
    1bac:	49 ce       	rjmp	.-878    	; 0x1840 <main+0x66>
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[DC];
    1bae:	30 91 27 03 	lds	r19, 0x0327
                    if (canJumpToHighspeed){
    1bb2:	80 91 0a 03 	lds	r24, 0x030A
    1bb6:	88 23       	and	r24, r24
    1bb8:	81 f1       	breq	.+96     	; 0x1c1a <main+0x440>
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
    1bba:	83 2f       	mov	r24, r19
    1bbc:	81 50       	subi	r24, 0x01	; 1
    1bbe:	82 30       	cpi	r24, 0x02	; 2
    1bc0:	70 f4       	brcc	.+28     	; 0x1bde <main+0x404>
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
    1bc2:	20 91 09 02 	lds	r18, 0x0209
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1bc6:	80 91 33 03 	lds	r24, 0x0333
    1bca:	88 23       	and	r24, r24
    1bcc:	19 f0       	breq	.+6      	; 0x1bd4 <main+0x3fa>
        cmd.stepDir[target] = -stepSize; //set step direction
    1bce:	d0 92 31 03 	sts	0x0331, r13
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <main+0x3fe>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1bd4:	90 93 31 03 	sts	0x0331, r25
                            cmd_updateStepDir(DC,1);
                            cmd.highSpeedMode[DC] = false;
    1bd8:	10 92 3b 03 	sts	0x033B, r1
    1bdc:	0d c0       	rjmp	.+26     	; 0x1bf8 <main+0x41e>
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
    1bde:	20 91 0a 02 	lds	r18, 0x020A
                            cmd_updateStepDir(DC,cmd.gVal[DC]);
    1be2:	90 91 55 03 	lds	r25, 0x0355
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1be6:	80 91 33 03 	lds	r24, 0x0333
    1bea:	81 11       	cpse	r24, r1
        cmd.stepDir[target] = -stepSize; //set step direction
    1bec:	91 95       	neg	r25
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1bee:	90 93 31 03 	sts	0x0331, r25
                            cmd.highSpeedMode[DC] = true;
    1bf2:	81 e0       	ldi	r24, 0x01	; 1
    1bf4:	80 93 3b 03 	sts	0x033B, r24
                        }
                        setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0)));
    1bf8:	82 2f       	mov	r24, r18
    1bfa:	20 ff       	sbrs	r18, 0
    1bfc:	02 c0       	rjmp	.+4      	; 0x1c02 <main+0x428>
    1bfe:	59 9a       	sbi	0x0b, 1	; 11
    1c00:	01 c0       	rjmp	.+2      	; 0x1c04 <main+0x42a>
    1c02:	59 98       	cbi	0x0b, 1	; 11
                        setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1)));
    1c04:	81 ff       	sbrs	r24, 1
    1c06:	02 c0       	rjmp	.+4      	; 0x1c0c <main+0x432>
    1c08:	5a 9a       	sbi	0x0b, 2	; 11
    1c0a:	01 c0       	rjmp	.+2      	; 0x1c0e <main+0x434>
    1c0c:	5a 98       	cbi	0x0b, 2	; 11
                        setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2)));
    1c0e:	82 ff       	sbrs	r24, 2
    1c10:	02 c0       	rjmp	.+4      	; 0x1c16 <main+0x43c>
    1c12:	5b 9a       	sbi	0x0b, 3	; 11
    1c14:	0d c0       	rjmp	.+26     	; 0x1c30 <main+0x456>
    1c16:	5b 98       	cbi	0x0b, 3	; 11
    1c18:	0b c0       	rjmp	.+22     	; 0x1c30 <main+0x456>
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1c1a:	80 91 33 03 	lds	r24, 0x0333
    1c1e:	88 23       	and	r24, r24
    1c20:	19 f0       	breq	.+6      	; 0x1c28 <main+0x44e>
        cmd.stepDir[target] = -stepSize; //set step direction
    1c22:	d0 92 31 03 	sts	0x0331, r13
    1c26:	02 c0       	rjmp	.+4      	; 0x1c2c <main+0x452>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1c28:	90 93 31 03 	sts	0x0331, r25
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(DC,1); //Just move along at one step per step
                        cmd.highSpeedMode[DC] = false;
    1c2c:	10 92 3b 03 	sts	0x033B, r1
                    }
                    if(GVal & 1){
    1c30:	30 ff       	sbrs	r19, 0
    1c32:	07 c0       	rjmp	.+14     	; 0x1c42 <main+0x468>
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	0e 94 4f 02 	call	0x49e	; 0x49e <motorStart>
                        cmd.highSpeedMode[DC] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(DC); //Slew type
                        readyToGo[DC] = 2; //We are now in a running mode which speed can be changed without stopping motor (unless a command changes the direction)
    1c3a:	82 e0       	ldi	r24, 0x02	; 2
    1c3c:	80 93 7b 02 	sts	0x027B, r24
    1c40:	ff cd       	rjmp	.-1026   	; 0x1840 <main+0x66>
                    } else {
                        //This is the function for goto mode.
                        gotoMode(DC); //Goto Mode
    1c42:	81 e0       	ldi	r24, 0x01	; 1
    1c44:	0e 94 57 02 	call	0x4ae	; 0x4ae <gotoMode>
                        readyToGo[DC] = 0; //We are now in a mode where no further changes can be made to the motor (apart from requesting a stop) until the go-to movement is done.
    1c48:	10 92 7b 02 	sts	0x027B, r1
    1c4c:	f9 cd       	rjmp	.-1038   	; 0x1840 <main+0x66>
        //////////
        } else {
        //
        // ST4 Basic Hand Controller Mode
        //
            if (loopCount == 0) {
    1c4e:	e1 14       	cp	r14, r1
    1c50:	f1 04       	cpc	r15, r1
    1c52:	71 f4       	brne	.+28     	; 0x1c70 <main+0x496>
                //we run these checks every so often, not all the time.
                
                //Update status LED
                togglePin(statusPin); //Toggle status pin at roughly constant rate in basic mode as indicator
    1c54:	85 b1       	in	r24, 0x05	; 5
    1c56:	80 58       	subi	r24, 0x80	; 128
    1c58:	85 b9       	out	0x05, r24	; 5
                
                //Check the speed
                byte newBasicHCSpeed = checkBasicHCSpeed();
    1c5a:	0e 94 28 01 	call	0x250	; 0x250 <_Z17checkBasicHCSpeedv>
    1c5e:	98 2f       	mov	r25, r24
                if (newBasicHCSpeed != cmd.st4Mode) {
    1c60:	80 91 5e 03 	lds	r24, 0x035E
    1c64:	98 17       	cp	r25, r24
    1c66:	39 f0       	breq	.+14     	; 0x1c76 <main+0x49c>
                    //Only update speed if changed.
                    Commands_configureST4Speed(newBasicHCSpeed); //Change the ST4 speeds
    1c68:	89 2f       	mov	r24, r25
    1c6a:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <_Z26Commands_configureST4Speedh>
    1c6e:	03 c0       	rjmp	.+6      	; 0x1c76 <main+0x49c>
            }
            
            //
            //NESW button handling - uses ST4 pins
            //
            if ((loopCount & 0xFF) == 0){
    1c70:	ee 20       	and	r14, r14
    1c72:	09 f0       	breq	.+2      	; 0x1c76 <main+0x49c>
    1c74:	e5 cd       	rjmp	.-1078   	; 0x1840 <main+0x66>
                //We only check the buttons every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
    1c76:	18 9b       	sbis	0x03, 0	; 3
    1c78:	aa c0       	rjmp	.+340    	; 0x1dce <main+0x5f4>
    1c7a:	1b 9b       	sbis	0x03, 3	; 3
    1c7c:	02 c0       	rjmp	.+4      	; 0x1c82 <main+0x4a8>
    1c7e:	4f ef       	ldi	r20, 0xFF	; 255
    1c80:	01 c0       	rjmp	.+2      	; 0x1c84 <main+0x4aa>
    1c82:	40 e0       	ldi	r20, 0x00	; 0
    1c84:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
    1c86:	1f b7       	in	r17, 0x3f	; 63
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
    1c88:	f8 94       	cli
                    if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] != dir) && (currentMotorSpeed(RA) < cmd.minSpeed[RA])) {
    1c8a:	80 91 38 03 	lds	r24, 0x0338
    1c8e:	88 23       	and	r24, r24
    1c90:	09 f0       	breq	.+2      	; 0x1c94 <main+0x4ba>
    1c92:	a6 c0       	rjmp	.+332    	; 0x1de0 <main+0x606>
    1c94:	80 91 32 03 	lds	r24, 0x0332
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	25 2f       	mov	r18, r21
    1c9c:	30 e0       	ldi	r19, 0x00	; 0
    1c9e:	82 17       	cp	r24, r18
    1ca0:	93 07       	cpc	r25, r19
    1ca2:	09 f4       	brne	.+2      	; 0x1ca6 <main+0x4cc>
    1ca4:	9d c0       	rjmp	.+314    	; 0x1de0 <main+0x606>
    1ca6:	20 91 9a 00 	lds	r18, 0x009A
    1caa:	30 91 9b 00 	lds	r19, 0x009B
    1cae:	80 91 71 03 	lds	r24, 0x0371
    1cb2:	90 91 72 03 	lds	r25, 0x0372
    1cb6:	28 17       	cp	r18, r24
    1cb8:	39 07       	cpc	r19, r25
    1cba:	08 f0       	brcs	.+2      	; 0x1cbe <main+0x4e4>
    1cbc:	91 c0       	rjmp	.+290    	; 0x1de0 <main+0x606>
    1cbe:	27 c0       	rjmp	.+78     	; 0x1d0e <main+0x534>
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
    1cc0:	e0 91 69 03 	lds	r30, 0x0369
    1cc4:	f0 91 6a 03 	lds	r31, 0x036A
    1cc8:	0b c0       	rjmp	.+22     	; 0x1ce0 <main+0x506>
    1cca:	e4 2f       	mov	r30, r20
    1ccc:	ff 27       	eor	r31, r31
    1cce:	e7 fd       	sbrc	r30, 7
    1cd0:	f0 95       	com	r31
    1cd2:	ee 0f       	add	r30, r30
    1cd4:	ff 1f       	adc	r31, r31
    1cd6:	e0 5a       	subi	r30, 0xA0	; 160
    1cd8:	fc 4f       	sbci	r31, 0xFC	; 252
    1cda:	01 90       	ld	r0, Z+
    1cdc:	f0 81       	ld	r31, Z
    1cde:	e0 2d       	mov	r30, r0
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1ce0:	f0 93 1f 03 	sts	0x031F, r31
    1ce4:	e0 93 1e 03 	sts	0x031E, r30
                        cmd_setDir(RA,dir);
    1ce8:	25 2f       	mov	r18, r21
    1cea:	51 11       	cpse	r21, r1
    1cec:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1cee:	20 93 32 03 	sts	0x0332, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1cf2:	22 23       	and	r18, r18
    1cf4:	19 f0       	breq	.+6      	; 0x1cfc <main+0x522>
        cmd.stepDir[target] = -stepSize; //set step direction
    1cf6:	d0 92 30 03 	sts	0x0330, r13
    1cfa:	03 c0       	rjmp	.+6      	; 0x1d02 <main+0x528>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1cfc:	81 e0       	ldi	r24, 0x01	; 1
    1cfe:	80 93 30 03 	sts	0x0330, r24
                        cmd_updateStepDir(RA,1);
                        if ((st4Pin == ST4O) && (cmd.st4Mode == CMD_ST4_HIGHSPEED)) {
    1d02:	4f 3f       	cpi	r20, 0xFF	; 255
    1d04:	41 f4       	brne	.+16     	; 0x1d16 <main+0x53c>
    1d06:	80 91 5e 03 	lds	r24, 0x035E
    1d0a:	82 30       	cpi	r24, 0x02	; 2
    1d0c:	21 f4       	brne	.+8      	; 0x1d16 <main+0x53c>
                            motorStopRA(false); //If no buttons pressed and in high speed mode, we stop entirely rather than going to tracking
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
    1d10:	0e 94 2b 03 	call	0x656	; 0x656 <motorStopRA>
    1d14:	02 c0       	rjmp	.+4      	; 0x1d1a <main+0x540>
                                                //This ensures that the motors stop if the handcontroller is subsequently unplugged.
                        } else {
                            motorStartRA(); //If the motor is currently stopped at this point, this will automatically start them.
    1d16:	0e 94 65 01 	call	0x2ca	; 0x2ca <motorStartRA>
                        }
                    }
                    SREG = oldSREG; //End atomic
    1d1a:	1f bf       	out	0x3f, r17	; 63
                }//End RA
                
                {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    1d1c:	19 99       	sbic	0x03, 1	; 3
    1d1e:	03 c0       	rjmp	.+6      	; 0x1d26 <main+0x54c>
    1d20:	51 e0       	ldi	r21, 0x01	; 1
    1d22:	41 e0       	ldi	r20, 0x01	; 1
    1d24:	06 c0       	rjmp	.+12     	; 0x1d32 <main+0x558>
    1d26:	1a 9b       	sbis	0x03, 2	; 3
    1d28:	02 c0       	rjmp	.+4      	; 0x1d2e <main+0x554>
    1d2a:	4f ef       	ldi	r20, 0xFF	; 255
    1d2c:	01 c0       	rjmp	.+2      	; 0x1d30 <main+0x556>
    1d2e:	40 e0       	ldi	r20, 0x00	; 0
    1d30:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
    1d32:	1f b7       	in	r17, 0x3f	; 63
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
    1d34:	f8 94       	cli
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
    1d36:	80 91 39 03 	lds	r24, 0x0339
    1d3a:	88 23       	and	r24, r24
    1d3c:	09 f0       	breq	.+2      	; 0x1d40 <main+0x566>
    1d3e:	54 c0       	rjmp	.+168    	; 0x1de8 <main+0x60e>
    1d40:	80 91 33 03 	lds	r24, 0x0333
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	25 2f       	mov	r18, r21
    1d48:	30 e0       	ldi	r19, 0x00	; 0
    1d4a:	82 17       	cp	r24, r18
    1d4c:	93 07       	cpc	r25, r19
    1d4e:	09 f4       	brne	.+2      	; 0x1d52 <main+0x578>
    1d50:	4b c0       	rjmp	.+150    	; 0x1de8 <main+0x60e>
    1d52:	20 91 98 00 	lds	r18, 0x0098
    1d56:	30 91 99 00 	lds	r19, 0x0099
    1d5a:	80 91 73 03 	lds	r24, 0x0373
    1d5e:	90 91 74 03 	lds	r25, 0x0374
    1d62:	28 17       	cp	r18, r24
    1d64:	39 07       	cpc	r19, r25
    1d66:	08 f0       	brcs	.+2      	; 0x1d6a <main+0x590>
    1d68:	3f c0       	rjmp	.+126    	; 0x1de8 <main+0x60e>
    1d6a:	18 c0       	rjmp	.+48     	; 0x1d9c <main+0x5c2>
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1d6c:	80 91 65 03 	lds	r24, 0x0365
    1d70:	90 91 66 03 	lds	r25, 0x0366
    1d74:	90 93 21 03 	sts	0x0321, r25
    1d78:	80 93 20 03 	sts	0x0320, r24
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
    1d7c:	25 2f       	mov	r18, r21
    1d7e:	51 11       	cpse	r21, r1
    1d80:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1d82:	20 93 33 03 	sts	0x0333, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1d86:	22 23       	and	r18, r18
    1d88:	19 f0       	breq	.+6      	; 0x1d90 <main+0x5b6>
        cmd.stepDir[target] = -stepSize; //set step direction
    1d8a:	d0 92 31 03 	sts	0x0331, r13
    1d8e:	03 c0       	rjmp	.+6      	; 0x1d96 <main+0x5bc>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1d90:	81 e0       	ldi	r24, 0x01	; 1
    1d92:	80 93 31 03 	sts	0x0331, r24
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
    1d96:	0e 94 d7 01 	call	0x3ae	; 0x3ae <motorStartDC>
    1d9a:	03 c0       	rjmp	.+6      	; 0x1da2 <main+0x5c8>
                        } else {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
    1d9c:	80 e0       	ldi	r24, 0x00	; 0
    1d9e:	0e 94 6e 03 	call	0x6dc	; 0x6dc <motorStopDC>
                        }
                    }
                    SREG = oldSREG; //End atomic
    1da2:	1f bf       	out	0x3f, r17	; 63
    1da4:	4d cd       	rjmp	.-1382   	; 0x1840 <main+0x66>
    1da6:	e0 e0       	ldi	r30, 0x00	; 0
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1da8:	ff 27       	eor	r31, r31
    1daa:	e7 fd       	sbrc	r30, 7
    1dac:	f0 95       	com	r31
    1dae:	b5 96       	adiw	r30, 0x25	; 37
    1db0:	ee 0f       	add	r30, r30
    1db2:	ff 1f       	adc	r31, r31
    1db4:	ea 5e       	subi	r30, 0xEA	; 234
    1db6:	fc 4f       	sbci	r31, 0xFC	; 252
    1db8:	80 81       	ld	r24, Z
    1dba:	91 81       	ldd	r25, Z+1	; 0x01
    1dbc:	90 93 1f 03 	sts	0x031F, r25
    1dc0:	80 93 1e 03 	sts	0x031E, r24
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                        //Update target speed.
                        if (st4Pin != ST4O) {
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
    1dc4:	0e 94 65 01 	call	0x2ca	; 0x2ca <motorStartRA>
    1dc8:	bb 24       	eor	r11, r11
    1dca:	b3 94       	inc	r11
    1dcc:	36 ce       	rjmp	.-916    	; 0x1a3a <main+0x260>
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
    1dce:	80 91 64 03 	lds	r24, 0x0364
    1dd2:	88 23       	and	r24, r24
    1dd4:	11 f0       	breq	.+4      	; 0x1dda <main+0x600>
    1dd6:	51 e0       	ldi	r21, 0x01	; 1
    1dd8:	01 c0       	rjmp	.+2      	; 0x1ddc <main+0x602>
    1dda:	50 e0       	ldi	r21, 0x00	; 0
    1ddc:	41 e0       	ldi	r20, 0x01	; 1
    1dde:	53 cf       	rjmp	.-346    	; 0x1c86 <main+0x4ac>
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
    1de0:	4f 3f       	cpi	r20, 0xFF	; 255
    1de2:	09 f0       	breq	.+2      	; 0x1de6 <main+0x60c>
    1de4:	72 cf       	rjmp	.-284    	; 0x1cca <main+0x4f0>
    1de6:	6c cf       	rjmp	.-296    	; 0x1cc0 <main+0x4e6>
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopDC(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
    1de8:	4f 3f       	cpi	r20, 0xFF	; 255
    1dea:	09 f0       	breq	.+2      	; 0x1dee <main+0x614>
    1dec:	bf cf       	rjmp	.-130    	; 0x1d6c <main+0x592>
    1dee:	d6 cf       	rjmp	.-84     	; 0x1d9c <main+0x5c2>

00001df0 <_Z26Commands_configureST4Speedh>:
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
}

void Commands_configureST4Speed(byte mode) {
    1df0:	0f 93       	push	r16
    1df2:	1f 93       	push	r17
    1df4:	48 2f       	mov	r20, r24
    cmd.st4Mode = mode;
    1df6:	80 93 5e 03 	sts	0x035E, r24
    if (mode == CMD_ST4_HIGHSPEED) {
    1dfa:	82 30       	cpi	r24, 0x02	; 2
    1dfc:	a1 f4       	brne	.+40     	; 0x1e26 <_Z26Commands_configureST4Speedh+0x36>
        //Set the ST4 speeds to highspeed standalone mode (goto speeds)
        cmd.st4RAIVal[ST4P] = cmd.normalGotoSpeed[RA];
    1dfe:	80 91 75 03 	lds	r24, 0x0375
    1e02:	90 91 76 03 	lds	r25, 0x0376
    1e06:	90 93 61 03 	sts	0x0361, r25
    1e0a:	80 93 60 03 	sts	0x0360, r24
        cmd.st4RAIVal[ST4N] = cmd.normalGotoSpeed[RA];
    1e0e:	90 93 63 03 	sts	0x0363, r25
    1e12:	80 93 62 03 	sts	0x0362, r24
        cmd.st4RAReverse    = CMD_REVERSE;
    1e16:	81 e0       	ldi	r24, 0x01	; 1
    1e18:	80 93 64 03 	sts	0x0364, r24
        cmd.st4DecIVal      = cmd.normalGotoSpeed[DC];
    1e1c:	80 91 77 03 	lds	r24, 0x0377
    1e20:	90 91 78 03 	lds	r25, 0x0378
    1e24:	1b c0       	rjmp	.+54     	; 0x1e5c <_Z26Commands_configureST4Speedh+0x6c>
    } else if (mode == CMD_ST4_STANDALONE) {
    1e26:	81 30       	cpi	r24, 0x01	; 1
    1e28:	f1 f4       	brne	.+60     	; 0x1e66 <_Z26Commands_configureST4Speedh+0x76>
        //Set the ST4 speeds to standalone mode (2x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA])/3; //3x speed
    1e2a:	20 91 69 03 	lds	r18, 0x0369
    1e2e:	30 91 6a 03 	lds	r19, 0x036A
    1e32:	c9 01       	movw	r24, r18
    1e34:	63 e0       	ldi	r22, 0x03	; 3
    1e36:	70 e0       	ldi	r23, 0x00	; 0
    1e38:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <__udivmodhi4>
    1e3c:	70 93 61 03 	sts	0x0361, r23
    1e40:	60 93 60 03 	sts	0x0360, r22
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA])  ; //-1x speed
    1e44:	30 93 63 03 	sts	0x0363, r19
    1e48:	20 93 62 03 	sts	0x0362, r18
        cmd.st4RAReverse    = CMD_REVERSE;
    1e4c:	40 93 64 03 	sts	0x0364, r20
        cmd.st4DecIVal      =(cmd.siderealIVal[DC])/2; //2x speed
    1e50:	80 91 6b 03 	lds	r24, 0x036B
    1e54:	90 91 6c 03 	lds	r25, 0x036C
    1e58:	96 95       	lsr	r25
    1e5a:	87 95       	ror	r24
    1e5c:	90 93 66 03 	sts	0x0366, r25
    1e60:	80 93 65 03 	sts	0x0365, r24
    1e64:	3b c0       	rjmp	.+118    	; 0x1edc <_Z26Commands_configureST4Speedh+0xec>
    } else {
        //Set the ST4 speeds to normal mode (0.25x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA] * 20)/(20 + cmd.st4SpeedFactor); //(1+SpeedFactor)x speed   -- Max. IVal = 1200, so this will never overflow.
    1e66:	80 91 69 03 	lds	r24, 0x0369
    1e6a:	90 91 6a 03 	lds	r25, 0x036A
    1e6e:	24 e1       	ldi	r18, 0x14	; 20
    1e70:	30 e0       	ldi	r19, 0x00	; 0
    1e72:	82 9f       	mul	r24, r18
    1e74:	80 01       	movw	r16, r0
    1e76:	83 9f       	mul	r24, r19
    1e78:	10 0d       	add	r17, r0
    1e7a:	92 9f       	mul	r25, r18
    1e7c:	10 0d       	add	r17, r0
    1e7e:	11 24       	eor	r1, r1
    1e80:	40 91 5f 03 	lds	r20, 0x035F
    1e84:	e4 2f       	mov	r30, r20
    1e86:	f0 e0       	ldi	r31, 0x00	; 0
    1e88:	bf 01       	movw	r22, r30
    1e8a:	6c 5e       	subi	r22, 0xEC	; 236
    1e8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1e8e:	c8 01       	movw	r24, r16
    1e90:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <__udivmodhi4>
    1e94:	70 93 61 03 	sts	0x0361, r23
    1e98:	60 93 60 03 	sts	0x0360, r22
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA] * 20)/(20 - cmd.st4SpeedFactor); //(1-SpeedFactor)x speed
    1e9c:	b9 01       	movw	r22, r18
    1e9e:	6e 1b       	sub	r22, r30
    1ea0:	7f 0b       	sbc	r23, r31
    1ea2:	c8 01       	movw	r24, r16
    1ea4:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <__udivmodhi4>
    1ea8:	70 93 63 03 	sts	0x0363, r23
    1eac:	60 93 62 03 	sts	0x0362, r22
        cmd.st4RAReverse    = CMD_FORWARD;
    1eb0:	10 92 64 03 	sts	0x0364, r1
        cmd.st4DecIVal      =(cmd.siderealIVal[DC] * 20)/( 0 + cmd.st4SpeedFactor); //(SpeedFactor)x speed
    1eb4:	80 91 6b 03 	lds	r24, 0x036B
    1eb8:	90 91 6c 03 	lds	r25, 0x036C
    1ebc:	bc 01       	movw	r22, r24
    1ebe:	62 9f       	mul	r22, r18
    1ec0:	c0 01       	movw	r24, r0
    1ec2:	63 9f       	mul	r22, r19
    1ec4:	90 0d       	add	r25, r0
    1ec6:	72 9f       	mul	r23, r18
    1ec8:	90 0d       	add	r25, r0
    1eca:	11 24       	eor	r1, r1
    1ecc:	64 2f       	mov	r22, r20
    1ece:	70 e0       	ldi	r23, 0x00	; 0
    1ed0:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <__udivmodhi4>
    1ed4:	70 93 66 03 	sts	0x0366, r23
    1ed8:	60 93 65 03 	sts	0x0365, r22
    }
}
    1edc:	1f 91       	pop	r17
    1ede:	0f 91       	pop	r16
    1ee0:	08 95       	ret

00001ee2 <_Z18Commands_getLengthcb>:
                                                 {'x', 0, 6},
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    1ee2:	98 2f       	mov	r25, r24
    1ee4:	eb e0       	ldi	r30, 0x0B	; 11
    1ee6:	f2 e0       	ldi	r31, 0x02	; 2
    1ee8:	20 e0       	ldi	r18, 0x00	; 0
    1eea:	30 e0       	ldi	r19, 0x00	; 0
    for(byte i = 0;i < numberOfCommands;i++){
        if(cmd_commands[i][0] == cmd){
    1eec:	80 81       	ld	r24, Z
    1eee:	89 17       	cp	r24, r25
    1ef0:	89 f4       	brne	.+34     	; 0x1f14 <_Z18Commands_getLengthcb+0x32>
    1ef2:	f9 01       	movw	r30, r18
    1ef4:	ee 0f       	add	r30, r30
    1ef6:	ff 1f       	adc	r31, r31
            if(sendRecieve){
    1ef8:	66 23       	and	r22, r22
    1efa:	31 f0       	breq	.+12     	; 0x1f08 <_Z18Commands_getLengthcb+0x26>
                return cmd_commands[i][1];
    1efc:	e2 0f       	add	r30, r18
    1efe:	f3 1f       	adc	r31, r19
    1f00:	e5 5f       	subi	r30, 0xF5	; 245
    1f02:	fd 4f       	sbci	r31, 0xFD	; 253
    1f04:	81 81       	ldd	r24, Z+1	; 0x01
    1f06:	08 95       	ret
            } else {
                return cmd_commands[i][2];
    1f08:	e2 0f       	add	r30, r18
    1f0a:	f3 1f       	adc	r31, r19
    1f0c:	e5 5f       	subi	r30, 0xF5	; 245
    1f0e:	fd 4f       	sbci	r31, 0xFD	; 253
    1f10:	82 81       	ldd	r24, Z+2	; 0x02
    1f12:	08 95       	ret
    1f14:	2f 5f       	subi	r18, 0xFF	; 255
    1f16:	3f 4f       	sbci	r19, 0xFF	; 255
    1f18:	33 96       	adiw	r30, 0x03	; 3
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    for(byte i = 0;i < numberOfCommands;i++){
    1f1a:	25 32       	cpi	r18, 0x25	; 37
    1f1c:	31 05       	cpc	r19, r1
    1f1e:	31 f7       	brne	.-52     	; 0x1eec <_Z18Commands_getLengthcb+0xa>
    1f20:	8f ef       	ldi	r24, 0xFF	; 255
                return cmd_commands[i][2];
            }
        }
    }
    return -1;
}
    1f22:	08 95       	ret

00001f24 <_Z13Commands_initmh>:

#include "commands.h"

Commands cmd = {0};

void Commands_init(unsigned long _eVal, byte _gVal){
    1f24:	4f 92       	push	r4
    1f26:	5f 92       	push	r5
    1f28:	6f 92       	push	r6
    1f2a:	7f 92       	push	r7
    1f2c:	8f 92       	push	r8
    1f2e:	9f 92       	push	r9
    1f30:	af 92       	push	r10
    1f32:	bf 92       	push	r11
    1f34:	cf 92       	push	r12
    1f36:	df 92       	push	r13
    1f38:	ef 92       	push	r14
    1f3a:	ff 92       	push	r15
    1f3c:	0f 93       	push	r16
    1f3e:	1f 93       	push	r17
    1f40:	cf 93       	push	r28
    1f42:	df 93       	push	r29
    1f44:	3b 01       	movw	r6, r22
    1f46:	4c 01       	movw	r8, r24
    1f48:	44 2e       	mov	r4, r20
    cmd.aVal[RA] = EEPROM_readLong(aVal1_Address);              //steps/axis
    1f4a:	8e e0       	ldi	r24, 0x0E	; 14
    1f4c:	90 e0       	ldi	r25, 0x00	; 0
    1f4e:	0e 94 af 10 	call	0x215e	; 0x215e <_Z15EEPROM_readLongj>
    1f52:	60 93 44 03 	sts	0x0344, r22
    1f56:	70 93 45 03 	sts	0x0345, r23
    1f5a:	80 93 46 03 	sts	0x0346, r24
    1f5e:	90 93 47 03 	sts	0x0347, r25
    cmd.aVal[DC] = EEPROM_readLong(aVal2_Address);              //steps/axis
    1f62:	82 e1       	ldi	r24, 0x12	; 18
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	0e 94 af 10 	call	0x215e	; 0x215e <_Z15EEPROM_readLongj>
    1f6a:	60 93 48 03 	sts	0x0348, r22
    1f6e:	70 93 49 03 	sts	0x0349, r23
    1f72:	80 93 4a 03 	sts	0x034A, r24
    1f76:	90 93 4b 03 	sts	0x034B, r25
    cmd.bVal[RA] = EEPROM_readLong(bVal1_Address);              //sidereal rate
    1f7a:	86 e1       	ldi	r24, 0x16	; 22
    1f7c:	90 e0       	ldi	r25, 0x00	; 0
    1f7e:	0e 94 af 10 	call	0x215e	; 0x215e <_Z15EEPROM_readLongj>
    1f82:	60 93 4c 03 	sts	0x034C, r22
    1f86:	70 93 4d 03 	sts	0x034D, r23
    1f8a:	80 93 4e 03 	sts	0x034E, r24
    1f8e:	90 93 4f 03 	sts	0x034F, r25
    cmd.bVal[DC] = EEPROM_readLong(bVal2_Address);              //sidereal rate
    1f92:	8a e1       	ldi	r24, 0x1A	; 26
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	0e 94 af 10 	call	0x215e	; 0x215e <_Z15EEPROM_readLongj>
    1f9a:	60 93 50 03 	sts	0x0350, r22
    1f9e:	70 93 51 03 	sts	0x0351, r23
    1fa2:	80 93 52 03 	sts	0x0352, r24
    1fa6:	90 93 53 03 	sts	0x0353, r25
    cmd.sVal[RA] = EEPROM_readLong(sVal1_Address);              //steps/worm rotation
    1faa:	8e e1       	ldi	r24, 0x1E	; 30
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	0e 94 af 10 	call	0x215e	; 0x215e <_Z15EEPROM_readLongj>
    1fb2:	60 93 56 03 	sts	0x0356, r22
    1fb6:	70 93 57 03 	sts	0x0357, r23
    1fba:	80 93 58 03 	sts	0x0358, r24
    1fbe:	90 93 59 03 	sts	0x0359, r25
    cmd.sVal[DC] = EEPROM_readLong(sVal2_Address);              //steps/worm rotation
    1fc2:	82 e2       	ldi	r24, 0x22	; 34
    1fc4:	90 e0       	ldi	r25, 0x00	; 0
    1fc6:	0e 94 af 10 	call	0x215e	; 0x215e <_Z15EEPROM_readLongj>
    1fca:	60 93 5a 03 	sts	0x035A, r22
    1fce:	70 93 5b 03 	sts	0x035B, r23
    1fd2:	80 93 5c 03 	sts	0x035C, r24
    1fd6:	90 93 5d 03 	sts	0x035D, r25
    
    cmd.siderealIVal[RA] = EEPROM_readInt(IVal1_Address);       //steps/worm rotation
    1fda:	86 e2       	ldi	r24, 0x26	; 38
    1fdc:	90 e0       	ldi	r25, 0x00	; 0
    1fde:	0e 94 a0 10 	call	0x2140	; 0x2140 <_Z14EEPROM_readIntj>
    1fe2:	90 93 6a 03 	sts	0x036A, r25
    1fe6:	80 93 69 03 	sts	0x0369, r24
    cmd.siderealIVal[DC] = EEPROM_readInt(IVal2_Address);       //steps/worm rotation
    1fea:	88 e2       	ldi	r24, 0x28	; 40
    1fec:	90 e0       	ldi	r25, 0x00	; 0
    1fee:	0e 94 a0 10 	call	0x2140	; 0x2140 <_Z14EEPROM_readIntj>
    1ff2:	90 93 6c 03 	sts	0x036C, r25
    1ff6:	80 93 6b 03 	sts	0x036B, r24
    cmd.normalGotoSpeed[RA] = EEPROM_readByte(RAGoto_Address);  //IVal for normal goto speed
    1ffa:	8c e0       	ldi	r24, 0x0C	; 12
    1ffc:	90 e0       	ldi	r25, 0x00	; 0
    1ffe:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    2002:	05 e7       	ldi	r16, 0x75	; 117
    2004:	13 e0       	ldi	r17, 0x03	; 3
    2006:	80 93 75 03 	sts	0x0375, r24
    200a:	10 92 76 03 	sts	0x0376, r1
    cmd.normalGotoSpeed[DC] = EEPROM_readByte(DECGoto_Address); //IVal for normal goto speed
    200e:	8d e0       	ldi	r24, 0x0D	; 13
    2010:	90 e0       	ldi	r25, 0x00	; 0
    2012:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    2016:	80 93 77 03 	sts	0x0377, r24
    201a:	f8 01       	movw	r30, r16
    201c:	13 82       	std	Z+3, r1	; 0x03
    cmd.st4SpeedFactor = EEPROM_readByte(SpeedFactor_Address);  //ST4 speed factor
    201e:	8e e2       	ldi	r24, 0x2E	; 46
    2020:	90 e0       	ldi	r25, 0x00	; 0
    2022:	0e 94 99 10 	call	0x2132	; 0x2132 <_Z15EEPROM_readBytej>
    2026:	80 93 5f 03 	sts	0x035F, r24
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    202a:	8c e2       	ldi	r24, 0x2C	; 44
    202c:	90 e0       	ldi	r25, 0x00	; 0
    202e:	0e 94 a0 10 	call	0x2140	; 0x2140 <_Z14EEPROM_readIntj>
    2032:	90 93 68 03 	sts	0x0368, r25
    2036:	80 93 67 03 	sts	0x0367, r24
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    203a:	c8 01       	movw	r24, r16
    203c:	08 96       	adiw	r24, 0x08	; 8
    203e:	60 e4       	ldi	r22, 0x40	; 64
    2040:	44 e6       	ldi	r20, 0x64	; 100
    2042:	50 e0       	ldi	r21, 0x00	; 0
    2044:	0e 94 df 10 	call	0x21be	; 0x21be <_Z21EEPROM_readAccelTableP16AccelTableStructhj>
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    2048:	8d e3       	ldi	r24, 0x3D	; 61
    204a:	94 e0       	ldi	r25, 0x04	; 4
    204c:	60 e4       	ldi	r22, 0x40	; 64
    204e:	44 e2       	ldi	r20, 0x24	; 36
    2050:	51 e0       	ldi	r21, 0x01	; 1
    2052:	0e 94 df 10 	call	0x21be	; 0x21be <_Z21EEPROM_readAccelTableP16AccelTableStructhj>
    2056:	26 e1       	ldi	r18, 0x16	; 22
    2058:	33 e0       	ldi	r19, 0x03	; 3
    205a:	79 01       	movw	r14, r18
    205c:	6d e7       	ldi	r22, 0x7D	; 125
    205e:	73 e0       	ldi	r23, 0x03	; 3
    2060:	09 e7       	ldi	r16, 0x79	; 121
    2062:	13 e0       	ldi	r17, 0x03	; 3
    2064:	e9 01       	movw	r28, r18
    2066:	d9 01       	movw	r26, r18
    2068:	40 e0       	ldi	r20, 0x00	; 0
    206a:	50 e0       	ldi	r21, 0x00	; 0
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
        cmd.stepDir[i] = 1; //1-dir*2
    206c:	55 24       	eor	r5, r5
    206e:	53 94       	inc	r5
        cmd.highSpeedMode[i] = false;
        cmd.stopped[i] = CMD_STOPPED;
        cmd.gotoEn[i] = CMD_DISABLED;
        cmd.FVal[i] = CMD_DISABLED;
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
    2070:	a1 2c       	mov	r10, r1
    2072:	b1 2c       	mov	r11, r1
    2074:	e0 e8       	ldi	r30, 0x80	; 128
    2076:	ce 2e       	mov	r12, r30
    2078:	d1 2c       	mov	r13, r1
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
    207a:	1c 8e       	std	Y+28, r1	; 0x1c
        cmd.stepDir[i] = 1; //1-dir*2
    207c:	fa 01       	movw	r30, r20
    207e:	ea 5e       	subi	r30, 0xEA	; 234
    2080:	fc 4f       	sbci	r31, 0xFC	; 252
    2082:	52 8e       	std	Z+26, r5	; 0x1a
        cmd.highSpeedMode[i] = false;
    2084:	1c a2       	std	Y+36, r1	; 0x24
        cmd.stopped[i] = CMD_STOPPED;
    2086:	5a a2       	std	Y+34, r5	; 0x22
        cmd.gotoEn[i] = CMD_DISABLED;
    2088:	18 a2       	std	Y+32, r1	; 0x20
        cmd.FVal[i] = CMD_DISABLED;
    208a:	1e 8e       	std	Y+30, r1	; 0x1e
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
    208c:	f7 01       	movw	r30, r14
    208e:	a1 92       	st	Z+, r10
    2090:	b1 92       	st	Z+, r11
    2092:	c1 92       	st	Z+, r12
    2094:	d1 92       	st	Z+, r13
    2096:	7f 01       	movw	r14, r30
        cmd.IVal[i] = cmd.siderealIVal[i]; //Recieved Speed will be set by :I command.
    2098:	ad 5a       	subi	r26, 0xAD	; 173
    209a:	bf 4f       	sbci	r27, 0xFF	; 255
    209c:	8d 91       	ld	r24, X+
    209e:	9c 91       	ld	r25, X
    20a0:	11 97       	sbiw	r26, 0x01	; 1
    20a2:	a3 55       	subi	r26, 0x53	; 83
    20a4:	b0 40       	sbci	r27, 0x00	; 0
    20a6:	19 96       	adiw	r26, 0x09	; 9
    20a8:	9c 93       	st	X, r25
    20aa:	8e 93       	st	-X, r24
    20ac:	18 97       	sbiw	r26, 0x08	; 8
        cmd.GVal[i] = 0; //Mode recieved from :G command
    20ae:	18 8a       	std	Y+16, r1	; 0x10
        cmd.HVal[i] = 0; //Value recieved from :H command
    20b0:	f9 01       	movw	r30, r18
    20b2:	12 8a       	std	Z+18, r1	; 0x12
    20b4:	13 8a       	std	Z+19, r1	; 0x13
    20b6:	14 8a       	std	Z+20, r1	; 0x14
    20b8:	15 8a       	std	Z+21, r1	; 0x15
        cmd.eVal[i] = _eVal; //version number
    20ba:	66 a2       	std	Z+38, r6	; 0x26
    20bc:	77 a2       	std	Z+39, r7	; 0x27
    20be:	80 a6       	std	Z+40, r8	; 0x28
    20c0:	91 a6       	std	Z+41, r9	; 0x29
        cmd.gVal[i] = _gVal; //High speed scalar
    20c2:	4e ae       	std	Y+62, r4	; 0x3e
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
    20c4:	fb 01       	movw	r30, r22
    20c6:	80 81       	ld	r24, Z
    20c8:	91 81       	ldd	r25, Z+1	; 0x01
    20ca:	a5 5a       	subi	r26, 0xA5	; 165
    20cc:	bf 4f       	sbci	r27, 0xFF	; 255
    20ce:	11 96       	adiw	r26, 0x01	; 1
    20d0:	9c 93       	st	X, r25
    20d2:	8e 93       	st	-X, r24
        cmd.stopSpeed[i] = cmd.minSpeed[i];
    20d4:	f8 01       	movw	r30, r16
    20d6:	81 93       	st	Z+, r24
    20d8:	91 93       	st	Z+, r25
    20da:	8f 01       	movw	r16, r30
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
    20dc:	14 97       	sbiw	r26, 0x04	; 4
    20de:	01 96       	adiw	r24, 0x01	; 1
    20e0:	11 96       	adiw	r26, 0x01	; 1
    20e2:	9c 93       	st	X, r25
    20e4:	8e 93       	st	-X, r24
    20e6:	a7 55       	subi	r26, 0x57	; 87
    20e8:	b0 40       	sbci	r27, 0x00	; 0
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    20ea:	1d 96       	adiw	r26, 0x0d	; 13
    20ec:	9c 93       	st	X, r25
    20ee:	8e 93       	st	-X, r24
    20f0:	1c 97       	sbiw	r26, 0x0c	; 12
    20f2:	4f 5f       	subi	r20, 0xFF	; 255
    20f4:	5f 4f       	sbci	r21, 0xFF	; 255
    20f6:	21 96       	adiw	r28, 0x01	; 1
    20f8:	12 96       	adiw	r26, 0x02	; 2
    20fa:	2c 5f       	subi	r18, 0xFC	; 252
    20fc:	3f 4f       	sbci	r19, 0xFF	; 255
    20fe:	60 54       	subi	r22, 0x40	; 64
    2100:	7f 4f       	sbci	r23, 0xFF	; 255
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
    2102:	42 30       	cpi	r20, 0x02	; 2
    2104:	51 05       	cpc	r21, r1
    2106:	09 f0       	breq	.+2      	; 0x210a <_Z13Commands_initmh+0x1e6>
    2108:	b8 cf       	rjmp	.-144    	; 0x207a <_Z13Commands_initmh+0x156>
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
        cmd.stopSpeed[i] = cmd.minSpeed[i];
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
    210a:	80 e0       	ldi	r24, 0x00	; 0
    210c:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <_Z26Commands_configureST4Speedh>
}
    2110:	df 91       	pop	r29
    2112:	cf 91       	pop	r28
    2114:	1f 91       	pop	r17
    2116:	0f 91       	pop	r16
    2118:	ff 90       	pop	r15
    211a:	ef 90       	pop	r14
    211c:	df 90       	pop	r13
    211e:	cf 90       	pop	r12
    2120:	bf 90       	pop	r11
    2122:	af 90       	pop	r10
    2124:	9f 90       	pop	r9
    2126:	8f 90       	pop	r8
    2128:	7f 90       	pop	r7
    212a:	6f 90       	pop	r6
    212c:	5f 90       	pop	r5
    212e:	4f 90       	pop	r4
    2130:	08 95       	ret

00002132 <_Z15EEPROM_readBytej>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2132:	f9 99       	sbic	0x1f, 1	; 31
    2134:	fe cf       	rjmp	.-4      	; 0x2132 <_Z15EEPROM_readBytej>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2136:	92 bd       	out	0x22, r25	; 34
    2138:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    213a:	f8 9a       	sbi	0x1f, 0	; 31
    213c:	80 b5       	in	r24, 0x20	; 32
#include <avr/eeprom.h>
#include "EEPROMReader.h"
 
byte EEPROM_readByte(unsigned int address) {
    return eeprom_read_byte((byte*) address);
}
    213e:	08 95       	ret

00002140 <_Z14EEPROM_readIntj>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2140:	f9 99       	sbic	0x1f, 1	; 31
    2142:	fe cf       	rjmp	.-4      	; 0x2140 <_Z14EEPROM_readIntj>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2144:	92 bd       	out	0x22, r25	; 34
    2146:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2148:	f8 9a       	sbi	0x1f, 0	; 31
    214a:	20 b5       	in	r18, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    214c:	f9 99       	sbic	0x1f, 1	; 31
    214e:	fe cf       	rjmp	.-4      	; 0x214c <_Z14EEPROM_readIntj+0xc>

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    2150:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2152:	92 bd       	out	0x22, r25	; 34
    2154:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2156:	f8 9a       	sbi	0x1f, 0	; 31
    2158:	90 b5       	in	r25, 0x20	; 32
    return fetcher.integer;
}
    215a:	82 2f       	mov	r24, r18
    215c:	08 95       	ret

0000215e <_Z15EEPROM_readLongj>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    215e:	f9 99       	sbic	0x1f, 1	; 31
    2160:	fe cf       	rjmp	.-4      	; 0x215e <_Z15EEPROM_readLongj>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2162:	92 bd       	out	0x22, r25	; 34
    2164:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2166:	f8 9a       	sbi	0x1f, 0	; 31
    2168:	20 b5       	in	r18, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    216a:	f9 99       	sbic	0x1f, 1	; 31
    216c:	fe cf       	rjmp	.-4      	; 0x216a <_Z15EEPROM_readLongj+0xc>
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    216e:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2170:	92 bd       	out	0x22, r25	; 34
    2172:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2174:	f8 9a       	sbi	0x1f, 0	; 31
    2176:	70 b5       	in	r23, 0x20	; 32
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    fetcher.array[1] = EEPROM_readInt(address+2);
    2178:	01 96       	adiw	r24, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    217a:	f9 99       	sbic	0x1f, 1	; 31
    217c:	fe cf       	rjmp	.-4      	; 0x217a <_Z15EEPROM_readLongj+0x1c>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    217e:	92 bd       	out	0x22, r25	; 34
    2180:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2182:	f8 9a       	sbi	0x1f, 0	; 31
    2184:	30 b5       	in	r19, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2186:	f9 99       	sbic	0x1f, 1	; 31
    2188:	fe cf       	rjmp	.-4      	; 0x2186 <_Z15EEPROM_readLongj+0x28>
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    218a:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    218c:	92 bd       	out	0x22, r25	; 34
    218e:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2190:	f8 9a       	sbi	0x1f, 0	; 31
    2192:	90 b5       	in	r25, 0x20	; 32
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    2194:	62 2f       	mov	r22, r18
    fetcher.array[1] = EEPROM_readInt(address+2);
    2196:	83 2f       	mov	r24, r19
    return fetcher.integer;
}
    2198:	08 95       	ret

0000219a <_Z17EEPROM_readStringPchj>:

void EEPROM_readString(char* string, byte len, unsigned int address) {
    219a:	fc 01       	movw	r30, r24
    219c:	90 e0       	ldi	r25, 0x00	; 0
    219e:	0c c0       	rjmp	.+24     	; 0x21b8 <_Z17EEPROM_readStringPchj+0x1e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21a0:	f9 99       	sbic	0x1f, 1	; 31
    21a2:	fe cf       	rjmp	.-4      	; 0x21a0 <_Z17EEPROM_readStringPchj+0x6>
    for(byte i = 0; i < len; i++) {
        string[i] = EEPROM_readByte(address++);
    21a4:	9a 01       	movw	r18, r20
    21a6:	2f 5f       	subi	r18, 0xFF	; 255
    21a8:	3f 4f       	sbci	r19, 0xFF	; 255
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21aa:	52 bd       	out	0x22, r21	; 34
    21ac:	41 bd       	out	0x21, r20	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    21ae:	f8 9a       	sbi	0x1f, 0	; 31
    21b0:	80 b5       	in	r24, 0x20	; 32
    21b2:	81 93       	st	Z+, r24
    fetcher.array[1] = EEPROM_readInt(address+2);
    return fetcher.integer;
}

void EEPROM_readString(char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
    21b4:	9f 5f       	subi	r25, 0xFF	; 255
    21b6:	a9 01       	movw	r20, r18
    21b8:	96 17       	cp	r25, r22
    21ba:	90 f3       	brcs	.-28     	; 0x21a0 <_Z17EEPROM_readStringPchj+0x6>
        string[i] = EEPROM_readByte(address++);
    }
}
    21bc:	08 95       	ret

000021be <_Z21EEPROM_readAccelTableP16AccelTableStructhj>:

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    21be:	fc 01       	movw	r30, r24
    21c0:	20 e0       	ldi	r18, 0x00	; 0
    21c2:	25 c0       	rjmp	.+74     	; 0x220e <__stack+0xf>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21c4:	f9 99       	sbic	0x1f, 1	; 31
    21c6:	fe cf       	rjmp	.-4      	; 0x21c4 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x6>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21c8:	52 bd       	out	0x22, r21	; 34
    21ca:	41 bd       	out	0x21, r20	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    21cc:	f8 9a       	sbi	0x1f, 0	; 31
    21ce:	90 b5       	in	r25, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21d0:	f9 99       	sbic	0x1f, 1	; 31
    21d2:	fe cf       	rjmp	.-4      	; 0x21d0 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x12>
    21d4:	4f 5f       	subi	r20, 0xFF	; 255
    21d6:	5f 4f       	sbci	r21, 0xFF	; 255
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21d8:	52 bd       	out	0x22, r21	; 34
    21da:	41 bd       	out	0x21, r20	; 33
    21dc:	41 50       	subi	r20, 0x01	; 1
    21de:	50 40       	sbci	r21, 0x00	; 0
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    21e0:	f8 9a       	sbi	0x1f, 0	; 31
    21e2:	80 b5       	in	r24, 0x20	; 32
    for(byte i = 0; i < elements; i++) {
        table[i].speed = EEPROM_readInt(address);
    21e4:	90 83       	st	Z, r25
    21e6:	81 83       	std	Z+1, r24	; 0x01
    21e8:	ca 01       	movw	r24, r20
    21ea:	02 96       	adiw	r24, 0x02	; 2
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21ec:	f9 99       	sbic	0x1f, 1	; 31
    21ee:	fe cf       	rjmp	.-4      	; 0x21ec <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x2e>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21f0:	92 bd       	out	0x22, r25	; 34
    21f2:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    21f4:	f8 9a       	sbi	0x1f, 0	; 31
    21f6:	80 b5       	in	r24, 0x20	; 32
    21f8:	4d 5f       	subi	r20, 0xFD	; 253
    21fa:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21fc:	f9 99       	sbic	0x1f, 1	; 31
    21fe:	fe cf       	rjmp	.-4      	; 0x21fc <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x3e>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2200:	52 bd       	out	0x22, r21	; 34
    2202:	41 bd       	out	0x21, r20	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2204:	f8 9a       	sbi	0x1f, 0	; 31
    2206:	90 b5       	in	r25, 0x20	; 32
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
    2208:	82 83       	std	Z+2, r24	; 0x02
        string[i] = EEPROM_readByte(address++);
    }
}

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
    220a:	2f 5f       	subi	r18, 0xFF	; 255
    220c:	33 96       	adiw	r30, 0x03	; 3
    220e:	26 17       	cp	r18, r22
    2210:	08 f4       	brcc	.+2      	; 0x2214 <__stack+0x15>
    2212:	d8 cf       	rjmp	.-80     	; 0x21c4 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x6>
        table[i].speed = EEPROM_readInt(address);
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
        address = address + sizeof(byte);
    }
}
    2214:	08 95       	ret

00002216 <_Z16EEPROM_writeBytehj>:
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2216:	f9 99       	sbic	0x1f, 1	; 31
    2218:	fe cf       	rjmp	.-4      	; 0x2216 <_Z16EEPROM_writeBytehj>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    221a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    221c:	72 bd       	out	0x22, r23	; 34
    221e:	61 bd       	out	0x21, r22	; 33
#endif
    EEDR = __value;
    2220:	80 bd       	out	0x20, r24	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    2222:	0f b6       	in	r0, 0x3f	; 63
    2224:	f8 94       	cli
    2226:	fa 9a       	sbi	0x1f, 2	; 31
    2228:	f9 9a       	sbi	0x1f, 1	; 31
    222a:	0f be       	out	0x3f, r0	; 63

void EEPROM_writeByte(byte val, unsigned int address) {
    return eeprom_write_byte((byte*) address, val);
}
    222c:	08 95       	ret

0000222e <_Z15EEPROM_writeIntjj>:

void EEPROM_writeInt(unsigned int val, unsigned int address) {
    TwoBytes storer = {val};
    222e:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2230:	f9 99       	sbic	0x1f, 1	; 31
    2232:	fe cf       	rjmp	.-4      	; 0x2230 <_Z15EEPROM_writeIntjj+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2234:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2236:	72 bd       	out	0x22, r23	; 34
    2238:	61 bd       	out	0x21, r22	; 33
#endif
    EEDR = __value;
    223a:	20 bd       	out	0x20, r18	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    223c:	0f b6       	in	r0, 0x3f	; 63
    223e:	f8 94       	cli
    2240:	fa 9a       	sbi	0x1f, 2	; 31
    2242:	f9 9a       	sbi	0x1f, 1	; 31
    2244:	0f be       	out	0x3f, r0	; 63
    EEPROM_writeByte(storer.array[0], address);
    EEPROM_writeByte(storer.array[1], address+1);
    2246:	93 2f       	mov	r25, r19
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2248:	f9 99       	sbic	0x1f, 1	; 31
    224a:	fe cf       	rjmp	.-4      	; 0x2248 <_Z15EEPROM_writeIntjj+0x1a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    224c:	1f ba       	out	0x1f, r1	; 31
    224e:	6f 5f       	subi	r22, 0xFF	; 255
    2250:	7f 4f       	sbci	r23, 0xFF	; 255
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2252:	72 bd       	out	0x22, r23	; 34
    2254:	61 bd       	out	0x21, r22	; 33
#endif
    EEDR = __value;
    2256:	90 bd       	out	0x20, r25	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    2258:	0f b6       	in	r0, 0x3f	; 63
    225a:	f8 94       	cli
    225c:	fa 9a       	sbi	0x1f, 2	; 31
    225e:	f9 9a       	sbi	0x1f, 1	; 31
    2260:	0f be       	out	0x3f, r0	; 63
}
    2262:	08 95       	ret

00002264 <_Z16EEPROM_writeLongmj>:

void EEPROM_writeLong(unsigned long val, unsigned int address) {
    2264:	ef 92       	push	r14
    2266:	ff 92       	push	r15
    2268:	0f 93       	push	r16
    226a:	1f 93       	push	r17
    226c:	8a 01       	movw	r16, r20
    FourBytes storer = {val};
    226e:	f8 2e       	mov	r15, r24
    2270:	e9 2e       	mov	r14, r25
    EEPROM_writeInt(storer.array[0], address);
    2272:	cb 01       	movw	r24, r22
    2274:	ba 01       	movw	r22, r20
    2276:	0e 94 17 11 	call	0x222e	; 0x222e <_Z15EEPROM_writeIntjj>
    EEPROM_writeInt(storer.array[1], address+2);
    227a:	0e 5f       	subi	r16, 0xFE	; 254
    227c:	1f 4f       	sbci	r17, 0xFF	; 255
    227e:	8f 2d       	mov	r24, r15
    2280:	9e 2d       	mov	r25, r14
    2282:	b8 01       	movw	r22, r16
    2284:	0e 94 17 11 	call	0x222e	; 0x222e <_Z15EEPROM_writeIntjj>
}
    2288:	1f 91       	pop	r17
    228a:	0f 91       	pop	r16
    228c:	ff 90       	pop	r15
    228e:	ef 90       	pop	r14
    2290:	08 95       	ret

00002292 <_Z18EEPROM_writeStringPKchj>:

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    2292:	fc 01       	movw	r30, r24
    2294:	20 e0       	ldi	r18, 0x00	; 0
    2296:	30 e0       	ldi	r19, 0x00	; 0
    2298:	12 c0       	rjmp	.+36     	; 0x22be <_Z18EEPROM_writeStringPKchj+0x2c>
    for(byte i = 0; i < len; i++) {
        EEPROM_writeByte(string[i], address+i);
    229a:	70 81       	ld	r23, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    229c:	f9 99       	sbic	0x1f, 1	; 31
    229e:	fe cf       	rjmp	.-4      	; 0x229c <_Z18EEPROM_writeStringPKchj+0xa>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    22a0:	1f ba       	out	0x1f, r1	; 31
    22a2:	c9 01       	movw	r24, r18
    22a4:	84 0f       	add	r24, r20
    22a6:	95 1f       	adc	r25, r21
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    22a8:	92 bd       	out	0x22, r25	; 34
    22aa:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    22ac:	70 bd       	out	0x20, r23	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    22ae:	0f b6       	in	r0, 0x3f	; 63
    22b0:	f8 94       	cli
    22b2:	fa 9a       	sbi	0x1f, 2	; 31
    22b4:	f9 9a       	sbi	0x1f, 1	; 31
    22b6:	0f be       	out	0x3f, r0	; 63
    22b8:	2f 5f       	subi	r18, 0xFF	; 255
    22ba:	3f 4f       	sbci	r19, 0xFF	; 255
    22bc:	31 96       	adiw	r30, 0x01	; 1
    EEPROM_writeInt(storer.array[0], address);
    EEPROM_writeInt(storer.array[1], address+2);
}

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
    22be:	26 17       	cp	r18, r22
    22c0:	60 f3       	brcs	.-40     	; 0x229a <_Z18EEPROM_writeStringPKchj+0x8>
        EEPROM_writeByte(string[i], address+i);
    }
}
    22c2:	08 95       	ret

000022c4 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>:

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    22c4:	ef 92       	push	r14
    22c6:	ff 92       	push	r15
    22c8:	0f 93       	push	r16
    22ca:	1f 93       	push	r17
    22cc:	cf 93       	push	r28
    22ce:	df 93       	push	r29
    22d0:	e6 2e       	mov	r14, r22
    22d2:	8a 01       	movw	r16, r20
    22d4:	ec 01       	movw	r28, r24
    22d6:	ff 24       	eor	r15, r15
    22d8:	17 c0       	rjmp	.+46     	; 0x2308 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x44>
    for(byte i = 0; i < elements; i++) {
        EEPROM_writeInt(table[i].speed,address);
    22da:	88 81       	ld	r24, Y
    22dc:	99 81       	ldd	r25, Y+1	; 0x01
    22de:	b8 01       	movw	r22, r16
    22e0:	0e 94 17 11 	call	0x222e	; 0x222e <_Z15EEPROM_writeIntjj>
    22e4:	c8 01       	movw	r24, r16
    22e6:	02 96       	adiw	r24, 0x02	; 2
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
    22e8:	2a 81       	ldd	r18, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    22ea:	f9 99       	sbic	0x1f, 1	; 31
    22ec:	fe cf       	rjmp	.-4      	; 0x22ea <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x26>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    22ee:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    22f0:	92 bd       	out	0x22, r25	; 34
    22f2:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    22f4:	20 bd       	out	0x20, r18	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    22f6:	0f b6       	in	r0, 0x3f	; 63
    22f8:	f8 94       	cli
    22fa:	fa 9a       	sbi	0x1f, 2	; 31
    22fc:	f9 9a       	sbi	0x1f, 1	; 31
    22fe:	0f be       	out	0x3f, r0	; 63
    2300:	0d 5f       	subi	r16, 0xFD	; 253
    2302:	1f 4f       	sbci	r17, 0xFF	; 255
        EEPROM_writeByte(string[i], address+i);
    }
}

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
    2304:	f3 94       	inc	r15
    2306:	23 96       	adiw	r28, 0x03	; 3
    2308:	fe 14       	cp	r15, r14
    230a:	38 f3       	brcs	.-50     	; 0x22da <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x16>
        EEPROM_writeInt(table[i].speed,address);
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
        address = address + sizeof(byte);
    }
}
    230c:	df 91       	pop	r29
    230e:	cf 91       	pop	r28
    2310:	1f 91       	pop	r17
    2312:	0f 91       	pop	r16
    2314:	ff 90       	pop	r15
    2316:	ef 90       	pop	r14
    2318:	08 95       	ret

0000231a <_Z17Serial_initialisem>:
RingBuffer rxBuf = {{0},0,0};

bool softSPIEnabled = false;

//Initialise the hardware UART port and set baud rate.
void Serial_initialise(const unsigned long baud) {
    231a:	ef 92       	push	r14
    231c:	ff 92       	push	r15
    231e:	0f 93       	push	r16
    2320:	1f 93       	push	r17
    2322:	7b 01       	movw	r14, r22
    2324:	8c 01       	movw	r16, r24
    Byter baud_setting;

    UCSRnA = _BV(U2Xn);
    2326:	82 e0       	ldi	r24, 0x02	; 2
    2328:	80 93 c0 00 	sts	0x00C0, r24
    baud_setting.integer = (F_CPU / 4 / baud - 1) / 2;
    232c:	60 e0       	ldi	r22, 0x00	; 0
    232e:	79 e0       	ldi	r23, 0x09	; 9
    2330:	8d e3       	ldi	r24, 0x3D	; 61
    2332:	90 e0       	ldi	r25, 0x00	; 0
    2334:	a8 01       	movw	r20, r16
    2336:	97 01       	movw	r18, r14
    2338:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__udivmodsi4>
    233c:	21 50       	subi	r18, 0x01	; 1
    233e:	30 40       	sbci	r19, 0x00	; 0
    2340:	40 40       	sbci	r20, 0x00	; 0
    2342:	50 40       	sbci	r21, 0x00	; 0
    2344:	56 95       	lsr	r21
    2346:	47 95       	ror	r20
    2348:	37 95       	ror	r19
    234a:	27 95       	ror	r18
    234c:	92 2f       	mov	r25, r18
    234e:	23 2f       	mov	r18, r19

    if (baud_setting.high & 0xF0) {
    2350:	83 2f       	mov	r24, r19
    2352:	80 7f       	andi	r24, 0xF0	; 240
    2354:	a1 f0       	breq	.+40     	; 0x237e <_Z17Serial_initialisem+0x64>
        UCSRnA = 0;
    2356:	10 92 c0 00 	sts	0x00C0, r1
        baud_setting.integer = (F_CPU / 8 / baud - 1) / 2;
    235a:	60 e8       	ldi	r22, 0x80	; 128
    235c:	74 e8       	ldi	r23, 0x84	; 132
    235e:	8e e1       	ldi	r24, 0x1E	; 30
    2360:	90 e0       	ldi	r25, 0x00	; 0
    2362:	a8 01       	movw	r20, r16
    2364:	97 01       	movw	r18, r14
    2366:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <__udivmodsi4>
    236a:	21 50       	subi	r18, 0x01	; 1
    236c:	30 40       	sbci	r19, 0x00	; 0
    236e:	40 40       	sbci	r20, 0x00	; 0
    2370:	50 40       	sbci	r21, 0x00	; 0
    2372:	56 95       	lsr	r21
    2374:	47 95       	ror	r20
    2376:	37 95       	ror	r19
    2378:	27 95       	ror	r18
    237a:	92 2f       	mov	r25, r18
    237c:	23 2f       	mov	r18, r19
    }

    // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
    UBRRnH = baud_setting.high & 0x0F;
    237e:	2f 70       	andi	r18, 0x0F	; 15
    2380:	20 93 c5 00 	sts	0x00C5, r18
    UBRRnL = baud_setting.low;
    2384:	90 93 c4 00 	sts	0x00C4, r25
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    2388:	8f b7       	in	r24, 0x3f	; 63
    cli();
    238a:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    238c:	10 92 1d 05 	sts	0x051D, r1
    txBuf.tail = 0;
    2390:	10 92 1e 05 	sts	0x051E, r1
    rxBuf.head = 0;
    2394:	10 92 3f 05 	sts	0x053F, r1
    rxBuf.tail = 0;
    2398:	10 92 40 05 	sts	0x0540, r1
    SREG = oldSREG;
    239c:	8f bf       	out	0x3f, r24	; 63

    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.

    //And enable
    sbi(UCSRnB, RXENn);
    239e:	80 91 c1 00 	lds	r24, 0x00C1
    23a2:	80 61       	ori	r24, 0x10	; 16
    23a4:	80 93 c1 00 	sts	0x00C1, r24
    sbi(UCSRnB, TXENn);
    23a8:	80 91 c1 00 	lds	r24, 0x00C1
    23ac:	88 60       	ori	r24, 0x08	; 8
    23ae:	80 93 c1 00 	sts	0x00C1, r24
    sbi(UCSRnB, RXCIEn);
    23b2:	80 91 c1 00 	lds	r24, 0x00C1
    23b6:	80 68       	ori	r24, 0x80	; 128
    23b8:	80 93 c1 00 	sts	0x00C1, r24
    cbi(UCSRnB, UDRIEn);
    23bc:	80 91 c1 00 	lds	r24, 0x00C1
    23c0:	8f 7d       	andi	r24, 0xDF	; 223
    23c2:	80 93 c1 00 	sts	0x00C1, r24
}
    23c6:	1f 91       	pop	r17
    23c8:	0f 91       	pop	r16
    23ca:	ff 90       	pop	r15
    23cc:	ef 90       	pop	r14
    23ce:	08 95       	ret

000023d0 <_Z14Serial_disablev>:

//Disable the hardware UART port
void Serial_disable() {
    cbi(UCSRnB, RXENn);
    23d0:	e1 ec       	ldi	r30, 0xC1	; 193
    23d2:	f0 e0       	ldi	r31, 0x00	; 0
    23d4:	80 81       	ld	r24, Z
    23d6:	8f 7e       	andi	r24, 0xEF	; 239
    23d8:	80 83       	st	Z, r24
    cbi(UCSRnB, TXENn);
    23da:	80 81       	ld	r24, Z
    23dc:	87 7f       	andi	r24, 0xF7	; 247
    23de:	80 83       	st	Z, r24
    cbi(UCSRnB, RXCIEn);
    23e0:	80 81       	ld	r24, Z
    23e2:	8f 77       	andi	r24, 0x7F	; 127
    23e4:	80 83       	st	Z, r24
    cbi(UCSRnB, UDRIEn);
    23e6:	80 81       	ld	r24, Z
    23e8:	8f 7d       	andi	r24, 0xDF	; 223
    23ea:	80 83       	st	Z, r24
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    23ec:	8f b7       	in	r24, 0x3f	; 63
    cli();
    23ee:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    23f0:	10 92 1d 05 	sts	0x051D, r1
    txBuf.tail = 0;
    23f4:	10 92 1e 05 	sts	0x051E, r1
    rxBuf.head = 0;
    23f8:	10 92 3f 05 	sts	0x053F, r1
    rxBuf.tail = 0;
    23fc:	10 92 40 05 	sts	0x0540, r1
    SREG = oldSREG;
    2400:	8f bf       	out	0x3f, r24	; 63
    cbi(UCSRnB, RXENn);
    cbi(UCSRnB, TXENn);
    cbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}
    2402:	08 95       	ret

00002404 <_Z14SPI_initialisev>:
}

//Initialise the Software SPI by setting ports to correct direction and state.
void SPI_initialise() {
    //Set all SPI pins to idle levels
    setPinDir  (SPIClockPin_Define,OUTPUT); //Clock is output idle high
    2404:	21 9a       	sbi	0x04, 1	; 4
    setPinValue(SPIClockPin_Define,  HIGH);
    2406:	29 9a       	sbi	0x05, 1	; 5
    setPinDir  (SPIMISOPin_Define,  INPUT); //MISO is input pull-up
    2408:	23 98       	cbi	0x04, 3	; 4
    setPinValue(SPIMISOPin_Define,   HIGH);
    240a:	2b 9a       	sbi	0x05, 3	; 5
    setPinDir  (SPIMOSIPin_Define, OUTPUT); //MOSI is output idle high
    240c:	22 9a       	sbi	0x04, 2	; 4
    setPinValue(SPIMOSIPin_Define,   HIGH);
    240e:	2a 9a       	sbi	0x05, 2	; 5
    setPinDir  (SPISSnPin_Define,  OUTPUT); //SSn is output idle high
    2410:	20 9a       	sbi	0x04, 0	; 4
    setPinValue(SPISSnPin_Define,    HIGH);
    2412:	28 9a       	sbi	0x05, 0	; 5
    //Standalone pin is switching to SPI ready, so ensure we out pull-up is to high.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    2414:	11 9a       	sbi	0x02, 1	; 2
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    2416:	8f b7       	in	r24, 0x3f	; 63
    cli();
    2418:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    241a:	10 92 1d 05 	sts	0x051D, r1
    txBuf.tail = 0;
    241e:	10 92 1e 05 	sts	0x051E, r1
    rxBuf.head = 0;
    2422:	10 92 3f 05 	sts	0x053F, r1
    rxBuf.tail = 0;
    2426:	10 92 40 05 	sts	0x0540, r1
    SREG = oldSREG;
    242a:	8f bf       	out	0x3f, r24	; 63
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.
    
    //Now enabled
    softSPIEnabled = true;
    242c:	81 e0       	ldi	r24, 0x01	; 1
    242e:	80 93 41 05 	sts	0x0541, r24
}
    2432:	08 95       	ret

00002434 <_Z11SPI_disablev>:

//Disable the Software SPI by setting all ports back to input pull-up
void SPI_disable() {
    //Set all SPI pins to High-Z
    setPinDir  (SPIClockPin_Define, INPUT);
    2434:	21 98       	cbi	0x04, 1	; 4
    setPinValue(SPIClockPin_Define,  HIGH);
    2436:	29 9a       	sbi	0x05, 1	; 5
    setPinDir  (SPIMISOPin_Define,  INPUT);
    2438:	23 98       	cbi	0x04, 3	; 4
    setPinValue(SPIMISOPin_Define,   HIGH);
    243a:	2b 9a       	sbi	0x05, 3	; 5
    setPinDir  (SPIMOSIPin_Define,  INPUT);
    243c:	22 98       	cbi	0x04, 2	; 4
    setPinValue(SPIMOSIPin_Define,   HIGH);
    243e:	2a 9a       	sbi	0x05, 2	; 5
    setPinDir  (SPISSnPin_Define,   INPUT);
    2440:	20 98       	cbi	0x04, 0	; 4
    setPinValue(SPISSnPin_Define,    HIGH);
    2442:	28 9a       	sbi	0x05, 0	; 5
    //Now disabled
    softSPIEnabled = false;
    2444:	10 92 41 05 	sts	0x0541, r1
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    2448:	8f b7       	in	r24, 0x3f	; 63
    cli();
    244a:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    244c:	10 92 1d 05 	sts	0x051D, r1
    txBuf.tail = 0;
    2450:	10 92 1e 05 	sts	0x051E, r1
    rxBuf.head = 0;
    2454:	10 92 3f 05 	sts	0x053F, r1
    rxBuf.tail = 0;
    2458:	10 92 40 05 	sts	0x0540, r1
    SREG = oldSREG;
    245c:	8f bf       	out	0x3f, r24	; 63
    setPinDir  (SPISSnPin_Define,   INPUT);
    setPinValue(SPISSnPin_Define,    HIGH);
    //Now disabled
    softSPIEnabled = false;
    Serial_clear(); //Empty the buffer of any outstanding data.
}
    245e:	08 95       	ret

00002460 <_Z12SPI_transferh>:

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    2460:	98 e0       	ldi	r25, 0x08	; 8
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
        setPinValue(SPIClockPin_Define,LOW); //Falling Edge   //--     2 cycles         .
    2462:	29 98       	cbi	0x05, 1	; 5
        if (data & 0x80) { //Send MSB first                   //-- 2 cycles | 1 cycle    |
    2464:	87 ff       	sbrs	r24, 7
    2466:	02 c0       	rjmp	.+4      	; 0x246c <_Z12SPI_transferh+0xc>
            setPinValue(SPIMOSIPin_Define,HIGH);              //-- 2 cycles | -          |
    2468:	2a 9a       	sbi	0x05, 2	; 5
    246a:	02 c0       	rjmp	.+4      	; 0x2470 <_Z12SPI_transferh+0x10>
        } else {                                              //--          | 2 cycles    > 8 cycles for both paths
            nop();                                            //--          | 1 cycle    |
    246c:	00 00       	nop
            setPinValue(SPIMOSIPin_Define,LOW);               //--          | 2 cycles   |
    246e:	2a 98       	cbi	0x05, 2	; 5
        }                                                     //-- 2 cycles | -         '
        setPinValue(SPIClockPin_Define,HIGH); //Rising Edge   //--      2 cycles        .
    2470:	29 9a       	sbi	0x05, 1	; 5
        data = data << 1; //Shift MSB-1 to MSB                //--      1 cycle          |
    2472:	88 0f       	add	r24, r24
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
    2474:	1b 99       	sbic	0x03, 3	; 3
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
    2476:	8f 5f       	subi	r24, 0xFF	; 255
}

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
    2478:	91 50       	subi	r25, 0x01	; 1
    247a:	99 f7       	brne	.-26     	; 0x2462 <_Z12SPI_transferh+0x2>
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
        }                                                     //--       3 cycles       '
    }                                                         //-- Total Path is 16 cycles = 1MHz @ 16MHz clock
    return data; //Return shifted in data.                    //-- 5 Cycles on entry (including CALL), 3 cycles on exit (including RET)
}
    247c:	08 95       	ret

0000247e <_Z8SPI_readv>:
//Performs an SPI read request and stores the data in the RX buffer.
// - If there is no space in the buffer, a read request will *not* be performed
//   The buffer should be first emptied by using Serial_read()
void SPI_read(void) {
    //First we check if there is space in the buffer, and that the slave has data to send
    if ((rxBuf.tail != rxBuf.head) && !(getPinValue(standalonePin[STANDALONE_IRQ]))) {
    247e:	90 91 40 05 	lds	r25, 0x0540
    2482:	80 91 3f 05 	lds	r24, 0x053F
    2486:	98 17       	cp	r25, r24
    2488:	c9 f0       	breq	.+50     	; 0x24bc <_Z8SPI_readv+0x3e>
    248a:	48 99       	sbic	0x09, 0	; 9
    248c:	17 c0       	rjmp	.+46     	; 0x24bc <_Z8SPI_readv+0x3e>
        //If there is, then do a read request  
        setPinValue(SPISSnPin_Define,LOW); //Select the slave
    248e:	28 98       	cbi	0x05, 0	; 5
        SPI_transfer(SPI_READ); //First send a read request
    2490:	81 e8       	ldi	r24, 0x81	; 129
    2492:	0e 94 30 12 	call	0x2460	; 0x2460 <_Z12SPI_transferh>
        while(!getPinValue(standalonePin[STANDALONE_IRQ])); //Wait for the slave to have loaded its data
    2496:	48 9b       	sbis	0x09, 0	; 9
    2498:	fe cf       	rjmp	.-4      	; 0x2496 <_Z8SPI_readv+0x18>
        byte data = SPI_transfer(SPI_RESP); //Then send a response request (clocks data from slave to master and informs slave that transfer is done)
    249a:	80 e8       	ldi	r24, 0x80	; 128
    249c:	0e 94 30 12 	call	0x2460	; 0x2460 <_Z12SPI_transferh>
        if (SPI_ISDATA(data)) {
    24a0:	87 fd       	sbrc	r24, 7
    24a2:	0b c0       	rjmp	.+22     	; 0x24ba <_Z8SPI_readv+0x3c>
            //If the slave had data available (indicated by the MSB being clear)
            rxBuf.buffer[rxBuf.head] = data; //Store the data
    24a4:	e0 91 3f 05 	lds	r30, 0x053F
    24a8:	f0 e0       	ldi	r31, 0x00	; 0
    24aa:	e1 5e       	subi	r30, 0xE1	; 225
    24ac:	fa 4f       	sbci	r31, 0xFA	; 250
    24ae:	80 83       	st	Z, r24
            rxBuf.head++; //And increment the head
    24b0:	80 91 3f 05 	lds	r24, 0x053F
    24b4:	8f 5f       	subi	r24, 0xFF	; 255
    24b6:	80 93 3f 05 	sts	0x053F, r24
        }
        setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    24ba:	28 9a       	sbi	0x05, 0	; 5
    24bc:	08 95       	ret

000024be <_Z9SPI_writeh>:
    }
}

//Performs an SPI write request.
void SPI_write(byte data) {
    setPinValue(SPISSnPin_Define,LOW); //Select the slave
    24be:	28 98       	cbi	0x05, 0	; 5
    SPI_transfer(data & SPI_DATA); 
    24c0:	8f 77       	andi	r24, 0x7F	; 127
    24c2:	0e 94 30 12 	call	0x2460	; 0x2460 <_Z12SPI_transferh>
    setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    24c6:	28 9a       	sbi	0x05, 0	; 5
}
    24c8:	08 95       	ret

000024ca <_Z16Serial_availablev>:

//Checks if there is any data available in the RX buffer.
// - If in SPI mode, this will also perform an SPI read transfer to see if there is any valid data.
byte Serial_available(void) {
    if (softSPIEnabled) {
    24ca:	80 91 41 05 	lds	r24, 0x0541
    24ce:	88 23       	and	r24, r24
    24d0:	11 f0       	breq	.+4      	; 0x24d6 <_Z16Serial_availablev+0xc>
        //If SPI is enabled, we do a read to check if there is any data.
        SPI_read();
    24d2:	0e 94 3f 12 	call	0x247e	; 0x247e <_Z8SPI_readv>
    }
    return ((rxBuf.head - rxBuf.tail) & BUFFER_PTR_MASK); //number of bytes available
    24d6:	80 91 3f 05 	lds	r24, 0x053F
    24da:	90 91 40 05 	lds	r25, 0x0540
    24de:	89 1b       	sub	r24, r25
}
    24e0:	8f 71       	andi	r24, 0x1F	; 31
    24e2:	08 95       	ret

000024e4 <_Z11Serial_readv>:

//Returns the next available data byte in the buffer
// - If there is nothing there, -1 is returned.
char Serial_read(void) {
    //If UART is enabled
    byte tail = rxBuf.tail;
    24e4:	90 91 40 05 	lds	r25, 0x0540
    if (rxBuf.head == tail) {
    24e8:	80 91 3f 05 	lds	r24, 0x053F
    24ec:	89 17       	cp	r24, r25
    24ee:	11 f4       	brne	.+4      	; 0x24f4 <_Z11Serial_readv+0x10>
    24f0:	8f ef       	ldi	r24, 0xFF	; 255
    24f2:	08 95       	ret
        return -1;
    } else {
        char c = rxBuf.buffer[tail];
    24f4:	e9 2f       	mov	r30, r25
    24f6:	f0 e0       	ldi	r31, 0x00	; 0
    24f8:	e1 5e       	subi	r30, 0xE1	; 225
    24fa:	fa 4f       	sbci	r31, 0xFA	; 250
    24fc:	80 81       	ld	r24, Z
        rxBuf.tail = ((tail + 1) & BUFFER_PTR_MASK);
    24fe:	9f 5f       	subi	r25, 0xFF	; 255
    2500:	9f 71       	andi	r25, 0x1F	; 31
    2502:	90 93 40 05 	sts	0x0540, r25
        return c;
    }
}
    2506:	08 95       	ret

00002508 <_Z12Serial_writec>:

//Write a byte of data
// - If in UART mode, the byte is stored into the TX buffer when there is space.
// - If in SPI mode, a write transfer is performed.
void Serial_write(char ch) {
    2508:	28 2f       	mov	r18, r24
    if (UCSRnB & _BV(TXENn)) { 
    250a:	80 91 c1 00 	lds	r24, 0x00C1
    250e:	83 ff       	sbrs	r24, 3
    2510:	1f c0       	rjmp	.+62     	; 0x2550 <_Z12Serial_writec+0x48>
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
    2512:	90 91 1d 05 	lds	r25, 0x051D
    2516:	9f 5f       	subi	r25, 0xFF	; 255
    2518:	9f 71       	andi	r25, 0x1F	; 31
        if (head == txBuf.tail) {
    251a:	80 91 1e 05 	lds	r24, 0x051E
    251e:	98 17       	cp	r25, r24
    2520:	49 f4       	brne	.+18     	; 0x2534 <_Z12Serial_writec+0x2c>
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
    2522:	80 91 c1 00 	lds	r24, 0x00C1
    2526:	80 62       	ori	r24, 0x20	; 32
    2528:	80 93 c1 00 	sts	0x00C1, r24
            while (head == txBuf.tail); //wait for buffer to have some space
    252c:	80 91 1e 05 	lds	r24, 0x051E
    2530:	98 17       	cp	r25, r24
    2532:	e1 f3       	breq	.-8      	; 0x252c <_Z12Serial_writec+0x24>
        }
        
        txBuf.buffer[txBuf.head] = ch; //Load the new data into the buffer
    2534:	e0 91 1d 05 	lds	r30, 0x051D
    2538:	f0 e0       	ldi	r31, 0x00	; 0
    253a:	e3 50       	subi	r30, 0x03	; 3
    253c:	fb 4f       	sbci	r31, 0xFB	; 251
    253e:	20 83       	st	Z, r18
        txBuf.head = head; //And store the new head.
    2540:	90 93 1d 05 	sts	0x051D, r25
        sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled if not already
    2544:	80 91 c1 00 	lds	r24, 0x00C1
    2548:	80 62       	ori	r24, 0x20	; 32
    254a:	80 93 c1 00 	sts	0x00C1, r24
    254e:	08 95       	ret
    } else if (softSPIEnabled) {
    2550:	80 91 41 05 	lds	r24, 0x0541
    2554:	88 23       	and	r24, r24
    2556:	19 f0       	breq	.+6      	; 0x255e <_Z12Serial_writec+0x56>
        //If SPI is enabled, we do an SPI write.
        SPI_write(ch);
    2558:	82 2f       	mov	r24, r18
    255a:	0e 94 5f 12 	call	0x24be	; 0x24be <_Z9SPI_writeh>
    255e:	08 95       	ret

00002560 <_Z12Serial_flushv>:
    }
}

//Flushes data from TX buffer
void Serial_flush() {
    if (UCSRnB & _BV(TXENn)) { 
    2560:	80 91 c1 00 	lds	r24, 0x00C1
    2564:	83 ff       	sbrs	r24, 3
    2566:	11 c0       	rjmp	.+34     	; 0x258a <_Z12Serial_flushv+0x2a>
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
    2568:	90 91 1d 05 	lds	r25, 0x051D
    256c:	9f 5f       	subi	r25, 0xFF	; 255
    256e:	9f 71       	andi	r25, 0x1F	; 31
        if (head == txBuf.tail) {
    2570:	80 91 1e 05 	lds	r24, 0x051E
    2574:	98 17       	cp	r25, r24
    2576:	49 f4       	brne	.+18     	; 0x258a <_Z12Serial_flushv+0x2a>
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
    2578:	80 91 c1 00 	lds	r24, 0x00C1
    257c:	80 62       	ori	r24, 0x20	; 32
    257e:	80 93 c1 00 	sts	0x00C1, r24
            while (head == txBuf.tail); //wait for buffer to have some space
    2582:	80 91 1e 05 	lds	r24, 0x051E
    2586:	98 17       	cp	r25, r24
    2588:	e1 f3       	breq	.-8      	; 0x2582 <_Z12Serial_flushv+0x22>
    258a:	08 95       	ret

0000258c <_Z15Serial_writeStrPc>:
        }
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    258c:	cf 93       	push	r28
    258e:	df 93       	push	r29
    2590:	ec 01       	movw	r28, r24
    2592:	03 c0       	rjmp	.+6      	; 0x259a <_Z15Serial_writeStrPc+0xe>
    while (*str) {
        Serial_write(*str++);
    2594:	21 96       	adiw	r28, 0x01	; 1
    2596:	0e 94 84 12 	call	0x2508	; 0x2508 <_Z12Serial_writec>
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    while (*str) {
    259a:	88 81       	ld	r24, Y
    259c:	88 23       	and	r24, r24
    259e:	d1 f7       	brne	.-12     	; 0x2594 <_Z15Serial_writeStrPc+0x8>
        Serial_write(*str++);
    }
}
    25a0:	df 91       	pop	r29
    25a2:	cf 91       	pop	r28
    25a4:	08 95       	ret

000025a6 <__vector_25>:
        "push r30    \n\t"
        "push r31    \n\t"
        :
        : "a" (c), "r" (head), "r" (tail), "I" (_SFR_IO_ADDR(SREG))
        :
    );
    25a6:	2f 93       	push	r18
    25a8:	2f b7       	in	r18, 0x3f	; 63
    25aa:	2f 93       	push	r18
    25ac:	9f 93       	push	r25
    25ae:	8f 93       	push	r24
    25b0:	ef 93       	push	r30
    25b2:	ff 93       	push	r31

    //Read in from the serial data register
    c = UDRn;
    25b4:	20 91 c6 00 	lds	r18, 0x00C6
    //get the current head
    head = rxBuf.head;
    25b8:	90 91 3f 05 	lds	r25, 0x053F
    head++;
    head &= BUFFER_PTR_MASK;
    25bc:	9f 5f       	subi	r25, 0xFF	; 255
    25be:	9f 71       	andi	r25, 0x1F	; 31
    tail = rxBuf.tail;
    25c0:	80 91 40 05 	lds	r24, 0x0540

    if (head != tail) {
    25c4:	98 17       	cp	r25, r24
    25c6:	41 f0       	breq	.+16     	; 0x25d8 <__vector_25+0x32>
        rxBuf.buffer[rxBuf.head] = c;
    25c8:	e0 91 3f 05 	lds	r30, 0x053F
    25cc:	f0 e0       	ldi	r31, 0x00	; 0
    25ce:	e1 5e       	subi	r30, 0xE1	; 225
    25d0:	fa 4f       	sbci	r31, 0xFA	; 250
    25d2:	20 83       	st	Z, r18
        rxBuf.head = head;
    25d4:	90 93 3f 05 	sts	0x053F, r25
        "pop %0     \n\t"
        "reti       \n\t"
        : "=a" (c), "=r" (head), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
    25d8:	ff 91       	pop	r31
    25da:	ef 91       	pop	r30
    25dc:	8f 91       	pop	r24
    25de:	9f 91       	pop	r25
    25e0:	2f 91       	pop	r18
    25e2:	2f bf       	out	0x3f, r18	; 63
    25e4:	2f 91       	pop	r18
    25e6:	18 95       	reti

000025e8 <__vector_26>:
        "push %0       \n\t"
        "push %1       \n\t"
        "push r30      \n\t"
        "push r31      \n\t"
        :: "r" (temp), "r" (tail), "I" (_SFR_IO_ADDR(SREG)):
    );
    25e8:	8f 93       	push	r24
    25ea:	8f b7       	in	r24, 0x3f	; 63
    25ec:	8f 93       	push	r24
    25ee:	9f 93       	push	r25
    25f0:	ef 93       	push	r30
    25f2:	ff 93       	push	r31
    tail = txBuf.tail;
    25f4:	90 91 1e 05 	lds	r25, 0x051E
    temp = txBuf.head;
    25f8:	80 91 1d 05 	lds	r24, 0x051D
    if (temp == tail) {
    25fc:	89 17       	cp	r24, r25
    25fe:	31 f4       	brne	.+12     	; 0x260c <__vector_26+0x24>
        // Buffer empty, so disable interrupts
        cbi(UCSRnB, UDRIEn);
    2600:	80 91 c1 00 	lds	r24, 0x00C1
    2604:	8f 7d       	andi	r24, 0xDF	; 223
    2606:	80 93 c1 00 	sts	0x00C1, r24
    260a:	0b c0       	rjmp	.+22     	; 0x2622 <__vector_26+0x3a>
    } else {
        // There is more data in the output buffer. Send the next byte
        temp = txBuf.buffer[tail];
    260c:	e9 2f       	mov	r30, r25
    260e:	f0 e0       	ldi	r31, 0x00	; 0
    2610:	e3 50       	subi	r30, 0x03	; 3
    2612:	fb 4f       	sbci	r31, 0xFB	; 251
    2614:	80 81       	ld	r24, Z
        tail++;
    2616:	9f 5f       	subi	r25, 0xFF	; 255
        tail &= BUFFER_PTR_MASK;
    2618:	9f 71       	andi	r25, 0x1F	; 31
        txBuf.tail = tail;
    261a:	90 93 1e 05 	sts	0x051E, r25
        UDRn = temp;
    261e:	80 93 c6 00 	sts	0x00C6, r24
        "pop %0     \n\t"
        "reti       \n\t"
        : "=r" (temp), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
    2622:	ff 91       	pop	r31
    2624:	ef 91       	pop	r30
    2626:	9f 91       	pop	r25
    2628:	8f 91       	pop	r24
    262a:	8f bf       	out	0x3f, r24	; 63
    262c:	8f 91       	pop	r24
    262e:	18 95       	reti

00002630 <_Z9hexToBytePc>:
    if (hex > '9'){
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    }
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    2630:	fc 01       	movw	r30, r24
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    2632:	91 81       	ldd	r25, Z+1	; 0x01
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
    2634:	9a 33       	cpi	r25, 0x3A	; 58
    2636:	0c f0       	brlt	.+2      	; 0x263a <_Z9hexToBytePc+0xa>
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    2638:	97 50       	subi	r25, 0x07	; 7
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    263a:	80 81       	ld	r24, Z
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
    263c:	8a 33       	cpi	r24, 0x3A	; 58
    263e:	0c f0       	brlt	.+2      	; 0x2642 <_Z9hexToBytePc+0x12>
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    2640:	87 50       	subi	r24, 0x07	; 7
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
    2642:	82 95       	swap	r24
    2644:	80 7f       	andi	r24, 0xF0	; 240
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    2646:	9f 70       	andi	r25, 0x0F	; 15
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
}
    2648:	89 2b       	or	r24, r25
    264a:	08 95       	ret

0000264c <_Z15synta_hexToBytePc>:

byte synta_hexToByte(char* hex){
    return hexToByte(hex);
    264c:	0e 94 18 13 	call	0x2630	; 0x2630 <_Z9hexToBytePc>
}
    2650:	08 95       	ret

00002652 <_Z15synta_hexToLongPc>:
unsigned long synta_hexToLong(char* hex){
    2652:	ef 92       	push	r14
    2654:	ff 92       	push	r15
    2656:	0f 93       	push	r16
    2658:	1f 93       	push	r17
    265a:	8c 01       	movw	r16, r24
    //  strncpy(str+2,&hex[2],2); //Middle Byte
    //  strncpy(str+4,hex,2); //Upper Byte
    //  str[6] = 0;
    //  return strtol(str,&boo,16); //convert hex to long integer

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    265c:	04 96       	adiw	r24, 0x04	; 4
    265e:	0e 94 18 13 	call	0x2630	; 0x2630 <_Z9hexToBytePc>
    2662:	e8 2e       	mov	r14, r24
    2664:	c8 01       	movw	r24, r16
    2666:	02 96       	adiw	r24, 0x02	; 2
    2668:	0e 94 18 13 	call	0x2630	; 0x2630 <_Z9hexToBytePc>
    266c:	f8 2e       	mov	r15, r24
    266e:	c8 01       	movw	r24, r16
    2670:	0e 94 18 13 	call	0x2630	; 0x2630 <_Z9hexToBytePc>
    return inter.integer; //and convert it to an integer
}
    2674:	68 2f       	mov	r22, r24
    2676:	7f 2d       	mov	r23, r15
    2678:	8e 2d       	mov	r24, r14
    267a:	90 e0       	ldi	r25, 0x00	; 0
    267c:	1f 91       	pop	r17
    267e:	0f 91       	pop	r16
    2680:	ff 90       	pop	r15
    2682:	ef 90       	pop	r14
    2684:	08 95       	ret

00002686 <_Z10synta_axish>:
char synta_command(){
    return _command;
}

byte synta_axis(byte axis){
    if(axis < 2){
    2686:	82 30       	cpi	r24, 0x02	; 2
    2688:	10 f4       	brcc	.+4      	; 0x268e <_Z10synta_axish+0x8>
        _axis = axis;
    268a:	80 93 4f 05 	sts	0x054F, r24
    }
    return _axis;
}
    268e:	80 91 4f 05 	lds	r24, 0x054F
    2692:	08 95       	ret

00002694 <_Z21synta_validateCommandhPc>:
    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    2694:	ef 92       	push	r14
    2696:	ff 92       	push	r15
    2698:	1f 93       	push	r17
    269a:	cf 93       	push	r28
    269c:	df 93       	push	r29
    269e:	18 2f       	mov	r17, r24
    26a0:	7b 01       	movw	r14, r22
    _command = commandString[0]; //first byte is command
    26a2:	90 91 43 05 	lds	r25, 0x0543
    26a6:	90 93 50 05 	sts	0x0550, r25
    _axis = commandString[1] - 49; //second byte is axis
    26aa:	80 91 44 05 	lds	r24, 0x0544
    26ae:	81 53       	subi	r24, 0x31	; 49
    26b0:	80 93 4f 05 	sts	0x054F, r24
    if(_axis > 1){
    26b4:	82 30       	cpi	r24, 0x02	; 2
    26b6:	f8 f4       	brcc	.+62     	; 0x26f6 <_Z21synta_validateCommandhPc+0x62>
        return false; //incorrect axis
    }
    char requiredLength = Commands_getLength(_command,1); //get the required length of this command
    26b8:	89 2f       	mov	r24, r25
    26ba:	61 e0       	ldi	r22, 0x01	; 1
    26bc:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <_Z18Commands_getLengthcb>
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    26c0:	13 50       	subi	r17, 0x03	; 3
    if(requiredLength != len){ //If invalid command, or not required length
    26c2:	28 2f       	mov	r18, r24
    26c4:	33 27       	eor	r19, r19
    26c6:	27 fd       	sbrc	r18, 7
    26c8:	30 95       	com	r19
    26ca:	81 2f       	mov	r24, r17
    26cc:	90 e0       	ldi	r25, 0x00	; 0
    26ce:	28 17       	cp	r18, r24
    26d0:	39 07       	cpc	r19, r25
    26d2:	89 f4       	brne	.+34     	; 0x26f6 <_Z21synta_validateCommandhPc+0x62>
    26d4:	a5 e4       	ldi	r26, 0x45	; 69
    26d6:	b5 e0       	ldi	r27, 0x05	; 5
    26d8:	e7 01       	movw	r28, r14
    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    26da:	f9 01       	movw	r30, r18
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
    26dc:	2a 0f       	add	r18, r26
    26de:	3b 1f       	adc	r19, r27
    26e0:	02 c0       	rjmp	.+4      	; 0x26e6 <_Z21synta_validateCommandhPc+0x52>
        decoded[i] = commandString[i + 2];
    26e2:	8d 91       	ld	r24, X+
    26e4:	89 93       	st	Y+, r24
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
    26e6:	a2 17       	cp	r26, r18
    26e8:	b3 07       	cpc	r27, r19
    26ea:	d9 f7       	brne	.-10     	; 0x26e2 <_Z21synta_validateCommandhPc+0x4e>
        decoded[i] = commandString[i + 2];
    }
    decoded[i] = '\0'; //Null
    26ec:	ee 0d       	add	r30, r14
    26ee:	ff 1d       	adc	r31, r15
    26f0:	10 82       	st	Z, r1
    26f2:	81 e0       	ldi	r24, 0x01	; 1
    26f4:	01 c0       	rjmp	.+2      	; 0x26f8 <_Z21synta_validateCommandhPc+0x64>
    return true;
    26f6:	80 e0       	ldi	r24, 0x00	; 0
}
    26f8:	df 91       	pop	r29
    26fa:	cf 91       	pop	r28
    26fc:	1f 91       	pop	r17
    26fe:	ff 90       	pop	r15
    2700:	ef 90       	pop	r14
    2702:	08 95       	ret

00002704 <_Z20synta_recieveCommandPcc>:

char synta_recieveCommand(char* dataPacket, char character){
    2704:	cf 93       	push	r28
    2706:	df 93       	push	r29
    2708:	ec 01       	movw	r28, r24
    if(validPacket){
    270a:	80 91 42 05 	lds	r24, 0x0542
    270e:	88 23       	and	r24, r24
    2710:	21 f1       	breq	.+72     	; 0x275a <_Z20synta_recieveCommandPcc+0x56>
        if (character == startInChar){
    2712:	6a 33       	cpi	r22, 0x3A	; 58
    2714:	49 f4       	brne	.+18     	; 0x2728 <_Z20synta_recieveCommandPcc+0x24>
            dataPacket[0] = errorChar;
    2716:	81 e2       	ldi	r24, 0x21	; 33
    2718:	88 83       	st	Y, r24
            dataPacket[1] = endChar;
    271a:	8d e0       	ldi	r24, 0x0D	; 13
    271c:	89 83       	std	Y+1, r24	; 0x01
            dataPacket[2] = '\0';
    271e:	1a 82       	std	Y+2, r1	; 0x02
            validPacket = 0; //new command without old finishing! (dataPacket contains error message)
    2720:	10 92 42 05 	sts	0x0542, r1
    2724:	8e ef       	ldi	r24, 0xFE	; 254
    2726:	2d c0       	rjmp	.+90     	; 0x2782 <_Z20synta_recieveCommandPcc+0x7e>
            return -2;
        }

        commandString[commandIndex++] = character; //Add character to current string build
    2728:	80 91 4e 05 	lds	r24, 0x054E
    272c:	e8 2f       	mov	r30, r24
    272e:	f0 e0       	ldi	r31, 0x00	; 0
    2730:	ed 5b       	subi	r30, 0xBD	; 189
    2732:	fa 4f       	sbci	r31, 0xFA	; 250
    2734:	60 83       	st	Z, r22
    2736:	8f 5f       	subi	r24, 0xFF	; 255
    2738:	80 93 4e 05 	sts	0x054E, r24

        if(character == endChar){
    273c:	6d 30       	cpi	r22, 0x0D	; 13
    273e:	51 f4       	brne	.+20     	; 0x2754 <_Z20synta_recieveCommandPcc+0x50>
            if(synta_validateCommand(commandIndex, dataPacket)){
    2740:	be 01       	movw	r22, r28
    2742:	0e 94 4a 13 	call	0x2694	; 0x2694 <_Z21synta_validateCommandhPc>
    2746:	88 23       	and	r24, r24
    2748:	91 f0       	breq	.+36     	; 0x276e <_Z20synta_recieveCommandPcc+0x6a>
                validPacket = 0;
    274a:	10 92 42 05 	sts	0x0542, r1
                return _command; //Successful decode (dataPacket contains decoded packet, return value is the current command)
    274e:	80 91 50 05 	lds	r24, 0x0550
    2752:	17 c0       	rjmp	.+46     	; 0x2782 <_Z20synta_recieveCommandPcc+0x7e>
            } else {
                goto error; //Decode Failed (dataPacket contains error message)
            }
        } else if (commandIndex == sizeof(commandString)){
    2754:	8b 30       	cpi	r24, 0x0B	; 11
    2756:	a1 f4       	brne	.+40     	; 0x2780 <_Z20synta_recieveCommandPcc+0x7c>
    2758:	0a c0       	rjmp	.+20     	; 0x276e <_Z20synta_recieveCommandPcc+0x6a>
            goto error; //Message too long! (dataPacket contains error message)
        }
    } else if (character == startInChar){
    275a:	6a 33       	cpi	r22, 0x3A	; 58
    275c:	89 f4       	brne	.+34     	; 0x2780 <_Z20synta_recieveCommandPcc+0x7c>
        //Begin new command
        commandIndex = 0;
    275e:	10 92 4e 05 	sts	0x054E, r1
        validPacket = 1;
    2762:	81 e0       	ldi	r24, 0x01	; 1
    2764:	80 93 42 05 	sts	0x0542, r24
        commandString[0] = '\0';
    2768:	10 92 43 05 	sts	0x0543, r1
    276c:	09 c0       	rjmp	.+18     	; 0x2780 <_Z20synta_recieveCommandPcc+0x7c>
    }
    return 0; //Decode not finished (dataPacket unchanged)
error:
    dataPacket[0] = errorChar;
    276e:	81 e2       	ldi	r24, 0x21	; 33
    2770:	88 83       	st	Y, r24
    dataPacket[1] = endChar;
    2772:	8d e0       	ldi	r24, 0x0D	; 13
    2774:	89 83       	std	Y+1, r24	; 0x01
    dataPacket[2] = '\0';
    2776:	1a 82       	std	Y+2, r1	; 0x02
    validPacket = 0;
    2778:	10 92 42 05 	sts	0x0542, r1
    277c:	8f ef       	ldi	r24, 0xFF	; 255
    277e:	01 c0       	rjmp	.+2      	; 0x2782 <_Z20synta_recieveCommandPcc+0x7e>
    return -1;
    2780:	80 e0       	ldi	r24, 0x00	; 0
}
    2782:	df 91       	pop	r29
    2784:	cf 91       	pop	r28
    2786:	08 95       	ret

00002788 <_Z22synta_assembleResponsePccm>:
inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
}

void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData){
    2788:	ff 92       	push	r15
    278a:	0f 93       	push	r16
    278c:	1f 93       	push	r17
    278e:	cf 93       	push	r28
    2790:	df 93       	push	r29
    2792:	ec 01       	movw	r28, r24
    2794:	12 2f       	mov	r17, r18
    2796:	03 2f       	mov	r16, r19
    2798:	f4 2e       	mov	r15, r20
    char replyLength = (commandOrError == '\0') ? -1 : Commands_getLength(commandOrError,0); //get the number of data bytes for response
    279a:	66 23       	and	r22, r22
    279c:	39 f0       	breq	.+14     	; 0x27ac <_Z22synta_assembleResponsePccm+0x24>
    279e:	86 2f       	mov	r24, r22
    27a0:	60 e0       	ldi	r22, 0x00	; 0
    27a2:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <_Z18Commands_getLengthcb>
    27a6:	98 2f       	mov	r25, r24

    if (replyLength < 0) {
    27a8:	87 ff       	sbrs	r24, 7
    27aa:	04 c0       	rjmp	.+8      	; 0x27b4 <_Z22synta_assembleResponsePccm+0x2c>
        replyLength = 0;
        dataPacket[0] = errorChar;  
    27ac:	81 e2       	ldi	r24, 0x21	; 33
    27ae:	88 83       	st	Y, r24
    27b0:	90 e0       	ldi	r25, 0x00	; 0
    27b2:	4e c0       	rjmp	.+156    	; 0x2850 <_Z22synta_assembleResponsePccm+0xc8>
    } else {
        dataPacket[0] = startOutChar;
    27b4:	8d e3       	ldi	r24, 0x3D	; 61
    27b6:	88 83       	st	Y, r24

        if (replyLength == 2) {
    27b8:	92 30       	cpi	r25, 0x02	; 2
    27ba:	d9 f1       	breq	.+118    	; 0x2832 <_Z22synta_assembleResponsePccm+0xaa>
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
    27bc:	93 30       	cpi	r25, 0x03	; 3
    27be:	c9 f4       	brne	.+50     	; 0x27f2 <_Z22synta_assembleResponsePccm+0x6a>
            DoubleNibbler nibble = { responseData };
    27c0:	21 2f       	mov	r18, r17
    27c2:	30 2f       	mov	r19, r16
            nibbleToHex(dataPacket+3, nibble.low);
    27c4:	81 2f       	mov	r24, r17
    27c6:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    27c8:	8a 30       	cpi	r24, 0x0A	; 10
    27ca:	08 f0       	brcs	.+2      	; 0x27ce <_Z22synta_assembleResponsePccm+0x46>
        nibble += (('A'-'0')-0xA);
    27cc:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    27ce:	80 5d       	subi	r24, 0xD0	; 208
    27d0:	8b 83       	std	Y+3, r24	; 0x03
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
    27d2:	82 2f       	mov	r24, r18
    27d4:	82 95       	swap	r24
    27d6:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    27d8:	8a 30       	cpi	r24, 0x0A	; 10
    27da:	08 f0       	brcs	.+2      	; 0x27de <_Z22synta_assembleResponsePccm+0x56>
        nibble += (('A'-'0')-0xA);
    27dc:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    27de:	80 5d       	subi	r24, 0xD0	; 208
    27e0:	8a 83       	std	Y+2, r24	; 0x02
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
    27e2:	83 2f       	mov	r24, r19
    27e4:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    27e6:	8a 30       	cpi	r24, 0x0A	; 10
    27e8:	08 f0       	brcs	.+2      	; 0x27ec <_Z22synta_assembleResponsePccm+0x64>
        nibble += (('A'-'0')-0xA);
    27ea:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    27ec:	80 5d       	subi	r24, 0xD0	; 208
    27ee:	89 83       	std	Y+1, r24	; 0x01
    27f0:	2f c0       	rjmp	.+94     	; 0x2850 <_Z22synta_assembleResponsePccm+0xc8>
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
        } else if (replyLength == 6) {
    27f2:	96 30       	cpi	r25, 0x06	; 6
    27f4:	69 f5       	brne	.+90     	; 0x2850 <_Z22synta_assembleResponsePccm+0xc8>
    }
    *hex = (nibble + '0');
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    27f6:	8f 2d       	mov	r24, r15
    27f8:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    27fa:	8a 30       	cpi	r24, 0x0A	; 10
    27fc:	08 f0       	brcs	.+2      	; 0x2800 <_Z22synta_assembleResponsePccm+0x78>
        nibble += (('A'-'0')-0xA);
    27fe:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    2800:	80 5d       	subi	r24, 0xD0	; 208
    2802:	8e 83       	std	Y+6, r24	; 0x06
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    2804:	4f 2d       	mov	r20, r15
    2806:	42 95       	swap	r20
    2808:	4f 70       	andi	r20, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    280a:	4a 30       	cpi	r20, 0x0A	; 10
    280c:	08 f0       	brcs	.+2      	; 0x2810 <_Z22synta_assembleResponsePccm+0x88>
        nibble += (('A'-'0')-0xA);
    280e:	49 5f       	subi	r20, 0xF9	; 249
    }
    *hex = (nibble + '0');
    2810:	40 5d       	subi	r20, 0xD0	; 208
    2812:	4d 83       	std	Y+5, r20	; 0x05
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    2814:	80 2f       	mov	r24, r16
    2816:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2818:	8a 30       	cpi	r24, 0x0A	; 10
    281a:	08 f0       	brcs	.+2      	; 0x281e <_Z22synta_assembleResponsePccm+0x96>
        nibble += (('A'-'0')-0xA);
    281c:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    281e:	80 5d       	subi	r24, 0xD0	; 208
    2820:	8c 83       	std	Y+4, r24	; 0x04
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    2822:	30 2f       	mov	r19, r16
    2824:	32 95       	swap	r19
    2826:	3f 70       	andi	r19, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2828:	3a 30       	cpi	r19, 0x0A	; 10
    282a:	08 f0       	brcs	.+2      	; 0x282e <_Z22synta_assembleResponsePccm+0xa6>
        nibble += (('A'-'0')-0xA);
    282c:	39 5f       	subi	r19, 0xF9	; 249
    }
    *hex = (nibble + '0');
    282e:	30 5d       	subi	r19, 0xD0	; 208
    2830:	3b 83       	std	Y+3, r19	; 0x03
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    2832:	81 2f       	mov	r24, r17
    2834:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2836:	8a 30       	cpi	r24, 0x0A	; 10
    2838:	08 f0       	brcs	.+2      	; 0x283c <_Z22synta_assembleResponsePccm+0xb4>
        nibble += (('A'-'0')-0xA);
    283a:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    283c:	80 5d       	subi	r24, 0xD0	; 208
    283e:	8a 83       	std	Y+2, r24	; 0x02
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    2840:	21 2f       	mov	r18, r17
    2842:	22 95       	swap	r18
    2844:	2f 70       	andi	r18, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2846:	2a 30       	cpi	r18, 0x0A	; 10
    2848:	08 f0       	brcs	.+2      	; 0x284c <_Z22synta_assembleResponsePccm+0xc4>
        nibble += (('A'-'0')-0xA);
    284a:	29 5f       	subi	r18, 0xF9	; 249
    }
    *hex = (nibble + '0');
    284c:	20 5d       	subi	r18, 0xD0	; 208
    284e:	29 83       	std	Y+1, r18	; 0x01
            private_byteToHex(dataPacket+2,dataPacket+1,inter.lowByter.lowNibbler);
        }

    }

    dataPacket[(byte)replyLength + 1] = endChar;
    2850:	fe 01       	movw	r30, r28
    2852:	e9 0f       	add	r30, r25
    2854:	f1 1d       	adc	r31, r1
    2856:	8d e0       	ldi	r24, 0x0D	; 13
    2858:	81 83       	std	Z+1, r24	; 0x01
    dataPacket[(byte)replyLength + 2] = '\0';  
    285a:	12 82       	std	Z+2, r1	; 0x02
    return;
}
    285c:	df 91       	pop	r29
    285e:	cf 91       	pop	r28
    2860:	1f 91       	pop	r17
    2862:	0f 91       	pop	r16
    2864:	ff 90       	pop	r15
    2866:	08 95       	ret

00002868 <_Z16synta_initialisemh>:

byte _axis;
char _command;

void synta_initialise(unsigned long eVal, byte gVal){
    validPacket = 0;
    2868:	10 92 42 05 	sts	0x0542, r1
    commandIndex = 0;
    286c:	10 92 4e 05 	sts	0x054E, r1
    memset(commandString,0,sizeof(commandString));
    2870:	2b e0       	ldi	r18, 0x0B	; 11
    2872:	e3 e4       	ldi	r30, 0x43	; 67
    2874:	f5 e0       	ldi	r31, 0x05	; 5
    2876:	df 01       	movw	r26, r30
    2878:	1d 92       	st	X+, r1
    287a:	2a 95       	dec	r18
    287c:	e9 f7       	brne	.-6      	; 0x2878 <_Z16synta_initialisemh+0x10>
    _axis = 0;
    287e:	10 92 4f 05 	sts	0x054F, r1
    Commands_init(eVal, gVal);
    2882:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <_Z13Commands_initmh>
}
    2886:	08 95       	ret

00002888 <__subsf3>:
    2888:	50 58       	subi	r21, 0x80	; 128

0000288a <__addsf3>:
    288a:	bb 27       	eor	r27, r27
    288c:	aa 27       	eor	r26, r26
    288e:	0e d0       	rcall	.+28     	; 0x28ac <__addsf3x>
    2890:	86 c1       	rjmp	.+780    	; 0x2b9e <__fp_round>
    2892:	77 d1       	rcall	.+750    	; 0x2b82 <__fp_pscA>
    2894:	30 f0       	brcs	.+12     	; 0x28a2 <__addsf3+0x18>
    2896:	7c d1       	rcall	.+760    	; 0x2b90 <__fp_pscB>
    2898:	20 f0       	brcs	.+8      	; 0x28a2 <__addsf3+0x18>
    289a:	31 f4       	brne	.+12     	; 0x28a8 <__addsf3+0x1e>
    289c:	9f 3f       	cpi	r25, 0xFF	; 255
    289e:	11 f4       	brne	.+4      	; 0x28a4 <__addsf3+0x1a>
    28a0:	1e f4       	brtc	.+6      	; 0x28a8 <__addsf3+0x1e>
    28a2:	6c c1       	rjmp	.+728    	; 0x2b7c <__fp_nan>
    28a4:	0e f4       	brtc	.+2      	; 0x28a8 <__addsf3+0x1e>
    28a6:	e0 95       	com	r30
    28a8:	e7 fb       	bst	r30, 7
    28aa:	37 c1       	rjmp	.+622    	; 0x2b1a <__fp_inf>

000028ac <__addsf3x>:
    28ac:	e9 2f       	mov	r30, r25
    28ae:	88 d1       	rcall	.+784    	; 0x2bc0 <__fp_split3>
    28b0:	80 f3       	brcs	.-32     	; 0x2892 <__addsf3+0x8>
    28b2:	ba 17       	cp	r27, r26
    28b4:	62 07       	cpc	r22, r18
    28b6:	73 07       	cpc	r23, r19
    28b8:	84 07       	cpc	r24, r20
    28ba:	95 07       	cpc	r25, r21
    28bc:	18 f0       	brcs	.+6      	; 0x28c4 <__addsf3x+0x18>
    28be:	71 f4       	brne	.+28     	; 0x28dc <__addsf3x+0x30>
    28c0:	9e f5       	brtc	.+102    	; 0x2928 <__addsf3x+0x7c>
    28c2:	b7 c1       	rjmp	.+878    	; 0x2c32 <__fp_zero>
    28c4:	0e f4       	brtc	.+2      	; 0x28c8 <__addsf3x+0x1c>
    28c6:	e0 95       	com	r30
    28c8:	0b 2e       	mov	r0, r27
    28ca:	ba 2f       	mov	r27, r26
    28cc:	a0 2d       	mov	r26, r0
    28ce:	0b 01       	movw	r0, r22
    28d0:	b9 01       	movw	r22, r18
    28d2:	90 01       	movw	r18, r0
    28d4:	0c 01       	movw	r0, r24
    28d6:	ca 01       	movw	r24, r20
    28d8:	a0 01       	movw	r20, r0
    28da:	11 24       	eor	r1, r1
    28dc:	ff 27       	eor	r31, r31
    28de:	59 1b       	sub	r21, r25
    28e0:	99 f0       	breq	.+38     	; 0x2908 <__addsf3x+0x5c>
    28e2:	59 3f       	cpi	r21, 0xF9	; 249
    28e4:	50 f4       	brcc	.+20     	; 0x28fa <__addsf3x+0x4e>
    28e6:	50 3e       	cpi	r21, 0xE0	; 224
    28e8:	68 f1       	brcs	.+90     	; 0x2944 <__addsf3x+0x98>
    28ea:	1a 16       	cp	r1, r26
    28ec:	f0 40       	sbci	r31, 0x00	; 0
    28ee:	a2 2f       	mov	r26, r18
    28f0:	23 2f       	mov	r18, r19
    28f2:	34 2f       	mov	r19, r20
    28f4:	44 27       	eor	r20, r20
    28f6:	58 5f       	subi	r21, 0xF8	; 248
    28f8:	f3 cf       	rjmp	.-26     	; 0x28e0 <__addsf3x+0x34>
    28fa:	46 95       	lsr	r20
    28fc:	37 95       	ror	r19
    28fe:	27 95       	ror	r18
    2900:	a7 95       	ror	r26
    2902:	f0 40       	sbci	r31, 0x00	; 0
    2904:	53 95       	inc	r21
    2906:	c9 f7       	brne	.-14     	; 0x28fa <__addsf3x+0x4e>
    2908:	7e f4       	brtc	.+30     	; 0x2928 <__addsf3x+0x7c>
    290a:	1f 16       	cp	r1, r31
    290c:	ba 0b       	sbc	r27, r26
    290e:	62 0b       	sbc	r22, r18
    2910:	73 0b       	sbc	r23, r19
    2912:	84 0b       	sbc	r24, r20
    2914:	ba f0       	brmi	.+46     	; 0x2944 <__addsf3x+0x98>
    2916:	91 50       	subi	r25, 0x01	; 1
    2918:	a1 f0       	breq	.+40     	; 0x2942 <__addsf3x+0x96>
    291a:	ff 0f       	add	r31, r31
    291c:	bb 1f       	adc	r27, r27
    291e:	66 1f       	adc	r22, r22
    2920:	77 1f       	adc	r23, r23
    2922:	88 1f       	adc	r24, r24
    2924:	c2 f7       	brpl	.-16     	; 0x2916 <__addsf3x+0x6a>
    2926:	0e c0       	rjmp	.+28     	; 0x2944 <__addsf3x+0x98>
    2928:	ba 0f       	add	r27, r26
    292a:	62 1f       	adc	r22, r18
    292c:	73 1f       	adc	r23, r19
    292e:	84 1f       	adc	r24, r20
    2930:	48 f4       	brcc	.+18     	; 0x2944 <__addsf3x+0x98>
    2932:	87 95       	ror	r24
    2934:	77 95       	ror	r23
    2936:	67 95       	ror	r22
    2938:	b7 95       	ror	r27
    293a:	f7 95       	ror	r31
    293c:	9e 3f       	cpi	r25, 0xFE	; 254
    293e:	08 f0       	brcs	.+2      	; 0x2942 <__addsf3x+0x96>
    2940:	b3 cf       	rjmp	.-154    	; 0x28a8 <__addsf3+0x1e>
    2942:	93 95       	inc	r25
    2944:	88 0f       	add	r24, r24
    2946:	08 f0       	brcs	.+2      	; 0x294a <__addsf3x+0x9e>
    2948:	99 27       	eor	r25, r25
    294a:	ee 0f       	add	r30, r30
    294c:	97 95       	ror	r25
    294e:	87 95       	ror	r24
    2950:	08 95       	ret

00002952 <ceil>:
    2952:	58 d1       	rcall	.+688    	; 0x2c04 <__fp_trunc>
    2954:	80 f0       	brcs	.+32     	; 0x2976 <ceil+0x24>
    2956:	9f 37       	cpi	r25, 0x7F	; 127
    2958:	40 f4       	brcc	.+16     	; 0x296a <ceil+0x18>
    295a:	91 11       	cpse	r25, r1
    295c:	0e f4       	brtc	.+2      	; 0x2960 <ceil+0xe>
    295e:	6a c1       	rjmp	.+724    	; 0x2c34 <__fp_szero>
    2960:	60 e0       	ldi	r22, 0x00	; 0
    2962:	70 e0       	ldi	r23, 0x00	; 0
    2964:	80 e8       	ldi	r24, 0x80	; 128
    2966:	9f e3       	ldi	r25, 0x3F	; 63
    2968:	08 95       	ret
    296a:	26 f0       	brts	.+8      	; 0x2974 <ceil+0x22>
    296c:	1b 16       	cp	r1, r27
    296e:	61 1d       	adc	r22, r1
    2970:	71 1d       	adc	r23, r1
    2972:	81 1d       	adc	r24, r1
    2974:	d8 c0       	rjmp	.+432    	; 0x2b26 <__fp_mintl>
    2976:	f2 c0       	rjmp	.+484    	; 0x2b5c <__fp_mpack>

00002978 <__divsf3>:
    2978:	0c d0       	rcall	.+24     	; 0x2992 <__divsf3x>
    297a:	11 c1       	rjmp	.+546    	; 0x2b9e <__fp_round>
    297c:	09 d1       	rcall	.+530    	; 0x2b90 <__fp_pscB>
    297e:	40 f0       	brcs	.+16     	; 0x2990 <__divsf3+0x18>
    2980:	00 d1       	rcall	.+512    	; 0x2b82 <__fp_pscA>
    2982:	30 f0       	brcs	.+12     	; 0x2990 <__divsf3+0x18>
    2984:	21 f4       	brne	.+8      	; 0x298e <__divsf3+0x16>
    2986:	5f 3f       	cpi	r21, 0xFF	; 255
    2988:	19 f0       	breq	.+6      	; 0x2990 <__divsf3+0x18>
    298a:	c7 c0       	rjmp	.+398    	; 0x2b1a <__fp_inf>
    298c:	51 11       	cpse	r21, r1
    298e:	52 c1       	rjmp	.+676    	; 0x2c34 <__fp_szero>
    2990:	f5 c0       	rjmp	.+490    	; 0x2b7c <__fp_nan>

00002992 <__divsf3x>:
    2992:	16 d1       	rcall	.+556    	; 0x2bc0 <__fp_split3>
    2994:	98 f3       	brcs	.-26     	; 0x297c <__divsf3+0x4>

00002996 <__divsf3_pse>:
    2996:	99 23       	and	r25, r25
    2998:	c9 f3       	breq	.-14     	; 0x298c <__divsf3+0x14>
    299a:	55 23       	and	r21, r21
    299c:	b1 f3       	breq	.-20     	; 0x298a <__divsf3+0x12>
    299e:	95 1b       	sub	r25, r21
    29a0:	55 0b       	sbc	r21, r21
    29a2:	bb 27       	eor	r27, r27
    29a4:	aa 27       	eor	r26, r26
    29a6:	62 17       	cp	r22, r18
    29a8:	73 07       	cpc	r23, r19
    29aa:	84 07       	cpc	r24, r20
    29ac:	38 f0       	brcs	.+14     	; 0x29bc <__divsf3_pse+0x26>
    29ae:	9f 5f       	subi	r25, 0xFF	; 255
    29b0:	5f 4f       	sbci	r21, 0xFF	; 255
    29b2:	22 0f       	add	r18, r18
    29b4:	33 1f       	adc	r19, r19
    29b6:	44 1f       	adc	r20, r20
    29b8:	aa 1f       	adc	r26, r26
    29ba:	a9 f3       	breq	.-22     	; 0x29a6 <__divsf3_pse+0x10>
    29bc:	33 d0       	rcall	.+102    	; 0x2a24 <__divsf3_pse+0x8e>
    29be:	0e 2e       	mov	r0, r30
    29c0:	3a f0       	brmi	.+14     	; 0x29d0 <__divsf3_pse+0x3a>
    29c2:	e0 e8       	ldi	r30, 0x80	; 128
    29c4:	30 d0       	rcall	.+96     	; 0x2a26 <__divsf3_pse+0x90>
    29c6:	91 50       	subi	r25, 0x01	; 1
    29c8:	50 40       	sbci	r21, 0x00	; 0
    29ca:	e6 95       	lsr	r30
    29cc:	00 1c       	adc	r0, r0
    29ce:	ca f7       	brpl	.-14     	; 0x29c2 <__divsf3_pse+0x2c>
    29d0:	29 d0       	rcall	.+82     	; 0x2a24 <__divsf3_pse+0x8e>
    29d2:	fe 2f       	mov	r31, r30
    29d4:	27 d0       	rcall	.+78     	; 0x2a24 <__divsf3_pse+0x8e>
    29d6:	66 0f       	add	r22, r22
    29d8:	77 1f       	adc	r23, r23
    29da:	88 1f       	adc	r24, r24
    29dc:	bb 1f       	adc	r27, r27
    29de:	26 17       	cp	r18, r22
    29e0:	37 07       	cpc	r19, r23
    29e2:	48 07       	cpc	r20, r24
    29e4:	ab 07       	cpc	r26, r27
    29e6:	b0 e8       	ldi	r27, 0x80	; 128
    29e8:	09 f0       	breq	.+2      	; 0x29ec <__divsf3_pse+0x56>
    29ea:	bb 0b       	sbc	r27, r27
    29ec:	80 2d       	mov	r24, r0
    29ee:	bf 01       	movw	r22, r30
    29f0:	ff 27       	eor	r31, r31
    29f2:	93 58       	subi	r25, 0x83	; 131
    29f4:	5f 4f       	sbci	r21, 0xFF	; 255
    29f6:	2a f0       	brmi	.+10     	; 0x2a02 <__divsf3_pse+0x6c>
    29f8:	9e 3f       	cpi	r25, 0xFE	; 254
    29fa:	51 05       	cpc	r21, r1
    29fc:	68 f0       	brcs	.+26     	; 0x2a18 <__divsf3_pse+0x82>
    29fe:	8d c0       	rjmp	.+282    	; 0x2b1a <__fp_inf>
    2a00:	19 c1       	rjmp	.+562    	; 0x2c34 <__fp_szero>
    2a02:	5f 3f       	cpi	r21, 0xFF	; 255
    2a04:	ec f3       	brlt	.-6      	; 0x2a00 <__divsf3_pse+0x6a>
    2a06:	98 3e       	cpi	r25, 0xE8	; 232
    2a08:	dc f3       	brlt	.-10     	; 0x2a00 <__divsf3_pse+0x6a>
    2a0a:	86 95       	lsr	r24
    2a0c:	77 95       	ror	r23
    2a0e:	67 95       	ror	r22
    2a10:	b7 95       	ror	r27
    2a12:	f7 95       	ror	r31
    2a14:	9f 5f       	subi	r25, 0xFF	; 255
    2a16:	c9 f7       	brne	.-14     	; 0x2a0a <__divsf3_pse+0x74>
    2a18:	88 0f       	add	r24, r24
    2a1a:	91 1d       	adc	r25, r1
    2a1c:	96 95       	lsr	r25
    2a1e:	87 95       	ror	r24
    2a20:	97 f9       	bld	r25, 7
    2a22:	08 95       	ret
    2a24:	e1 e0       	ldi	r30, 0x01	; 1
    2a26:	66 0f       	add	r22, r22
    2a28:	77 1f       	adc	r23, r23
    2a2a:	88 1f       	adc	r24, r24
    2a2c:	bb 1f       	adc	r27, r27
    2a2e:	62 17       	cp	r22, r18
    2a30:	73 07       	cpc	r23, r19
    2a32:	84 07       	cpc	r24, r20
    2a34:	ba 07       	cpc	r27, r26
    2a36:	20 f0       	brcs	.+8      	; 0x2a40 <__divsf3_pse+0xaa>
    2a38:	62 1b       	sub	r22, r18
    2a3a:	73 0b       	sbc	r23, r19
    2a3c:	84 0b       	sbc	r24, r20
    2a3e:	ba 0b       	sbc	r27, r26
    2a40:	ee 1f       	adc	r30, r30
    2a42:	88 f7       	brcc	.-30     	; 0x2a26 <__divsf3_pse+0x90>
    2a44:	e0 95       	com	r30
    2a46:	08 95       	ret

00002a48 <__fixunssfsi>:
    2a48:	c3 d0       	rcall	.+390    	; 0x2bd0 <__fp_splitA>
    2a4a:	88 f0       	brcs	.+34     	; 0x2a6e <__fixunssfsi+0x26>
    2a4c:	9f 57       	subi	r25, 0x7F	; 127
    2a4e:	90 f0       	brcs	.+36     	; 0x2a74 <__fixunssfsi+0x2c>
    2a50:	b9 2f       	mov	r27, r25
    2a52:	99 27       	eor	r25, r25
    2a54:	b7 51       	subi	r27, 0x17	; 23
    2a56:	a0 f0       	brcs	.+40     	; 0x2a80 <__fixunssfsi+0x38>
    2a58:	d1 f0       	breq	.+52     	; 0x2a8e <__fixunssfsi+0x46>
    2a5a:	66 0f       	add	r22, r22
    2a5c:	77 1f       	adc	r23, r23
    2a5e:	88 1f       	adc	r24, r24
    2a60:	99 1f       	adc	r25, r25
    2a62:	1a f0       	brmi	.+6      	; 0x2a6a <__fixunssfsi+0x22>
    2a64:	ba 95       	dec	r27
    2a66:	c9 f7       	brne	.-14     	; 0x2a5a <__fixunssfsi+0x12>
    2a68:	12 c0       	rjmp	.+36     	; 0x2a8e <__fixunssfsi+0x46>
    2a6a:	b1 30       	cpi	r27, 0x01	; 1
    2a6c:	81 f0       	breq	.+32     	; 0x2a8e <__fixunssfsi+0x46>
    2a6e:	e1 d0       	rcall	.+450    	; 0x2c32 <__fp_zero>
    2a70:	b1 e0       	ldi	r27, 0x01	; 1
    2a72:	08 95       	ret
    2a74:	de c0       	rjmp	.+444    	; 0x2c32 <__fp_zero>
    2a76:	67 2f       	mov	r22, r23
    2a78:	78 2f       	mov	r23, r24
    2a7a:	88 27       	eor	r24, r24
    2a7c:	b8 5f       	subi	r27, 0xF8	; 248
    2a7e:	39 f0       	breq	.+14     	; 0x2a8e <__fixunssfsi+0x46>
    2a80:	b9 3f       	cpi	r27, 0xF9	; 249
    2a82:	cc f3       	brlt	.-14     	; 0x2a76 <__fixunssfsi+0x2e>
    2a84:	86 95       	lsr	r24
    2a86:	77 95       	ror	r23
    2a88:	67 95       	ror	r22
    2a8a:	b3 95       	inc	r27
    2a8c:	d9 f7       	brne	.-10     	; 0x2a84 <__fixunssfsi+0x3c>
    2a8e:	3e f4       	brtc	.+14     	; 0x2a9e <__fixunssfsi+0x56>
    2a90:	90 95       	com	r25
    2a92:	80 95       	com	r24
    2a94:	70 95       	com	r23
    2a96:	61 95       	neg	r22
    2a98:	7f 4f       	sbci	r23, 0xFF	; 255
    2a9a:	8f 4f       	sbci	r24, 0xFF	; 255
    2a9c:	9f 4f       	sbci	r25, 0xFF	; 255
    2a9e:	08 95       	ret

00002aa0 <__floatunsisf>:
    2aa0:	e8 94       	clt
    2aa2:	09 c0       	rjmp	.+18     	; 0x2ab6 <__floatsisf+0x12>

00002aa4 <__floatsisf>:
    2aa4:	97 fb       	bst	r25, 7
    2aa6:	3e f4       	brtc	.+14     	; 0x2ab6 <__floatsisf+0x12>
    2aa8:	90 95       	com	r25
    2aaa:	80 95       	com	r24
    2aac:	70 95       	com	r23
    2aae:	61 95       	neg	r22
    2ab0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ab2:	8f 4f       	sbci	r24, 0xFF	; 255
    2ab4:	9f 4f       	sbci	r25, 0xFF	; 255
    2ab6:	99 23       	and	r25, r25
    2ab8:	a9 f0       	breq	.+42     	; 0x2ae4 <__floatsisf+0x40>
    2aba:	f9 2f       	mov	r31, r25
    2abc:	96 e9       	ldi	r25, 0x96	; 150
    2abe:	bb 27       	eor	r27, r27
    2ac0:	93 95       	inc	r25
    2ac2:	f6 95       	lsr	r31
    2ac4:	87 95       	ror	r24
    2ac6:	77 95       	ror	r23
    2ac8:	67 95       	ror	r22
    2aca:	b7 95       	ror	r27
    2acc:	f1 11       	cpse	r31, r1
    2ace:	f8 cf       	rjmp	.-16     	; 0x2ac0 <__floatsisf+0x1c>
    2ad0:	fa f4       	brpl	.+62     	; 0x2b10 <__floatsisf+0x6c>
    2ad2:	bb 0f       	add	r27, r27
    2ad4:	11 f4       	brne	.+4      	; 0x2ada <__floatsisf+0x36>
    2ad6:	60 ff       	sbrs	r22, 0
    2ad8:	1b c0       	rjmp	.+54     	; 0x2b10 <__floatsisf+0x6c>
    2ada:	6f 5f       	subi	r22, 0xFF	; 255
    2adc:	7f 4f       	sbci	r23, 0xFF	; 255
    2ade:	8f 4f       	sbci	r24, 0xFF	; 255
    2ae0:	9f 4f       	sbci	r25, 0xFF	; 255
    2ae2:	16 c0       	rjmp	.+44     	; 0x2b10 <__floatsisf+0x6c>
    2ae4:	88 23       	and	r24, r24
    2ae6:	11 f0       	breq	.+4      	; 0x2aec <__floatsisf+0x48>
    2ae8:	96 e9       	ldi	r25, 0x96	; 150
    2aea:	11 c0       	rjmp	.+34     	; 0x2b0e <__floatsisf+0x6a>
    2aec:	77 23       	and	r23, r23
    2aee:	21 f0       	breq	.+8      	; 0x2af8 <__floatsisf+0x54>
    2af0:	9e e8       	ldi	r25, 0x8E	; 142
    2af2:	87 2f       	mov	r24, r23
    2af4:	76 2f       	mov	r23, r22
    2af6:	05 c0       	rjmp	.+10     	; 0x2b02 <__floatsisf+0x5e>
    2af8:	66 23       	and	r22, r22
    2afa:	71 f0       	breq	.+28     	; 0x2b18 <__floatsisf+0x74>
    2afc:	96 e8       	ldi	r25, 0x86	; 134
    2afe:	86 2f       	mov	r24, r22
    2b00:	70 e0       	ldi	r23, 0x00	; 0
    2b02:	60 e0       	ldi	r22, 0x00	; 0
    2b04:	2a f0       	brmi	.+10     	; 0x2b10 <__floatsisf+0x6c>
    2b06:	9a 95       	dec	r25
    2b08:	66 0f       	add	r22, r22
    2b0a:	77 1f       	adc	r23, r23
    2b0c:	88 1f       	adc	r24, r24
    2b0e:	da f7       	brpl	.-10     	; 0x2b06 <__floatsisf+0x62>
    2b10:	88 0f       	add	r24, r24
    2b12:	96 95       	lsr	r25
    2b14:	87 95       	ror	r24
    2b16:	97 f9       	bld	r25, 7
    2b18:	08 95       	ret

00002b1a <__fp_inf>:
    2b1a:	97 f9       	bld	r25, 7
    2b1c:	9f 67       	ori	r25, 0x7F	; 127
    2b1e:	80 e8       	ldi	r24, 0x80	; 128
    2b20:	70 e0       	ldi	r23, 0x00	; 0
    2b22:	60 e0       	ldi	r22, 0x00	; 0
    2b24:	08 95       	ret

00002b26 <__fp_mintl>:
    2b26:	88 23       	and	r24, r24
    2b28:	71 f4       	brne	.+28     	; 0x2b46 <__fp_mintl+0x20>
    2b2a:	77 23       	and	r23, r23
    2b2c:	21 f0       	breq	.+8      	; 0x2b36 <__fp_mintl+0x10>
    2b2e:	98 50       	subi	r25, 0x08	; 8
    2b30:	87 2b       	or	r24, r23
    2b32:	76 2f       	mov	r23, r22
    2b34:	07 c0       	rjmp	.+14     	; 0x2b44 <__fp_mintl+0x1e>
    2b36:	66 23       	and	r22, r22
    2b38:	11 f4       	brne	.+4      	; 0x2b3e <__fp_mintl+0x18>
    2b3a:	99 27       	eor	r25, r25
    2b3c:	0d c0       	rjmp	.+26     	; 0x2b58 <__fp_mintl+0x32>
    2b3e:	90 51       	subi	r25, 0x10	; 16
    2b40:	86 2b       	or	r24, r22
    2b42:	70 e0       	ldi	r23, 0x00	; 0
    2b44:	60 e0       	ldi	r22, 0x00	; 0
    2b46:	2a f0       	brmi	.+10     	; 0x2b52 <__fp_mintl+0x2c>
    2b48:	9a 95       	dec	r25
    2b4a:	66 0f       	add	r22, r22
    2b4c:	77 1f       	adc	r23, r23
    2b4e:	88 1f       	adc	r24, r24
    2b50:	da f7       	brpl	.-10     	; 0x2b48 <__fp_mintl+0x22>
    2b52:	88 0f       	add	r24, r24
    2b54:	96 95       	lsr	r25
    2b56:	87 95       	ror	r24
    2b58:	97 f9       	bld	r25, 7
    2b5a:	08 95       	ret

00002b5c <__fp_mpack>:
    2b5c:	9f 3f       	cpi	r25, 0xFF	; 255
    2b5e:	49 f0       	breq	.+18     	; 0x2b72 <__fp_mpack+0x16>
    2b60:	91 50       	subi	r25, 0x01	; 1
    2b62:	28 f4       	brcc	.+10     	; 0x2b6e <__fp_mpack+0x12>
    2b64:	86 95       	lsr	r24
    2b66:	77 95       	ror	r23
    2b68:	67 95       	ror	r22
    2b6a:	b7 95       	ror	r27
    2b6c:	9f 5f       	subi	r25, 0xFF	; 255
    2b6e:	80 38       	cpi	r24, 0x80	; 128
    2b70:	9f 4f       	sbci	r25, 0xFF	; 255
    2b72:	88 0f       	add	r24, r24
    2b74:	96 95       	lsr	r25
    2b76:	87 95       	ror	r24
    2b78:	97 f9       	bld	r25, 7
    2b7a:	08 95       	ret

00002b7c <__fp_nan>:
    2b7c:	9f ef       	ldi	r25, 0xFF	; 255
    2b7e:	80 ec       	ldi	r24, 0xC0	; 192
    2b80:	08 95       	ret

00002b82 <__fp_pscA>:
    2b82:	00 24       	eor	r0, r0
    2b84:	0a 94       	dec	r0
    2b86:	16 16       	cp	r1, r22
    2b88:	17 06       	cpc	r1, r23
    2b8a:	18 06       	cpc	r1, r24
    2b8c:	09 06       	cpc	r0, r25
    2b8e:	08 95       	ret

00002b90 <__fp_pscB>:
    2b90:	00 24       	eor	r0, r0
    2b92:	0a 94       	dec	r0
    2b94:	12 16       	cp	r1, r18
    2b96:	13 06       	cpc	r1, r19
    2b98:	14 06       	cpc	r1, r20
    2b9a:	05 06       	cpc	r0, r21
    2b9c:	08 95       	ret

00002b9e <__fp_round>:
    2b9e:	09 2e       	mov	r0, r25
    2ba0:	03 94       	inc	r0
    2ba2:	00 0c       	add	r0, r0
    2ba4:	11 f4       	brne	.+4      	; 0x2baa <__fp_round+0xc>
    2ba6:	88 23       	and	r24, r24
    2ba8:	52 f0       	brmi	.+20     	; 0x2bbe <__fp_round+0x20>
    2baa:	bb 0f       	add	r27, r27
    2bac:	40 f4       	brcc	.+16     	; 0x2bbe <__fp_round+0x20>
    2bae:	bf 2b       	or	r27, r31
    2bb0:	11 f4       	brne	.+4      	; 0x2bb6 <__fp_round+0x18>
    2bb2:	60 ff       	sbrs	r22, 0
    2bb4:	04 c0       	rjmp	.+8      	; 0x2bbe <__fp_round+0x20>
    2bb6:	6f 5f       	subi	r22, 0xFF	; 255
    2bb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2bba:	8f 4f       	sbci	r24, 0xFF	; 255
    2bbc:	9f 4f       	sbci	r25, 0xFF	; 255
    2bbe:	08 95       	ret

00002bc0 <__fp_split3>:
    2bc0:	57 fd       	sbrc	r21, 7
    2bc2:	90 58       	subi	r25, 0x80	; 128
    2bc4:	44 0f       	add	r20, r20
    2bc6:	55 1f       	adc	r21, r21
    2bc8:	59 f0       	breq	.+22     	; 0x2be0 <__fp_splitA+0x10>
    2bca:	5f 3f       	cpi	r21, 0xFF	; 255
    2bcc:	71 f0       	breq	.+28     	; 0x2bea <__fp_splitA+0x1a>
    2bce:	47 95       	ror	r20

00002bd0 <__fp_splitA>:
    2bd0:	88 0f       	add	r24, r24
    2bd2:	97 fb       	bst	r25, 7
    2bd4:	99 1f       	adc	r25, r25
    2bd6:	61 f0       	breq	.+24     	; 0x2bf0 <__fp_splitA+0x20>
    2bd8:	9f 3f       	cpi	r25, 0xFF	; 255
    2bda:	79 f0       	breq	.+30     	; 0x2bfa <__fp_splitA+0x2a>
    2bdc:	87 95       	ror	r24
    2bde:	08 95       	ret
    2be0:	12 16       	cp	r1, r18
    2be2:	13 06       	cpc	r1, r19
    2be4:	14 06       	cpc	r1, r20
    2be6:	55 1f       	adc	r21, r21
    2be8:	f2 cf       	rjmp	.-28     	; 0x2bce <__fp_split3+0xe>
    2bea:	46 95       	lsr	r20
    2bec:	f1 df       	rcall	.-30     	; 0x2bd0 <__fp_splitA>
    2bee:	08 c0       	rjmp	.+16     	; 0x2c00 <__fp_splitA+0x30>
    2bf0:	16 16       	cp	r1, r22
    2bf2:	17 06       	cpc	r1, r23
    2bf4:	18 06       	cpc	r1, r24
    2bf6:	99 1f       	adc	r25, r25
    2bf8:	f1 cf       	rjmp	.-30     	; 0x2bdc <__fp_splitA+0xc>
    2bfa:	86 95       	lsr	r24
    2bfc:	71 05       	cpc	r23, r1
    2bfe:	61 05       	cpc	r22, r1
    2c00:	08 94       	sec
    2c02:	08 95       	ret

00002c04 <__fp_trunc>:
    2c04:	e5 df       	rcall	.-54     	; 0x2bd0 <__fp_splitA>
    2c06:	a0 f0       	brcs	.+40     	; 0x2c30 <__fp_trunc+0x2c>
    2c08:	be e7       	ldi	r27, 0x7E	; 126
    2c0a:	b9 17       	cp	r27, r25
    2c0c:	88 f4       	brcc	.+34     	; 0x2c30 <__fp_trunc+0x2c>
    2c0e:	bb 27       	eor	r27, r27
    2c10:	9f 38       	cpi	r25, 0x8F	; 143
    2c12:	60 f4       	brcc	.+24     	; 0x2c2c <__fp_trunc+0x28>
    2c14:	16 16       	cp	r1, r22
    2c16:	b1 1d       	adc	r27, r1
    2c18:	67 2f       	mov	r22, r23
    2c1a:	78 2f       	mov	r23, r24
    2c1c:	88 27       	eor	r24, r24
    2c1e:	98 5f       	subi	r25, 0xF8	; 248
    2c20:	f7 cf       	rjmp	.-18     	; 0x2c10 <__fp_trunc+0xc>
    2c22:	86 95       	lsr	r24
    2c24:	77 95       	ror	r23
    2c26:	67 95       	ror	r22
    2c28:	b1 1d       	adc	r27, r1
    2c2a:	93 95       	inc	r25
    2c2c:	96 39       	cpi	r25, 0x96	; 150
    2c2e:	c8 f3       	brcs	.-14     	; 0x2c22 <__fp_trunc+0x1e>
    2c30:	08 95       	ret

00002c32 <__fp_zero>:
    2c32:	e8 94       	clt

00002c34 <__fp_szero>:
    2c34:	bb 27       	eor	r27, r27
    2c36:	66 27       	eor	r22, r22
    2c38:	77 27       	eor	r23, r23
    2c3a:	cb 01       	movw	r24, r22
    2c3c:	97 f9       	bld	r25, 7
    2c3e:	08 95       	ret

00002c40 <__mulsf3>:
    2c40:	0b d0       	rcall	.+22     	; 0x2c58 <__mulsf3x>
    2c42:	ad cf       	rjmp	.-166    	; 0x2b9e <__fp_round>
    2c44:	9e df       	rcall	.-196    	; 0x2b82 <__fp_pscA>
    2c46:	28 f0       	brcs	.+10     	; 0x2c52 <__mulsf3+0x12>
    2c48:	a3 df       	rcall	.-186    	; 0x2b90 <__fp_pscB>
    2c4a:	18 f0       	brcs	.+6      	; 0x2c52 <__mulsf3+0x12>
    2c4c:	95 23       	and	r25, r21
    2c4e:	09 f0       	breq	.+2      	; 0x2c52 <__mulsf3+0x12>
    2c50:	64 cf       	rjmp	.-312    	; 0x2b1a <__fp_inf>
    2c52:	94 cf       	rjmp	.-216    	; 0x2b7c <__fp_nan>
    2c54:	11 24       	eor	r1, r1
    2c56:	ee cf       	rjmp	.-36     	; 0x2c34 <__fp_szero>

00002c58 <__mulsf3x>:
    2c58:	b3 df       	rcall	.-154    	; 0x2bc0 <__fp_split3>
    2c5a:	a0 f3       	brcs	.-24     	; 0x2c44 <__mulsf3+0x4>

00002c5c <__mulsf3_pse>:
    2c5c:	95 9f       	mul	r25, r21
    2c5e:	d1 f3       	breq	.-12     	; 0x2c54 <__mulsf3+0x14>
    2c60:	95 0f       	add	r25, r21
    2c62:	50 e0       	ldi	r21, 0x00	; 0
    2c64:	55 1f       	adc	r21, r21
    2c66:	62 9f       	mul	r22, r18
    2c68:	f0 01       	movw	r30, r0
    2c6a:	72 9f       	mul	r23, r18
    2c6c:	bb 27       	eor	r27, r27
    2c6e:	f0 0d       	add	r31, r0
    2c70:	b1 1d       	adc	r27, r1
    2c72:	63 9f       	mul	r22, r19
    2c74:	aa 27       	eor	r26, r26
    2c76:	f0 0d       	add	r31, r0
    2c78:	b1 1d       	adc	r27, r1
    2c7a:	aa 1f       	adc	r26, r26
    2c7c:	64 9f       	mul	r22, r20
    2c7e:	66 27       	eor	r22, r22
    2c80:	b0 0d       	add	r27, r0
    2c82:	a1 1d       	adc	r26, r1
    2c84:	66 1f       	adc	r22, r22
    2c86:	82 9f       	mul	r24, r18
    2c88:	22 27       	eor	r18, r18
    2c8a:	b0 0d       	add	r27, r0
    2c8c:	a1 1d       	adc	r26, r1
    2c8e:	62 1f       	adc	r22, r18
    2c90:	73 9f       	mul	r23, r19
    2c92:	b0 0d       	add	r27, r0
    2c94:	a1 1d       	adc	r26, r1
    2c96:	62 1f       	adc	r22, r18
    2c98:	83 9f       	mul	r24, r19
    2c9a:	a0 0d       	add	r26, r0
    2c9c:	61 1d       	adc	r22, r1
    2c9e:	22 1f       	adc	r18, r18
    2ca0:	74 9f       	mul	r23, r20
    2ca2:	33 27       	eor	r19, r19
    2ca4:	a0 0d       	add	r26, r0
    2ca6:	61 1d       	adc	r22, r1
    2ca8:	23 1f       	adc	r18, r19
    2caa:	84 9f       	mul	r24, r20
    2cac:	60 0d       	add	r22, r0
    2cae:	21 1d       	adc	r18, r1
    2cb0:	82 2f       	mov	r24, r18
    2cb2:	76 2f       	mov	r23, r22
    2cb4:	6a 2f       	mov	r22, r26
    2cb6:	11 24       	eor	r1, r1
    2cb8:	9f 57       	subi	r25, 0x7F	; 127
    2cba:	50 40       	sbci	r21, 0x00	; 0
    2cbc:	8a f0       	brmi	.+34     	; 0x2ce0 <__mulsf3_pse+0x84>
    2cbe:	e1 f0       	breq	.+56     	; 0x2cf8 <__mulsf3_pse+0x9c>
    2cc0:	88 23       	and	r24, r24
    2cc2:	4a f0       	brmi	.+18     	; 0x2cd6 <__mulsf3_pse+0x7a>
    2cc4:	ee 0f       	add	r30, r30
    2cc6:	ff 1f       	adc	r31, r31
    2cc8:	bb 1f       	adc	r27, r27
    2cca:	66 1f       	adc	r22, r22
    2ccc:	77 1f       	adc	r23, r23
    2cce:	88 1f       	adc	r24, r24
    2cd0:	91 50       	subi	r25, 0x01	; 1
    2cd2:	50 40       	sbci	r21, 0x00	; 0
    2cd4:	a9 f7       	brne	.-22     	; 0x2cc0 <__mulsf3_pse+0x64>
    2cd6:	9e 3f       	cpi	r25, 0xFE	; 254
    2cd8:	51 05       	cpc	r21, r1
    2cda:	70 f0       	brcs	.+28     	; 0x2cf8 <__mulsf3_pse+0x9c>
    2cdc:	1e cf       	rjmp	.-452    	; 0x2b1a <__fp_inf>
    2cde:	aa cf       	rjmp	.-172    	; 0x2c34 <__fp_szero>
    2ce0:	5f 3f       	cpi	r21, 0xFF	; 255
    2ce2:	ec f3       	brlt	.-6      	; 0x2cde <__mulsf3_pse+0x82>
    2ce4:	98 3e       	cpi	r25, 0xE8	; 232
    2ce6:	dc f3       	brlt	.-10     	; 0x2cde <__mulsf3_pse+0x82>
    2ce8:	86 95       	lsr	r24
    2cea:	77 95       	ror	r23
    2cec:	67 95       	ror	r22
    2cee:	b7 95       	ror	r27
    2cf0:	f7 95       	ror	r31
    2cf2:	e7 95       	ror	r30
    2cf4:	9f 5f       	subi	r25, 0xFF	; 255
    2cf6:	c1 f7       	brne	.-16     	; 0x2ce8 <__mulsf3_pse+0x8c>
    2cf8:	fe 2b       	or	r31, r30
    2cfa:	88 0f       	add	r24, r24
    2cfc:	91 1d       	adc	r25, r1
    2cfe:	96 95       	lsr	r25
    2d00:	87 95       	ror	r24
    2d02:	97 f9       	bld	r25, 7
    2d04:	08 95       	ret

00002d06 <__mulsi3>:
    2d06:	62 9f       	mul	r22, r18
    2d08:	d0 01       	movw	r26, r0
    2d0a:	73 9f       	mul	r23, r19
    2d0c:	f0 01       	movw	r30, r0
    2d0e:	82 9f       	mul	r24, r18
    2d10:	e0 0d       	add	r30, r0
    2d12:	f1 1d       	adc	r31, r1
    2d14:	64 9f       	mul	r22, r20
    2d16:	e0 0d       	add	r30, r0
    2d18:	f1 1d       	adc	r31, r1
    2d1a:	92 9f       	mul	r25, r18
    2d1c:	f0 0d       	add	r31, r0
    2d1e:	83 9f       	mul	r24, r19
    2d20:	f0 0d       	add	r31, r0
    2d22:	74 9f       	mul	r23, r20
    2d24:	f0 0d       	add	r31, r0
    2d26:	65 9f       	mul	r22, r21
    2d28:	f0 0d       	add	r31, r0
    2d2a:	99 27       	eor	r25, r25
    2d2c:	72 9f       	mul	r23, r18
    2d2e:	b0 0d       	add	r27, r0
    2d30:	e1 1d       	adc	r30, r1
    2d32:	f9 1f       	adc	r31, r25
    2d34:	63 9f       	mul	r22, r19
    2d36:	b0 0d       	add	r27, r0
    2d38:	e1 1d       	adc	r30, r1
    2d3a:	f9 1f       	adc	r31, r25
    2d3c:	bd 01       	movw	r22, r26
    2d3e:	cf 01       	movw	r24, r30
    2d40:	11 24       	eor	r1, r1
    2d42:	08 95       	ret

00002d44 <__udivmodhi4>:
    2d44:	aa 1b       	sub	r26, r26
    2d46:	bb 1b       	sub	r27, r27
    2d48:	51 e1       	ldi	r21, 0x11	; 17
    2d4a:	07 c0       	rjmp	.+14     	; 0x2d5a <__udivmodhi4_ep>

00002d4c <__udivmodhi4_loop>:
    2d4c:	aa 1f       	adc	r26, r26
    2d4e:	bb 1f       	adc	r27, r27
    2d50:	a6 17       	cp	r26, r22
    2d52:	b7 07       	cpc	r27, r23
    2d54:	10 f0       	brcs	.+4      	; 0x2d5a <__udivmodhi4_ep>
    2d56:	a6 1b       	sub	r26, r22
    2d58:	b7 0b       	sbc	r27, r23

00002d5a <__udivmodhi4_ep>:
    2d5a:	88 1f       	adc	r24, r24
    2d5c:	99 1f       	adc	r25, r25
    2d5e:	5a 95       	dec	r21
    2d60:	a9 f7       	brne	.-22     	; 0x2d4c <__udivmodhi4_loop>
    2d62:	80 95       	com	r24
    2d64:	90 95       	com	r25
    2d66:	bc 01       	movw	r22, r24
    2d68:	cd 01       	movw	r24, r26
    2d6a:	08 95       	ret

00002d6c <__udivmodsi4>:
    2d6c:	a1 e2       	ldi	r26, 0x21	; 33
    2d6e:	1a 2e       	mov	r1, r26
    2d70:	aa 1b       	sub	r26, r26
    2d72:	bb 1b       	sub	r27, r27
    2d74:	fd 01       	movw	r30, r26
    2d76:	0d c0       	rjmp	.+26     	; 0x2d92 <__udivmodsi4_ep>

00002d78 <__udivmodsi4_loop>:
    2d78:	aa 1f       	adc	r26, r26
    2d7a:	bb 1f       	adc	r27, r27
    2d7c:	ee 1f       	adc	r30, r30
    2d7e:	ff 1f       	adc	r31, r31
    2d80:	a2 17       	cp	r26, r18
    2d82:	b3 07       	cpc	r27, r19
    2d84:	e4 07       	cpc	r30, r20
    2d86:	f5 07       	cpc	r31, r21
    2d88:	20 f0       	brcs	.+8      	; 0x2d92 <__udivmodsi4_ep>
    2d8a:	a2 1b       	sub	r26, r18
    2d8c:	b3 0b       	sbc	r27, r19
    2d8e:	e4 0b       	sbc	r30, r20
    2d90:	f5 0b       	sbc	r31, r21

00002d92 <__udivmodsi4_ep>:
    2d92:	66 1f       	adc	r22, r22
    2d94:	77 1f       	adc	r23, r23
    2d96:	88 1f       	adc	r24, r24
    2d98:	99 1f       	adc	r25, r25
    2d9a:	1a 94       	dec	r1
    2d9c:	69 f7       	brne	.-38     	; 0x2d78 <__udivmodsi4_loop>
    2d9e:	60 95       	com	r22
    2da0:	70 95       	com	r23
    2da2:	80 95       	com	r24
    2da4:	90 95       	com	r25
    2da6:	9b 01       	movw	r18, r22
    2da8:	ac 01       	movw	r20, r24
    2daa:	bd 01       	movw	r22, r26
    2dac:	cf 01       	movw	r24, r30
    2dae:	08 95       	ret

00002db0 <_exit>:
    2db0:	f8 94       	cli

00002db2 <__stop_program>:
    2db2:	ff cf       	rjmp	.-2      	; 0x2db2 <__stop_program>
ELF          S                 4     (  
 %  $ >   :;I  $ >  $ >  4 :;I  & I  4 :;I                                      z3       int                                         SS #   5(       $   3    %   2SCK &   4SDA (   SCL )       *   A0 ,   6A1 -   7A2 .   8A3 /   9A4 0   :A5 1   ;A6 2   <A7 3   =A8 4   >A9 5   ?A10 6   @A11 7   AA12 8   BA13 9   CA14 :   DA15 ;   E        
    e:/thomas/downloads/programs/exe/uecide/hardware/compilers/avr-gcc/lib/gcc/../../avr/include E:\Thomas\Downloads\Programs\EXE\uecide\hardware\boards\Arduino\mega2560  pins_arduino.h   stdint.h                         LED_BUILTIN bool GNU C++ 4.3.2 float short unsigned int unsigned char double MISO MOSI long unsigned int unsigned int long long unsigned int uint8_t E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api\CDC.cpp long long int char long int signed char  .symtab .strtab .shstrtab .text .data .bss .debug_abbrev .rela.debug_info .rela.debug_line .debug_str                                                       4                      !             4                      '             4                      ,              4   c                  ?                                  :              $                P              3                   K              ,	                 \      0       8                                @  g                                                	                c                                                                                        	   ?            >            =         $   4         ,             8                                                                   	 E              T               CDC.cpp __SREG__ __SP_H__ __SP_L__ __CCP__ __tmp_reg__ __zero_reg__ __do_copy_data __do_clear_bss                                                      $        )        6     8   D     i   K        R     W   Y        `     v   m     %   t        {             F                R        M                     /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\commands.cpp"
//Command Structures ---------------------------------------------------------
//
// Definition of the commands used by the Synta protocol, and variables in which responses
// are storedz
//
// Data structure of flag Flag:
//   flag = xxxx00ds000g000f where bits:
//   x = dont care
//   d = dir
//   s = stopped
//   g = goto
//   f = energised
//
// Only dir can be used to set the direction, but stepDir method can be used
// to returns it in a more useful format
//
//----------------------------------------------------------------------------

#include "commands.h"

Commands cmd = {0};

void Commands_init(unsigned long _eVal, byte _gVal){
    cmd.aVal[RA] = EEPROM_readLong(aVal1_Address);              //steps/axis
    cmd.aVal[DC] = EEPROM_readLong(aVal2_Address);              //steps/axis
    cmd.bVal[RA] = EEPROM_readLong(bVal1_Address);              //sidereal rate
    cmd.bVal[DC] = EEPROM_readLong(bVal2_Address);              //sidereal rate
    cmd.sVal[RA] = EEPROM_readLong(sVal1_Address);              //steps/worm rotation
    cmd.sVal[DC] = EEPROM_readLong(sVal2_Address);              //steps/worm rotation
    
    cmd.siderealIVal[RA] = EEPROM_readInt(IVal1_Address);       //steps/worm rotation
    cmd.siderealIVal[DC] = EEPROM_readInt(IVal2_Address);       //steps/worm rotation
    cmd.normalGotoSpeed[RA] = EEPROM_readByte(RAGoto_Address);  //IVal for normal goto speed
    cmd.normalGotoSpeed[DC] = EEPROM_readByte(DECGoto_Address); //IVal for normal goto speed
    cmd.st4SpeedFactor = EEPROM_readByte(SpeedFactor_Address);  //ST4 speed factor
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
        cmd.stepDir[i] = 1; //1-dir*2
        cmd.highSpeedMode[i] = false;
        cmd.stopped[i] = CMD_STOPPED;
        cmd.gotoEn[i] = CMD_DISABLED;
        cmd.FVal[i] = CMD_DISABLED;
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
        cmd.IVal[i] = cmd.siderealIVal[i]; //Recieved Speed will be set by :I command.
        cmd.GVal[i] = 0; //Mode recieved from :G command
        cmd.HVal[i] = 0; //Value recieved from :H command
        cmd.eVal[i] = _eVal; //version number
        cmd.gVal[i] = _gVal; //High speed scalar
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
        cmd.stopSpeed[i] = cmd.minSpeed[i];
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
}

void Commands_configureST4Speed(byte mode) {
    cmd.st4Mode = mode;
    if (mode == CMD_ST4_HIGHSPEED) {
        //Set the ST4 speeds to highspeed standalone mode (goto speeds)
        cmd.st4RAIVal[ST4P] = cmd.normalGotoSpeed[RA];
        cmd.st4RAIVal[ST4N] = cmd.normalGotoSpeed[RA];
        cmd.st4RAReverse    = CMD_REVERSE;
        cmd.st4DecIVal      = cmd.normalGotoSpeed[DC];
    } else if (mode == CMD_ST4_STANDALONE) {
        //Set the ST4 speeds to standalone mode (2x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA])/3; //3x speed
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA])  ; //-1x speed
        cmd.st4RAReverse    = CMD_REVERSE;
        cmd.st4DecIVal      =(cmd.siderealIVal[DC])/2; //2x speed
    } else {
        //Set the ST4 speeds to normal mode (0.25x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA] * 20)/(20 + cmd.st4SpeedFactor); //(1+SpeedFactor)x speed   -- Max. IVal = 1200, so this will never overflow.
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA] * 20)/(20 - cmd.st4SpeedFactor); //(1-SpeedFactor)x speed
        cmd.st4RAReverse    = CMD_FORWARD;
        cmd.st4DecIVal      =(cmd.siderealIVal[DC] * 20)/( 0 + cmd.st4SpeedFactor); //(SpeedFactor)x speed
    }
}

const char cmd_commands[numberOfCommands][3] = { {'j', 0, 6}, //arranged in order of most frequently used to reduce searching time.
                                                 {'f', 0, 3},
                                                 {'I', 6, 0},
                                                 {'G', 2, 0},
                                                 {'J', 0, 0},
                                                 {'K', 0, 0},
                                                 {'H', 6, 0},
                                                 {'M', 6, 0},
                                                 {'e', 0, 6},
                                                 {'a', 0, 6},
                                                 {'b', 0, 6},
                                                 {'g', 0, 2},
                                                 {'s', 0, 6},
                                                 {'E', 6, 0},
                                                 {'P', 1, 0},
                                                 {'F', 0, 0},
                                                 {'L', 0, 0},
                                                 //Programmer Commands
                                                 {'A', 6, 0},
                                                 {'B', 6, 0},
                                                 {'S', 6, 0},
                                                 {'n', 0, 6},
                                                 {'N', 6, 0},
                                                 {'D', 2, 0},
                                                 {'d', 0, 2},
                                                 {'C', 1, 0},
                                                 {'c', 0, 2},
                                                 {'Z', 2, 0},
                                                 {'z', 0, 2},
                                                 {'R', 6, 0},
                                                 {'r', 0, 6},
                                                 {'O', 1, 0},
                                                 {'Q', 2, 0},
                                                 {'q', 0, 2},
                                                 {'X', 6, 0},
                                                 {'x', 0, 6},
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    for(byte i = 0;i < numberOfCommands;i++){
        if(cmd_commands[i][0] == cmd){
            if(sendRecieve){
                return cmd_commands[i][1];
            } else {
                return cmd_commands[i][2];
            }
        }
    }
    return -1;
}

//void Commands::setStepLength(byte target, byte stepLength) {
//  if (stepDir[target] > 0) {
//    stepDir[target] = stepLength;
//  } else {
//    stepDir[target] = -stepLength;
//  }
//}

ELF          S                 4     (   %RU  $ >   :;I  $ >  $ >  :;   :;I8
  :;  	 :;I8
  
I  ! I/  5 I  .?:;@@
   :;I  .?:;@I@
   :;I   :;I
  4 :;I    4 :;I  & I  4 :;I  4 :;I?
  4 :;I
   Y                                       z7       int                         ,       n       oE   #     ph   #     #;      %;  #     &K  #    'K  #    ([  #    );  #    *  #/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\commands.h"
//_fVal Flag get/set callers -------------------------------------------------
//
//Data structure of _fVal Flag:
//  _fVal = xxxx00ds000g000f where bits:
//  x = dont care
//  d = dir
//  s = stopped
//  g = goto
//  f = energised
//
//Only dir can be used to set the direction, but stepDir method can be used
//to returns it in a more useful format
//
//----------------------------------------------------------------------------

#ifndef __COMMANDS_H__
#define __COMMANDS_H__
  
#include "AstroEQ.h"
#include "EEPROMReader.h" //Read config file

#define CMD_ST4_HIGHSPEED   2
#define CMD_ST4_STANDALONE  1
#define CMD_ST4_DEFAULT     0

#define CMD_FORWARD         false
#define CMD_REVERSE         true

#define CMD_STOPPED         true
#define CMD_RUNNING         false

#define CMD_ENABLED         true
#define CMD_DISABLED        false

typedef struct{        
    //class variables
    unsigned long    jVal           [2]; //_jVal: Current position
    unsigned int     IVal           [2]; //_IVal: speed to move if in slew mode
    unsigned int     motorSpeed     [2]; //speed at which moving. Accelerates to IVal.
    byte             GVal           [2]; //_GVal: slew/goto mode
    unsigned long    HVal           [2]; //_HVal: steps to move if in goto mode
    volatile char    stepDir        [2]; 
    bool             dir            [2];
    bool             FVal           [2];
    bool             gotoEn         [2];
    bool             stopped        [2];
    bool             highSpeedMode  [2];
    unsigned long    eVal           [2]; //_eVal: Version number
    unsigned long    aVal           [2]; //_aVal: Steps per axis revolution
    unsigned long    bVal           [2]; //_bVal: Sidereal Rate of axis
    byte             gVal           [2]; //_gVal: Speed scalar for highspeed slew
    unsigned long    sVal           [2]; //_sVal: Steps per worm gear revolution
    byte             st4Mode;            //Current ST-4 mode
    byte             st4SpeedFactor;     //Multiplication factor to get st4 speed. min = 1 = 0.05x, max = 19 = 0.95x.
    unsigned int     st4RAIVal      [2]; //_IVal: for RA ST4 movements ({RA+,RA-});
    bool             st4RAReverse;       //Reverse RA- axis direction if true.
    unsigned int     st4DecIVal;         //_IVal: for declination ST4 movements
    unsigned int     st4DecBacklash;     //Number of steps to perform on ST-4 direction change ---- Not yet implemented.
    unsigned int     siderealIVal   [2]; //_IVal: at sidereal rate
    unsigned int     currentIVal    [2]; //this will be upldated to match the requested IVal once the motors are stopped.
    unsigned int     minSpeed       [2]; //slowest speed allowed
    unsigned int     normalGotoSpeed[2]; //IVal for normal goto movement.
    unsigned int     stopSpeed      [2]; //Speed at which mount should stop. May be lower than minSpeed if doing a very slow IVal.
    AccelTableStruct accelTable     [2][AccelTableLength]; //Acceleration profile now controlled via lookup table. The first element will be used for cmd.minSpeed[]. max repeat=85
} Commands;

#define numberOfCommands 37

void Commands_init(unsigned long _eVal, byte _gVal);
void Commands_configureST4Speed(byte mode);
char Commands_getLength(char cmd, bool sendRecieve);
  
//Command definitions
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    }
}

inline unsigned int cmd_fVal(byte target){ //_fVal: 00ds000g000f; d = dir, s = stopped, g = goto, f = energised
    unsigned int fVal = 0;
    if (cmd.dir[target]) {
        fVal |= (1 << 9);
    }
    if (cmd.stopped[target]) {
        fVal |= (1 << 8);
    }
    if (cmd.gotoEn[target]) {
        fVal |= (1 << 4);
    }
    if (cmd.FVal[target]){
        fVal |= (1 << 0);
    }
    return fVal;
}

inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
}

inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
}

inline void cmd_setaVal(byte target, unsigned long _aVal){ //Set Method
    cmd.aVal[target] = _aVal;
}

inline void cmd_setbVal(byte target, unsigned long _bVal){ //Set Method
    cmd.bVal[target] = _bVal;
}

inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
}

inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
}

inline void cmd_setst4DecBacklash(unsigned int _backlash){ //Set Method
    cmd.st4DecBacklash = _backlash;
}


#endif //__COMMANDS_H__
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMAddresses.h"
#include "avr/io.h"

#define EEPROMStart_Address (                      0 )
#define AstroEQID_Address   (EEPROMStart_Address + 0 )
#define Microstep_Address   (EEPROMStart_Address + 8 ) //whether to use microstepping.
#define RAReverse_Address   (EEPROMStart_Address + 9 )
#define DECReverse_Address  (EEPROMStart_Address + 10)
#define Driver_Address      (EEPROMStart_Address + 11)
#define RAGoto_Address      (EEPROMStart_Address + 12)
#define DECGoto_Address     (EEPROMStart_Address + 13)
#define aVal1_Address       (EEPROMStart_Address + 14) //steps/axis
#define aVal2_Address       (EEPROMStart_Address + 18) //steps/axis
#define bVal1_Address       (EEPROMStart_Address + 22) //sidereal rate
#define bVal2_Address       (EEPROMStart_Address + 26) //sidereal rate
#define sVal1_Address       (EEPROMStart_Address + 30) //steps/worm rotation
#define sVal2_Address       (EEPROMStart_Address + 34) //steps/worm rotation
#define IVal1_Address       (EEPROMStart_Address + 38) //steps/worm rotation
#define IVal2_Address       (EEPROMStart_Address + 40) //steps/worm rotation
#define GearEnable_Address  (EEPROMStart_Address + 42) //Allow "gear change"
#define AdvHCEnable_Address (EEPROMStart_Address + 43) //Allow advanced controller detection
#define DecBacklash_Address (EEPROMStart_Address + 44) //DEC backlash correction factor
#define SpeedFactor_Address (EEPROMStart_Address + 46) //ST4 Speed Factor (0.05x to 0.95x sidereal as multiple of 1/20)

#define AccelTableLength 64
#define AccelTable1_Address (EEPROMStart_Address + 100) //Leave a gap so we can add more settings later.
#define AccelTable2_Address (EEPROMStart_Address + 100 + AccelTableLength*3)

#if ((EEPROMStart_Address + 100 + (6*AccelTableLength) - 1) > E2END)
    #error "AccelTable too large for EEPROM"
#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMReader.cpp"

#include <avr/eeprom.h>
#include "EEPROMReader.h"
 
byte EEPROM_readByte(unsigned int address) {
    return eeprom_read_byte((byte*) address);
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    fetcher.array[1] = EEPROM_readInt(address+2);
    return fetcher.integer;
}

void EEPROM_readString(char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
        string[i] = EEPROM_readByte(address++);
    }
}

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
        table[i].speed = EEPROM_readInt(address);
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
        address = address + sizeof(byte);
    }
}

void EEPROM_writeByte(byte val, unsigned int address) {
    return eeprom_write_byte((byte*) address, val);
}

void EEPROM_writeInt(unsigned int val, unsigned int address) {
    TwoBytes storer = {val};
    EEPROM_writeByte(storer.array[0], address);
    EEPROM_writeByte(storer.array[1], address+1);
}

void EEPROM_writeLong(unsigned long val, unsigned int address) {
    FourBytes storer = {val};
    EEPROM_writeInt(storer.array[0], address);
    EEPROM_writeInt(storer.array[1], address+2);
}

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
        EEPROM_writeByte(string[i], address+i);
    }
}

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
        EEPROM_writeInt(table[i].speed,address);
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
        address = address + sizeof(byte);
    }
}
ELF          S                 4     ( + ( %RU  $ >   :;I  $ >  :;   :;I  I  ! I/  	$ >  
:;   :;I8
  .:;I    :;I  4 :;I   I  & I  .?:;I    :;I     1  4 1    .:;    :;I   :;I  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMReader.h"
#ifndef __EEPROM_H__
#define __EEPROM_H__

#include "AstroEQ.h"

byte EEPROM_readByte(unsigned int address);
unsigned int EEPROM_readInt(unsigned int address);
unsigned long EEPROM_readLong(unsigned int address);
void EEPROM_readString(char* string, byte len, unsigned int address);
void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address);
void EEPROM_writeByte(byte val,unsigned int address);
void EEPROM_writeInt(unsigned int val,unsigned int address);
void EEPROM_writeLong(unsigned long val,unsigned int address);
void EEPROM_writeString(const char* string, byte len, unsigned int address);
void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address);

#endif //__EEPROM_H__
ELF          S            L]     4     ( V S %RU   :;I  $ >  $ >   I  $ >  :;   :;I8
2  	 :;I8
2  
.?:;@2<   I4  .?:;<   I  .?:;@I<  .?:;@<  .?:;@I2<  .?:;@I2<  :;   :;I8
    & I   I  <   :;  .?:;<  ELF          S                 4     (  
 %  $ >   :;I  $ >  $ >  4 :;I  & I  4 :;I                                      z3       int                                         SS #   5(       $   3    %   2SCK &   4SDA (   SCL )       *   A0 ,   6A1 -   7A2 .   8A3 /   9A4 0   :A5 1   ;A6 2   <A7 3   =A8 4   >A9 5   ?A10 6   @A11 7   AA12 8   BA13 9   CA14 :   DA15 ;   E        
    e:/thomas/downloads/programs/exe/uecide/hardware/compilers/avr-gcc/lib/gcc/../../avr/include E:\Thomas\Downloads\Programs\EXE\uecide\hardware\boards\Arduino\mega2560  pins_arduino.h   stdint.h                         LED_BUILTIN bool GNU C++ 4.3.2 float short unsigned int unsigned char double MISO MOSI long unsigned int unsigned int long long unsigned int uint8_t long long int char long int signed char E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api\HID.cpp  .symtab .strtab .shstrtab .text .data .bss .debug_abbrev .rela.debug_info .rela.debug_line .debug_str                                                       4                      !             4                      '             4                      ,              4   c                  ?                                  :              $                P              3                   K              ,	                 \      0       8                                @  g                                                	                c                                                                                        	   ?            >            =         $   4         ,             8                                                                   	 E              T               HID.cpp __SREG__ __SP_H__ __SP_L__ __CCP__ __tmp_reg__ __zero_reg__ __do_copy_data __do_clear_bss                                                      $        )        6     8   D     i   K        R     W   Y        `     v   m     %   t        {             F                R        M                     ELF          S            $     4     ( 7 4 %RU   :;I  $ >  $ >  $ >   I  & I  <  	.?:;@I<  
 I4   I   :;  :;   I8
2   :;I8
2  .?@I4<  .?4<  .?:;@I2<  .?:;<  .?:;@ILM
<   I8
4  I  ! I/   I  I  ELF          S                 4     (   %RU  $ >  $ >   :;I  $ >  .?:;I@
   :;I     	 I  
. ?:;@
  . ?:;I@
  4 :;I  & I  4 :;I                                      int             zL                                       ,                           	   
                 ,            SS #   5A       $   3    %   2SCK &   4SDA (   SCL )       *   A0 ,   6A1 -   7A2 .   8A3 /   9A4 0   :A5 1   ;A6 2   <A7 3   =A8 4   >A9 5   ?A10 6   @A11 7   AA12 8   BA13 9   CA14 :   DA15 ;   E    #  
    e:/thomas/downloads/programs/exe/uecide/hardware/compilers/avr-gcc/lib/gcc/../../avr/include E:\Thomas\Downloads\Programs\EXE\uecide\hardware\boards\Arduino\mega2560 E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api  main.cpp   pins_arduino.h   stdint.h               *                /                1               ELF          S            
     4     ( $ ! %RU   :;I  $ >  $ >  .?:;I@
   :;I   I  .?:;@
  	 I
  
. ?:;@
  .?:;@@
     .?:;@I@
   :;I  .?:;@I@
                                      0       int         P           7               g         E                   g                         	   hi 
                                ptr                         :  ptr                           i      %                               %         /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\PinMappings.h"

//
// Useful Macros
//

#define setPinDir(p,d) {if(d){*digitalPinToDirectionReg((p)) |= _BV(digitalPinToBit((p)));}else{*digitalPinToDirectionReg((p)) &= ~_BV(digitalPinToBit((p)));}}
#define setPinValue(p,v) {if(v){*digitalPinToPortReg((p)) |= _BV(digitalPinToBit((p)));}else{*digitalPinToPortReg((p)) &= ~_BV(digitalPinToBit((p)));}}
#define getPinValue(p) (!!(*digitalPinToPinReg((p)) & _BV(digitalPinToBit((p)))))
#define togglePin(p) {*digitalPinToPortReg((p)) ^= _BV(digitalPinToBit((p)));}


//
// Pin Mappings
//

#if defined(__AVR_ATmega162__)

//----- User Configurable Pin Definitions for ATMega162 Variants -----
//Warning: D20 to D27 inclusive are NOT allowed

//GPIO Header:
                             //VCC (Header Pin 5)
#define gpioPin_0_Define 2   //IO0 (Header Pin 4) [ATMega PD2] - Interrupt Capable (INT0)
#define gpioPin_1_Define 29  //IO1 (Header Pin 3) [ATMega PE1] - GPIO Pin
#define gpioPin_2_Define 28  //IO2 (Header Pin 2) [ATMega PE0] - GPIO Pin
                             //GND (Header Pin 1)

//Status Pins:
#define statusPin_Define 13 

//Motor Driver Pins:
#define resetPin_0_Define 15
#define resetPin_1_Define 14

#define dirPin_0_Define 3
#define dirPin_1_Define 7

#define enablePin_0_Define 4
#define enablePin_1_Define 8

#define stepPin_0_Define 5
#define stepPin_1_Define 30

#define modePins0_0_Define 6
#define modePins1_0_Define 17
#define modePins2_0_Define 16
#define modePins0_1_Define 10
#define modePins1_1_Define 18
#define modePins2_1_Define 19

//ST4 Pins:
#define ST4AddPin_0_Define 34
#define ST4AddPin_1_Define 33
#define ST4SubPin_0_Define 31
#define ST4SubPin_1_Define 32

//SPI Pins:
#define SPIClockPin_Define 32 //(13)
#define SPIMISOPin_Define  34 //(12) - Comments are hardware SPI pin. These are sadly partly used for other things.
#define SPIMOSIPin_Define  33 //(11) - Instead we are currently doing software SPI on same pins as ST4.
#define SPISSnPin_Define   31 //(6)


#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)

//---- User Configurable Pin Definitions for ATMegaXXX0 Variants -----
//Warning: D30 to D37 inclusive are NOT allowed

//GPIO Pins:
#define gpioPin_0_Define 21  //IO0 [ATMega PD0] - Interrupt Capable (INT0)
#define gpioPin_1_Define 22  //IO1 [ATMega PA0] - GPIO Pin
#define gpioPin_2_Define 23  //IO2 [ATMega PA1] - GPIO Pin

//Status Pins:
#define statusPin_Define 13

//Motor Driver Pins:
#define resetPin_0_Define 55 //Analog 1
#define resetPin_1_Define 54 //Analog 0

#define dirPin_0_Define 3
#define dirPin_1_Define 7

#define enablePin_0_Define 4
#define enablePin_1_Define 8

#define stepPin_0_Define 5
#define stepPin_1_Define 12

#define modePins0_0_Define 15
#define modePins1_0_Define 16
#define modePins2_0_Define 17
#define modePins0_1_Define 20
#define modePins1_1_Define 19
#define modePins2_1_Define 18

//ST4 Pins:
//#define ALTERNATE_ST4 //Uncomment this line to use the alternate mapping for the ST4 port, using A8 to A11 instead of 50 to 53

//You only have a choice between two locations for the ST4 pins as controlled by the above #define.
#ifdef ALTERNATE_ST4
#define ST4AddPin_0_Define 62 //Analog 8
#define ST4AddPin_1_Define 63 //Analog 9
#define ST4SubPin_0_Define 64 //Analog 10
#define ST4SubPin_1_Define 65 //Analog 11
#else
#define ST4AddPin_0_Define 50
#define ST4AddPin_1_Define 51
#define ST4SubPin_0_Define 53
#define ST4SubPin_1_Define 52
#endif

//SPI Pins:
#define SPIClockPin_Define 52
#define SPIMISOPin_Define  50
#define SPIMOSIPin_Define  51
#define SPISSnPin_Define   53


#endif








// Do not modify anything below this line! ---------------------------------------


#if (CS10 != CS30) || (CS11 != CS31) || (CS12 != CS32)
#error incorrect assumption about prescale bits being equal between timer 1 and 3.
#endif
#define CSn0 CS10
#define CSn1 CS11
#define CSn2 CS12



#if defined(__AVR_ATmega162__)


#ifndef USART0_TX_vect
#define USART0_TX_vect USART0_TXC_vect
#endif
#ifndef USART0_RX_vect
#define USART0_RX_vect USART0_RXC_vect
#endif

#ifndef USART1_TX_vect
#define USART1_TX_vect USART1_TXC_vect
#endif
#ifndef USART1_RX_vect
#define USART1_RX_vect USART1_RXC_vect
#endif

//Pick some registers we are not going use for GPIOR
#define GPIOR0 PORTC
#define GPIOR1 OCR0
#define GPIOR2 TCNT0

#define PCICR GICR

#ifndef TIMSK3
#define TIMSK3 ETIMSK
#endif
#ifndef TIMSK1
#define TIMSK1 TIMSK
#endif
#ifndef ICIE3
#define ICIE3 TICIE3
#endif
#ifndef ICIE1
#define ICIE1 TICIE1
#endif

#define digitalPinToPortReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &PORTA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &PORTB : \
((((P) >= 20 && (P) <= 27)                            ) ? &PORTC : \
((((P) <= 7              )                            ) ? &PORTD : &PORTE ))))

#define digitalPinToDirectionReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &DDRA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &DDRB : \
((((P) >= 20 && (P) <= 27)                            ) ? &DDRC : \
((((P) <= 7              )                            ) ? &DDRD : &DDRE ))))

#define digitalPinToPinReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &PINA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &PINB : \
((((P) >= 20 && (P) <= 27)                            ) ? &PINC : \
((((P) <= 7              )                            ) ? &PIND : &PINE ))))

#define digitalPinToBit(P) \
(((P) >=  0 && (P) <=  3) ? (P)      : \
(((P) >= 10 && (P) <= 13) ? (P) - 6  : \
(((P) >=  8 && (P) <=  9) ? (P) - 8  : \
(((P) >= 18 && (P) <= 19) ? 21 - (P) : \
(((P) >= 20 && (P) <= 27) ? (P) - 20 : \
(((P) >= 28 && (P) <= 30) ? (P) - 28 : \
(((P) >= 31 && (P) <= 34) ? (P) - 27 : \
(((P) >= 14 && (P) <= 17) ? (P) - 14 : \
(((P) >=  5 && (P) <=  6) ? (P) - 1  : \
(((P) == 7              ) ? (P)      : 6 ))))))))))


#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)


#define digitalPinToPortReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &PORTA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PORTB : \
((((P) >= 30 && (P) <= 37)                            ) ? &PORTC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &PORTD : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &PORTE : \
((((P) >= 54 && (P) <= 61)                            ) ? &PORTF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &PORTG : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &PORTH : \
((((P) >= 14 && (P) <= 15)                            ) ? &PORTJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &PORTK : &PORTL))))))))))

#define digitalPinToDirectionReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &DDRA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &DDRB : \
((((P) >= 30 && (P) <= 37)                            ) ? &DDRC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &DDRD : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &DDRE : \
((((P) >= 54 && (P) <= 61)                            ) ? &DDRF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &DDRG : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &DDRH : \
((((P) >= 14 && (P) <= 15)                            ) ? &DDRJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &DDRK : &DDRL))))))))))

#define digitalPinToPinReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &PINA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PINB : \
((((P) >= 30 && (P) <= 37)                            ) ? &PINC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &PIND : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &PINE : \
((((P) >= 54 && (P) <= 61)                            ) ? &PINF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &PING : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &PINH : \
((((P) >= 14 && (P) <= 15)                            ) ? &PINJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &PINK : &PINL))))))))))

#define digitalPinToBit(P) \
(((P) >=  7 && (P) <=  9) ? (P) - 3 : \
(((P) >= 10 && (P) <= 13) ? (P) - 6 : \
(((P) >= 22 && (P) <= 29) ? (P) - 22 : \
(((P) >= 30 && (P) <= 37) ? 37 - (P) : \
(((P) >= 39 && (P) <= 41) ? 41 - (P) : \
(((P) >= 42 && (P) <= 49) ? 49 - (P) : \
(((P) >= 50 && (P) <= 53) ? 53 - (P) : \
(((P) >= 54 && (P) <= 61) ? (P) - 54 : \
(((P) >= 62 && (P) <= 69) ? (P) - 62 : \
(((P) >= 0  && (P) <= 1 ) ? (P)      : \
(((P) >= 14 && (P) <= 15) ? 15 - (P) : \
(((P) >= 16 && (P) <= 17) ? 17 - (P) : \
(((P) >= 20 && (P) <= 21) ? 21 - (P) : \
(((P) == 19             ) ?       2  : \
(((P) >= 5  && (P) <= 6 ) ?       3  : \
(((P) == 18             ) ?       3  : \
(((P) == 2              ) ?       4  : \
(((P) >= 3  && (P) <= 4 ) ?       5  : 7))))))))))))))))))



#endif
ELF          S            LS     4     ( K H nan inf ovf . %RU   :;I  $ >  $ >   I  $ >  :;   :;I8
2  	 :;I8
2  
.?:;@2<   I4  .?:;<   I  .?:;@I<  .?:;@<  .?:;@I2<  .?:;@I2<  :;   :;I8
    & I   I  :;   :;   I8
4  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\SerialLink.cpp"

#include "SerialLink.h"
#include <avr/io.h>
#include <avr/interrupt.h>

//This stuff is needed for GCC to correctly append in the value from SERIALn above
#define __REGnD(r,n,d) r##n##d
#define __REGn(r,n) r##n
#define _REGnD(r,n,d) __REGnD(r,n,d)
#define _REGn(r,n) __REGn(r,n)

//Two macros to make things like UCSRA0A and U2X0
#define REGnD(r,d) _REGnD(r,SERIALn,d)
#define REGn(r) _REGn(r,SERIALn)

//Registers
#define UCSRnA REGnD(UCSR,A)
#define UCSRnB REGnD(UCSR,B)
#define UBRRnH REGnD(UBRR,H)
#define UBRRnL REGnD(UBRR,L)
#define UDRn REGn(UDR)

//Bits
#define U2Xn REGn(U2X)
#define RXENn REGn(RXEN)
#define TXENn REGn(TXEN)
#define RXCIEn REGn(RXCIE)
#define UDRIEn REGn(UDRIE)

//Vectors
#define USARTn_RX_vect REGnD(USART,_RX_vect)
#define USARTn_UDRE_vect REGnD(USART,_UDRE_vect)

#define SPI_NULL 0xFF //NULL means ignore
#define SPI_DATA 0x7F //And-ed with all outgoing write packets. An incoming byte is ignored if bits outside this mask are set.
#define SPI_READ 0x81 //SPI read request command
#define SPI_RESP 0x80 //SPI read response request command
#define SPI_ISDATA(a) (!((a) & (~SPI_DATA))) //Returns true if SPI_DATA
#define SPI_ISREAD(a) ( ((a) == ( SPI_READ))) //Returns true if SPI_READ

#define BUFFER_SIZE 32 //Must be power of 2!
#define BUFFER_PTR_MASK (BUFFER_SIZE - 1)
typedef struct {
    unsigned char buffer[BUFFER_SIZE];
    volatile unsigned char head;
    volatile unsigned char tail;
} 
RingBuffer;

RingBuffer txBuf = {{0},0,0};
RingBuffer rxBuf = {{0},0,0};

bool softSPIEnabled = false;

//Initialise the hardware UART port and set baud rate.
void Serial_initialise(const unsigned long baud) {
    Byter baud_setting;

    UCSRnA = _BV(U2Xn);
    baud_setting.integer = (F_CPU / 4 / baud - 1) / 2;

    if (baud_setting.high & 0xF0) {
        UCSRnA = 0;
        baud_setting.integer = (F_CPU / 8 / baud - 1) / 2;
    }

    // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
    UBRRnH = baud_setting.high & 0x0F;
    UBRRnL = baud_setting.low;

    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.

    //And enable
    sbi(UCSRnB, RXENn);
    sbi(UCSRnB, TXENn);
    sbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
}

//Disable the hardware UART port
void Serial_disable() {
    cbi(UCSRnB, RXENn);
    cbi(UCSRnB, TXENn);
    cbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    cli();
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    txBuf.tail = 0;
    rxBuf.head = 0;
    rxBuf.tail = 0;
    SREG = oldSREG;
}

//Initialise the Software SPI by setting ports to correct direction and state.
void SPI_initialise() {
    //Set all SPI pins to idle levels
    setPinDir  (SPIClockPin_Define,OUTPUT); //Clock is output idle high
    setPinValue(SPIClockPin_Define,  HIGH);
    setPinDir  (SPIMISOPin_Define,  INPUT); //MISO is input pull-up
    setPinValue(SPIMISOPin_Define,   HIGH);
    setPinDir  (SPIMOSIPin_Define, OUTPUT); //MOSI is output idle high
    setPinValue(SPIMOSIPin_Define,   HIGH);
    setPinDir  (SPISSnPin_Define,  OUTPUT); //SSn is output idle high
    setPinValue(SPISSnPin_Define,    HIGH);
    //Standalone pin is switching to SPI ready, so ensure we out pull-up is to high.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.
    
    //Now enabled
    softSPIEnabled = true;
}

//Disable the Software SPI by setting all ports back to input pull-up
void SPI_disable() {
    //Set all SPI pins to High-Z
    setPinDir  (SPIClockPin_Define, INPUT);
    setPinValue(SPIClockPin_Define,  HIGH);
    setPinDir  (SPIMISOPin_Define,  INPUT);
    setPinValue(SPIMISOPin_Define,   HIGH);
    setPinDir  (SPIMOSIPin_Define,  INPUT);
    setPinValue(SPIMOSIPin_Define,   HIGH);
    setPinDir  (SPISSnPin_Define,   INPUT);
    setPinValue(SPISSnPin_Define,    HIGH);
    //Now disabled
    softSPIEnabled = false;
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
        setPinValue(SPIClockPin_Define,LOW); //Falling Edge   //--     2 cycles         .
        if (data & 0x80) { //Send MSB first                   //-- 2 cycles | 1 cycle    |
            setPinValue(SPIMOSIPin_Define,HIGH);              //-- 2 cycles | -          |
        } else {                                              //--          | 2 cycles    > 8 cycles for both paths
            nop();                                            //--          | 1 cycle    |
            setPinValue(SPIMOSIPin_Define,LOW);               //--          | 2 cycles   |
        }                                                     //-- 2 cycles | -         '
        setPinValue(SPIClockPin_Define,HIGH); //Rising Edge   //--      2 cycles        .
        data = data << 1; //Shift MSB-1 to MSB                //--      1 cycle          |
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
        }                                                     //--       3 cycles       '
    }                                                         //-- Total Path is 16 cycles = 1MHz @ 16MHz clock
    return data; //Return shifted in data.                    //-- 5 Cycles on entry (including CALL), 3 cycles on exit (including RET)
}

//Performs an SPI read request and stores the data in the RX buffer.
// - If there is no space in the buffer, a read request will *not* be performed
//   The buffer should be first emptied by using Serial_read()
void SPI_read(void) {
    //First we check if there is space in the buffer, and that the slave has data to send
    if ((rxBuf.tail != rxBuf.head) && !(getPinValue(standalonePin[STANDALONE_IRQ]))) {
        //If there is, then do a read request  
        setPinValue(SPISSnPin_Define,LOW); //Select the slave
        SPI_transfer(SPI_READ); //First send a read request
        while(!getPinValue(standalonePin[STANDALONE_IRQ])); //Wait for the slave to have loaded its data
        byte data = SPI_transfer(SPI_RESP); //Then send a response request (clocks data from slave to master and informs slave that transfer is done)
        if (SPI_ISDATA(data)) {
            //If the slave had data available (indicated by the MSB being clear)
            rxBuf.buffer[rxBuf.head] = data; //Store the data
            rxBuf.head++; //And increment the head
        }
        setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    }
}

//Performs an SPI write request.
void SPI_write(byte data) {
    setPinValue(SPISSnPin_Define,LOW); //Select the slave
    SPI_transfer(data & SPI_DATA); 
    setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
}

//Checks if there is any data available in the RX buffer.
// - If in SPI mode, this will also perform an SPI read transfer to see if there is any valid data.
byte Serial_available(void) {
    if (softSPIEnabled) {
        //If SPI is enabled, we do a read to check if there is any data.
        SPI_read();
    }
    return ((rxBuf.head - rxBuf.tail) & BUFFER_PTR_MASK); //number of bytes available
}

//Returns the next available data byte in the buffer
// - If there is nothing there, -1 is returned.
char Serial_read(void) {
    //If UART is enabled
    byte tail = rxBuf.tail;
    if (rxBuf.head == tail) {
        return -1;
    } else {
        char c = rxBuf.buffer[tail];
        rxBuf.tail = ((tail + 1) & BUFFER_PTR_MASK);
        return c;
    }
}

//Write a byte of data
// - If in UART mode, the byte is stored into the TX buffer when there is space.
// - If in SPI mode, a write transfer is performed.
void Serial_write(char ch) {
    if (UCSRnB & _BV(TXENn)) { 
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
        if (head == txBuf.tail) {
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
            while (head == txBuf.tail); //wait for buffer to have some space
        }
        
        txBuf.buffer[txBuf.head] = ch; //Load the new data into the buffer
        txBuf.head = head; //And store the new head.
        sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled if not already
    } else if (softSPIEnabled) {
        //If SPI is enabled, we do an SPI write.
        SPI_write(ch);
    }
}

//Flushes data from TX buffer
void Serial_flush() {
    if (UCSRnB & _BV(TXENn)) { 
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
        if (head == txBuf.tail) {
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
            while (head == txBuf.tail); //wait for buffer to have some space
        }
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    while (*str) {
        Serial_write(*str++);
    }
}

//Convert array to bytes
void Serial_writeArr(char* arr, byte len) {
    while (len--) {
        Serial_write(*arr++);
    }
}

//UART RX IRQ
// - Stores data from UART port into RX ring buffer
ISR(USARTn_RX_vect,ISR_NAKED) {
    register unsigned char c asm("r18");
    register unsigned char head asm("r25");
    register unsigned char tail asm("r24");
    asm volatile (
        "push %0     \n\t"
        "in   %0, %3 \n\t" 
        "push %0     \n\t"
        "push %1     \n\t"
        "push %2     \n\t"
        "push r30    \n\t"
        "push r31    \n\t"
        :
        : "a" (c), "r" (head), "r" (tail), "I" (_SFR_IO_ADDR(SREG))
        :
    );

    //Read in from the serial data register
    c = UDRn;
    //get the current head
    head = rxBuf.head;
    head++;
    head &= BUFFER_PTR_MASK;
    tail = rxBuf.tail;

    if (head != tail) {
        rxBuf.buffer[rxBuf.head] = c;
        rxBuf.head = head;
    } 

    asm volatile (
        "pop r31    \n\t"
        "pop r30    \n\t"
        "pop %2     \n\t"
        "pop %1     \n\t"
        "pop %0     \n\t"
        "out %3, %0 \n\t"
        "pop %0     \n\t"
        "reti       \n\t"
        : "=a" (c), "=r" (head), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
}

//UART TX IRQ
// - Writes data to UART port from TX ring buffer
ISR(USARTn_UDRE_vect, ISR_NAKED)
{
    register unsigned char tail asm("r25");
    register unsigned char temp asm("r24");
    asm volatile (
        "push %0       \n\t"
        "in   %0, %2   \n\t" 
        "push %0       \n\t"
        "push %1       \n\t"
        "push r30      \n\t"
        "push r31      \n\t"
        :: "r" (temp), "r" (tail), "I" (_SFR_IO_ADDR(SREG)):
    );
    tail = txBuf.tail;
    temp = txBuf.head;
    if (temp == tail) {
        // Buffer empty, so disable interrupts
        cbi(UCSRnB, UDRIEn);
    } else {
        // There is more data in the output buffer. Send the next byte
        temp = txBuf.buffer[tail];
        tail++;
        tail &= BUFFER_PTR_MASK;
        txBuf.tail = tail;
        UDRn = temp;
    }

    asm volatile (
        "pop r31    \n\t"
        "pop r30    \n\t"
        "pop %1     \n\t"
        "pop %0     \n\t"
        "out %2, %0 \n\t"
        "pop %0     \n\t"
        "reti       \n\t"
        : "=r" (temp), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
}
ELF          S                 4     ( : 7 %RU  $ >   :;I  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  I  ! I/  5 I  .?:;   4 :;I  .?:;@@
   :;I  4 :;I  1XY  4 1  & I  4 1
  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\SerialLink.h"
#ifndef __SERIAL_LINK_H__
#define __SERIAL_LINK_H__

#include "AstroEQ.h"

//Serial Defines
//Select the required serial port with the #define below.
//For ATMega162, valid options are 0. USART1 on the ATMega162 variants must not be used for AstroEQ.
//For Arduino Mega, valid options are 0,1,(2,3) the latter two are untested but should work.
#define SERIALn 0

//Serial Functions
void Serial_initialise(const unsigned long baud);
void Serial_disable();

//SPI Functions
void SPI_initialise();
void SPI_disable();

//Common Functions
byte Serial_available(void);
void Serial_clear(void);
char Serial_read(void);
void Serial_flush(void);
void Serial_write(char ch);
void Serial_writeStr(char* str);
void Serial_writeArr(char* arr, byte len);

#endif //__SERIAL_LINK_H__

ELF          S            0?     4     ( 6 3  %RU   :;I  $ >  $ >  $ >  :;   :;I8
2   :;I8
2  	.?:;@2<  
 I4  .?:;<   I  .?:;@I<  .?:;@<  .?:;@I2<  .?:;@I2<   I  :;   :;I8
    & I   I  <   :;  :;  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\synta.cpp"

#include "synta.h"
#include <string.h>


bool validateCommand(byte len);
bool validPacket;
char commandString[11];
byte commandIndex;

byte _axis;
char _command;

void synta_initialise(unsigned long eVal, byte gVal){
    validPacket = 0;
    commandIndex = 0;
    memset(commandString,0,sizeof(commandString));
    _axis = 0;
    Commands_init(eVal, gVal);
}

const char startInChar = ':';
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
        nibble += (('A'-'0')-0xA);
    }
    *hex = (nibble + '0');
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
}

void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData){
    char replyLength = (commandOrError == '\0') ? -1 : Commands_getLength(commandOrError,0); //get the number of data bytes for response

    if (replyLength < 0) {
        replyLength = 0;
        dataPacket[0] = errorChar;  
    } else {
        dataPacket[0] = startOutChar;

        if (replyLength == 2) {
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
        } else if (replyLength == 6) {
            Inter inter = Inter(responseData);
            private_byteToHex(dataPacket+6,dataPacket+5,inter.highByter.lowNibbler);
            private_byteToHex(dataPacket+4,dataPacket+3,inter.lowByter.highNibbler);
            private_byteToHex(dataPacket+2,dataPacket+1,inter.lowByter.lowNibbler);
        }

    }

    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    _command = commandString[0]; //first byte is command
    _axis = commandString[1] - 49; //second byte is axis
    if(_axis > 1){
        return false; //incorrect axis
    }
    char requiredLength = Commands_getLength(_command,1); //get the required length of this command
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
        decoded[i] = commandString[i + 2];
    }
    decoded[i] = '\0'; //Null
    return true;
}

char synta_recieveCommand(char* dataPacket, char character){
    if(validPacket){
        if (character == startInChar){
            dataPacket[0] = errorChar;
            dataPacket[1] = endChar;
            dataPacket[2] = '\0';
            validPacket = 0; //new command without old finishing! (dataPacket contains error message)
            return -2;
        }

        commandString[commandIndex++] = character; //Add character to current string build

        if(character == endChar){
            if(synta_validateCommand(commandIndex, dataPacket)){
                validPacket = 0;
                return _command; //Successful decode (dataPacket contains decoded packet, return value is the current command)
            } else {
                goto error; //Decode Failed (dataPacket contains error message)
            }
        } else if (commandIndex == sizeof(commandString)){
            goto error; //Message too long! (dataPacket contains error message)
        }
    } else if (character == startInChar){
        //Begin new command
        commandIndex = 0;
        validPacket = 1;
        commandString[0] = '\0';
    }
    return 0; //Decode not finished (dataPacket unchanged)
error:
    dataPacket[0] = errorChar;
    dataPacket[1] = endChar;
    dataPacket[2] = '\0';
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    }
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
}

byte synta_hexToByte(char* hex){
    return hexToByte(hex);
}
unsigned long synta_hexToLong(char* hex){
    //  char *boo; //waste point for strtol
    //  char str[7]; //Destination of rearranged hex
    //  strncpy(str,&hex[4],2); //Lower Byte
    //  strncpy(str+2,&hex[2],2); //Middle Byte
    //  strncpy(str+4,hex,2); //Upper Byte
    //  str[6] = 0;
    //  return strtol(str,&boo,16); //convert hex to long integer

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    return inter.integer; //and convert it to an integer
}

char synta_command(){
    return _command;
}

byte synta_axis(byte axis){
    if(axis < 2){
        _axis = axis;
    }
    return _axis;
}

ELF          S            "     4     ( . + %RU  $ >   :;I  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  .?:;<   I4   I  .?:;<   I  :;  I  ! I/  5 I  .?:;    :;I   :;I  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\synta.h"

#ifndef synta_h
#define synta_h

#include "AstroEQ.h"
#include "commands.h"

void synta_initialise(unsigned long version, byte gVal);
void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData);
char synta_recieveCommand(char* dataPacket, char character);
byte synta_axis(byte axis = 2); //make target readonly to outside world.
char synta_command(); //make current command readonly to outside world.
unsigned long synta_hexToLong(char* hex);
byte synta_hexToByte(char* hex);

//Methods for accessing command variables - now in commands.h
//void cmd_setDir(byte target, byte _dir);
//void cmd_updateStepDir(byte target, byte stepSize);
//unsigned int cmd_fVal(byte target);
//void cmd_setStopped(byte target, byte _stopped);
//void cmd_setGotoEn(byte target, byte _gotoEn);
//void cmd_setFVal(byte target, byte _FVal);
//void cmd_setjVal(byte target, unsigned long _jVal);
//void cmd_setIVal(byte target, unsigned int _IVal);
//void cmd_setHVal(byte target, unsigned long _HVal);
//void cmd_setGVal(byte target, byte _GVal);
  
#endif
ELF          S            %     4     ( 3 0 %RU   :;I  $ >  $ >  $ >  .?:;@@
   :;I  4 :;I  	  
4 :;I  4 :;I  . ?:;@
  .:;I    :;I  4 :;I    4 :;I    .?:;@@
   :;I  4 :;I  4 :;I  1XY   1  4 1  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\UnionHelpers.h"

#ifndef __UNION_HELPERS_H__
#define __UNION_HELPERS_H__

#include <inttypes.h>
typedef uint8_t byte;

typedef union {
    uint16_t integer;
    uint8_t array[2];
} TwoBytes;

typedef union {
    uint32_t integer;
    uint16_t array[2];
    uint8_t bytes[4];
} FourBytes;

typedef union{
    byte integer;
    struct {
        byte low:4;
        byte high:4;
    };
} Nibbler;

typedef union{
    unsigned int integer;
    struct {
        byte low;
        byte high;
    };
    struct {
        Nibbler lowNibbler;
        Nibbler highNibbler;
    };
} Byter;

typedef union InterMaker{
    unsigned long integer;
    struct {
        byte low;
        byte mid;
        byte high;
        byte top;
    };
    struct {
        Byter lowByter;
        Byter highByter;
    };
    InterMaker(unsigned long _integer){
        integer = _integer;
    }
    InterMaker(byte _top, byte _high, byte _mid, byte _low){
        low = _low;
        mid = _mid;
        high = _high;
        top = _top;
    }
} Inter;

typedef union{
    unsigned int integer;
    struct {
        unsigned int low:4;
        unsigned int mid:4;
        unsigned int high:4;
        unsigned int:4;
    };
    struct {
        Nibbler lowNibbler;
        Nibbler highNibbler;
    };
} DoubleNibbler;

#endif //__UNION_HELPERS_H__
ELF          S                 4     (  
 %  $ >   :;I  $ >  $ >  4 :;I  & I  4 :;I                                      z3       int                                         SS #   5(       $   3    %   2SCK &   4SDA (   SCL )       *   A0 ,   6A1 -   7A2 .   8A3 /   9A4 0   :A5 1   ;A6 2   <A7 3   =A8 4   >A9 5   ?A10 6   @A11 7   AA12 8   BA13 9   CA14 :   DA15 ;   E        
    e:/thomas/downloads/programs/exe/uecide/hardware/compilers/avr-gcc/lib/gcc/../../avr/include E:\Thomas\Downloads\Programs\EXE\uecide\hardware\boards\Arduino\mega2560  pins_arduino.h   stdint.h                         LED_BUILTIN bool GNU C++ 4.3.2 float short unsigned int unsigned char double MISO MOSI long unsigned int unsigned int long long unsigned int uint8_t long long int char long int signed char E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api\USBCore.cpp  .symtab .strtab .shstrtab .text .data .bss .debug_abbrev .rela.debug_info .rela.debug_line .debug_str                                                       4                      !             4                      '             4                      ,              4   c                  ?                                  :              ,                P              3                   K              4	                 \      0       8                                D  g                                                	                g                                                                                           ?            >            =         (   4         0             <                                                                   	 I              X               USBCore.cpp __SREG__ __SP_H__ __SP_L__ __CCP__ __tmp_reg__ __zero_reg__ __do_copy_data __do_clear_bss                                                      $        )        6     8   D     i   K        R     W   Y        `     v   m     %   t        {             F                R        M                     ELF          S                 4     ( , ) %RU  $ >   :;I  $ >  $ >   I   '  .?:;'@
  	 :;I  
 :;I
  . ?:;'@
  4 :;I  & I  4 :;I  I  ! I/  4 :;I
  5 I                                          z7       int                             A          &            	    &,       	    &       
    &>   de                 
    ,   h                                            ELF          S                 4     (   %RU  $ >   :;I  $ >  $ >  .?:;'@
   :;I
  .?:;'I@
  	 :;I  
4 :;I  4 :;I    4 :;I  4 :;I  & I  4 :;I  I  !   4 :;I?<  4 :;I?
                                          z7       int     |P                               !                 ,   h     )>               	pin (,       
low *,           *,            g         K  	pin f,       	val f>                   xE       x,         SS #V  5,       $V  3    %V  2SCK &V  4SDA (V  SCL )V      *V  A0 ,V  6A1 -V  7A2 .V  8A3 /V  9A4 0V  :A5 1V  ;A6 2V  <A7 3V  =A8 4V  >A9 5V  ?A10 6V  @A11 7V  AA12 8V  BA13 9V  CA14 :V  DA15 ;V  E,   d       q  Y      ,        J   |  
    e:/thomas/downloads/programs/exe/uecide/hardware/compilers/avr-gcc/lib/gcc/../../avr/include E:\Thomas\Downloads\Programs\EXE\uecide\hardware\boards\Arduino\mega2560 E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api\  wiring_analog.c   stdint.h   pins_arduino.h   /Arduino.h               4                     <                               ELF          S                 4     (    %RU  $ >   :;I  $ >  $ >  .?:;'@
   :;I   :;I
  	4 :;I  
4 :;I    4 :;I
  4 :;I     I  5 I  .:;'@
   :;I  .?:;'I@
  4 :;I  & I  4 :;I  I  ! I/  4 :;I?
  ELF          S            4     4     (   %RU  $ >   :;I  $ >  $ >  .?:;'I@
   :;I   :;I  	4 :;I  
4 :;I  4 :;I      4 :;I  & I  4 :;I  I  !   4 :;I?<   C                                       z7       int     |P                               !^              pin  ,            ,            ^       	bit %,   
    &,       ',           (^           ,^           -^               C  
    %E       %,                k  
    &E       &,                      0E           0E                      5E           5E                    :E           :E         SS #  5,       $  3    %  2SCK &  4SDA (  SCL )      *  A0 ,  6A1 -  7A2 .  8A3 /  9A4 0  :A5 1  ;A6 2  <A7 3  =A8 4  >A9 5  ?A10 6  @A11 7  AA12 8  BA13 9  CA14 :  DA15 ;  EE              ,   "       /        A        {  
    e:/thomas/downloads/programs/exe/uecide/hardware/compilers/avr-gcc/lib/gcc/../../avr/include E:\Thomas\Downloads\Programs\EXE\uecide\hardware\boards\Arduino\mega2560 E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api\  wiring_pulse.c   stdint.h   pins_arduino.h   /Arduino.h               4                    ELF          S                 4     ( !  %RU  $ >  $ >  .?:;@I@
   :;I   :;I  .?:;@I@
  4 :;I  	.?:;@@
                                      int     map 6    3               x 63           63           63           63           63            ;    %               w ;%            <    %            
  h <
      l <
               %    3            @      %3            -    3                  -3           -3           23    	                     %         <   `   
    E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api  WMath.cpp               I                     N                O                8                          @                          1                               /?O_o;L*nj{			bELF          S            h     4     (    %RU  $ >  $ >  $ >  :;   :;I8
2   :;I8
2  .?:;@2<  	 I4  
.?:;<   I  .?:;@I<  .?:;@<  .?:;@I2<  .?:;@I2<   I  :;   :;I8
    & I   I   I8
2  .?:;<  .G:;    I4  