/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ.cpp"
/*
  Code written by Thomas Carpenter 2012-2017
  
  With thanks Chris over at the EQMOD Yahoo group for assisting decoding the Skywatcher protocol
  
  
  Equatorial mount tracking system for integration with EQMOD using the Skywatcher/Synta
  communication protocol.
 
  Works with EQ5, HEQ5, and EQ6 mounts, and also a great many custom mount configurations.
 
  Current Verison: 8.0.2
*/

//Only works with ATmega162, and Arduino Mega boards (1280 and 2560)
#if defined(__AVR_ATmega162__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)


/*
 * Include headers
 */
 
#include "AstroEQ.h" //AstroEQ header

#include "EEPROMReader.h" //Read config file
#include "SerialLink.h" //Serial Port
#include "UnionHelpers.h" //Union prototypes
#include "synta.h" //Synta Communications Protocol.
#include <util/delay.h>    
#include <util/delay_basic.h>
#include <avr/wdt.h>

// Watchdog disable on boot.
void wdt_init(void) __attribute__((naked)) __attribute__((section(".init3")));
void wdt_init(void)
{
    wdt_disable();
    return;
}

/*
 * Defines
 */
//Define the version number
#define ASTROEQ_VER 802

/*
 * Global Variables
 */
byte stepIncrement[2];
byte readyToGo[2] = {0,0};
unsigned long gotoPosn[2] = {0UL,0UL}; //where to slew to
bool encodeDirection[2];
byte progMode = RUNMODE; //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
byte microstepConf;
byte driverVersion;
bool standaloneMode = false; //Initially not in standalone mode (EQMOD mode)
bool syntaMode = true; //And synta processing is enabled.

#define timerCountRate 8000000

#define DecimalDistnWidth 32
unsigned int timerOVF[2][DecimalDistnWidth];
bool canJumpToHighspeed = false;
bool defaultSpeedState = SPEEDNORM;
bool disableGearChange = false;
bool allowAdvancedHCDetection = false;
unsigned int gotoDecelerationLength[2];
byte accelTableRepeatsLeft[2] = {0,0};
byte accelTableIndex[2] = {0,0};

/*
 * Helper Macros
 */
#define distributionSegment(m)      (m ? GPIOR1     : GPIOR2    )
#define currentMotorSpeed(m)        (m ? OCR3A      : OCR3B     )
#define irqToNextStep(m)            (m ? OCR1A      : OCR1B     )
#define interruptOVFCount(m)        (m ? ICR3       : ICR1      )
#define interruptControlRegister(m) (m ? TIMSK3     : TIMSK1    )
#define interruptControlBitMask(m)  (m ? _BV(ICIE3) : _BV(ICIE1))
#define timerCountRegister(m)       (m ? TCNT3      : TCNT1     )
#define timerPrescalarRegister(m)   (m ? TCCR3B     : TCCR1B    )
#define gotoDeceleratingBitMask(m)  (m ? _BV(3)     : _BV(2)    )
#define gotoRunningBitMask(m)       (m ? _BV(1)     : _BV(0)    )
#define gotoControlRegister GPIOR0




/*
 * Inline functions
 */
inline bool gotoRunning(const byte axis) {
    return (gotoControlRegister & gotoRunningBitMask(axis));
}
inline bool gotoDecelerating(const byte axis) {
    return (gotoControlRegister & gotoDeceleratingBitMask(axis));
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
}
inline void clearGotoDecelerating(const byte axis) {
    gotoControlRegister &= ~gotoDeceleratingBitMask(axis);
}



/*
 * Generate Mode Mappings
 */

#define MODE0 0
#define MODE1 1
#define MODE2 2
#define MODE0DIR 3
#define MODE1DIR 4
#define MODE2DIR 5
byte modeState[2] = {((LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0)), (( LOW << MODE2) | ( LOW << MODE1) | (LOW << MODE0))}; //Default to 1/8th stepping as that is the same for all

void buildModeMapping(byte microsteps, byte driverVersion){
    //For microstep modes less than 8, we cannot jump to high speed, so we use the SPEEDFAST mode maps. Given that the SPEEDFAST maps are generated for the microstepping modes >=8
    //anyway, we can simply multiply the number of microsteps by 8 if it is less than 8 and thus reduce the number of cases in the mode generation switch statement below 
    if (microsteps < 8){
        microsteps *= 8;
    }
    //Generate the mode mapping for the current driver version and microstepping modes.
    switch (microsteps) {
        case 8:
            // 1/8
            modeState[SPEEDNORM] =                                                                                       (( LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/1
            modeState[SPEEDFAST] =                                                                                       (( LOW << MODE2) | ( LOW << MODE1) | ( LOW << MODE0));
            break;
        case 32:
            // 1/32
            modeState[SPEEDNORM] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | (HIGH << MODE1) | ( LOW << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/4
            modeState[SPEEDFAST] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | (HIGH << MODE1) | ( LOW << MODE0));
            break;
        case 16:
        default:  //Unknown. Default to half/sixteenth stepping
            // 1/16
            modeState[SPEEDNORM] = (driverVersion == DRV882x) ? ((  LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
            // 1/2
            modeState[SPEEDFAST] = (driverVersion == DRV882x) ? (( HIGH << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0));
            break;
    }
}




/*
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
}

void calculateRate(byte axis){
  
    unsigned long rate;
    unsigned long remainder;
    float floatRemainder;
    unsigned long divisor = cmd.bVal[axis];
    byte distWidth = DecimalDistnWidth;
    
    //When dividing a very large number by a much smaller on, float accuracy is abismal. So firstly we use integer math to split the division into quotient and remainder
    rate = timerCountRate / divisor; //Calculate the quotient
    remainder = timerCountRate % divisor; //Calculate the remainder
    
    //Then convert the remainder into a decimal number (division of a small number by a larger one, improving accuracy)
    floatRemainder = (float)remainder/(float)divisor; //Convert the remainder to a decimal.
    
    //Multiply the remainder by distributionWidth to work out an approximate number of extra clocks needed per full step (each step is 'distributionWidth' microsteps)
    floatRemainder *= (float)distWidth; 
    //This many extra cycles are needed:
    remainder = (unsigned long)(floatRemainder+0.5f); 
    
    //Now truncate to an unsigned int with a sensible max value (the int is to avoid register issues with the 16 bit timer)
    if((unsigned int)(rate >> 16)){
        rate = 65535UL;
    } else if (rate < 128UL) {
        rate = 128UL;
    }
#if defined(__AVR_ATmega162__)
    rate--;
#endif
  
    for (byte i = 0; i < distWidth; i++){
#if defined(__AVR_ATmega162__)
        timerOVF[axis][i] = rate; //Subtract 1 as timer is 0 indexed.
#else
        timerOVF[axis][i] = rate; //Hmm, for some reason this one doesn't need 1 subtracting???
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
        distn *= (float)distWidth;
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    }
    
}

void systemInitialiser(){    
    
    encodeDirection[RA] = EEPROM_readByte(RAReverse_Address) ? CMD_REVERSE : CMD_FORWARD;  //reverse the right ascension if 1
    encodeDirection[DC] = EEPROM_readByte(DECReverse_Address) ? CMD_REVERSE : CMD_FORWARD; //reverse the declination if 1
    
    driverVersion = EEPROM_readByte(Driver_Address);
    microstepConf = EEPROM_readByte(Microstep_Address);

    allowAdvancedHCDetection = !EEPROM_readByte(AdvHCEnable_Address);
    
    defaultSpeedState = (microstepConf >= 8) ? SPEEDNORM : SPEEDFAST;
    disableGearChange = !EEPROM_readByte(GearEnable_Address);
    canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
        
    synta_initialise(ASTROEQ_VER,(canJumpToHighspeed ? 8 : 1)); //initialise mount instance, specify version!
    
    buildModeMapping(microstepConf, driverVersion);
    
    if(!checkEEPROM()){
        progMode = PROGMODE; //prevent AstroEQ startup if EEPROM is blank.
    }

    calculateRate(RA); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateDecelerationLength(RA);
    calculateDecelerationLength(DC);
    
    //Status pin to output low
    setPinDir  (statusPin,OUTPUT);
    setPinValue(statusPin,   LOW);

    //Standalone Speed/IRQ pin to input no-pullup
    setPinDir  (standalonePin[  STANDALONE_IRQ], INPUT);
    setPinValue(standalonePin[  STANDALONE_IRQ],  HIGH); //enable pull-up to pull IRQ high.

    //Standalone Pullup/Pulldown pin to output high
    setPinDir  (standalonePin[ STANDALONE_PULL],OUTPUT);
    setPinValue(standalonePin[ STANDALONE_PULL],  HIGH);
    
    //ST4 pins to input with pullup
    setPinDir  (st4Pins[RA][ST4P],INPUT);
    setPinValue(st4Pins[RA][ST4P],HIGH );
    setPinDir  (st4Pins[RA][ST4N],INPUT);
    setPinValue(st4Pins[RA][ST4N],HIGH );
    setPinDir  (st4Pins[DC][ST4P],INPUT);
    setPinValue(st4Pins[DC][ST4P],HIGH );
    setPinDir  (st4Pins[DC][ST4N],INPUT);
    setPinValue(st4Pins[DC][ST4N],HIGH );
    
    //Reset pins to output
    setPinDir  (resetPin[RA],OUTPUT);
    setPinValue(resetPin[RA],   LOW);  //Motor driver in Reset
    setPinDir  (resetPin[DC],OUTPUT);
    setPinValue(resetPin[DC],   LOW);  //Motor driver in Reset 
    
    //Enable pins to output
    setPinDir  (enablePin[RA],OUTPUT);
    setPinValue(enablePin[RA],  HIGH); //Motor Driver Disabled
    setPinDir  (enablePin[DC],OUTPUT);
    setPinValue(enablePin[DC],  HIGH); //Motor Driver Disabled
    
    //Step pins to output
    setPinDir  (stepPin[RA],OUTPUT);
    setPinValue(stepPin[RA],   LOW);
    setPinDir  (stepPin[DC],OUTPUT);
    setPinValue(stepPin[DC],   LOW);
    
    //Direction pins to output
    setPinDir  (dirPin[RA],OUTPUT);
    setPinValue(dirPin[RA],   LOW);
    setPinDir  (dirPin[DC],OUTPUT);
    setPinValue(dirPin[DC],   LOW);
    
    //Load the correct mode
    byte state = modeState[defaultSpeedState]; //Extract the default mode - If the microstep mode is >= then we start in NORMAL mode, otherwise we use FAST mode

    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    setPinDir  (modePins[RA][MODE0],  OUTPUT                      ); 
    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    setPinDir  (modePins[DC][MODE0],  OUTPUT                      );
    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    setPinDir  (modePins[RA][MODE1],  OUTPUT                      );
    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    setPinDir  (modePins[DC][MODE1],  OUTPUT                      );
    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    setPinDir  (modePins[RA][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    setPinDir  (modePins[DC][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.

    //Give some time for the Motor Drivers to reset.
    _delay_ms(1);

    //Then bring them out of reset.
    setPinValue(resetPin[RA],HIGH);
    setPinValue(resetPin[DC],HIGH);
    
#if defined(__AVR_ATmega162__)
    //Disable Timer 0
    //Timer 0 registers are being used as general purpose data storage for high efficency
    //interrupt routines. So timer must be fully disabled. The ATMegaxxx0 has three of these
    //registers, but the ATMega162 doesn't, so I've had to improvise and use other registers
    //instead. See PinMappings.h for the ATMega162 to see which registers have been #defined
    //as GPIORx.
    TIMSK &= ~(_BV(TOIE0) | _BV(OCIE0));
    TCCR0 = 0;
#endif

    //Ensure SPI is disabled
    SPI_disable();
    
    //Initialise the Serial port:
    Serial_initialise(BAUD_RATE); //SyncScan runs at 9600Baud, use a serial port of your choice as defined in SerialLink.h
      
}




/*
 * EEPROM Validation and Programming Routines
 */

bool checkEEPROM(){
    char temp[9] = {0};
    EEPROM_readString(temp,8,AstroEQID_Address);
    if(strncmp(temp,"AstroEQ",8)){
        return false;
    }
    if (driverVersion > DRV8834){
        return false; //invalid value.
    }
    if ((driverVersion == A498x) && microstepConf > 16){
        return false; //invalid value.
    } else if (microstepConf > 32){
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[RA] > 1200) || (cmd.siderealIVal[RA] < MIN_IVAL)) {
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[DC] > 1200) || (cmd.siderealIVal[DC] < MIN_IVAL)) {
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[RA] == 0){
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[DC] == 0){
        return false; //invalid value.
    }
    if((cmd.st4SpeedFactor < 1) || (cmd.st4SpeedFactor > 19)){
        return false; //invalid value
    }
    return true;
}

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
}

void storeEEPROM(){
    EEPROM_writeLong(cmd.aVal[RA],aVal1_Address);
    EEPROM_writeLong(cmd.aVal[DC],aVal2_Address);
    EEPROM_writeLong(cmd.bVal[RA],bVal1_Address);
    EEPROM_writeLong(cmd.bVal[DC],bVal2_Address);
    EEPROM_writeLong(cmd.sVal[RA],sVal1_Address);
    EEPROM_writeLong(cmd.sVal[DC],sVal2_Address);
    EEPROM_writeByte(encodeDirection[RA],RAReverse_Address);
    EEPROM_writeByte(encodeDirection[DC],DECReverse_Address);
    EEPROM_writeByte(driverVersion,Driver_Address);
    EEPROM_writeByte(microstepConf,Microstep_Address);
    EEPROM_writeByte(cmd.normalGotoSpeed[RA],RAGoto_Address);
    EEPROM_writeByte(cmd.normalGotoSpeed[DC],DECGoto_Address);
    EEPROM_writeInt(cmd.siderealIVal[RA],IVal1_Address);
    EEPROM_writeInt(cmd.siderealIVal[DC],IVal2_Address);
    EEPROM_writeByte(!disableGearChange, GearEnable_Address);
    EEPROM_writeByte(!allowAdvancedHCDetection, AdvHCEnable_Address);
    EEPROM_writeInt(cmd.st4DecBacklash, DecBacklash_Address);
    EEPROM_writeByte(cmd.st4SpeedFactor, SpeedFactor_Address);
    EEPROM_writeAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address);
    EEPROM_writeAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address);
}









/*
 * Standalone Helpers
 */

byte standaloneModeTest() {
    //We need to test what sort of controller is attached.
    //The IRQ pin on the ST4 connector is used to determine this. It has the following
    //states:
    //   FLOAT      | No handcontroller
    //   DRIVE LOW  | Basic handcontroller
    //   DRIVE HIGH | Advanced handcontroller
    //We can test for each of these states by virtue of having a controllable pull up/down
    //resistor on that pin.
    //If we pull down and the pin stays high, then pin must be driven high (DRIVE HIGH)
    //If we pull up and the pin stays low, then pin must be driven low (DRIVE LOW)
    //Otherwise if pin follows us then it must be floating.

    //To start we check for an advanced controller
    setPinValue(standalonePin[STANDALONE_PULL],LOW); //Pull low
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(allowAdvancedHCDetection && getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Note: Must be an advanced controller as pin stayed high and we are allowing HC detection. (If HC detection is disallowed its because we have no external pull down available)
        return ADVANCED_HC_MODE;
    }
    //Otherwise we check for a basic controller
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Convert to external pull-up of IRQ
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Must be a basic controller as pin stayed low.
        return BASIC_HC_MODE;
    }


    //If we get this far then it is floating, so we assume EQMOD mode
    return EQMOD_MODE;
}


byte checkBasicHCSpeed() {
    //Here we check what the speed is for the basic hand controller.
    //
    //By using both external and internal pull-ups, the following three speeds are possible:
    // +-----------+-----+-----+
    // |  Pull-Up: | Ext | Int |
    // +-----------+-----+-----+
    // | ST-4 Rate |  0  |  0  |
    // |   2x Rate |  1  |  0  |
    // | GoTo Rate |  1  |  1  |
    // +-----------+-----+-----+
    //
    //Note: if we don't have an external pull-up resistor, this function will return either ST-4 Rate (0,0) or GoTo Rate (1,1)
    //
    byte speed;
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
        //Must be a ST-4 rate as IRQ pin is low when external pull-up enabled
        speed = CMD_ST4_DEFAULT;
    } else {
        //Otherwise check which high-speed mode it is
        setPinDir  (standalonePin[STANDALONE_PULL],INPUT); //Disable external resistor by switching to input
        setPinValue(standalonePin[STANDALONE_PULL],LOW);   //with no internal pull-up (we are using the IRQ pin internal pull-up)
        nop(); // Input synchroniser takes a couple of cycles
        nop();
        nop();
        nop();
        
        if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
            //Must be a 2x rate as IRQ pin goes low when external pull-up disabled
            speed = CMD_ST4_STANDALONE;
        } else {
            speed = CMD_ST4_HIGHSPEED;
        }
    }
    setPinDir  (standalonePin[STANDALONE_PULL],OUTPUT); //Ensure we leave an external pull-up of IRQ.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH);
    //And return the new speed
    return speed;
}



/*
 * AstroEQ firmware main() function
 */

int main(void) {
    //Enable global interrupt flag
    sei();
    //Initialise global variables from the EEPROM
    systemInitialiser();
    
    bool mcuReset = false; //Not resetting the MCU after programming command
    
    bool isST4Move[2] = {false, false};
    
    unsigned int loopCount = 0;
    char recievedChar = 0; //last character we received
    int8_t decoded = 0; //Whether we have decoded the packet
    char decodedPacket[11]; //temporary store for completed command ready to be processed
    
    for(;;){ //Run loop

        loopCount++; //Counter used to time events based on number of loops.

        if (!standaloneMode && (loopCount == 0)) { 
            //If we are not in standalone mode, periodically check if we have just entered it
            byte mode = standaloneModeTest();
            if (mode != EQMOD_MODE) {
                //If we have just entered stand-alone mode, then we enable the motors and configure the mount
                motorStop(RA, true); //Ensure both motors are stopped
                motorStop(DC, true);
                
                //This next bit needs to be atomic
                byte oldSREG = SREG; 
                cli();  
                cmd_setjVal(RA, 0x800000); //set the current position to the middle
                cmd_setjVal(DC, 0x800000); //set the current position to the middle
                SREG = oldSREG;
                //End atomic
                //Disable Serial
                Serial_disable();
    
                //We are now in standalone mode.
                standaloneMode = true; 
                
                //Next check what type of hand controller we have
                if (mode == ADVANCED_HC_MODE) {
                    //We pulled low, but pin stayed high
                    //This means we must have an advanced controller actively pulling the line high
                    syntaMode = true; 
                    
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
                    Serial_writeStr(welcome); //Send error packet to trigger controller state machine.
                    
                } else {
                    //Pin either is being pulled low by us or by something else
                    //This means we might have a basic controller actively pulling the line low
                    //Even if we don't we would default to basic mode.
                    syntaMode = false;
                    
                    //High speed not supported in Basic HC
                    canJumpToHighspeed = false;
                    
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
                    
                    Commands_configureST4Speed(CMD_ST4_DEFAULT); //Change the ST4 speeds to default
                    
                    motorEnable(RA); //Ensure the motors are enabled
                    motorEnable(DC);
                    
                    cmd_setGVal      (RA, 1); //Set both axes to slew mode.
                    cmd_setGVal      (DC, 1);
                    cmd_setDir       (RA, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA ,1);
                    cmd_setDir       (DC, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA,1);
                    cmd_setIVal      (RA, cmd.siderealIVal[RA]); //Set RA speed to sidereal
                    
                    readyToGo[RA] = 1; //Signal we are ready to go on the RA axis to start sideral tracking
                }
            }
            //If we end up in standalone mode, we don't exit until a reset.
        }

        /////////////
        if (syntaMode) {
        //
        // EQMOD or Advanced Hand Controller Synta Mode
        //
            //Check if we need to run the command parser
            
            if ((decoded == -2) || Serial_available()) { //is there a byte in buffer or we still need to process the previous byte?
                //Toggle on the LED to indicate activity.
                togglePin(statusPin);
                //See what character we need to parse
                if (decoded != -2) {
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
                //Once full command packet recieved, synta_recieveCommand populates either an error packet (and returns -1), or data packet (returns 1). If incomplete, decodedPacket is unchanged and 0 is returned
                if (decoded != 0){ //Send a response
                    if (decoded > 0){ //Valid Packet, current command is in decoded variable.
                        mcuReset = !decodeCommand(decoded,decodedPacket); //decode the valid packet and populate response.
                    }
                    Serial_writeStr(decodedPacket); //send the response packet (recieveCommand() generated the error packet, or decodeCommand() a valid response)
                } //otherwise command not yet fully recieved, so wait for next byte
                
                if (mcuReset) {
                    //Special case. We were asked to reset the MCU.
                    Serial_flush(); //Flush out last response.
                    wdt_enable(WDTO_120MS); //WDT has been set to reset MCU.
                    exit(0); //Done
                }
            }
            if (loopCount == 0) {
                setPinValue(statusPin, 0);
            }
            
            //
            //ST4 button handling
            //
            if (!standaloneMode && ((loopCount & 0xFF) == 0)){
                //We only check the ST-4 buttons in EQMOD mode when not doing Go-To, and only every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //In Synta mode, we only allow the ST-4 port to move forward, and only if EQMOD has configured us previously to be in tracking mode
                    if ((cmd.dir[RA] == CMD_FORWARD) && (readyToGo[RA] == 2)) {
                        //Determine which ST4 pin if any
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                        //Update target speed.
                        if (st4Pin != ST4O) {
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
                            isST4Move[RA] = true; //Now doing ST4 movement
                        }
                        else if (isST4Move[RA]) { 
                            //Only return to sidereal speed if we are in an ST4 move.
                            cmd_setIVal(RA,cmd.siderealIVal[RA]);
                            motorStartRA();
                            isST4Move[RA] = false; //No longer ST4 movement
                        }
                    }
                }//End RA
                
                if (!cmd.gotoEn[DC]) {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir)) {
                        //If we are currently moving in the wrong direction
                        motorStopDC(false); //Stop the Dec motor
                        readyToGo[DC]=0;    //No longer ready to go as we have now deleted any pre-running EQMOD movement.
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
                            isST4Move[DC] = true; //Now doing ST4 movement
                        } else if (isST4Move[DC]) {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
                            isST4Move[DC] = false; //No longer ST4 movement
                        }
                    }
                }//End DEC
            }
            
            //Check both axes - loop unravelled for speed efficiency - lots of Flash available.
            if(readyToGo[RA]==1){
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[RA] == CMD_STOPPED){
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[RA];
                    if (canJumpToHighspeed){
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
                            cmd_updateStepDir(RA,1);
                            cmd.highSpeedMode[RA] = false;
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
                            cmd_updateStepDir(RA,cmd.gVal[RA]);
                            cmd.highSpeedMode[RA] = true;
                        }
                        setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0)));
                        setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1)));
                        setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2)));
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(RA,1); //Just move along at one step per step
                        cmd.highSpeedMode[RA] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(RA); //Slew type
                        readyToGo[RA] = 2;
                    } else {
                        //This is the function for goto mode. You may need to customise it for a different motor driver
                        gotoMode(RA); //Goto Mode
                        readyToGo[RA] = 0;
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
            if(readyToGo[DC]==1){
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[DC] == CMD_STOPPED){
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[DC];
                    if (canJumpToHighspeed){
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
                            cmd_updateStepDir(DC,1);
                            cmd.highSpeedMode[DC] = false;
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
                            cmd_updateStepDir(DC,cmd.gVal[DC]);
                            cmd.highSpeedMode[DC] = true;
                        }
                        setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0)));
                        setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1)));
                        setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2)));
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(DC,1); //Just move along at one step per step
                        cmd.highSpeedMode[DC] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(DC); //Slew type
                        readyToGo[DC] = 2; //We are now in a running mode which speed can be changed without stopping motor (unless a command changes the direction)
                    } else {
                        //This is the function for goto mode.
                        gotoMode(DC); //Goto Mode
                        readyToGo[DC] = 0; //We are now in a mode where no further changes can be made to the motor (apart from requesting a stop) until the go-to movement is done.
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
        //////////
        } else {
        //
        // ST4 Basic Hand Controller Mode
        //
            if (loopCount == 0) {
                //we run these checks every so often, not all the time.
                
                //Update status LED
                togglePin(statusPin); //Toggle status pin at roughly constant rate in basic mode as indicator
                
                //Check the speed
                byte newBasicHCSpeed = checkBasicHCSpeed();
                if (newBasicHCSpeed != cmd.st4Mode) {
                    //Only update speed if changed.
                    Commands_configureST4Speed(newBasicHCSpeed); //Change the ST4 speeds
                }
            }
            
            //
            //NESW button handling - uses ST4 pins
            //
            if ((loopCount & 0xFF) == 0){
                //We only check the buttons every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
                    if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] != dir) && (currentMotorSpeed(RA) < cmd.minSpeed[RA])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
                        cmd_setDir(RA,dir);
                        cmd_updateStepDir(RA,1);
                        if ((st4Pin == ST4O) && (cmd.st4Mode == CMD_ST4_HIGHSPEED)) {
                            motorStopRA(false); //If no buttons pressed and in high speed mode, we stop entirely rather than going to tracking
                                                //This ensures that the motors stop if the handcontroller is subsequently unplugged.
                        } else {
                            motorStartRA(); //If the motor is currently stopped at this point, this will automatically start them.
                        }
                    }
                    SREG = oldSREG; //End atomic
                }//End RA
                
                {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopDC(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
                        } else {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
                        }
                    }
                    SREG = oldSREG; //End atomic
                }//End DEC
            }
        ///////////
        }
        
        
    }//End of run loop
}

/*
#ifdef ALTERNATE_ST4
ISR(PCINT2_vect)
#else
ISR(PCINT0_vect)
#endif
{
    //ST4 Pin Change Interrupt Handler.
    if(!cmd.gotoEn[RA] && !cmd.gotoEn[DC]){
        //Only allow when not it goto mode.
        {//Start RA
            //Determine which if any ST4 Pin
            char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
            if (syntaMode) {
                //In Synta mode, we only allow the ST-4 port to move forward, and not to automatically start moving
                if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] == CMD_FORWARD)) {
                    //If we are not stopped and we are moving in the correct direction, update speed.
                    cmd.currentIVal[RA] = (st4Pin != ST4O) ? cmd.st4RAIVal[st4Pin] :  cmd.siderealIVal[RA];
                    //Ensure that if the new speed is slower than the stopping speed that we don't stop
                    cmd.stopSpeed[RA] = (cmd.currentIVal[RA] < cmd.minSpeed[RA]) ? cmd.minSpeed[RA] : cmd.currentIVal[RA];
                }
            } 
        }//End RA

        {//Start DEC
            //Determine which if any ST4 Pin
            char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
            //Determine the new direction
            byte dir = CMD_FORWARD;
            char stepDir = 1;
            if (st4Pin == ST4N) {
                //If requested reverse, switch direction
                dir = CMD_REVERSE;
                stepDir = -1;
            }
            if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//make our target >stopSpeed so that ISRs bring us to a halt.
            } else {
                //Otherwise we are now free to change to the new required speed.
                //Set to correct direction
                cmd.stepDir[DC] = stepDir; //set step direction
                cmd.dir[DC] = dir; //set direction
                //Then update speed
                if (st4Pin != ST4O) {
                    //If an ST4 Dec pin is pressed
                    if (cmd.stopped[DC] != CMD_STOPPED) {
                        //If running, update to new required speed directly
                        cmd.currentIVal[DC] = cmd.st4DecIVal;
                        //Ensure that if the new speed is slower than the stopping speed that we don't stop
                        cmd.stopSpeed[DC] = (cmd.currentIVal[DC] < cmd.minSpeed[DC]) ? cmd.minSpeed[DC] : cmd.currentIVal[DC];
                    } else  {
                        //Otherwise we are stopped when we should be moving.
                        //First lets update global IVal
                        cmd.IVal[DC] = cmd.st4DecIVal;
                        //Then trigger main() loop to start us moving
                        readyToGo[DC]=1;
                    }
                } else {
                    //Otherwise stop
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;
                }
                //If the motor is currently stopped at this point when it should be moving, the main() function will automatically start it at the IVal.
            }
        }//End DEC
    }
}
*/

/*
 * Decode and Perform the Command
 */

bool decodeCommand(char command, char* buffer){ //each command is axis specific. The axis being modified can be retrieved by calling synta_axis()
    unsigned long responseData = 0; //data for response
    bool success = true;
    byte axis = synta_axis();
    unsigned int correction;
    byte oldSREG;
    switch(command) {
        case 'e': //readonly, return the eVal (version number)
            responseData = cmd.eVal[axis]; //response to the e command is stored in the eVal function for that axis.
            break;
        case 'a': //readonly, return the aVal (steps per axis)
            responseData = cmd.aVal[axis]; //response to the a command is stored in the aVal function for that axis.
            break;
        case 'b': //readonly, return the bVal (sidereal step rate)
            responseData = cmd.bVal[axis]; //response to the b command is stored in the bVal function for that axis.
            if (!progMode) {
                //If not in programming mode, we need to apply a correction factor to ensure that calculations in EQMOD round correctly
                correction = (cmd.siderealIVal[axis] << 1);
                responseData = (responseData * (correction+1))/correction; //account for rounding inside Skywatcher DLL.
            }
            break;
        case 'g': //readonly, return the gVal (high speed multiplier)
            responseData = cmd.gVal[axis]; //response to the g command is stored in the gVal function for that axis.
            break;
        case 's': //readonly, return the sVal (steps per worm rotation)
            responseData = cmd.sVal[axis]; //response to the s command is stored in the sVal function for that axis.
            break;
        case 'f': //readonly, return the fVal (axis status)
            responseData = cmd_fVal(axis); //response to the f command is stored in the fVal function for that axis.
            break;
        case 'j': //readonly, return the jVal (current position)
            oldSREG = SREG; 
            cli();  //The next bit needs to be atomic, just in case the motors are running
            responseData = cmd.jVal[axis]; //response to the j command is stored in the jVal function for that axis.
            SREG = oldSREG;
            break;
        case 'K': //stop the motor, return empty response
            motorStop(axis,0); //normal ISR based decelleration trigger.
            readyToGo[axis] = 0;
            break;
        case 'L':
            motorStop(axis,1); //emergency axis stop.
            motorDisable(axis); //shutdown driver power.
            break;
        case 'G': //set mode and direction, return empty response
            /*if (packetIn[0] == '0'){
              packetIn[0] = '2'; //don't allow a high torque goto. But do allow a high torque slew.
            }*/
            cmd_setGVal(axis, (buffer[0] - '0')); //Store the current mode for the axis
            cmd_setDir(axis, (buffer[1] != '0') ? CMD_REVERSE : CMD_FORWARD); //Store the current direction for that axis
            readyToGo[axis] = 0;
            break;
        case 'H': //set goto position, return empty response (this sets the number of steps to move from cuurent position if in goto mode)
            cmd_setHVal(axis, synta_hexToLong(buffer)); //set the goto position container (convert string to long first)
            readyToGo[axis] = 0;
            break;
        case 'I': //set slew speed, return empty response (this sets the speed to move at if in slew mode)
            responseData = synta_hexToLong(buffer); //convert string to long first
            if (responseData < cmd.accelTable[axis][AccelTableLength-1].speed) {
                //Limit the IVal to the largest speed in the acceleration table to prevent sudden rapid acceleration at the end.
                responseData = cmd.accelTable[axis][AccelTableLength-1].speed; 
            }
            cmd_setIVal(axis, responseData); //set the speed container
            responseData = 0;
            if (readyToGo[axis] == 2) {
                //If we are in a running mode which allows speed update without motor reconfiguration
                motorStart(axis); //Simply update the speed.
            } else {
                //Otherwise we are no longer ready to go until the next :J command is received
                readyToGo[axis] = 0;
            }
            break;
        case 'E': //set the current position, return empty response
            oldSREG = SREG; 
            cli();  //The next bit needs to be atomic, just in case the motors are running
            cmd_setjVal(axis, synta_hexToLong(buffer)); //set the current position (used to sync to what EQMOD thinks is the current position at startup
            SREG = oldSREG;
            break;
        case 'F': //Enable the motor driver, return empty response
            if (progMode == 0) { //only allow motors to be enabled outside of programming mode.
                motorEnable(axis); //This enables the motors - gives the motor driver board power
            } else {
                command = 0; //force sending of error packet!.
            }
            break;
            
        //Command required for entering programming mode. All other programming commands cannot be used when progMode = 0 (normal ops)
        case 'O': //set the programming mode.
            progMode = buffer[0] - '0';              //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
            if (progMode != 0) {
                motorStop(RA,1); //emergency axis stop.
                motorDisable(RA); //shutdown driver power.
                motorStop(DC,1); //emergency axis stop.
                motorDisable(DC); //shutdown driver power.
                readyToGo[RA] = 0;
                readyToGo[DC] = 0;
            } else { //reset the uC to return to normal ops mode.
                success = false;
            }
            break;

        default:
            //Prevent any chance of accidentally running configuration commands when not in programming mode.
            if (progMode != 0) {
                //The following are used for configuration ----------
                switch(command) {
                    case 'A': //store the aVal (steps per axis)
                        cmd_setaVal(axis, synta_hexToLong(buffer)); //store aVal for that axis.
                        break;
                    case 'B': //store the bVal (sidereal rate)
                        cmd_setbVal(axis, synta_hexToLong(buffer)); //store bVal for that axis.
                        break;
                    case 'S': //store the sVal (steps per worm rotation)
                        cmd_setsVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
                        break;
                    case 'n': //return the IVal (EQMOD Speed at sidereal)
                        responseData = cmd.siderealIVal[axis];
                        break;
                    case 'N': //store the IVal (EQMOD Speed at sidereal)
                        cmd_setsideIVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
                        break;
                    case 'd': //return the driver version or step mode
                        if (axis) {
                            responseData = microstepConf; 
                        } else {
                            responseData = driverVersion;
                        }
                        break;
                    case 'D': //store the driver verison and step modes
                        if (axis) {
                            microstepConf = synta_hexToByte(buffer); //store step mode.
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
                        } else {
                            driverVersion = synta_hexToByte(buffer); //store driver version.
                        }
                        break;
                    case 'r': //return the dec backlash or st4 speed factor
                        if (axis) {
                            responseData = cmd.st4DecBacklash; 
                        } else {
                            responseData = cmd.st4SpeedFactor;
                        }
                        break;
                    case 'R': //store the dec backlash or st4 speed factor
                        if (axis) {
                            unsigned long dataIn = synta_hexToLong(buffer); //store step mode.
                            if (dataIn > 65535) {
                                command = '\0'; //If the step rate is out of range, force an error response packet.
                            } else {
                                cmd_setst4DecBacklash(dataIn); //store st4 speed factor
                            }
                        } else {
                            byte factor = synta_hexToByte(buffer);
                            if ((factor > 19) || (factor < 1)) {
                                command = '\0'; //If the factor is out of range, force an error response packet.
                            } else {
                                cmd_setst4SpeedFactor(factor); //store st4 speed factor
                            }
                        }
                        break;
                    case 'z': //return the Goto speed
                        responseData = cmd.normalGotoSpeed[axis];
                        break;
                    case 'Z': //return the Goto speed factor
                        cmd.normalGotoSpeed[axis] = synta_hexToByte(buffer); //store the goto speed factor
                        break;
                    case 'c': //return the axisDirectionReverse
                        responseData = encodeDirection[axis];
                        break;
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
                            responseData = disableGearChange; 
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
                        } else {
                            responseData = allowAdvancedHCDetection;
                        }
                        break;
                    case 'Q': //store the disableGearChange/allowAdvancedHCDetection setting
                        if (axis) {
                            disableGearChange = synta_hexToByte(buffer); //store whether we can change gear
                        } else {
                            allowAdvancedHCDetection = synta_hexToByte(buffer); //store whether to allow advanced hand controller detection
                        }
                        break;
                    case 'x': {  //return the accelTable
                        Inter responsePack = InterMaker(0);
                        responsePack.lowByter.integer = cmd.accelTable[axis][accelTableIndex[axis]].speed;
                        responsePack.highByter.low = cmd.accelTable[axis][accelTableIndex[axis]].repeats; 
                        responseData = responsePack.integer;
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if reading sequentially.
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            accelTableIndex[axis] = 0; //Wrap around
                        }
                        break;
                    }
                    case 'X': { //store the accelTable value for address set by 'Y', or next address after last 'X'
                        unsigned long dataIn = synta_hexToLong(buffer);
                        cmd.accelTable[axis][accelTableIndex[axis]].speed = (unsigned int)dataIn; //lower two bytes is speed
                        cmd.accelTable[axis][accelTableIndex[axis]].repeats = (byte)(dataIn>>16); //upper byte is repeats.
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if programming sequentially.
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            accelTableIndex[axis] = 0; //Wrap around
                        }
                        break;
                    }
                    case 'Y': //store the accelTableIndex value
                        //Use axis=0 to set which address we are accessing (we'll repurpose accelTableIndex[RA] in prog mode for this)
                        accelTableIndex[axis] = synta_hexToByte(buffer);
                        if (accelTableIndex[axis] >= AccelTableLength) {
                            command = '\0'; //If the address out of range, force an error response packet.
                        }
                        break;
                    case 'T': //set mode, return empty response
                        if (progMode & 2) {
                        //proceed with eeprom write
                            if (progMode & 1) {
                                buildEEPROM();
                            } else {
                                storeEEPROM();
                            }
                        } else if (progMode & 1) {
                            if (!checkEEPROM()) { //check if EEPROM contains valid data.
                                command = 0; //force sending of an error packet.
                            }
                        }
                        break;
                    //---------------------------------------------------
                    default: //Return empty response (deals with commands that don't do anything before the response sent (i.e 'J', 'R'), or do nothing at all (e.g. 'M') )
                        break;
                }
            }
            break;
    }
  
    synta_assembleResponse(buffer, command, responseData); //generate correct response (this is required as is)
    
    if ((command == 'J') && (progMode == 0)) { //J tells us we are ready to begin the requested movement.
        readyToGo[axis] = 1; //So signal we are ready to go and when the last movement complets this one will execute.
        if (!(cmd.GVal[axis] & 1)){
            //If go-to mode requested
            cmd_setGotoEn(axis,CMD_ENABLED);
        }
    }
    return success;
}










void motorEnable(byte axis){
    if (axis == RA){
        setPinValue(enablePin[RA],LOW); //IC enabled
        cmd_setFVal(RA,CMD_ENABLED);
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
        cmd_setFVal(DC,CMD_ENABLED);
    }
    configureTimer(); //setup the motor pulse timers.
}

void motorDisable(byte axis){
    if (axis == RA){
        setPinValue(enablePin[RA],HIGH); //IC enabled
        cmd_setFVal(RA,CMD_DISABLED);
    } else {
        setPinValue(enablePin[DC],HIGH); //IC enabled
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
}

void gotoMode(byte axis){
    unsigned int decelerationLength = gotoDecelerationLength[axis];
    
    if (cmd.highSpeedMode[axis]) {
        //Additionally in order to maintain the same speed profile in high-speed mode, we actually increase the profile repeats by a factor of sqrt(8)
        //compared with running in normal-speed mode. See Atmel AVR466 app note for calculation.
        decelerationLength = decelerationLength * 3; //multiply by 3 as it is approx sqrt(8)
    }
    
    byte dirMagnitude = abs(cmd.stepDir[axis]);
    byte dir = cmd.dir[axis];

    if (cmd.HVal[axis] < 2*dirMagnitude){
        cmd_setHVal(axis,2*dirMagnitude);
    }

    decelerationLength = decelerationLength * dirMagnitude;
    //decelleration length is here a multiple of stepDir.
    unsigned long HVal = cmd.HVal[axis];
    unsigned long halfHVal = (HVal >> 1);
    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    if(dirMagnitude == 8){
        HVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
    }
    if(dirMagnitude == 8){
        halfHVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
    }
    //HVal and halfHVal are here a multiple of stepDir
    if (halfHVal < decelerationLength) {
        decelerationLength = halfHVal;
    }
    HVal -= decelerationLength;
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
    
    cmd_setIVal(axis, gotoSpeed);
    clearGotoDecelerating(axis);
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStart functions (one for RA and one for DEC)
void motorStart(byte motor){
    if (motor == RA) {
        motorStartRA();
    } else {
        motorStartDC();
    }
}

void motorStartRA(){
    unsigned int IVal = cmd.IVal[RA];
    unsigned int currentIVal;
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
    currentIVal = currentMotorSpeed(RA);
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    
    if (IVal > cmd.minSpeed[RA]){
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[RA];
    }
    if(cmd.stopped[RA]) {
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[RA]) {
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
    cmd.currentIVal[RA] = cmd.IVal[RA];
    currentMotorSpeed(RA) = startSpeed;
    cmd.stopSpeed[RA] = stoppingSpeed;
    setPinValue(dirPin[RA],(encodeDirection[RA] != cmd.dir[RA]));
    
    if(cmd.stopped[RA]) { //if stopped, configure timers
        irqToNextStep(RA) = 1;
        accelTableRepeatsLeft[RA] = cmd.accelTable[RA][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
        accelTableIndex[RA] = 0;
        distributionSegment(RA) = 0;
        timerCountRegister(RA) = 0;
        interruptOVFCount(RA) = timerOVF[RA][0];
        timerEnable(RA);
        cmd_setStopped(RA, CMD_RUNNING);
    }
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
}

void motorStartDC(){
    unsigned int IVal = cmd.IVal[DC];
    unsigned int currentIVal;
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
    currentIVal = currentMotorSpeed(DC);
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
    
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    if (IVal > cmd.minSpeed[DC]){
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[DC];
    }
    if(cmd.stopped[DC]) {
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[DC]) {
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
    cmd.currentIVal[DC] = cmd.IVal[DC];
    currentMotorSpeed(DC) = startSpeed;
    cmd.stopSpeed[DC] = stoppingSpeed;
    setPinValue(dirPin[DC],(encodeDirection[DC] != cmd.dir[DC]));
    
    if(cmd.stopped[DC]) { //if stopped, configure timers
        irqToNextStep(DC) = 1;
        accelTableRepeatsLeft[DC] = cmd.accelTable[DC][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
        accelTableIndex[DC] = 0;
        distributionSegment(DC) = 0;
        timerCountRegister(DC) = 0;
        interruptOVFCount(DC) = timerOVF[DC][0];
        timerEnable(DC);
        cmd_setStopped(DC, CMD_RUNNING);
    }
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStop functions (one for RA and one for DEC)
void motorStop(byte motor, byte emergency){
    if (motor == RA) {
        motorStopRA(emergency);
    } else {
        motorStopDC(emergency);
    }
}

void motorStopRA(bool emergency){
    if (emergency) {
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(RA);
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
        clearGotoRunning(RA);
    } else if (!cmd.stopped[RA]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
        //trigger ISR based decelleration
        //readyToGo[RA] = 0;
        byte oldSREG = SREG;
        cli();
        cmd_setGotoEn(RA,CMD_DISABLED); //No longer in goto mode.
        clearGotoRunning(RA);
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        //interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
        if(cmd.currentIVal[RA] < cmd.minSpeed[RA]){
            if(cmd.stopSpeed[RA] > cmd.minSpeed[RA]){
                cmd.stopSpeed[RA] = cmd.minSpeed[RA];
            }
        }/* else {
            stopSpeed[RA] = cmd.currentIVal[RA];
        }*/
        cmd.currentIVal[RA] = cmd.stopSpeed[RA] + 1;//cmd.stepIncrement[motor];
        SREG = oldSREG;
        //interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    }
}

void motorStopDC(bool emergency){
    if (emergency) {
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(DC);
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
        clearGotoRunning(DC);
    } else if (!cmd.stopped[DC]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
        //trigger ISR based decelleration
        //readyToGo[motor] = 0;
        byte oldSREG = SREG;
        cli();
        cmd_setGotoEn(DC,CMD_DISABLED); //No longer in goto mode.
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        clearGotoRunning(DC);
        //interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
        if(cmd.currentIVal[DC] < cmd.minSpeed[DC]){
            if(cmd.stopSpeed[DC] > cmd.minSpeed[DC]){
                cmd.stopSpeed[DC] = cmd.minSpeed[DC];
            }
        }/* else {
        stopSpeed[DC] = cmd.currentIVal[DC];
        }*/
        cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//cmd.stepIncrement[motor];
        SREG = oldSREG;
        //interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
    }
}

//Timer Interrupt-----------------------------------------------------------------------------
void configureTimer(){
    interruptControlRegister(DC) = 0; //disable all timer interrupts.
#if defined(__AVR_ATmega162__)
    interruptControlRegister(RA) &= 0b00000011; //for 162, the lower 2 bits of the declination register control another timer, so leave them alone.
#else
    interruptControlRegister(RA) = 0;
#endif
    //set to ctc mode (0100)
    TCCR1A = 0;//~((1<<WGM11) | (1<<WGM10));
    TCCR1B = ((1<<WGM12) | (1<<WGM13));
    TCCR3A = 0;//~((1<<WGM31) | (1<<WGM30));
    TCCR3B = ((1<<WGM32) | (1<<WGM33));
}



/*Timer Interrupt Vector*/
ISR(TIMER3_CAPT_vect) {
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(DC)-1;
    //Check if we are ready to step
    if (irqToNext == 0) {
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(DC); //Get the current time segement
        
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(DC) = timerOVF[DC][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(DC) = *(int*)((byte*)timerOVF[DC] + index); //Update interrupt base rate.
        
        distributionSegment(DC) = timeSegment + 1; //Increment time segement for next time.

        unsigned int currentSpeed = currentMotorSpeed(DC); //Get the current motor speed
        irqToNextStep(DC) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
        
        if (getPinValue(stepPin[DC])){
            //If the step pin is currently high...
            
            setPinValue(stepPin[DC],LOW); //set step pin low to complete step
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[DC]; 
            jVal = jVal + cmd.stepDir[DC];
            cmd.jVal[DC] = jVal;
            
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(DC); //Mark that we have started decelleration.
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
                    accelTableRepeatsLeft[DC] = 0;
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[DC]) {
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(DC)){ 
                    //if we are currently running a goto... 
                    cmd_setGotoEn(DC,CMD_DISABLED); //Switch back to slew mode 
                    clearGotoRunning(DC); //And mark goto status as complete
                } //otherwise don't as it cancels a 'goto ready' state 
                
                cmd_setStopped(DC,CMD_STOPPED); //mark as stopped 
                timerDisable(DC);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[DC],HIGH); //Set it high to start next step.
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[DC]; //load the number of repeats left for this accel table entry
            if (repeatsReqd == 0) { 
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[DC]; //Get the target speed
                if (currentSpeed > targetSpeed) {
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
                    if (accelIndex >= AccelTableLength-1) {
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
                        accelTableIndex[DC] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed <= targetSpeed) {
                            //If the new value is too fast
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
                    if (accelIndex == 0) {
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
                        accelTableIndex[DC] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed >= targetSpeed) {
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                }
                currentMotorSpeed(DC) = currentSpeed; //Update the current speed in case it has changed.
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[DC] = repeatsReqd - 1;
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(DC) = irqToNext; //Update the number of IRQs remaining until the next step.
    }   


}






/*Timer Interrupt Vector*/
ISR(TIMER1_CAPT_vect) {
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(RA)-1;
    //Check if we are ready to step
    if (irqToNext == 0) {
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(RA); //Get the current time segement
        
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(RA) = timerOVF[RA][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(RA) = *(int*)((byte*)timerOVF[RA] + index); //Update interrupt base rate.
        
        distributionSegment(RA) = timeSegment + 1; //Increment time segement for next time.

        unsigned int currentSpeed = currentMotorSpeed(RA); //Get the current motor speed
        irqToNextStep(RA) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
        
        if (getPinValue(stepPin[RA])){
            //If the step pin is currently high...
            
            setPinValue(stepPin[RA],LOW); //set step pin low to complete step
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[RA]; 
            jVal = jVal + cmd.stepDir[RA];
            cmd.jVal[RA] = jVal;
            
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(RA); //Mark that we have started decelleration.
                    cmd.currentIVal[RA] = cmd.stopSpeed[RA]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
                    accelTableRepeatsLeft[RA] = 0;
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[RA]) {
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(RA)){ 
                    //if we are currently running a goto... 
                    cmd_setGotoEn(RA,CMD_DISABLED); //Switch back to slew mode 
                    clearGotoRunning(RA); //And mark goto status as complete
                } //otherwise don't as it cancels a 'goto ready' state 
                
                cmd_setStopped(RA,CMD_STOPPED); //mark as stopped 
                timerDisable(RA);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[RA],HIGH); //Set it high to start next step.
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[RA]; //load the number of repeats left for this accel table entry
            if (repeatsReqd == 0) { 
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[RA]; //Get the target speed
                if (currentSpeed > targetSpeed) {
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
                    if (accelIndex >= AccelTableLength-1) {
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
                        accelTableIndex[RA] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed <= targetSpeed) {
                            //If the new value is too fast
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
                    if (accelIndex == 0) {
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
                        accelTableIndex[RA] = accelIndex; //Save the new index back
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
                        if (currentSpeed >= targetSpeed) {
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                }
                currentMotorSpeed(RA) = currentSpeed; //Update the current speed in case it has changed.
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[RA] = repeatsReqd - 1;
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(RA) = irqToNext; //Update the number of IRQs remaining until the next step.
    }   


}

#else
#error Unsupported Part! Please use an Arduino Mega, or ATMega162
#endif

ELF          S            X     4     ( [ X AstroEQ %RU   :;I  $ >  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  .?:;<   I4   I  .?:;<   I  :;  I  ! I/  5 I  .:;    :;I  .?:;   /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ.h"
/*
  Code written by Thomas Carpenter 2012
  
  With thanks Chris over at the EQMOD Yahoo group for explaining the Skywatcher protocol
  
  
  Equatorial mount tracking system for integration with EQMOD using the Skywatcher/Synta
  communication protocol.
 
  Works with EQ5, HEQ5, and EQ6 mounts, and also a great many custom mount configurations.
 
  Current Verison: 7.5
*/

//Only works with ATmega162, and Arduino Mega boards (1280 and 2560)
#if defined(__AVR_ATmega162__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)

#ifndef __ASTROEQ_H__
#define __ASTROEQ_H__

#ifdef __cplusplus
extern "C"{
#endif

/*
 * File Includes
 */
 
#include "PinMappings.h" //Read Pin Mappings
#include "EEPROMAddresses.h" //Config file addresses
#include "UnionHelpers.h"

#include <string.h>
#include <stdlib.h>
#include <math.h>

#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/interrupt.h>

#include <inttypes.h>

/*
 * Useful Defines
 */
 
#ifndef sbi
  #define sbi(r,b) r |= _BV(b)
#endif
#ifndef cbi
  #define cbi(r,b) r &= ~_BV(b)
#endif

#define FLOAT (1<<3)
#define HIGH 1
#define LOW 0

#define OUTPUT 1
#define INPUT 0

#define A498x 0
#define DRV882x 1
#define DRV8834 2

#define SPEEDNORM 0
#define SPEEDFAST 1

#define REBUILDMODE 3
#define STOREMODE 2
#define PROGMODE 1
#define RUNMODE 0

#ifdef abs
#undef abs
#endif

#define abs(x) ((x)>0?(x):-(x))

#ifndef max
#define max(a,b) ((a > b) ? a : b)
#endif

typedef uint8_t byte;

#define RA 0 //Right Ascension is AstroEQ axis 0 (Synta axis '1')
#define DC 1 //Declination is AstroEQ axis 1 (Synta axis '2')

#define ST4P (0)  //Positive ST4 Pin
#define ST4N (1)  //Negative ST4 Pin
#define ST4O (-1) //Neither ST4 Pin

#define MIN_IVAL 50

#define BAUD_RATE 9600

#define nop() __asm__ __volatile__ ("nop \n\t")


/*
 * Standalone Pin Names
 */

#define STANDALONE_IRQ   0
#define STANDALONE_PULL  1

#define EQMOD_MODE 0
#define BASIC_HC_MODE 1
#define ADVANCED_HC_MODE 2

typedef struct {
    unsigned int speed;
    byte repeats;
} AccelTableStruct;

/*
 * Declare constant arrays of pin numbers
 */
 
const byte standalonePin[2] = {gpioPin_0_Define,gpioPin_2_Define};
const byte statusPin = statusPin_Define;
const byte resetPin[2] = {resetPin_0_Define,resetPin_1_Define};
const byte dirPin[2] = {dirPin_0_Define,dirPin_1_Define};
const byte enablePin[2] = {enablePin_0_Define,enablePin_1_Define};
const byte stepPin[2] = {stepPin_0_Define,stepPin_1_Define};
const byte st4Pins[2][2] = {{ST4AddPin_0_Define,ST4SubPin_0_Define},{ST4AddPin_1_Define,ST4SubPin_1_Define}};
const byte modePins[2][3] = {{modePins0_0_Define,modePins1_0_Define,modePins2_0_Define},{modePins0_1_Define,modePins1_1_Define,modePins2_1_Define}};


/*
 * Function Prototypes
 */
 
bool checkEEPROM();
void buildEEPROM();
void storeEEPROM();
void systemInitialiser();
byte standaloneModeTest();
int main(void);
bool decodeCommand(char command, char* packetIn);
void calculateRate(byte axis);
void calculateDecelerationLength (byte axis);
void motorEnable(byte axis);
void motorDisable(byte axis);
void slewMode(byte axis);
void gotoMode(byte axis);
void motorStart(byte motor);
void motorStartRA();
void motorStartDC();
void motorStop(byte motor, byte emergency);
void motorStopRA(bool emergency);
void motorStopDC(bool emergency);
void configureTimer();
void buildModeMapping(byte microsteps, byte driverVersion);


#ifdef __cplusplus
} // extern "C"
#endif


#endif


#else
#error Unsupported Part! Please use an Arduino Mega, or ATMega162
#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE INO OR *
 * PDE FILE THIS FILE IS GENERATED FROM!!!         *
 ***************************************************/

#include <Arduino.h>
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\AstroEQ6.ino"
ELF          S                 4     (  
 %  $ >  $ >   :;I  $ >  4 :;I  & I  4 :;I                                  int             zH                                   SS #   5=       $   3    %   2SCK &   4SDA (   SCL )       *   A0 ,   6A1 -   7A2 .   8A3 /   9A4 0   :A5 1   ;A6 2   <A7 3   =A8 4   >A9 5   ?A10 6   @A11 7   AA12 8   BA13 9   CA14 :   DA15 ;   E        
    e:/thomas/downloads/programs/exe/uecide/hardware/compilers/avr-gcc/lib/gcc/../../avr/include E:\Thomas\Downloads\Programs\EXE\uecide\hardware\boards\Arduino\mega  pins_arduino.h   stdint.h                         LED_BUILTIN bool GNU C++ 4.3.2 float unsigned char double MISO MOSI long unsigned int unsigned int long long unsigned int uint8_t long long int char C:\Users\Thomas\AppData\Local\Temp\build-257f0514-347c-4697-aed5-e6694d4cdfa1\AstroEQ6.cpp long int signed char  .symtab .strtab .shstrtab .text .data .bss .debug_abbrev .rela.debug_info .rela.debug_line .debug_str                                                         4                      !             4                      '             4                      ,              4   c                  ?                                  :                               P              ,                   K              	                 \      0       -                                2  g                                                	                h                                                                                           ?            >             =         )   4         1             =                                                                   	 J              Y               AstroEQ6.cpp __SREG__ __SP_H__ __SP_L__ __CCP__ __tmp_reg__ __zero_reg__ __do_copy_data __do_clear_bss                                                     $     V   2        9        >     z   K     %   R     D   Y        `     c   m        t        {     3                ?        :                     :00000001FF
ELF          S        4   |     4    (                 -  -           D.    -  z   z            .  z z                                                                  eu												1					v																												K		$` `  75  APP@0  002	
b0	b0a0	a0
        #!H        pH	        H	#)4}5q o     #!4b5@Po }o   o bo  q0rr/i/$5t/i/8#)//o }o Pn@m0   py`z2uu#)         ` 8o bo @ P!q }q   q bq  s0tr/i/$5t/i/9#)//q }q Pp@o0   p{`|3!a~#)  ?:100000000C94AC000C94D4000C94D4000C94D40048
:100010000C94D4000C94D4000C94D4000C94D40010
:100020000C94D4000C94D4000C94D4000C94D40000
:100030000C94D4000C94D4000C94D4000C94D400F0
:100040000C94B6040C94D4000C94D4000C94D400FA
:100050000C94D4000C94D4000C94D4000C94D400D0
:100060000C94D4000C94D1120C94F2120C94D40081
:100070000C94D4000C94D4000C94D4000C94BC03C5
:100080000C94D4000C94D4000C94D4000C94D400A0
:100090000C94D4000C94D4000C94D4000C94D40090
:1000A0000C94D4000C94D4000C94D4000C94D40080
:1000B0000C94D4000C94D4000C94D4000C94D40070
:1000C0000C94D4000C94D4000C94D4000C94D40060
:1000D0000C94D4000C94D4000C94D4000C94D40050
:1000E0000C94D400650875081009B508C309C30944
:1000F000C309C309C309C309C309C309C309A108C3
:10010000C309C3093109D7088508AD09C309C30963
:10011000C3097609A209FC08C309C309C309C309B5
:10012000C309C309C309C3090809AD08C309C30941
:10013000C309C309C309C309C309C309C30995088E
:10014000C309C3091C09CD08C309C309C309C309ED
:10015000C3094B09C309F50811241FBECFEFD1E233
:10016000DEBFCDBF88E10FB6F89480936000109297
:1001700060000FBE12E0A0E0B2E0E0EBFDE200E0C4
:100180000BBF02C007900D92AA37B107D9F71BBE6B
:1001900015E0AAE7B2E001C01D92A135B107E1F771
:1001A0000E94EB0B0C94D6160C940000FB01DC01B2
:1001B0004150504030F08D910190801919F4002089
:1001C000B9F7881B990B0895883018F4880F880FA9
:1001D000880F883019F08032A1F406C083E0809344
:1001E000090210920A020895623011F087E001C0FE
:1001F00082E280930902623011F082E00EC080E258
:100200000CC0613011F087E001C081E080930902E9
:10021000613011F081E001C084E080930A0208950A
:100220001198000000000000000080910D03882359
:1002300021F0489B02C082E00895119A000000005E
:100240000000000089B1809581700895489902C02E
:1002500080E00BC009981198000000000000000029
:10026000489B02C082E001C081E0099A119A08957A
:10027000882329F4A59881E08093340308C08091F5
:1002800002018F7D8093020181E0809335031092FB
:10029000710010926F001092800088E180938100BD
:1002A00010929000809391000895882321F4A59ADC
:1002B00010923403089580910201806280930201BC
:1002C00010923503089540911E0350911F038091B1
:1002D0006F008F7D80936F00E0919A00F0919B00FA
:1002E00080916F00806280936F0020917103309144
:1002F0007203C901722F692F2417350718F4CA0138
:10030000742F692FA0913803AA2329F4E217F30769
:1003100010F49F0103C0872F962F9C0180916F00DE
:100320008F7D80936F0050936E0340936D033093E5
:100330009B0020939A007093790360937A039091C5
:10034000840280913203981711F0759A01C0759854
:10035000AA2329F181E090E090938B0080938A009A
:1003600080917F0380931203109214031BBC1092A0
:1003700085001092840080918A0290918B02909364
:1003800087008093860080918100897F809381001F
:100390008091810081608093810010923803809168
:1003A0006F00806280936F00089540912003509108
:1003B0002103809171008F7D80937100E0919800FE
:1003C000F09199008091710080628093710020917A
:1003D000730330917403C901722F692F24173507F5
:1003E00018F4CA01742F692FA0913903AA2329F4A4
:1003F000E217F30710F49F0103C0872F962F9C018B
:10040000809171008F7D80937100509370034093B1
:100410006F03309399002093980070937B0360934F
:100420007C039091850280913303981721F080918D
:100430000201806103C0809102018F7E80930201DE
:10044000AA2329F181E090E09093890080938800AD
:1004500080913F0480931303109215031ABC1092ED
:100460009500109294008091CA029091CB029093D3
:1004700097008093960080919100897F80939100EE
:100480008091910081608093910010923903809156
:1004900071008062809371000895882319F40E948E
:1004A000630108950E94D50108959F92AF92BF9273
:1004B000CF92DF92EF92FF920F931F93CF93DF9330
:1004C000C82EC82FD0E0FE01EE0FFF1FE25FFC4FE9
:1004D00000811181FE01EA5EFC4F84A1882329F08E
:1004E000C801880F991F080F191FFE01EA5EFC4F13
:1004F000828D181614F4D28C02C0D28CD194FE01D5
:10050000EA5EFC4F948C8D2D90E0880F991F9C0122
:10051000442737FD4095542FFE01EE0FFF1FEE0FCD
:10052000FF1FEA5EFC4F82899389A489B5898217EF
:100530009307A407B50720F4228B338B448B558B8C
:100540008D2D90E0809FB001819F700D909F700D68
:100550001124FE01EE0FFF1FEE0FFF1FEA5EFC4F9E
:10056000E288F38804891589A80197015695479573
:1005700037952795FE01EE0FFF1FEB58FC4FA0802B
:10058000B18088E0D81649F488EF9FEFAFEFBFEF56
:10059000E822F9220A231B23287FCB01A0E0B0E048
:1005A000281739074A075B0708F4B901CB01A0E017
:1005B000B0E0A8019701281B390B4A0B5B0BDA014D
:1005C000C901FE01EE0FFF1FEE0FFF1FEA5EFC4F99
:1005D0002081318142815381992039F0B095A095D5
:1005E000909581959F4FAF4FBF4FFE01EE0FFF1FBC
:1005F000EE0FFF1FE458FD4F820F931FA41FB51F7E
:1006000080839183A283B383CC0FDD1FC25EDC4F56
:10061000B982A8829EB3CC2011F48BEF01C087EF82
:1006200089238EBB9EB3CC2011F481E001C082E00F
:10063000892B8EBB8C2D0E944D02DF91CF911F9193
:100640000F91FF90EF90DF90CF90BF90AF909F9071
:1006500008958823A9F080916F008F7D80936F00AB
:1006600080918100887F809381001092360381E021
:10067000809338031092260310927A02F09808951E
:1006800080913803882339F54FB7F89410923603D8
:10069000F09810922603209171033091720380919B
:1006A0006D0390916E038217930758F4809179033C
:1006B00090917A032817390720F430937A03209316
:1006C00079038091790390917A03019690936E0358
:1006D00080936D034FBF08958823A9F08091710026
:1006E0008F7D8093710080919100887F809391002D
:1006F0001092370381E08093390310922703109200
:100700007B02F198089580913903882339F54FB71A
:10071000F8941092370310922703F19820917303F5
:100720003091740380916F03909170038217930747
:1007300058F480917B0390917C032817390720F4AB
:1007400030937C0320937B0380917B0390917C0307
:1007500001969093700380936F034FBF0895882391
:1007600029F4611181E00E942903089580E061115C
:1007700081E00E946C0308951F920F920FB60F92B2
:100780000BB60F9211242F933F934F935F936F9368
:100790007F938F939F93AF93BF93EF93FF9380913A
:1007A000880090918900019709F0C9C08AB5E82FA7
:1007B000EE73F0E0E653FD4F2081318130939700D6
:1007C000209396008F5F8ABD609198007091990088
:1007D00070938900609388001E9B54C02E9880916E
:1007E0001A0390911B03A0911C03B0911D0320914B
:1007F0003103332727FD3095432F532F280F391FFF
:100800004A1F5B1F20931A0330931B0340931C0362
:1008100050931D03F19B1BC0F39919C08091800276
:1008200090918102A0918202B09183028217930776
:10083000A407B50761F4F39A80917B0390917C0340
:1008400001969093700380936F031092130380912D
:100850007B0390917C038617970708F074C0F19B87
:1008600003C010923703F19881E08093390380919F
:1008700071008F7D8093710080919100887F8093BB
:10088000910061C02E9A80911303882309F053C010
:1008900020916F033091700326173707D0F48091B1
:1008A00015038F3308F041C08F5F8093150390E0EC
:1008B000FC01EE0FFF1FE80FF91FEA5EFC4FE95D38
:1008C000FE4F60817181E752F14026173707E0F053
:1008D0002CC06217730750F580911503882329F106
:1008E00081508093150390E0FC01EE0FFF1FE80F8D
:1008F000F91FEA5EFC4FE95DFE4F60817181E752AE
:10090000F1406217730788F480913B03E75DFE4F67
:10091000882339F0808123E0829FC00111248E5FFB
:1009200001C080818093130301C0B90170939900C5
:100930006093980008C081508093130304C0909383
:10094000890080938800FF91EF91BF91AF919F91B3
:100950008F917F916F915F914F913F912F910F9068
:100960000BBE0F900FBE0F901F9018951F920F9205
:100970000FB60F920BB60F9211242F933F934F9304
:100980005F936F937F938F939F93AF93BF93EF93F7
:10099000FF9380918A0090918B00019709F0C9C064
:1009A0008BB5E82FEE73F0E0E657FD4F20813181E3
:1009B00030938700209386008F5F8BBD60919A00F3
:1009C00070919B0070938B0060938A00639B54C06E
:1009D00073988091160390911703A0911803B0911A
:1009E000190320913003332727FD3095432F532FD0
:1009F000280F391F4A1F5B1F2093160330931703DC
:100A00004093180350931903F09B1BC0F29919C02F
:100A100080917C0290917D02A0917E02B0917F0234
:100A200082179307A407B50761F4F29A80917903BE
:100A300090917A03019690936E0380936D031092C8
:100A400012038091790390917A038617970708F033
:100A500074C0F09B03C010923603F09881E080933D
:100A6000380380916F008F7D80936F0080918100AB
:100A7000887F8093810061C0739A809112038823DC
:100A800009F053C020916D0330916E03261737078C
:100A9000D0F4809114038F3308F041C08F5F8093AE
:100AA000140390E0FC01EE0FFF1FE80FF91FEA5E50
:100AB000FC4FE959FF4F60817181E756F0402617DE
:100AC0003707E0F02CC06217730750F580911403CC
:100AD000882329F181508093140390E0FC01EE0FEC
:100AE000FF1FE80FF91FEA5EFC4FE959FF4F6081D5
:100AF0007181E756F0406217730788F480913A03DA
:100B0000E759FF4F882339F0808123E0829FC0019D
:100B100011248E5F01C080818093120301C0B9014E
:100B200070939B0060939A0008C0815080931203D9
:100B300004C090938B0080938A00FF91EF91BF9146
:100B4000AF919F918F917F916F915F914F913F9165
:100B50002F910F900BBE0F900FBE0F901F90189506
:100B60001F936091440370914503809146039091D7
:100B700047034EE050E00E943011609148037091AD
:100B8000490380914A0390914B0342E150E00E9457
:100B9000301160914C0370914D0380914E03909100
:100BA0004F0346E150E00E94301160915003709174
:100BB000510380915203909153034AE150E00E9407
:100BC00030116091560370915703809158039091B2
:100BD00059034EE150E00E94301160915A03709128
:100BE0005B0380915C0390915D0342E250E00E94C0
:100BF00030118091840269E070E00E9409118091B7
:100C000085026AE070E00E940911809188026BE021
:100C100070E00E9409118091870268E070E00E94F4
:100C20000911809175036CE070E00E9409118091B8
:100C300077036DE070E00E94091180916903909143
:100C40006A0366E270E00E94151180916B03909137
:100C50006C0368E270E00E94151180910C0311E0B2
:100C600081276AE270E00E94091180910D038127BB
:100C70006BE270E00E940911809167039091680314
:100C80006CE270E00E94151180915F036EE270E0EB
:100C90000E9409118DE793E060E444E650E00E9471
:100CA00060118DE394E060E444E251E00E94601141
:100CB0001F91089580E092E068E040E050E00E94DB
:100CC000471108950F931F93DF93CF93CDB7DEB7EE
:100CD00029970FB6F894DEBF0FBECDBF8E010F5F10
:100CE0001F4F89E0F80111928A95E9F7C80168E081
:100CF00040E050E00E94CB10C80160E072E048E0A4
:100D000050E00E94D600009791F5809188028330D0
:100D100070F5882321F480918702813140F580911C
:100D20008702813220F58091690390916A03C2970E
:100D30008F579440E0F480916B0390916C03C297BD
:100D40008F579440A0F48091750390917603892B7E
:100D500071F08091770390917803892B41F090E0B6
:100D600080915F038150833118F491E001C090E0DD
:100D7000892F29960FB6F894DEBF0FBECDBFCF9155
:100D8000DF911F910F9108958F929F92AF92BF9222
:100D9000CF92DF92EF92FF920F931F93CF93DF9347
:100DA000A82E4B0182E00E944113B82E0FE4A0163A
:100DB00009F451C10A15FCF018E4A11609F4EAC0BF
:100DC0001A1564F026E4A21609F43CC12A150CF4A5
:100DD000CBC085E4A81609F05EC121C1ABE4AA1618
:100DE00009F4B5C0BCE4AB1609F4B7C0E9E4AE162B
:100DF00009F051C1E3C0F6E6AF1609F476C0FA1562
:100E00005CF002E6A01679F115E6A11691F021E654
:100E1000A21609F040C11AC08AE6A81609F487C0D4
:100E2000A3E7AA1609F454C0B7E6AB1609F033C11C
:100E30004AC0E82FF0E0EE0FFF1FEE0FFF1FEA5E43
:100E4000FC4F26A137A140A551A5A1C2E82FF0E093
:100E5000EE0FFF1FEE0FFF1FEA5EFC4F26A537A522
:100E600040A951A994C2A82FB0E0FD01EE0FFF1FC9
:100E7000EE0FFF1FEA5EFC4F26A937A940AD51AD2A
:100E800080918602882309F082C2AA0FBB1FA7594E
:100E9000BC4FED90FC90EE0CFF1C0894E11CF11C83
:100EA000B70180E090E00894E108F1080E94811603
:100EB00000E010E0A80197010E94B416C901DA0110
:100EC0009C01AD0164C2EB2DF0E0EC5AFC4FA4C1D3
:100ED000EB2DF0E0EE0FFF1FEE0FFF1FEA5AFC4F65
:100EE000208131814281538152C2A82FB0E0FD019F
:100EF000EA5EFC4F848D882319F020E032E002C0C6
:100F000020E030E0FD01EA5EFC4F82A181113160FA
:100F1000FD01EA5EFC4F80A181112061AA5EBC4FF9
:100F20005E968C91882309F409C1216007C18FB7AF
:100F3000F894EB2DF0E0EE0FFF1FEE0FFF1FEA5EBF
:100F4000FC4F20813181428153818FBF20C260E0FC
:100F50000E94AF03EB2DF0E019C061E00E94AF03E7
:100F60008B2D0E9455010FC2E82FF0E0DF01AA5E31
:100F7000BC4FE4018881805350968C93509790E049
:100F80008981803309F091E05C969C93E658FD4F8F
:100F90001082F9C1C4010E942713AB2DB0E0FD01FE
:100FA000EE0FFF1FEE0FFF1FEA5EFC4F628B738B8D
:100FB000848B958BA658BD4F1C92E5C1C4010E943D
:100FC0002713CB2CDD24E601CC0FDD1FC25EDC4FE6
:100FD00020EC30E0C29EF001C39EF00DD29EF00DD9
:100FE0001124E65CFB4F20813181790100E010E0A3
:100FF000AC01CB01DA018E159F05A007B10710F4F3
:10100000D801C70199838883F601E658FD4F808196
:10101000823009F0BDCF8B2D0E944D02B4C11FB7A5
:10102000F894C4010E942713EB2DF0E0EE0FFF1F90
:10103000EE0FFF1FEA5EFC4F608371838283938310
:101040001FBFA1C180918602882309F09BC18B2D0F
:101050000E94380198C1F4018081805380938602F8
:10106000882331F420E030E040E050E010E090C10F
:1010700080E061E00E94AF0380E00E94550181E0C2
:1010800061E00E94AF0381E00E94550110927A0254
:1010900010927B0278C120918602222309F473C149
:1010A0008A2D992787FD9095A92FB92FFC01E1542E
:1010B000F040EA33F10508F066C1EE58FF4FEE0F3D
:1010C000FF1F0590F491E02D0994C4010E9427139D
:1010D000EB2DF0E0EE0FFF1FEE0FFF1FEA5EFC4F5F
:1010E00066A777A780AB91AB4EC1C4010E942713BE
:1010F000EB2DF0E0EE0FFF1FEE0FFF1FEA5EFC4F3F
:1011000066AB77AB80AF91AF3EC1C4010E9427139D
:10111000EB2DF0E0EE0FFF1FEE0FFF1FEA5AFC4F22
:1011200060837183828393832EC1EB2DF0E0EE0FF9
:10113000FF1FE759FC4F808191819C0140E050E006
:1011400026C1C4010E942713EB2DF0E0EE0FFF1F14
:10115000E759FC4F7183608316C1BB2019F0809161
:1011600087025BC08091880258C0BB2081F0C40117
:101170000E94241380938702883010F490E004C00A
:1011800090910C0381E0982790930A03FCC0C4015E
:101190000E94241380938802F6C0BB2029F080911E
:1011A000670390916803C9CF80915F0336C0BB206D
:1011B00089F0C4010E9427136030F0E07F07F1E05E
:1011C0008F07F0E09F0708F0DDC07093680360931D
:1011D0006703D9C0C4010E942413982F8150833122
:1011E00008F0D0C090935F03CEC0EB2DF0E0EE0F7F
:1011F000FF1FEB58FC4F9FCFC4010E942413EB2D1F
:10120000F0E0EE0FFF1FEB58FC4F80831182BBC054
:10121000EB2DF0E0EC57FD4F8081282F30E08ECF92
:10122000EB2DF0E0EC57FD4F90E0D4018C91803332
:1012300009F091E09083A7C0BB2081F020910C03BE
:1012400080918702883010F480E002C081E082271C
:1012500030E040E050E080930A0399C080910D0394
:10126000DCCFBB2061F0C4010E94241310920C0358
:10127000882309F488C081E080930C0384C0C401F2
:101280000E94241310920D03882309F47CC081E08E
:1012900080930D0378C020E030E040E050E06B2DFB
:1012A00070E0EB01CC5EDC4FA8818A2F90E0FC015E
:1012B000EE0FFF1FE80FF91F80EC90E08C01609F9C
:1012C000C001619F900D709F900D1124E80FF91FD0
:1012D000EA5EFC4FE959FF4F219131914081AF5FA8
:1012E000A883A03408F453C0188251C0C4010E94DE
:1012F00027134B2D50E0EA01CC5EDC4FA8812A2F4A
:1013000030E0F901EE0FFF1FE20FF31F20EC30E099
:101310008901409F9001419F300D509F300D112455
:10132000E20FF31FEA5EFC4FE959FF4F619371939F
:10133000BC01882799276083AF5FA883A03418F188
:10134000188221C0C4010E942413EB2DF0E0EC5E52
:10135000FC4F80838034B0F416C0822F90E09C0153
:101360002170307081FF08C0232B19F00E945A06AB
:101370000AC00E94B00507C0232B29F00E94620614
:10138000882309F4AA2420E030E040E050E011E096
:10139000C4016A2D0E94C2132AE4A21689F4809126
:1013A0008602882369F48B2D90E0FC01E658FD4FFE
:1013B00021E02083FC01EA5EFC4F808980FF20A3AE
:1013C000812FDF91CF911F910F91FF90EF90DF90D0
:1013D000CF90BF90AF909F908F9008952F923F92A3
:1013E0004F925F926F927F928F929F92AF92BF9235
:1013F000CF92DF92EF92FF920F931F93CF93DF93E1
:10140000C82FD0E0FE01EE0FFF1FEE0FFF1FEA5EB8
:10141000FC4FA6A8B7A8C0ACD1AC60E072E18AE7E7
:1014200090E0A60195010E94B416C901DA013C01C1
:101430004D0160E072E18AE790E0A60195010E940B
:10144000B4160E944E157B018C01C601B5010E94A5
:101450004E159B01AC01C801B7010E94BA1420E0EF
:1014600030E040E052E40E941E1620E030E040E010
:101470005FE30E9443140E9422151B012C01C4014A
:10148000AA27BB27892B39F05FEF652E5FEF752EFA
:10149000812C912C0BC080E86816710481049104A2
:1014A00028F440E8642E712C812C912CFE0136E04A
:1014B000EE0FFF1F3A95E1F7E657FD4F80E061928E
:1014C00071928F5F8032D9F7AA24BB24650125E091
:1014D000CC0FDD1F2A95E1F72BC0C601B5010E9494
:1014E0004E1520E030E040E052E40E941E167B01E1
:1014F0008C01C201B1010E944E159B01AC01C801D3
:10150000B7010E94BA140E94A7140E942215FE017E
:10151000E60FF11DEE0FFF1FE657FD4F8081918111
:101520000196918380830894A11CB11CC11CD11C1D
:10153000A214B304C404D50480F2DF91CF911F91AB
:101540000F91FF90EF90DF90CF90BF90AF909F9062
:101550008F907F906F905F904F903F902F90089565
:1015600089E090E00E94971010928402882319F07D
:1015700081E0809384028AE090E00E9497101092AC
:101580008502882319F081E0809385028BE090E04A
:101590000E9497108093880288E090E00E94971044
:1015A000809387028BE290E00E94971010920D03C7
:1015B000882319F481E080930D0310920B0380912E
:1015C0008702883018F481E080930B038AE290E070
:1015D0000E94971090E0882309F491E090930C0307
:1015E00080918702883010F480E002C081E0892772
:1015F00080930A03882311F441E001C048E062E2CD
:1016000073E080E090E00E94321480918702609144
:1016100088020E94E4000E946206882319F481E097
:101620008093860280E00E94EE0981E00E94EE092C
:101630004091750350917603EDE7F3E020E030E050
:10164000808191814817590750F4828190E001967A
:10165000280F391F339684E0ED33F80789F730936C
:101660000F0320930E034091770350917803EDE32D
:10167000F4E020E030E0808191814817590750F470
:10168000828190E00196280F391F339684E0ED3F68
:10169000F80789F73093110320931003279A2F98A6
:1016A0005098589A099A119A23982B9A2098289A18
:1016B00022982A9A2198299A819A8998809A8898BA
:1016C0009D9AA59A80910101806280930101809189
:1016D00002018062809302016B9A7398269A2E9879
:1016E0006D9A7598809101018061809301018091CC
:1016F00002018F7E80930201E0910B03F0E0E75F2F
:10170000FD4F8081282F30E0A9014170507080FF8B
:1017100004C080910501816003C0809105018E7F26
:101720008093050180910401816080930401452B21
:1017300011F0599A01C05998519AA90142705070FC
:1017400021FF04C080910201826003C080910201E8
:101750008D7F80930201809101018260809301015D
:10176000452B11F05A9A01C05A98529AB9016470E7
:10177000707022FF04C080910201816003C08091DB
:1017800002018E7F80930201A9014072507025FDF5
:1017900004C080910101816003C0809101018E7FAE
:1017A00080930101672B11F05B9A01C05B98452B78
:1017B00011F4539A01C0539880EA9FE00197F1F722
:1017C000899A889A0E94181260E875E280E090E099
:1017D0000E948B1108952F923F924F925F926F92C9
:1017E0007F928F929F92AF92BF92CF92DF92EF92B1
:1017F000FF920F931F93DF93CF93CDB7DEB72E9752
:101800000FB6F894DEBF0FBECDBF78940E94B00A29
:10181000EE24FF24AA2400E0CC24BB24412C512C2C
:1018200080E8682E712C1E010894211C311CDD24D7
:10183000DA9414E0812E912C8C0E9D1E0894E11CEC
:10184000F11C80918902882309F095C0E114F1040C
:1018500009F091C00E941001182F882309F48BC051
:1018600080E061E00E94AF0381E061E00E94AF038D
:101870008FB7F894409216035092170360921803A2
:101880007092190340921A0350921B0360921C033A
:1018900070921D038FBF0E94E61181E08093890240
:1018A000123081F4809308020E940012C10160E0AE
:1018B00020E030E040E050E00E94C213C1010E94ED
:1018C000C41259C01092080210920A03119AE091B2
:1018D0000B03F0E0E75FFD4F8081982F80FF07C08A
:1018E00080910501816080930501599A06C080911D
:1018F00005018E7F80930501599891FF07C0809163
:1019000002018260809302015A9A06C0809102010E
:101910008D7F809302015A9892FF07C08091020147
:101920008160809302015B9A06C0809102018E7FE4
:10193000809302015B9880E00E94F60E80E00E9496
:10194000380181E00E94380121E020932603209392
:101950002703109232032093300310923303209315
:1019600030038091690390916A0390931F038093E1
:101970001E0320937A0280910802882309F465C12E
:101980000E3F21F00E946312882371F185B18058C7
:1019900085B90E3F19F00E947012A82EC4016A2D5D
:1019A0000E948013082F8823F9F0181614F010E015
:1019B00005C0B4010E94C40611E01827C4010E94AA
:1019C000C412112389F00E94AE122BE088E190E04E
:1019D0000FB6F894A895809360000FBE2093600026
:1019E00080E090E00E94D616E114F10409F42F98EB
:1019F00080918902882309F062C0EE2009F05FC05F
:101A0000809132038823B9F480917A02823099F46C
:101A1000199902C0E1E0C6C11A9BC3C1BB2059F0AD
:101A20008091690390916A0390931F0380931E0332
:101A30000E946301BB2480913703882309F03FC0D3
:101A4000199903C051E041E006C01A9B02C04FEF54
:101A500001C040E050E080913903882371F4809107
:101A6000330390E0252F30E08217930731F080E0B8
:101A70000E946C0310927B0222C04F3FD1F08091F4
:101A80006503909166039093210380932003252F93
:101A9000511121E020933303222319F0D092310316
:101AA00003C081E0809331030E94D501CC24C3940C
:101AB00006C0CC2021F080E00E946C03CC249091E1
:101AC0007A02913009F067C080913803882309F4C5
:101AD00062C03091260380910A03882309F442C032
:101AE000832F8150823070F420910902809132035B
:101AF000882319F0D092300302C0909330031092E3
:101B00003A030DC020910A02909154038091320350
:101B1000811191959093300381E080933A03922F45
:101B200020FF04C080910501816003C08091050100
:101B30008E7F8093050191FF04C080910201826035
:101B400003C0809102018D7F8093020192FF04C047
:101B500080910201816003C0809102018E7F809399
:101B600002010BC080913203882319F0D092300318
:101B700002C09093300310923A0330FF07C080E018
:101B80000E944D0282E080937A0205C080E00E94AC
:101B9000550210927A0290917B02913009F04ECE5C
:101BA00080913903882309F449CE3091270380912D
:101BB0000A03882381F1832F8150823070F42091B1
:101BC000090280913303882319F0D092310302C0B7
:101BD0009093310310923B030DC020910A02909123
:101BE000550380913303811191959093310381E0E6
:101BF00080933B03822F20FF02C0599A01C059985D
:101C000081FF02C05A9A01C05A9882FF02C05B9AB3
:101C10000DC05B980BC080913303882319F0D092DC
:101C2000310302C09093310310923B0330FF07C091
:101C300081E00E944D0282E080937B02FFCD81E033
:101C40000E94550210927B02F9CDE114F10471F467
:101C500085B1805885B90E942601982F80915E0336
:101C6000981739F0892F0E94F60E03C0EE2009F074
:101C7000E5CD189BAAC01B9B02C04FEF01C040E0FE
:101C800050E01FB7F89480913803882309F0A6C06C
:101C90008091320390E0252F30E08217930709F4FA
:101CA0009DC020919A0030919B008091710390918A
:101CB00072032817390708F091C027C0E091690323
:101CC000F0916A030BC0E42FFF27E7FDF095EE0FBC
:101CD000FF1FE05AFC4F0190F081E02DF0931F03AD
:101CE000E0931E03252F511121E02093320322237C
:101CF00019F0D092300303C081E0809330034F3F4E
:101D000041F480915E03823021F480E00E94290337
:101D100002C00E9463011FBF199903C051E041E056
:101D200006C01A9B02C04FEF01C040E050E01FB751
:101D3000F89480913903882309F054C080913303CB
:101D400090E0252F30E08217930709F44BC02091D3
:101D50009800309199008091730390917403281733
:101D6000390708F03FC018C0809165039091660361
:101D70009093210380932003252F511121E020937C
:101D80003303222319F0D092310303C081E0809302
:101D900031030E94D50103C080E00E946C031FBF85
:101DA0004DCDE0E0FF27E7FDF095B596EE0FFF1F64
:101DB000EA5EFC4F8081918190931F0380931E0304
:101DC0000E946301BB24B39436CE809164038823C0
:101DD00011F051E001C050E041E053CF4F3F09F016
:101DE00072CF6CCF4F3F09F0BFCFD6CF0F931F9369
:101DF000482F80935E038230A1F480917503909107
:101E000076039093610380936003909363038093C0
:101E1000620381E08093640380917703909178035B
:101E20001BC08130F1F42091690330916A03C9012C
:101E300063E070E00E94A0167093610360936003FA
:101E400030936303209362034093640380916B0398
:101E500090916C03969587959093660380936503A4
:101E60003BC08091690390916A0324E130E0829F36
:101E70008001839F100D929F100D112440915F03EC
:101E8000E42FF0E0BF016C5E7F4FC8010E94A016F6
:101E90007093610360936003B9016E1B7F0BC801EF
:101EA0000E94A01670936303609362031092640310
:101EB00080916B0390916C03BC01629FC001639F92
:101EC000900D729F900D1124642F70E00E94A01657
:101ED00070936603609365031F910F910895982F87
:101EE000EBE0F2E020E030E08081891789F4F9012D
:101EF000EE0FFF1F662331F0E20FF31FE55FFD4F8A
:101F000081810895E20FF31FE55FFD4F82810895FF
:101F10002F5F3F4F33962532310531F78FEF08950C
:101F20004F925F926F927F928F929F92AF92BF92E9
:101F3000CF92DF92EF92FF920F931F93CF93DF9395
:101F40003B014C01442E8EE090E00E94AD10609366
:101F5000440370934503809346039093470382E1C3
:101F600090E00E94AD106093480370934903809302
:101F70004A0390934B0386E190E00E94AD1060937A
:101F80004C0370934D0380934E0390934F038AE16B
:101F900090E00E94AD1060935003709351038093C2
:101FA0005203909353038EE190E00E94AD10609332
:101FB000560370935703809358039093590382E21A
:101FC00090E00E94AD1060935A0370935B0380937E
:101FD0005C0390935D0386E290E00E949E109093D4
:101FE0006A038093690388E290E00E949E109093B8
:101FF0006C0380936B038CE090E00E94971005E7E0
:1020000013E080937503109276038DE090E00E94B8
:10201000971080937703F80113828EE290E00E947C
:10202000971080935F038CE290E00E949E10909343
:10203000680380936703C801089660E444E650E0B3
:102040000E94DD108DE394E060E444E251E00E94E0
:10205000DD1026E133E079016DE773E009E713E075
:10206000E901D90140E050E055245394A12CB12C52
:10207000E0E8CE2ED12C1C8EFA01EA5EFC4F528E87
:102080001CA25AA218A21E8EF701A192B192C1926F
:10209000D1927F01AD5ABF4F8D919C911197A3555D
:1020A000B04019969C938E931897188AF901128A5A
:1020B000138A148A158A66A277A280A691A64EAECC
:1020C000FB0180819181A55ABF4F11969C938E93FD
:1020D000F801819391938F011497019611969C9327
:1020E0008E93A755B0401D969C938E931C974F5F7F
:1020F0005F4F219612962C5F3F4F60547F4F4230C6
:10210000510509F0B8CF80E00E94F60EDF91CF9123
:102110001F910F91FF90EF90DF90CF90BF90AF9005
:102120009F908F907F906F905F904F900895F99956
:10213000FECF92BD81BDF89A80B50895F999FECF82
:1021400092BD81BDF89A20B5F999FECF019692BD56
:1021500081BDF89A90B5822F0895F999FECF92BD6E
:1021600081BDF89A20B5F999FECF019692BD81BD47
:10217000F89A70B50196F999FECF92BD81BDF89A93
:1021800030B5F999FECF019692BD81BDF89A90B510
:10219000622F832F0895FC0190E00CC0F999FECFC7
:1021A0009A012F5F3F4F52BD41BDF89A80B5819390
:1021B0009F5FA901961790F30895FC0120E025C0C8
:1021C000F999FECF52BD41BDF89A90B5F999FECF6D
:1021D0004F5F5F4F52BD41BD41505040F89A80B5AE
:1021E00090838183CA010296F999FECF92BD81BD89
:1021F000F89A80B54D5F5F4FF999FECF52BD41BD52
:10220000F89A90B582832F5F3396261708F4D8CFBB
:102210000895F999FECF1FBA72BD61BD80BD0FB69A
:10222000F894FA9AF99A0FBE08959C01F999FECF95
:102230001FBA72BD61BD20BD0FB6F894FA9AF99A23
:102240000FBE932FF999FECF1FBA6F5F7F4F72BDFC
:1022500061BD90BD0FB6F894FA9AF99A0FBE089531
:10226000EF92FF920F931F938A01F82EE92ECB0174
:10227000BA010E9415110E5F1F4F8F2D9E2DB801C0
:102280000E9415111F910F91FF90EF900895FC018E
:1022900020E030E012C07081F999FECF1FBAC90169
:1022A000840F951F92BD81BD70BD0FB6F894FA9A48
:1022B000F99A0FBE2F5F3F4F3196261760F30895AE
:1022C000EF92FF920F931F93CF93DF93E62E8A0135
:1022D000EC01FF2417C088819981B8010E94151173
:1022E000C80102962A81F999FECF1FBA92BD81BD1D
:1022F00020BD0FB6F894FA9AF99A0FBE0D5F1F4FE2
:10230000F3942396FE1438F3DF91CF911F910F9130
:10231000FF90EF900895EF92FF920F931F937B0130
:102320008C0182E08093C00060E079E08DE390E072
:10233000A80197010E94B4162150304040405040FF
:102340005695479537952795922F232F832F807F7A
:10235000A1F01092C00060E874E88EE190E0A8015E
:1023600097010E94B416215030404040504056958D
:10237000479537952795922F232F2F702093C500CF
:102380009093C4008FB7F89410921D0510921E050B
:1023900010923F05109240058FBF8091C10080616F
:1023A0008093C1008091C10088608093C1008091BA
:1023B000C10080688093C1008091C1008F7D8093AF
:1023C000C1001F910F91FF90EF900895E1ECF0E0B4
:1023D00080818F7E80838081877F808380818F77DB
:1023E000808380818F7D80838FB7F89410921D0544
:1023F00010921E0510923F05109240058FBF089560
:10240000219A299A23982B9A229A2A9A209A289AD2
:10241000119A8FB7F89410921D0510921E05109214
:102420003F05109240058FBF81E0809341050895DC
:102430002198299A23982B9A22982A9A2098289AA8
:10244000109241058FB7F89410921D0510921E0549
:1024500010923F05109240058FBF089598E029988B
:1024600087FF02C02A9A02C000002A98299A880F82
:102470001B998F5F915099F7089590914005809135
:102480003F059817C9F0489917C0289881E80E941D
:102490002E12489BFECF80E80E942E1287FD0BC0B3
:1024A000E0913F05F0E0E15EFA4F808380913F05C7
:1024B0008F5F80933F05289A089528988F770E9410
:1024C0002E12289A089580914105882311F00E94C8
:1024D0003D1280913F0590914005891B8F710895B1
:1024E0009091400580913F05891711F48FEF089571
:1024F000E92FF0E0E15EFA4F80819F5F9F7190933A
:1025000040050895282F8091C10083FF1FC090913E
:102510001D059F5F9F7180911E05981749F480915A
:10252000C10080628093C10080911E059817E1F37D
:10253000E0911D05F0E0E350FB4F208390931D05D3
:102540008091C10080628093C1000895809141050F
:10255000882319F0822F0E945D1208958091C10096
:1025600083FF11C090911D059F5F9F7180911E0593
:10257000981749F48091C10080628093C1008091D6
:102580001E059817E1F30895CF93DF93EC0103C084
:1025900021960E94821288818823D1F7DF91CF9102
:1025A00008952F932FB72F939F938F93EF93FF93BC
:1025B0002091C60090913F059F5F9F7180914005DB
:1025C000981741F0E0913F05F0E0E15EFA4F20837B
:1025D00090933F05FF91EF918F919F912F912FBF86
:1025E0002F9118958F938FB78F939F93EF93FF93AE
:1025F00090911E0580911D05891731F48091C100CD
:102600008F7D8093C1000BC0E92FF0E0E350FB4FBA
:1026100080819F5F9F7190931E058093C600FF91FC
:10262000EF919F918F918FBF8F911895FC019181B0
:102630009A330CF0975080818A330CF08750829542
:10264000807F9F70892B08950E9416130895EF9242
:10265000FF920F931F938C0104960E941613E82E8D
:10266000C80102960E941613F82EC8010E94161384
:10267000682F7F2D8E2D90E01F910F91FF90EF908E
:102680000895823010F480934F0580914F0508958E
:10269000EF92FF921F93CF93DF93182F7B019091BE
:1026A00043059093500580914405815380934F05D5
:1026B0008230F8F4892F61E00E946F0F1350282FA9
:1026C000332727FD3095812F90E02817390789F4AB
:1026D000A5E4B5E0E701F9012A0F3B1F02C08D9187
:1026E0008993A217B307D9F7EE0DFF1D108281E081
:1026F00001C080E0DF91CF911F91FF90EF9008958E
:10270000CF93DF93EC0180914205882321F16A3356
:1027100049F481E288838DE089831A821092420510
:102720008EEF2DC080914E05E82FF0E0ED5BFA4F63
:1027300060838F5F80934E056D3051F4BE010E941F
:102740004813882391F0109242058091500517C0DC
:102750008B30A1F40AC06A3389F410924E0581E0EF
:10276000809342051092430509C081E288838DE081
:1027700089831A82109242058FEF01C080E0DF91B9
:10278000CF910895FF920F931F93CF93DF93EC01A6
:10279000122F032FF42E662339F0862F60E00E945B
:1027A0006F0F982F87FF04C081E2888390E04EC0AE
:1027B0008DE388839230D9F19330C9F4212F302FE3
:1027C000812F8F708A3008F0895F805D8B83822F24
:1027D00082958F708A3008F0895F805D8A83832FAD
:1027E0008F708A3008F0895F805D89832FC09630B2
:1027F00069F58F2D8F708A3008F0895F805D8E8338
:102800004F2D42954F704A3008F0495F405D4D832F
:10281000802F8F708A3008F0895F805D8C83302F25
:1028200032953F703A3008F0395F305D3B83812F3D
:102830008F708A3008F0895F805D8A83212F22950E
:102840002F702A3008F0295F205D2983FE01E90FEF
:10285000F11D8DE081831282DF91CF911F910F9145
:10286000FF9008951092420510924E052BE0E3E48C
:10287000F5E0DF011D922A95E9F710924F050E94BD
:10288000900F08955058BB27AA270ED086C177D144
:1028900030F07CD120F031F49F3F11F41EF46CC174
:1028A0000EF4E095E7FB37C1E92F88D180F3BA1722
:1028B000620773078407950718F071F49EF5B7C196
:1028C0000EF4E0950B2EBA2FA02D0B01B90190014B
:1028D0000C01CA01A0011124FF27591B99F0593F8F
:1028E00050F4503E68F11A16F040A22F232F342FD7
:1028F0004427585FF3CF469537952795A795F04025
:102900005395C9F77EF41F16BA0B620B730B840B39
:10291000BAF09150A1F0FF0FBB1F661F771F881FF1
:10292000C2F70EC0BA0F621F731F841F48F4879549
:1029300077956795B795F7959E3F08F0B3CF939538
:10294000880F08F09927EE0F97958795089558D12D
:1029500080F09F3740F491110EF46AC160E070E09E
:1029600080E89FE3089526F01B16611D711D811DEF
:10297000D8C0F2C00CD011C109D140F000D130F064
:1029800021F45F3F19F0C7C0511152C1F5C016D1F3
:1029900098F39923C9F35523B1F3951B550BBB2726
:1029A000AA2762177307840738F09F5F5F4F220FD3
:1029B000331F441FAA1FA9F333D00E2E3AF0E0E8CC
:1029C00030D091505040E695001CCAF729D0FE2F18
:1029D00027D0660F771F881FBB1F261737074807AA
:1029E000AB07B0E809F0BB0B802DBF01FF27935860
:1029F0005F4F2AF09E3F510568F08DC019C15F3FBF
:102A0000ECF3983EDCF3869577956795B795F79547
:102A10009F5FC9F7880F911D9695879597F908953F
:102A2000E1E0660F771F881FBB1F621773078407DB
:102A3000BA0720F0621B730B840BBA0BEE1F88F7EA
:102A4000E0950895C3D088F09F5790F0B92F99274B
:102A5000B751A0F0D1F0660F771F881F991F1AF0A9
:102A6000BA95C9F712C0B13081F0E1D0B1E0089554
:102A7000DEC0672F782F8827B85F39F0B93FCCF3D5
:102A8000869577956795B395D9F73EF4909580959F
:102A9000709561957F4F8F4F9F4F0895E89409C0BF
:102AA00097FB3EF490958095709561957F4F8F4F81
:102AB0009F4F9923A9F0F92F96E9BB279395F69597
:102AC000879577956795B795F111F8CFFAF4BB0F15
:102AD00011F460FF1BC06F5F7F4F8F4F9F4F16C079
:102AE000882311F096E911C0772321F09EE8872F03
:102AF000762F05C0662371F096E8862F70E060E0BF
:102B00002AF09A95660F771F881FDAF7880F969537
:102B1000879597F9089597F99F6780E870E060E0DE
:102B20000895882371F4772321F09850872B762F0E
:102B300007C0662311F499270DC09051862B70E0D1
:102B400060E02AF09A95660F771F881FDAF7880FE2
:102B50009695879597F908959F3F49F0915028F4ED
:102B6000869577956795B7959F5F80389F4F880FBB
:102B70009695879597F908959FEF80EC0895002426
:102B80000A941616170618060906089500240A94D2
:102B900012161306140605060895092E0394000C58
:102BA00011F4882352F0BB0F40F4BF2B11F460FFE7
:102BB00004C06F5F7F4F8F4F9F4F089557FD905810
:102BC000440F551F59F05F3F71F04795880F97FBF1
:102BD000991F61F09F3F79F08795089512161306AB
:102BE0001406551FF2CF4695F1DF08C016161706DA
:102BF0001806991FF1CF869571056105089408950F
:102C0000E5DFA0F0BEE7B91788F4BB279F3860F472
:102C10001616B11D672F782F8827985FF7CF8695F6
:102C200077956795B11D93959639C8F30895E89403
:102C3000BB2766277727CB0197F908950BD0ADCF37
:102C40009EDF28F0A3DF18F0952309F064CF94CF1E
:102C50001124EECFB3DFA0F3959FD1F3950F50E091
:102C6000551F629FF001729FBB27F00DB11D639F3E
:102C7000AA27F00DB11DAA1F649F6627B00DA11DE4
:102C8000661F829F2227B00DA11D621F739FB00D8A
:102C9000A11D621F839FA00D611D221F749F3327FA
:102CA000A00D611D231F849F600D211D822F762F93
:102CB0006A2F11249F5750408AF0E1F088234AF090
:102CC000EE0FFF1FBB1F661F771F881F91505040DC
:102CD000A9F79E3F510570F01ECFAACF5F3FECF3DE
:102CE000983EDCF3869577956795B795F795E795C8
:102CF0009F5FC1F7FE2B880F911D9695879597F9D9
:102D00000895629FD001739FF001829FE00DF11D35
:102D1000649FE00DF11D929FF00D839FF00D749F55
:102D2000F00D659FF00D9927729FB00DE11DF91F01
:102D3000639FB00DE11DF91FBD01CF01112408955E
:102D4000AA1BBB1B51E107C0AA1FBB1FA617B707D1
:102D500010F0A61BB70B881F991F5A95A9F78095ED
:102D60009095BC01CD010895A1E21A2EAA1BBB1BB0
:102D7000FD010DC0AA1FBB1FEE1FFF1FA217B30747
:102D8000E407F50720F0A21BB30BE40BF50B661F5D
:102D9000771F881F991F1A9469F760957095809521
:102DA00090959B01AC01BD01CF010895F894FFCF30
:102DB000417374726F4551000103006A000666009A
:102DC000034906004702004A00004B000048060085
:102DD0004D0600650006610006620006670002738A
:102DE00000064506005001004600004C0000410668
:102DF000004206005306006E00064E060044020024
:102E00006400024301006300025A02007A00025289
:102E100006007200064F01005102007100025806C0
:0A2E2000007800065902005400007B
:00000001FF

C:\Users\Thomas\AppData\Local\Temp\build-257f0514-347c-4697-aed5-e6694d4cdfa1/AstroEQ6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007a  00800200  00002db0  00002e44  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002db0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002d7  0080027a  0080027a  00002ebe  2**0
                  ALLOC
  3 .debug_aranges 00000270  00000000  00000000  00002ebe  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000006ce  00000000  00000000  0000312e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003dd2  00000000  00000000  000037fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000cc7  00000000  00000000  000075ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003159  00000000  00000000  00008295  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000440  00000000  00000000  0000b3f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001135  00000000  00000000  0000b830  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001a73  00000000  00000000  0000c965  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000400  00000000  00000000  0000e3d8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

/*
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){
       0:	0c 94 ac 00 	jmp	0x158	; 0x158 <__ctors_end>
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
       4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    return inter.integer; //and convert it to an integer
}

char synta_command(){
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      18:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 b6 04 	jmp	0x96c	; 0x96c <__vector_16>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d1 12 	jmp	0x25a2	; 0x25a2 <__vector_25>
      68:	0c 94 f2 12 	jmp	0x25e4	; 0x25e4 <__vector_26>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 bc 03 	jmp	0x778	; 0x778 <__vector_31>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	65 08       	sbc	r6, r5
      e6:	75 08       	sbc	r7, r5
      e8:	10 09       	sbc	r17, r0
      ea:	b5 08       	sbc	r11, r5
      ec:	c3 09       	sbc	r28, r3
      ee:	c3 09       	sbc	r28, r3
      f0:	c3 09       	sbc	r28, r3
      f2:	c3 09       	sbc	r28, r3
      f4:	c3 09       	sbc	r28, r3
      f6:	c3 09       	sbc	r28, r3
      f8:	c3 09       	sbc	r28, r3
      fa:	c3 09       	sbc	r28, r3
      fc:	c3 09       	sbc	r28, r3
      fe:	a1 08       	sbc	r10, r1
     100:	c3 09       	sbc	r28, r3
     102:	c3 09       	sbc	r28, r3
     104:	31 09       	sbc	r19, r1
     106:	d7 08       	sbc	r13, r7
     108:	85 08       	sbc	r8, r5
     10a:	ad 09       	sbc	r26, r13
     10c:	c3 09       	sbc	r28, r3
     10e:	c3 09       	sbc	r28, r3
     110:	c3 09       	sbc	r28, r3
     112:	76 09       	sbc	r23, r6
     114:	a2 09       	sbc	r26, r2
     116:	fc 08       	sbc	r15, r12
     118:	c3 09       	sbc	r28, r3
     11a:	c3 09       	sbc	r28, r3
     11c:	c3 09       	sbc	r28, r3
     11e:	c3 09       	sbc	r28, r3
     120:	c3 09       	sbc	r28, r3
     122:	c3 09       	sbc	r28, r3
     124:	c3 09       	sbc	r28, r3
     126:	c3 09       	sbc	r28, r3
     128:	08 09       	sbc	r16, r8
     12a:	ad 08       	sbc	r10, r13
     12c:	c3 09       	sbc	r28, r3
     12e:	c3 09       	sbc	r28, r3
     130:	c3 09       	sbc	r28, r3
     132:	c3 09       	sbc	r28, r3
     134:	c3 09       	sbc	r28, r3
     136:	c3 09       	sbc	r28, r3
     138:	c3 09       	sbc	r28, r3
     13a:	c3 09       	sbc	r28, r3
     13c:	c3 09       	sbc	r28, r3
     13e:	95 08       	sbc	r9, r5
     140:	c3 09       	sbc	r28, r3
     142:	c3 09       	sbc	r28, r3
     144:	1c 09       	sbc	r17, r12
     146:	cd 08       	sbc	r12, r13
     148:	c3 09       	sbc	r28, r3
     14a:	c3 09       	sbc	r28, r3
     14c:	c3 09       	sbc	r28, r3
     14e:	c3 09       	sbc	r28, r3
     150:	c3 09       	sbc	r28, r3
     152:	4b 09       	sbc	r20, r11
     154:	c3 09       	sbc	r28, r3
     156:	f5 08       	sbc	r15, r5

00000158 <__ctors_end>:
     158:	11 24       	eor	r1, r1
     15a:	1f be       	out	0x3f, r1	; 63
     15c:	cf ef       	ldi	r28, 0xFF	; 255
     15e:	d1 e2       	ldi	r29, 0x21	; 33
     160:	de bf       	out	0x3e, r29	; 62
     162:	cd bf       	out	0x3d, r28	; 61

00000164 <_Z8wdt_initv>:

// Watchdog disable on boot.
void wdt_init(void) __attribute__((naked)) __attribute__((section(".init3")));
void wdt_init(void)
{
    wdt_disable();
     164:	88 e1       	ldi	r24, 0x18	; 24
     166:	0f b6       	in	r0, 0x3f	; 63
     168:	f8 94       	cli
     16a:	80 93 60 00 	sts	0x0060, r24
     16e:	10 92 60 00 	sts	0x0060, r1
     172:	0f be       	out	0x3f, r0	; 63

00000174 <__do_copy_data>:
     174:	12 e0       	ldi	r17, 0x02	; 2
     176:	a0 e0       	ldi	r26, 0x00	; 0
     178:	b2 e0       	ldi	r27, 0x02	; 2
     17a:	e0 eb       	ldi	r30, 0xB0	; 176
     17c:	fd e2       	ldi	r31, 0x2D	; 45
     17e:	00 e0       	ldi	r16, 0x00	; 0
     180:	0b bf       	out	0x3b, r16	; 59
     182:	02 c0       	rjmp	.+4      	; 0x188 <__do_copy_data+0x14>
     184:	07 90       	elpm	r0, Z+
     186:	0d 92       	st	X+, r0
     188:	aa 37       	cpi	r26, 0x7A	; 122
     18a:	b1 07       	cpc	r27, r17
     18c:	d9 f7       	brne	.-10     	; 0x184 <__do_copy_data+0x10>
     18e:	1b be       	out	0x3b, r1	; 59

00000190 <__do_clear_bss>:
     190:	15 e0       	ldi	r17, 0x05	; 5
     192:	aa e7       	ldi	r26, 0x7A	; 122
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a1 35       	cpi	r26, 0x51	; 81
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <main>
     1a4:	0c 94 d6 16 	jmp	0x2dac	; 0x2dac <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <strncmp>:
     1ac:	fb 01       	movw	r30, r22
     1ae:	dc 01       	movw	r26, r24
     1b0:	41 50       	subi	r20, 0x01	; 1
     1b2:	50 40       	sbci	r21, 0x00	; 0
     1b4:	30 f0       	brcs	.+12     	; 0x1c2 <strncmp+0x16>
     1b6:	8d 91       	ld	r24, X+
     1b8:	01 90       	ld	r0, Z+
     1ba:	80 19       	sub	r24, r0
     1bc:	19 f4       	brne	.+6      	; 0x1c4 <strncmp+0x18>
     1be:	00 20       	and	r0, r0
     1c0:	b9 f7       	brne	.-18     	; 0x1b0 <strncmp+0x4>
     1c2:	88 1b       	sub	r24, r24
     1c4:	99 0b       	sbc	r25, r25
     1c6:	08 95       	ret

000001c8 <buildModeMapping>:
byte modeState[2] = {((LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0)), (( LOW << MODE2) | ( LOW << MODE1) | (LOW << MODE0))}; //Default to 1/8th stepping as that is the same for all

void buildModeMapping(byte microsteps, byte driverVersion){
    //For microstep modes less than 8, we cannot jump to high speed, so we use the SPEEDFAST mode maps. Given that the SPEEDFAST maps are generated for the microstepping modes >=8
    //anyway, we can simply multiply the number of microsteps by 8 if it is less than 8 and thus reduce the number of cases in the mode generation switch statement below 
    if (microsteps < 8){
     1c8:	88 30       	cpi	r24, 0x08	; 8
     1ca:	18 f4       	brcc	.+6      	; 0x1d2 <buildModeMapping+0xa>
        microsteps *= 8;
     1cc:	88 0f       	add	r24, r24
     1ce:	88 0f       	add	r24, r24
     1d0:	88 0f       	add	r24, r24
    }
    //Generate the mode mapping for the current driver version and microstepping modes.
    switch (microsteps) {
     1d2:	88 30       	cpi	r24, 0x08	; 8
     1d4:	19 f0       	breq	.+6      	; 0x1dc <buildModeMapping+0x14>
     1d6:	80 32       	cpi	r24, 0x20	; 32
     1d8:	a1 f4       	brne	.+40     	; 0x202 <buildModeMapping+0x3a>
     1da:	06 c0       	rjmp	.+12     	; 0x1e8 <buildModeMapping+0x20>
        case 8:
            // 1/8
            modeState[SPEEDNORM] =                                                                                       (( LOW << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     1dc:	83 e0       	ldi	r24, 0x03	; 3
     1de:	80 93 09 02 	sts	0x0209, r24
            // 1/1
            modeState[SPEEDFAST] =                                                                                       (( LOW << MODE2) | ( LOW << MODE1) | ( LOW << MODE0));
     1e2:	10 92 0a 02 	sts	0x020A, r1
     1e6:	08 95       	ret
            break;
        case 32:
            // 1/32
            modeState[SPEEDNORM] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | (HIGH << MODE1) | ( LOW << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     1e8:	62 30       	cpi	r22, 0x02	; 2
     1ea:	11 f0       	breq	.+4      	; 0x1f0 <buildModeMapping+0x28>
     1ec:	87 e0       	ldi	r24, 0x07	; 7
     1ee:	01 c0       	rjmp	.+2      	; 0x1f2 <buildModeMapping+0x2a>
     1f0:	82 e2       	ldi	r24, 0x22	; 34
     1f2:	80 93 09 02 	sts	0x0209, r24
            // 1/4
            modeState[SPEEDFAST] = (driverVersion == DRV8834) ? ((FLOAT << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | (HIGH << MODE1) | ( LOW << MODE0));
     1f6:	62 30       	cpi	r22, 0x02	; 2
     1f8:	11 f0       	breq	.+4      	; 0x1fe <buildModeMapping+0x36>
     1fa:	82 e0       	ldi	r24, 0x02	; 2
     1fc:	0e c0       	rjmp	.+28     	; 0x21a <buildModeMapping+0x52>
     1fe:	80 e2       	ldi	r24, 0x20	; 32
     200:	0c c0       	rjmp	.+24     	; 0x21a <buildModeMapping+0x52>
            break;
        case 16:
        default:  //Unknown. Default to half/sixteenth stepping
            // 1/16
            modeState[SPEEDNORM] = (driverVersion == DRV882x) ? ((  LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0)) : ((HIGH << MODE2) | (HIGH << MODE1) | (HIGH << MODE0));
     202:	61 30       	cpi	r22, 0x01	; 1
     204:	11 f0       	breq	.+4      	; 0x20a <buildModeMapping+0x42>
     206:	87 e0       	ldi	r24, 0x07	; 7
     208:	01 c0       	rjmp	.+2      	; 0x20c <buildModeMapping+0x44>
     20a:	81 e0       	ldi	r24, 0x01	; 1
     20c:	80 93 09 02 	sts	0x0209, r24
            // 1/2
            modeState[SPEEDFAST] = (driverVersion == DRV882x) ? (( HIGH << MODE2) | ( LOW << MODE1) | ( LOW << MODE0)) : (( LOW << MODE2) | ( LOW << MODE1) | (HIGH << MODE0));
     210:	61 30       	cpi	r22, 0x01	; 1
     212:	11 f0       	breq	.+4      	; 0x218 <buildModeMapping+0x50>
     214:	81 e0       	ldi	r24, 0x01	; 1
     216:	01 c0       	rjmp	.+2      	; 0x21a <buildModeMapping+0x52>
     218:	84 e0       	ldi	r24, 0x04	; 4
     21a:	80 93 0a 02 	sts	0x020A, r24
     21e:	08 95       	ret

00000220 <standaloneModeTest>:
    //If we pull down and the pin stays high, then pin must be driven high (DRIVE HIGH)
    //If we pull up and the pin stays low, then pin must be driven low (DRIVE LOW)
    //Otherwise if pin follows us then it must be floating.

    //To start we check for an advanced controller
    setPinValue(standalonePin[STANDALONE_PULL],LOW); //Pull low
     220:	11 98       	cbi	0x02, 1	; 2
	...
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(allowAdvancedHCDetection && getPinValue(standalonePin[STANDALONE_IRQ])) {
     22a:	80 91 0d 03 	lds	r24, 0x030D
     22e:	88 23       	and	r24, r24
     230:	21 f0       	breq	.+8      	; 0x23a <standaloneModeTest+0x1a>
     232:	48 9b       	sbis	0x09, 0	; 9
     234:	02 c0       	rjmp	.+4      	; 0x23a <standaloneModeTest+0x1a>
     236:	82 e0       	ldi	r24, 0x02	; 2
     238:	08 95       	ret
        //Note: Must be an advanced controller as pin stayed high and we are allowing HC detection. (If HC detection is disallowed its because we have no external pull down available)
        return ADVANCED_HC_MODE;
    }
    //Otherwise we check for a basic controller
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Convert to external pull-up of IRQ
     23a:	11 9a       	sbi	0x02, 1	; 2
	...
    nop(); // Input synchroniser takes a couple of cycles
    nop();
    nop();
    nop();
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     244:	89 b1       	in	r24, 0x09	; 9
     246:	80 95       	com	r24
     248:	81 70       	andi	r24, 0x01	; 1
    }


    //If we get this far then it is floating, so we assume EQMOD mode
    return EQMOD_MODE;
}
     24a:	08 95       	ret

0000024c <_Z17checkBasicHCSpeedv>:
    // +-----------+-----+-----+
    //
    //Note: if we don't have an external pull-up resistor, this function will return either ST-4 Rate (0,0) or GoTo Rate (1,1)
    //
    byte speed;
    if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     24c:	48 99       	sbic	0x09, 0	; 9
     24e:	02 c0       	rjmp	.+4      	; 0x254 <_Z17checkBasicHCSpeedv+0x8>
     250:	80 e0       	ldi	r24, 0x00	; 0
     252:	0b c0       	rjmp	.+22     	; 0x26a <_Z17checkBasicHCSpeedv+0x1e>
        //Must be a ST-4 rate as IRQ pin is low when external pull-up enabled
        speed = CMD_ST4_DEFAULT;
    } else {
        //Otherwise check which high-speed mode it is
        setPinDir  (standalonePin[STANDALONE_PULL],INPUT); //Disable external resistor by switching to input
     254:	09 98       	cbi	0x01, 1	; 1
        setPinValue(standalonePin[STANDALONE_PULL],LOW);   //with no internal pull-up (we are using the IRQ pin internal pull-up)
     256:	11 98       	cbi	0x02, 1	; 2
	...
        nop(); // Input synchroniser takes a couple of cycles
        nop();
        nop();
        nop();
        
        if(!getPinValue(standalonePin[STANDALONE_IRQ])) {
     260:	48 9b       	sbis	0x09, 0	; 9
     262:	02 c0       	rjmp	.+4      	; 0x268 <_Z17checkBasicHCSpeedv+0x1c>
     264:	82 e0       	ldi	r24, 0x02	; 2
     266:	01 c0       	rjmp	.+2      	; 0x26a <_Z17checkBasicHCSpeedv+0x1e>
     268:	81 e0       	ldi	r24, 0x01	; 1
            speed = CMD_ST4_STANDALONE;
        } else {
            speed = CMD_ST4_HIGHSPEED;
        }
    }
    setPinDir  (standalonePin[STANDALONE_PULL],OUTPUT); //Ensure we leave an external pull-up of IRQ.
     26a:	09 9a       	sbi	0x01, 1	; 1
    setPinValue(standalonePin[STANDALONE_PULL],HIGH);
     26c:	11 9a       	sbi	0x02, 1	; 2
    //And return the new speed
    return speed;
}
     26e:	08 95       	ret

00000270 <motorEnable>:




void motorEnable(byte axis){
    if (axis == RA){
     270:	88 23       	and	r24, r24
     272:	29 f4       	brne	.+10     	; 0x27e <motorEnable+0xe>
        setPinValue(enablePin[RA],LOW); //IC enabled
     274:	a5 98       	cbi	0x14, 5	; 20
inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
}

inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
     276:	81 e0       	ldi	r24, 0x01	; 1
     278:	80 93 34 03 	sts	0x0334, r24
     27c:	08 c0       	rjmp	.+16     	; 0x28e <motorEnable+0x1e>
        cmd_setFVal(RA,CMD_ENABLED);
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
     27e:	80 91 02 01 	lds	r24, 0x0102
     282:	8f 7d       	andi	r24, 0xDF	; 223
     284:	80 93 02 01 	sts	0x0102, r24
     288:	81 e0       	ldi	r24, 0x01	; 1
     28a:	80 93 35 03 	sts	0x0335, r24
    }
}

//Timer Interrupt-----------------------------------------------------------------------------
void configureTimer(){
    interruptControlRegister(DC) = 0; //disable all timer interrupts.
     28e:	10 92 71 00 	sts	0x0071, r1
#if defined(__AVR_ATmega162__)
    interruptControlRegister(RA) &= 0b00000011; //for 162, the lower 2 bits of the declination register control another timer, so leave them alone.
#else
    interruptControlRegister(RA) = 0;
     292:	10 92 6f 00 	sts	0x006F, r1
#endif
    //set to ctc mode (0100)
    TCCR1A = 0;//~((1<<WGM11) | (1<<WGM10));
     296:	10 92 80 00 	sts	0x0080, r1
    TCCR1B = ((1<<WGM12) | (1<<WGM13));
     29a:	88 e1       	ldi	r24, 0x18	; 24
     29c:	80 93 81 00 	sts	0x0081, r24
    TCCR3A = 0;//~((1<<WGM31) | (1<<WGM30));
     2a0:	10 92 90 00 	sts	0x0090, r1
    TCCR3B = ((1<<WGM32) | (1<<WGM33));
     2a4:	80 93 91 00 	sts	0x0091, r24
    } else {
        setPinValue(enablePin[DC],LOW); //IC enabled
        cmd_setFVal(DC,CMD_ENABLED);
    }
    configureTimer(); //setup the motor pulse timers.
}
     2a8:	08 95       	ret

000002aa <motorDisable>:

void motorDisable(byte axis){
    if (axis == RA){
     2aa:	88 23       	and	r24, r24
     2ac:	21 f4       	brne	.+8      	; 0x2b6 <motorDisable+0xc>
        setPinValue(enablePin[RA],HIGH); //IC enabled
     2ae:	a5 9a       	sbi	0x14, 5	; 20
     2b0:	10 92 34 03 	sts	0x0334, r1
     2b4:	08 95       	ret
        cmd_setFVal(RA,CMD_DISABLED);
    } else {
        setPinValue(enablePin[DC],HIGH); //IC enabled
     2b6:	80 91 02 01 	lds	r24, 0x0102
     2ba:	80 62       	ori	r24, 0x20	; 32
     2bc:	80 93 02 01 	sts	0x0102, r24
     2c0:	10 92 35 03 	sts	0x0335, r1
     2c4:	08 95       	ret

000002c6 <motorStartRA>:
        motorStartDC();
    }
}

void motorStartRA(){
    unsigned int IVal = cmd.IVal[RA];
     2c6:	40 91 1e 03 	lds	r20, 0x031E
     2ca:	50 91 1f 03 	lds	r21, 0x031F
    unsigned int currentIVal;
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
     2ce:	80 91 6f 00 	lds	r24, 0x006F
     2d2:	8f 7d       	andi	r24, 0xDF	; 223
     2d4:	80 93 6f 00 	sts	0x006F, r24
    currentIVal = currentMotorSpeed(RA);
     2d8:	e0 91 9a 00 	lds	r30, 0x009A
     2dc:	f0 91 9b 00 	lds	r31, 0x009B
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
     2e0:	80 91 6f 00 	lds	r24, 0x006F
     2e4:	80 62       	ori	r24, 0x20	; 32
     2e6:	80 93 6f 00 	sts	0x006F, r24
    
    if (IVal > cmd.minSpeed[RA]){
     2ea:	20 91 71 03 	lds	r18, 0x0371
     2ee:	30 91 72 03 	lds	r19, 0x0372
     2f2:	c9 01       	movw	r24, r18
     2f4:	72 2f       	mov	r23, r18
     2f6:	69 2f       	mov	r22, r25
     2f8:	24 17       	cp	r18, r20
     2fa:	35 07       	cpc	r19, r21
     2fc:	18 f4       	brcc	.+6      	; 0x304 <motorStartRA+0x3e>
     2fe:	ca 01       	movw	r24, r20
     300:	74 2f       	mov	r23, r20
     302:	69 2f       	mov	r22, r25
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[RA];
    }
    if(cmd.stopped[RA]) {
     304:	a0 91 38 03 	lds	r26, 0x0338
     308:	aa 23       	and	r26, r26
     30a:	29 f4       	brne	.+10     	; 0x316 <motorStartRA+0x50>
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[RA]) {
     30c:	e2 17       	cp	r30, r18
     30e:	f3 07       	cpc	r31, r19
     310:	10 f4       	brcc	.+4      	; 0x316 <motorStartRA+0x50>
     312:	9f 01       	movw	r18, r30
     314:	03 c0       	rjmp	.+6      	; 0x31c <motorStartRA+0x56>
     316:	87 2f       	mov	r24, r23
     318:	96 2f       	mov	r25, r22
     31a:	9c 01       	movw	r18, r24
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
     31c:	80 91 6f 00 	lds	r24, 0x006F
     320:	8f 7d       	andi	r24, 0xDF	; 223
     322:	80 93 6f 00 	sts	0x006F, r24
    cmd.currentIVal[RA] = cmd.IVal[RA];
     326:	50 93 6e 03 	sts	0x036E, r21
     32a:	40 93 6d 03 	sts	0x036D, r20
    currentMotorSpeed(RA) = startSpeed;
     32e:	30 93 9b 00 	sts	0x009B, r19
     332:	20 93 9a 00 	sts	0x009A, r18
    cmd.stopSpeed[RA] = stoppingSpeed;
     336:	70 93 79 03 	sts	0x0379, r23
     33a:	60 93 7a 03 	sts	0x037A, r22
    setPinValue(dirPin[RA],(encodeDirection[RA] != cmd.dir[RA]));
     33e:	90 91 84 02 	lds	r25, 0x0284
     342:	80 91 32 03 	lds	r24, 0x0332
     346:	98 17       	cp	r25, r24
     348:	11 f0       	breq	.+4      	; 0x34e <motorStartRA+0x88>
     34a:	75 9a       	sbi	0x0e, 5	; 14
     34c:	01 c0       	rjmp	.+2      	; 0x350 <motorStartRA+0x8a>
     34e:	75 98       	cbi	0x0e, 5	; 14
    
    if(cmd.stopped[RA]) { //if stopped, configure timers
     350:	aa 23       	and	r26, r26
     352:	29 f1       	breq	.+74     	; 0x39e <motorStartRA+0xd8>
        irqToNextStep(RA) = 1;
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	90 93 8b 00 	sts	0x008B, r25
     35c:	80 93 8a 00 	sts	0x008A, r24
        accelTableRepeatsLeft[RA] = cmd.accelTable[RA][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
     360:	80 91 7f 03 	lds	r24, 0x037F
     364:	80 93 12 03 	sts	0x0312, r24
        accelTableIndex[RA] = 0;
     368:	10 92 14 03 	sts	0x0314, r1
        distributionSegment(RA) = 0;
     36c:	1b bc       	out	0x2b, r1	; 43
        timerCountRegister(RA) = 0;
     36e:	10 92 85 00 	sts	0x0085, r1
     372:	10 92 84 00 	sts	0x0084, r1
        interruptOVFCount(RA) = timerOVF[RA][0];
     376:	80 91 8a 02 	lds	r24, 0x028A
     37a:	90 91 8b 02 	lds	r25, 0x028B
     37e:	90 93 87 00 	sts	0x0087, r25
     382:	80 93 86 00 	sts	0x0086, r24
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
     386:	80 91 81 00 	lds	r24, 0x0081
     38a:	89 7f       	andi	r24, 0xF9	; 249
     38c:	80 93 81 00 	sts	0x0081, r24
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
     390:	80 91 81 00 	lds	r24, 0x0081
     394:	81 60       	ori	r24, 0x01	; 1
     396:	80 93 81 00 	sts	0x0081, r24
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     39a:	10 92 38 03 	sts	0x0338, r1
        timerCountRegister(RA) = 0;
        interruptOVFCount(RA) = timerOVF[RA][0];
        timerEnable(RA);
        cmd_setStopped(RA, CMD_RUNNING);
    }
    interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
     39e:	80 91 6f 00 	lds	r24, 0x006F
     3a2:	80 62       	ori	r24, 0x20	; 32
     3a4:	80 93 6f 00 	sts	0x006F, r24
}
     3a8:	08 95       	ret

000003aa <motorStartDC>:

void motorStartDC(){
    unsigned int IVal = cmd.IVal[DC];
     3aa:	40 91 20 03 	lds	r20, 0x0320
     3ae:	50 91 21 03 	lds	r21, 0x0321
    unsigned int currentIVal;
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
     3b2:	80 91 71 00 	lds	r24, 0x0071
     3b6:	8f 7d       	andi	r24, 0xDF	; 223
     3b8:	80 93 71 00 	sts	0x0071, r24
    currentIVal = currentMotorSpeed(DC);
     3bc:	e0 91 98 00 	lds	r30, 0x0098
     3c0:	f0 91 99 00 	lds	r31, 0x0099
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
     3c4:	80 91 71 00 	lds	r24, 0x0071
     3c8:	80 62       	ori	r24, 0x20	; 32
     3ca:	80 93 71 00 	sts	0x0071, r24
    
    unsigned int startSpeed;
    unsigned int stoppingSpeed;
    if (IVal > cmd.minSpeed[DC]){
     3ce:	20 91 73 03 	lds	r18, 0x0373
     3d2:	30 91 74 03 	lds	r19, 0x0374
     3d6:	c9 01       	movw	r24, r18
     3d8:	72 2f       	mov	r23, r18
     3da:	69 2f       	mov	r22, r25
     3dc:	24 17       	cp	r18, r20
     3de:	35 07       	cpc	r19, r21
     3e0:	18 f4       	brcc	.+6      	; 0x3e8 <motorStartDC+0x3e>
     3e2:	ca 01       	movw	r24, r20
     3e4:	74 2f       	mov	r23, r20
     3e6:	69 2f       	mov	r22, r25
        stoppingSpeed = IVal;
    } else {
        stoppingSpeed = cmd.minSpeed[DC];
    }
    if(cmd.stopped[DC]) {
     3e8:	a0 91 39 03 	lds	r26, 0x0339
     3ec:	aa 23       	and	r26, r26
     3ee:	29 f4       	brne	.+10     	; 0x3fa <motorStartDC+0x50>
        startSpeed = stoppingSpeed;
    } else if (currentIVal < cmd.minSpeed[DC]) {
     3f0:	e2 17       	cp	r30, r18
     3f2:	f3 07       	cpc	r31, r19
     3f4:	10 f4       	brcc	.+4      	; 0x3fa <motorStartDC+0x50>
     3f6:	9f 01       	movw	r18, r30
     3f8:	03 c0       	rjmp	.+6      	; 0x400 <motorStartDC+0x56>
     3fa:	87 2f       	mov	r24, r23
     3fc:	96 2f       	mov	r25, r22
     3fe:	9c 01       	movw	r18, r24
        startSpeed = currentIVal;
    } else {
        startSpeed = stoppingSpeed;
    }
    
    interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
     400:	80 91 71 00 	lds	r24, 0x0071
     404:	8f 7d       	andi	r24, 0xDF	; 223
     406:	80 93 71 00 	sts	0x0071, r24
    cmd.currentIVal[DC] = cmd.IVal[DC];
     40a:	50 93 70 03 	sts	0x0370, r21
     40e:	40 93 6f 03 	sts	0x036F, r20
    currentMotorSpeed(DC) = startSpeed;
     412:	30 93 99 00 	sts	0x0099, r19
     416:	20 93 98 00 	sts	0x0098, r18
    cmd.stopSpeed[DC] = stoppingSpeed;
     41a:	70 93 7b 03 	sts	0x037B, r23
     41e:	60 93 7c 03 	sts	0x037C, r22
    setPinValue(dirPin[DC],(encodeDirection[DC] != cmd.dir[DC]));
     422:	90 91 85 02 	lds	r25, 0x0285
     426:	80 91 33 03 	lds	r24, 0x0333
     42a:	98 17       	cp	r25, r24
     42c:	21 f0       	breq	.+8      	; 0x436 <motorStartDC+0x8c>
     42e:	80 91 02 01 	lds	r24, 0x0102
     432:	80 61       	ori	r24, 0x10	; 16
     434:	03 c0       	rjmp	.+6      	; 0x43c <motorStartDC+0x92>
     436:	80 91 02 01 	lds	r24, 0x0102
     43a:	8f 7e       	andi	r24, 0xEF	; 239
     43c:	80 93 02 01 	sts	0x0102, r24
    
    if(cmd.stopped[DC]) { //if stopped, configure timers
     440:	aa 23       	and	r26, r26
     442:	29 f1       	breq	.+74     	; 0x48e <motorStartDC+0xe4>
        irqToNextStep(DC) = 1;
     444:	81 e0       	ldi	r24, 0x01	; 1
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	90 93 89 00 	sts	0x0089, r25
     44c:	80 93 88 00 	sts	0x0088, r24
        accelTableRepeatsLeft[DC] = cmd.accelTable[DC][0].repeats; //If we are stopped, we must do the required number of repeats for the first entry in the speed table.
     450:	80 91 3f 04 	lds	r24, 0x043F
     454:	80 93 13 03 	sts	0x0313, r24
        accelTableIndex[DC] = 0;
     458:	10 92 15 03 	sts	0x0315, r1
        distributionSegment(DC) = 0;
     45c:	1a bc       	out	0x2a, r1	; 42
        timerCountRegister(DC) = 0;
     45e:	10 92 95 00 	sts	0x0095, r1
     462:	10 92 94 00 	sts	0x0094, r1
        interruptOVFCount(DC) = timerOVF[DC][0];
     466:	80 91 ca 02 	lds	r24, 0x02CA
     46a:	90 91 cb 02 	lds	r25, 0x02CB
     46e:	90 93 97 00 	sts	0x0097, r25
     472:	80 93 96 00 	sts	0x0096, r24
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
}

inline void timerEnable(byte motor) {
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
     476:	80 91 91 00 	lds	r24, 0x0091
     47a:	89 7f       	andi	r24, 0xF9	; 249
     47c:	80 93 91 00 	sts	0x0091, r24
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
     480:	80 91 91 00 	lds	r24, 0x0091
     484:	81 60       	ori	r24, 0x01	; 1
     486:	80 93 91 00 	sts	0x0091, r24
     48a:	10 92 39 03 	sts	0x0339, r1
        timerCountRegister(DC) = 0;
        interruptOVFCount(DC) = timerOVF[DC][0];
        timerEnable(DC);
        cmd_setStopped(DC, CMD_RUNNING);
    }
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
     48e:	80 91 71 00 	lds	r24, 0x0071
     492:	80 62       	ori	r24, 0x20	; 32
     494:	80 93 71 00 	sts	0x0071, r24
}
     498:	08 95       	ret

0000049a <motorStart>:
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStart functions (one for RA and one for DEC)
void motorStart(byte motor){
    if (motor == RA) {
     49a:	88 23       	and	r24, r24
     49c:	19 f4       	brne	.+6      	; 0x4a4 <motorStart+0xa>
        motorStartRA();
     49e:	0e 94 63 01 	call	0x2c6	; 0x2c6 <motorStartRA>
     4a2:	08 95       	ret
    } else {
        motorStartDC();
     4a4:	0e 94 d5 01 	call	0x3aa	; 0x3aa <motorStartDC>
     4a8:	08 95       	ret

000004aa <gotoMode>:

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
}

void gotoMode(byte axis){
     4aa:	9f 92       	push	r9
     4ac:	af 92       	push	r10
     4ae:	bf 92       	push	r11
     4b0:	cf 92       	push	r12
     4b2:	df 92       	push	r13
     4b4:	ef 92       	push	r14
     4b6:	ff 92       	push	r15
     4b8:	0f 93       	push	r16
     4ba:	1f 93       	push	r17
     4bc:	cf 93       	push	r28
     4be:	df 93       	push	r29
     4c0:	c8 2e       	mov	r12, r24
    unsigned int decelerationLength = gotoDecelerationLength[axis];
     4c2:	c8 2f       	mov	r28, r24
     4c4:	d0 e0       	ldi	r29, 0x00	; 0
     4c6:	fe 01       	movw	r30, r28
     4c8:	ee 0f       	add	r30, r30
     4ca:	ff 1f       	adc	r31, r31
     4cc:	e2 5f       	subi	r30, 0xF2	; 242
     4ce:	fc 4f       	sbci	r31, 0xFC	; 252
     4d0:	00 81       	ld	r16, Z
     4d2:	11 81       	ldd	r17, Z+1	; 0x01
    
    if (cmd.highSpeedMode[axis]) {
     4d4:	fe 01       	movw	r30, r28
     4d6:	ea 5e       	subi	r30, 0xEA	; 234
     4d8:	fc 4f       	sbci	r31, 0xFC	; 252
     4da:	84 a1       	ldd	r24, Z+36	; 0x24
     4dc:	88 23       	and	r24, r24
     4de:	29 f0       	breq	.+10     	; 0x4ea <gotoMode+0x40>
        //Additionally in order to maintain the same speed profile in high-speed mode, we actually increase the profile repeats by a factor of sqrt(8)
        //compared with running in normal-speed mode. See Atmel AVR466 app note for calculation.
        decelerationLength = decelerationLength * 3; //multiply by 3 as it is approx sqrt(8)
     4e0:	c8 01       	movw	r24, r16
     4e2:	88 0f       	add	r24, r24
     4e4:	99 1f       	adc	r25, r25
     4e6:	08 0f       	add	r16, r24
     4e8:	19 1f       	adc	r17, r25
    }
    
    byte dirMagnitude = abs(cmd.stepDir[axis]);
     4ea:	fe 01       	movw	r30, r28
     4ec:	ea 5e       	subi	r30, 0xEA	; 234
     4ee:	fc 4f       	sbci	r31, 0xFC	; 252
     4f0:	82 8d       	ldd	r24, Z+26	; 0x1a
     4f2:	18 16       	cp	r1, r24
     4f4:	14 f4       	brge	.+4      	; 0x4fa <gotoMode+0x50>
     4f6:	d2 8c       	ldd	r13, Z+26	; 0x1a
     4f8:	02 c0       	rjmp	.+4      	; 0x4fe <gotoMode+0x54>
     4fa:	d2 8c       	ldd	r13, Z+26	; 0x1a
     4fc:	d1 94       	neg	r13
    byte dir = cmd.dir[axis];
     4fe:	fe 01       	movw	r30, r28
     500:	ea 5e       	subi	r30, 0xEA	; 234
     502:	fc 4f       	sbci	r31, 0xFC	; 252
     504:	94 8c       	ldd	r9, Z+28	; 0x1c

    if (cmd.HVal[axis] < 2*dirMagnitude){
     506:	8d 2d       	mov	r24, r13
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	88 0f       	add	r24, r24
     50c:	99 1f       	adc	r25, r25
     50e:	9c 01       	movw	r18, r24
     510:	44 27       	eor	r20, r20
     512:	37 fd       	sbrc	r19, 7
     514:	40 95       	com	r20
     516:	54 2f       	mov	r21, r20
     518:	fe 01       	movw	r30, r28
     51a:	ee 0f       	add	r30, r30
     51c:	ff 1f       	adc	r31, r31
     51e:	ee 0f       	add	r30, r30
     520:	ff 1f       	adc	r31, r31
     522:	ea 5e       	subi	r30, 0xEA	; 234
     524:	fc 4f       	sbci	r31, 0xFC	; 252
     526:	82 89       	ldd	r24, Z+18	; 0x12
     528:	93 89       	ldd	r25, Z+19	; 0x13
     52a:	a4 89       	ldd	r26, Z+20	; 0x14
     52c:	b5 89       	ldd	r27, Z+21	; 0x15
     52e:	82 17       	cp	r24, r18
     530:	93 07       	cpc	r25, r19
     532:	a4 07       	cpc	r26, r20
     534:	b5 07       	cpc	r27, r21
     536:	20 f4       	brcc	.+8      	; 0x540 <gotoMode+0x96>
inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
     538:	22 8b       	std	Z+18, r18	; 0x12
     53a:	33 8b       	std	Z+19, r19	; 0x13
     53c:	44 8b       	std	Z+20, r20	; 0x14
     53e:	55 8b       	std	Z+21, r21	; 0x15
        cmd_setHVal(axis,2*dirMagnitude);
    }

    decelerationLength = decelerationLength * dirMagnitude;
     540:	8d 2d       	mov	r24, r13
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	80 9f       	mul	r24, r16
     546:	b0 01       	movw	r22, r0
     548:	81 9f       	mul	r24, r17
     54a:	70 0d       	add	r23, r0
     54c:	90 9f       	mul	r25, r16
     54e:	70 0d       	add	r23, r0
     550:	11 24       	eor	r1, r1
    //decelleration length is here a multiple of stepDir.
    unsigned long HVal = cmd.HVal[axis];
     552:	fe 01       	movw	r30, r28
     554:	ee 0f       	add	r30, r30
     556:	ff 1f       	adc	r31, r31
     558:	ee 0f       	add	r30, r30
     55a:	ff 1f       	adc	r31, r31
     55c:	ea 5e       	subi	r30, 0xEA	; 234
     55e:	fc 4f       	sbci	r31, 0xFC	; 252
     560:	e2 88       	ldd	r14, Z+18	; 0x12
     562:	f3 88       	ldd	r15, Z+19	; 0x13
     564:	04 89       	ldd	r16, Z+20	; 0x14
     566:	15 89       	ldd	r17, Z+21	; 0x15
    unsigned long halfHVal = (HVal >> 1);
     568:	a8 01       	movw	r20, r16
     56a:	97 01       	movw	r18, r14
     56c:	56 95       	lsr	r21
     56e:	47 95       	ror	r20
     570:	37 95       	ror	r19
     572:	27 95       	ror	r18
    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
     574:	fe 01       	movw	r30, r28
     576:	ee 0f       	add	r30, r30
     578:	ff 1f       	adc	r31, r31
     57a:	eb 58       	subi	r30, 0x8B	; 139
     57c:	fc 4f       	sbci	r31, 0xFC	; 252
     57e:	a0 80       	ld	r10, Z
     580:	b1 80       	ldd	r11, Z+1	; 0x01
    if(dirMagnitude == 8){
     582:	88 e0       	ldi	r24, 0x08	; 8
     584:	d8 16       	cp	r13, r24
     586:	49 f4       	brne	.+18     	; 0x59a <gotoMode+0xf0>
        HVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
     588:	88 ef       	ldi	r24, 0xF8	; 248
     58a:	9f ef       	ldi	r25, 0xFF	; 255
     58c:	af ef       	ldi	r26, 0xFF	; 255
     58e:	bf ef       	ldi	r27, 0xFF	; 255
     590:	e8 22       	and	r14, r24
     592:	f9 22       	and	r15, r25
     594:	0a 23       	and	r16, r26
     596:	1b 23       	and	r17, r27
    }
    if(dirMagnitude == 8){
        halfHVal &= 0xFFFFFFF8; //clear the lower bits to avoid overshoot.
     598:	28 7f       	andi	r18, 0xF8	; 248
    }
    //HVal and halfHVal are here a multiple of stepDir
    if (halfHVal < decelerationLength) {
     59a:	cb 01       	movw	r24, r22
     59c:	a0 e0       	ldi	r26, 0x00	; 0
     59e:	b0 e0       	ldi	r27, 0x00	; 0
     5a0:	28 17       	cp	r18, r24
     5a2:	39 07       	cpc	r19, r25
     5a4:	4a 07       	cpc	r20, r26
     5a6:	5b 07       	cpc	r21, r27
     5a8:	08 f4       	brcc	.+2      	; 0x5ac <gotoMode+0x102>
        decelerationLength = halfHVal;
     5aa:	b9 01       	movw	r22, r18
    }
    HVal -= decelerationLength;
     5ac:	cb 01       	movw	r24, r22
     5ae:	a0 e0       	ldi	r26, 0x00	; 0
     5b0:	b0 e0       	ldi	r27, 0x00	; 0
     5b2:	a8 01       	movw	r20, r16
     5b4:	97 01       	movw	r18, r14
     5b6:	28 1b       	sub	r18, r24
     5b8:	39 0b       	sbc	r19, r25
     5ba:	4a 0b       	sbc	r20, r26
     5bc:	5b 0b       	sbc	r21, r27
     5be:	da 01       	movw	r26, r20
     5c0:	c9 01       	movw	r24, r18
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
     5c2:	fe 01       	movw	r30, r28
     5c4:	ee 0f       	add	r30, r30
     5c6:	ff 1f       	adc	r31, r31
     5c8:	ee 0f       	add	r30, r30
     5ca:	ff 1f       	adc	r31, r31
     5cc:	ea 5e       	subi	r30, 0xEA	; 234
     5ce:	fc 4f       	sbci	r31, 0xFC	; 252
     5d0:	20 81       	ld	r18, Z
     5d2:	31 81       	ldd	r19, Z+1	; 0x01
     5d4:	42 81       	ldd	r20, Z+2	; 0x02
     5d6:	53 81       	ldd	r21, Z+3	; 0x03
     5d8:	99 20       	and	r9, r9
     5da:	39 f0       	breq	.+14     	; 0x5ea <gotoMode+0x140>
     5dc:	b0 95       	com	r27
     5de:	a0 95       	com	r26
     5e0:	90 95       	com	r25
     5e2:	81 95       	neg	r24
     5e4:	9f 4f       	sbci	r25, 0xFF	; 255
     5e6:	af 4f       	sbci	r26, 0xFF	; 255
     5e8:	bf 4f       	sbci	r27, 0xFF	; 255
     5ea:	fe 01       	movw	r30, r28
     5ec:	ee 0f       	add	r30, r30
     5ee:	ff 1f       	adc	r31, r31
     5f0:	ee 0f       	add	r30, r30
     5f2:	ff 1f       	adc	r31, r31
     5f4:	e4 58       	subi	r30, 0x84	; 132
     5f6:	fd 4f       	sbci	r31, 0xFD	; 253
     5f8:	82 0f       	add	r24, r18
     5fa:	93 1f       	adc	r25, r19
     5fc:	a4 1f       	adc	r26, r20
     5fe:	b5 1f       	adc	r27, r21
     600:	80 83       	st	Z, r24
     602:	91 83       	std	Z+1, r25	; 0x01
     604:	a2 83       	std	Z+2, r26	; 0x02
     606:	b3 83       	std	Z+3, r27	; 0x03
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
     608:	cc 0f       	add	r28, r28
     60a:	dd 1f       	adc	r29, r29
     60c:	c2 5e       	subi	r28, 0xE2	; 226
     60e:	dc 4f       	sbci	r29, 0xFC	; 252
     610:	b9 82       	std	Y+1, r11	; 0x01
     612:	a8 82       	st	Y, r10
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
}
inline void clearGotoDecelerating(const byte axis) {
    gotoControlRegister &= ~gotoDeceleratingBitMask(axis);
     614:	9e b3       	in	r25, 0x1e	; 30
     616:	cc 20       	and	r12, r12
     618:	11 f4       	brne	.+4      	; 0x61e <gotoMode+0x174>
     61a:	8b ef       	ldi	r24, 0xFB	; 251
     61c:	01 c0       	rjmp	.+2      	; 0x620 <gotoMode+0x176>
     61e:	87 ef       	ldi	r24, 0xF7	; 247
     620:	89 23       	and	r24, r25
     622:	8e bb       	out	0x1e, r24	; 30
}
inline bool gotoDecelerating(const byte axis) {
    return (gotoControlRegister & gotoDeceleratingBitMask(axis));
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
     624:	9e b3       	in	r25, 0x1e	; 30
     626:	cc 20       	and	r12, r12
     628:	11 f4       	brne	.+4      	; 0x62e <gotoMode+0x184>
     62a:	81 e0       	ldi	r24, 0x01	; 1
     62c:	01 c0       	rjmp	.+2      	; 0x630 <gotoMode+0x186>
     62e:	82 e0       	ldi	r24, 0x02	; 2
     630:	89 2b       	or	r24, r25
     632:	8e bb       	out	0x1e, r24	; 30
    gotoPosn[axis] = cmd.jVal[axis] + ((dir == CMD_REVERSE) ? -HVal : HVal); //current position + relative change - decelleration region
    
    cmd_setIVal(axis, gotoSpeed);
    clearGotoDecelerating(axis);
    setGotoRunning(axis); //start the goto.
    motorStart(axis); //Begin PWM
     634:	8c 2d       	mov	r24, r12
     636:	0e 94 4d 02 	call	0x49a	; 0x49a <motorStart>
}
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	1f 91       	pop	r17
     640:	0f 91       	pop	r16
     642:	ff 90       	pop	r15
     644:	ef 90       	pop	r14
     646:	df 90       	pop	r13
     648:	cf 90       	pop	r12
     64a:	bf 90       	pop	r11
     64c:	af 90       	pop	r10
     64e:	9f 90       	pop	r9
     650:	08 95       	ret

00000652 <motorStopRA>:
        motorStopDC(emergency);
    }
}

void motorStopRA(bool emergency){
    if (emergency) {
     652:	88 23       	and	r24, r24
     654:	a9 f0       	breq	.+42     	; 0x680 <motorStopRA+0x2e>
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     656:	80 91 6f 00 	lds	r24, 0x006F
     65a:	8f 7d       	andi	r24, 0xDF	; 223
     65c:	80 93 6f 00 	sts	0x006F, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     660:	80 91 81 00 	lds	r24, 0x0081
     664:	88 7f       	andi	r24, 0xF8	; 248
     666:	80 93 81 00 	sts	0x0081, r24
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     66a:	10 92 36 03 	sts	0x0336, r1
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	80 93 38 03 	sts	0x0338, r24
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     674:	10 92 26 03 	sts	0x0326, r1
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(RA);
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
     678:	10 92 7a 02 	sts	0x027A, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     67c:	f0 98       	cbi	0x1e, 0	; 30
     67e:	08 95       	ret
        cmd_setGotoEn(RA,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(RA,CMD_STOPPED); //mark as stopped
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[RA] = 0;
        clearGotoRunning(RA);
    } else if (!cmd.stopped[RA]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
     680:	80 91 38 03 	lds	r24, 0x0338
     684:	88 23       	and	r24, r24
     686:	39 f5       	brne	.+78     	; 0x6d6 <motorStopRA+0x84>
        //trigger ISR based decelleration
        //readyToGo[RA] = 0;
        byte oldSREG = SREG;
     688:	4f b7       	in	r20, 0x3f	; 63
        cli();
     68a:	f8 94       	cli
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     68c:	10 92 36 03 	sts	0x0336, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     690:	f0 98       	cbi	0x1e, 0	; 30
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     692:	10 92 26 03 	sts	0x0326, r1
        cli();
        cmd_setGotoEn(RA,CMD_DISABLED); //No longer in goto mode.
        clearGotoRunning(RA);
        cmd_setGVal(RA, 0); //Switch back to slew mode (in case we just finished a GoTo)
        //interruptControlRegister(RA) &= ~interruptControlBitMask(RA); //Disable timer interrupt
        if(cmd.currentIVal[RA] < cmd.minSpeed[RA]){
     696:	20 91 71 03 	lds	r18, 0x0371
     69a:	30 91 72 03 	lds	r19, 0x0372
     69e:	80 91 6d 03 	lds	r24, 0x036D
     6a2:	90 91 6e 03 	lds	r25, 0x036E
     6a6:	82 17       	cp	r24, r18
     6a8:	93 07       	cpc	r25, r19
     6aa:	58 f4       	brcc	.+22     	; 0x6c2 <motorStopRA+0x70>
            if(cmd.stopSpeed[RA] > cmd.minSpeed[RA]){
     6ac:	80 91 79 03 	lds	r24, 0x0379
     6b0:	90 91 7a 03 	lds	r25, 0x037A
     6b4:	28 17       	cp	r18, r24
     6b6:	39 07       	cpc	r19, r25
     6b8:	20 f4       	brcc	.+8      	; 0x6c2 <motorStopRA+0x70>
                cmd.stopSpeed[RA] = cmd.minSpeed[RA];
     6ba:	30 93 7a 03 	sts	0x037A, r19
     6be:	20 93 79 03 	sts	0x0379, r18
            }
        }/* else {
            stopSpeed[RA] = cmd.currentIVal[RA];
        }*/
        cmd.currentIVal[RA] = cmd.stopSpeed[RA] + 1;//cmd.stepIncrement[motor];
     6c2:	80 91 79 03 	lds	r24, 0x0379
     6c6:	90 91 7a 03 	lds	r25, 0x037A
     6ca:	01 96       	adiw	r24, 0x01	; 1
     6cc:	90 93 6e 03 	sts	0x036E, r25
     6d0:	80 93 6d 03 	sts	0x036D, r24
        SREG = oldSREG;
     6d4:	4f bf       	out	0x3f, r20	; 63
     6d6:	08 95       	ret

000006d8 <motorStopDC>:
        //interruptControlRegister(RA) |= interruptControlBitMask(RA); //enable timer interrupt
    }
}

void motorStopDC(bool emergency){
    if (emergency) {
     6d8:	88 23       	and	r24, r24
     6da:	a9 f0       	breq	.+42     	; 0x706 <motorStopDC+0x2e>
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     6dc:	80 91 71 00 	lds	r24, 0x0071
     6e0:	8f 7d       	andi	r24, 0xDF	; 223
     6e2:	80 93 71 00 	sts	0x0071, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     6e6:	80 91 91 00 	lds	r24, 0x0091
     6ea:	88 7f       	andi	r24, 0xF8	; 248
     6ec:	80 93 91 00 	sts	0x0091, r24
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     6f0:	10 92 37 03 	sts	0x0337, r1
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     6f4:	81 e0       	ldi	r24, 0x01	; 1
     6f6:	80 93 39 03 	sts	0x0339, r24
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     6fa:	10 92 27 03 	sts	0x0327, r1
        //trigger instant shutdown of the motor in an emergency.
        timerDisable(DC);
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
     6fe:	10 92 7b 02 	sts	0x027B, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     702:	f1 98       	cbi	0x1e, 1	; 30
     704:	08 95       	ret
        cmd_setGotoEn(DC,CMD_DISABLED); //Not in goto mode.
        cmd_setStopped(DC,CMD_STOPPED); //mark as stopped
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        readyToGo[DC] = 0;
        clearGotoRunning(DC);
    } else if (!cmd.stopped[DC]){  //Only stop if not already stopped - for some reason EQMOD stops both axis when slewing, even if one isn't currently moving?
     706:	80 91 39 03 	lds	r24, 0x0339
     70a:	88 23       	and	r24, r24
     70c:	39 f5       	brne	.+78     	; 0x75c <motorStopDC+0x84>
        //trigger ISR based decelleration
        //readyToGo[motor] = 0;
        byte oldSREG = SREG;
     70e:	4f b7       	in	r20, 0x3f	; 63
        cli();
     710:	f8 94       	cli
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     712:	10 92 37 03 	sts	0x0337, r1
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     716:	10 92 27 03 	sts	0x0327, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     71a:	f1 98       	cbi	0x1e, 1	; 30
        cli();
        cmd_setGotoEn(DC,CMD_DISABLED); //No longer in goto mode.
        cmd_setGVal(DC, 0); //Switch back to slew mode (in case we just finished a GoTo)
        clearGotoRunning(DC);
        //interruptControlRegister(DC) &= ~interruptControlBitMask(DC); //Disable timer interrupt
        if(cmd.currentIVal[DC] < cmd.minSpeed[DC]){
     71c:	20 91 73 03 	lds	r18, 0x0373
     720:	30 91 74 03 	lds	r19, 0x0374
     724:	80 91 6f 03 	lds	r24, 0x036F
     728:	90 91 70 03 	lds	r25, 0x0370
     72c:	82 17       	cp	r24, r18
     72e:	93 07       	cpc	r25, r19
     730:	58 f4       	brcc	.+22     	; 0x748 <motorStopDC+0x70>
            if(cmd.stopSpeed[DC] > cmd.minSpeed[DC]){
     732:	80 91 7b 03 	lds	r24, 0x037B
     736:	90 91 7c 03 	lds	r25, 0x037C
     73a:	28 17       	cp	r18, r24
     73c:	39 07       	cpc	r19, r25
     73e:	20 f4       	brcc	.+8      	; 0x748 <motorStopDC+0x70>
                cmd.stopSpeed[DC] = cmd.minSpeed[DC];
     740:	30 93 7c 03 	sts	0x037C, r19
     744:	20 93 7b 03 	sts	0x037B, r18
            }
        }/* else {
        stopSpeed[DC] = cmd.currentIVal[DC];
        }*/
        cmd.currentIVal[DC] = cmd.stopSpeed[DC] + 1;//cmd.stepIncrement[motor];
     748:	80 91 7b 03 	lds	r24, 0x037B
     74c:	90 91 7c 03 	lds	r25, 0x037C
     750:	01 96       	adiw	r24, 0x01	; 1
     752:	90 93 70 03 	sts	0x0370, r25
     756:	80 93 6f 03 	sts	0x036F, r24
        SREG = oldSREG;
     75a:	4f bf       	out	0x3f, r20	; 63
     75c:	08 95       	ret

0000075e <motorStop>:
    interruptControlRegister(DC) |= interruptControlBitMask(DC); //enable timer interrupt
}

//As there is plenty of FLASH left, then to improve speed, I have created two motorStop functions (one for RA and one for DEC)
void motorStop(byte motor, byte emergency){
    if (motor == RA) {
     75e:	88 23       	and	r24, r24
     760:	29 f4       	brne	.+10     	; 0x76c <motorStop+0xe>
        motorStopRA(emergency);
     762:	61 11       	cpse	r22, r1
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	0e 94 29 03 	call	0x652	; 0x652 <motorStopRA>
     76a:	08 95       	ret
    } else {
        motorStopDC(emergency);
     76c:	80 e0       	ldi	r24, 0x00	; 0
     76e:	61 11       	cpse	r22, r1
     770:	81 e0       	ldi	r24, 0x01	; 1
     772:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <motorStopDC>
     776:	08 95       	ret

00000778 <__vector_31>:
}



/*Timer Interrupt Vector*/
ISR(TIMER3_CAPT_vect) {
     778:	1f 92       	push	r1
     77a:	0f 92       	push	r0
     77c:	0f b6       	in	r0, 0x3f	; 63
     77e:	0f 92       	push	r0
     780:	0b b6       	in	r0, 0x3b	; 59
     782:	0f 92       	push	r0
     784:	11 24       	eor	r1, r1
     786:	2f 93       	push	r18
     788:	3f 93       	push	r19
     78a:	4f 93       	push	r20
     78c:	5f 93       	push	r21
     78e:	6f 93       	push	r22
     790:	7f 93       	push	r23
     792:	8f 93       	push	r24
     794:	9f 93       	push	r25
     796:	af 93       	push	r26
     798:	bf 93       	push	r27
     79a:	ef 93       	push	r30
     79c:	ff 93       	push	r31
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(DC)-1;
     79e:	80 91 88 00 	lds	r24, 0x0088
     7a2:	90 91 89 00 	lds	r25, 0x0089
     7a6:	01 97       	sbiw	r24, 0x01	; 1
    //Check if we are ready to step
    if (irqToNext == 0) {
     7a8:	09 f0       	breq	.+2      	; 0x7ac <__vector_31+0x34>
     7aa:	c9 c0       	rjmp	.+402    	; 0x93e <__vector_31+0x1c6>
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(DC); //Get the current time segement
     7ac:	8a b5       	in	r24, 0x2a	; 42
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(DC) = timerOVF[DC][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(DC) = *(int*)((byte*)timerOVF[DC] + index); //Update interrupt base rate.
     7ae:	e8 2f       	mov	r30, r24
     7b0:	ee 73       	andi	r30, 0x3E	; 62
     7b2:	f0 e0       	ldi	r31, 0x00	; 0
     7b4:	e6 53       	subi	r30, 0x36	; 54
     7b6:	fd 4f       	sbci	r31, 0xFD	; 253
     7b8:	20 81       	ld	r18, Z
     7ba:	31 81       	ldd	r19, Z+1	; 0x01
     7bc:	30 93 97 00 	sts	0x0097, r19
     7c0:	20 93 96 00 	sts	0x0096, r18
        
        distributionSegment(DC) = timeSegment + 1; //Increment time segement for next time.
     7c4:	8f 5f       	subi	r24, 0xFF	; 255
     7c6:	8a bd       	out	0x2a, r24	; 42

        unsigned int currentSpeed = currentMotorSpeed(DC); //Get the current motor speed
     7c8:	60 91 98 00 	lds	r22, 0x0098
     7cc:	70 91 99 00 	lds	r23, 0x0099
        irqToNextStep(DC) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
     7d0:	70 93 89 00 	sts	0x0089, r23
     7d4:	60 93 88 00 	sts	0x0088, r22
        
        if (getPinValue(stepPin[DC])){
     7d8:	1e 9b       	sbis	0x03, 6	; 3
     7da:	54 c0       	rjmp	.+168    	; 0x884 <__vector_31+0x10c>
            //If the step pin is currently high...
            
            setPinValue(stepPin[DC],LOW); //set step pin low to complete step
     7dc:	2e 98       	cbi	0x05, 6	; 5
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[DC]; 
     7de:	80 91 1a 03 	lds	r24, 0x031A
     7e2:	90 91 1b 03 	lds	r25, 0x031B
     7e6:	a0 91 1c 03 	lds	r26, 0x031C
     7ea:	b0 91 1d 03 	lds	r27, 0x031D
            jVal = jVal + cmd.stepDir[DC];
     7ee:	20 91 31 03 	lds	r18, 0x0331
     7f2:	33 27       	eor	r19, r19
     7f4:	27 fd       	sbrc	r18, 7
     7f6:	30 95       	com	r19
     7f8:	43 2f       	mov	r20, r19
     7fa:	53 2f       	mov	r21, r19
     7fc:	28 0f       	add	r18, r24
     7fe:	39 1f       	adc	r19, r25
     800:	4a 1f       	adc	r20, r26
     802:	5b 1f       	adc	r21, r27
            cmd.jVal[DC] = jVal;
     804:	20 93 1a 03 	sts	0x031A, r18
     808:	30 93 1b 03 	sts	0x031B, r19
     80c:	40 93 1c 03 	sts	0x031C, r20
     810:	50 93 1d 03 	sts	0x031D, r21
            
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
     814:	f1 9b       	sbis	0x1e, 1	; 30
     816:	1b c0       	rjmp	.+54     	; 0x84e <__vector_31+0xd6>
     818:	f3 99       	sbic	0x1e, 3	; 30
     81a:	19 c0       	rjmp	.+50     	; 0x84e <__vector_31+0xd6>
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
     81c:	80 91 80 02 	lds	r24, 0x0280
     820:	90 91 81 02 	lds	r25, 0x0281
     824:	a0 91 82 02 	lds	r26, 0x0282
     828:	b0 91 83 02 	lds	r27, 0x0283
     82c:	82 17       	cp	r24, r18
     82e:	93 07       	cpc	r25, r19
     830:	a4 07       	cpc	r26, r20
     832:	b5 07       	cpc	r27, r21
     834:	61 f4       	brne	.+24     	; 0x84e <__vector_31+0xd6>
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
     836:	f3 9a       	sbi	0x1e, 3	; 30
            if(gotoRunning(DC) && !gotoDecelerating(DC)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[DC] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(DC); //Mark that we have started decelleration.
                    cmd.currentIVal[DC] = cmd.stopSpeed[DC]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
     838:	80 91 7b 03 	lds	r24, 0x037B
     83c:	90 91 7c 03 	lds	r25, 0x037C
     840:	01 96       	adiw	r24, 0x01	; 1
     842:	90 93 70 03 	sts	0x0370, r25
     846:	80 93 6f 03 	sts	0x036F, r24
                    accelTableRepeatsLeft[DC] = 0;
     84a:	10 92 13 03 	sts	0x0313, r1
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[DC]) {
     84e:	80 91 7b 03 	lds	r24, 0x037B
     852:	90 91 7c 03 	lds	r25, 0x037C
     856:	86 17       	cp	r24, r22
     858:	97 07       	cpc	r25, r23
     85a:	08 f0       	brcs	.+2      	; 0x85e <__vector_31+0xe6>
     85c:	74 c0       	rjmp	.+232    	; 0x946 <__vector_31+0x1ce>
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(DC)){ 
     85e:	f1 9b       	sbis	0x1e, 1	; 30
     860:	03 c0       	rjmp	.+6      	; 0x868 <__vector_31+0xf0>
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     862:	10 92 37 03 	sts	0x0337, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     866:	f1 98       	cbi	0x1e, 1	; 30
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     868:	81 e0       	ldi	r24, 0x01	; 1
     86a:	80 93 39 03 	sts	0x0339, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     86e:	80 91 71 00 	lds	r24, 0x0071
     872:	8f 7d       	andi	r24, 0xDF	; 223
     874:	80 93 71 00 	sts	0x0071, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     878:	80 91 91 00 	lds	r24, 0x0091
     87c:	88 7f       	andi	r24, 0xF8	; 248
     87e:	80 93 91 00 	sts	0x0091, r24
     882:	61 c0       	rjmp	.+194    	; 0x946 <__vector_31+0x1ce>
                cmd_setStopped(DC,CMD_STOPPED); //mark as stopped 
                timerDisable(DC);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[DC],HIGH); //Set it high to start next step.
     884:	2e 9a       	sbi	0x05, 6	; 5
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[DC]; //load the number of repeats left for this accel table entry
     886:	80 91 13 03 	lds	r24, 0x0313
            if (repeatsReqd == 0) { 
     88a:	88 23       	and	r24, r24
     88c:	09 f0       	breq	.+2      	; 0x890 <__vector_31+0x118>
     88e:	53 c0       	rjmp	.+166    	; 0x936 <__vector_31+0x1be>
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[DC]; //Get the target speed
     890:	20 91 6f 03 	lds	r18, 0x036F
     894:	30 91 70 03 	lds	r19, 0x0370
                if (currentSpeed > targetSpeed) {
     898:	26 17       	cp	r18, r22
     89a:	37 07       	cpc	r19, r23
     89c:	d0 f4       	brcc	.+52     	; 0x8d2 <__vector_31+0x15a>
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
     89e:	80 91 15 03 	lds	r24, 0x0315
                    if (accelIndex >= AccelTableLength-1) {
     8a2:	8f 33       	cpi	r24, 0x3F	; 63
     8a4:	08 f0       	brcs	.+2      	; 0x8a8 <__vector_31+0x130>
     8a6:	41 c0       	rjmp	.+130    	; 0x92a <__vector_31+0x1b2>
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
     8a8:	8f 5f       	subi	r24, 0xFF	; 255
                        accelTableIndex[DC] = accelIndex; //Save the new index back
     8aa:	80 93 15 03 	sts	0x0315, r24
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	fc 01       	movw	r30, r24
     8b2:	ee 0f       	add	r30, r30
     8b4:	ff 1f       	adc	r31, r31
     8b6:	e8 0f       	add	r30, r24
     8b8:	f9 1f       	adc	r31, r25
     8ba:	ea 5e       	subi	r30, 0xEA	; 234
     8bc:	fc 4f       	sbci	r31, 0xFC	; 252
     8be:	e9 5d       	subi	r30, 0xD9	; 217
     8c0:	fe 4f       	sbci	r31, 0xFE	; 254
     8c2:	60 81       	ld	r22, Z
     8c4:	71 81       	ldd	r23, Z+1	; 0x01
     8c6:	e7 52       	subi	r30, 0x27	; 39
     8c8:	f1 40       	sbci	r31, 0x01	; 1
                        if (currentSpeed <= targetSpeed) {
     8ca:	26 17       	cp	r18, r22
     8cc:	37 07       	cpc	r19, r23
     8ce:	e0 f0       	brcs	.+56     	; 0x908 <__vector_31+0x190>
     8d0:	2c c0       	rjmp	.+88     	; 0x92a <__vector_31+0x1b2>
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
     8d2:	62 17       	cp	r22, r18
     8d4:	73 07       	cpc	r23, r19
     8d6:	50 f5       	brcc	.+84     	; 0x92c <__vector_31+0x1b4>
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[DC]; //Load the acceleration table index
     8d8:	80 91 15 03 	lds	r24, 0x0315
                    if (accelIndex == 0) {
     8dc:	88 23       	and	r24, r24
     8de:	29 f1       	breq	.+74     	; 0x92a <__vector_31+0x1b2>
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
     8e0:	81 50       	subi	r24, 0x01	; 1
                        accelTableIndex[DC] = accelIndex; //Save the new index back
     8e2:	80 93 15 03 	sts	0x0315, r24
                        currentSpeed = cmd.accelTable[DC][accelIndex].speed;  //load the new speed from the table
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	fc 01       	movw	r30, r24
     8ea:	ee 0f       	add	r30, r30
     8ec:	ff 1f       	adc	r31, r31
     8ee:	e8 0f       	add	r30, r24
     8f0:	f9 1f       	adc	r31, r25
     8f2:	ea 5e       	subi	r30, 0xEA	; 234
     8f4:	fc 4f       	sbci	r31, 0xFC	; 252
     8f6:	e9 5d       	subi	r30, 0xD9	; 217
     8f8:	fe 4f       	sbci	r31, 0xFE	; 254
     8fa:	60 81       	ld	r22, Z
     8fc:	71 81       	ldd	r23, Z+1	; 0x01
     8fe:	e7 52       	subi	r30, 0x27	; 39
     900:	f1 40       	sbci	r31, 0x01	; 1
                        if (currentSpeed >= targetSpeed) {
     902:	62 17       	cp	r22, r18
     904:	73 07       	cpc	r23, r19
     906:	88 f4       	brcc	.+34     	; 0x92a <__vector_31+0x1b2>
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[DC]) {
     908:	80 91 3b 03 	lds	r24, 0x033B
     90c:	e7 5d       	subi	r30, 0xD7	; 215
     90e:	fe 4f       	sbci	r31, 0xFE	; 254
     910:	88 23       	and	r24, r24
     912:	39 f0       	breq	.+14     	; 0x922 <__vector_31+0x1aa>
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats * 3 + 2;
     914:	80 81       	ld	r24, Z
     916:	23 e0       	ldi	r18, 0x03	; 3
     918:	82 9f       	mul	r24, r18
     91a:	c0 01       	movw	r24, r0
     91c:	11 24       	eor	r1, r1
     91e:	8e 5f       	subi	r24, 0xFE	; 254
     920:	01 c0       	rjmp	.+2      	; 0x924 <__vector_31+0x1ac>
                            } else {
                                accelTableRepeatsLeft[DC] = cmd.accelTable[DC][accelIndex].repeats;
     922:	80 81       	ld	r24, Z
     924:	80 93 13 03 	sts	0x0313, r24
     928:	01 c0       	rjmp	.+2      	; 0x92c <__vector_31+0x1b4>
     92a:	b9 01       	movw	r22, r18
                            }
                        }
                    }
                }
                currentMotorSpeed(DC) = currentSpeed; //Update the current speed in case it has changed.
     92c:	70 93 99 00 	sts	0x0099, r23
     930:	60 93 98 00 	sts	0x0098, r22
     934:	08 c0       	rjmp	.+16     	; 0x946 <__vector_31+0x1ce>
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[DC] = repeatsReqd - 1;
     936:	81 50       	subi	r24, 0x01	; 1
     938:	80 93 13 03 	sts	0x0313, r24
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__vector_31+0x1ce>
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(DC) = irqToNext; //Update the number of IRQs remaining until the next step.
     93e:	90 93 89 00 	sts	0x0089, r25
     942:	80 93 88 00 	sts	0x0088, r24
    }   


}
     946:	ff 91       	pop	r31
     948:	ef 91       	pop	r30
     94a:	bf 91       	pop	r27
     94c:	af 91       	pop	r26
     94e:	9f 91       	pop	r25
     950:	8f 91       	pop	r24
     952:	7f 91       	pop	r23
     954:	6f 91       	pop	r22
     956:	5f 91       	pop	r21
     958:	4f 91       	pop	r20
     95a:	3f 91       	pop	r19
     95c:	2f 91       	pop	r18
     95e:	0f 90       	pop	r0
     960:	0b be       	out	0x3b, r0	; 59
     962:	0f 90       	pop	r0
     964:	0f be       	out	0x3f, r0	; 63
     966:	0f 90       	pop	r0
     968:	1f 90       	pop	r1
     96a:	18 95       	reti

0000096c <__vector_16>:




/*Timer Interrupt Vector*/
ISR(TIMER1_CAPT_vect) {
     96c:	1f 92       	push	r1
     96e:	0f 92       	push	r0
     970:	0f b6       	in	r0, 0x3f	; 63
     972:	0f 92       	push	r0
     974:	0b b6       	in	r0, 0x3b	; 59
     976:	0f 92       	push	r0
     978:	11 24       	eor	r1, r1
     97a:	2f 93       	push	r18
     97c:	3f 93       	push	r19
     97e:	4f 93       	push	r20
     980:	5f 93       	push	r21
     982:	6f 93       	push	r22
     984:	7f 93       	push	r23
     986:	8f 93       	push	r24
     988:	9f 93       	push	r25
     98a:	af 93       	push	r26
     98c:	bf 93       	push	r27
     98e:	ef 93       	push	r30
     990:	ff 93       	push	r31
    
    //Load the number of interrupts until the next step
    unsigned int irqToNext = irqToNextStep(RA)-1;
     992:	80 91 8a 00 	lds	r24, 0x008A
     996:	90 91 8b 00 	lds	r25, 0x008B
     99a:	01 97       	sbiw	r24, 0x01	; 1
    //Check if we are ready to step
    if (irqToNext == 0) {
     99c:	09 f0       	breq	.+2      	; 0x9a0 <__vector_16+0x34>
     99e:	c9 c0       	rjmp	.+402    	; 0xb32 <__vector_16+0x1c6>
        //Once the required number of interrupts have occurred...
        
        //First update the interrupt base rate using our distribution array. 
        //This affords a more accurate sidereal rate by dithering the intterrupt rate to get higher resolution.
        byte timeSegment = distributionSegment(RA); //Get the current time segement
     9a0:	8b b5       	in	r24, 0x2b	; 43
        /* 
        byte index = ((DecimalDistnWidth-1) & timeSegment) >> 1; //Convert time segment to array index
        interruptOVFCount(RA) = timerOVF[RA][index]; //Update interrupt base rate.
        */// Below is optimised version of above:
        byte index = ((DecimalDistnWidth-1) << 1) & timeSegment; //Convert time segment to array index
        interruptOVFCount(RA) = *(int*)((byte*)timerOVF[RA] + index); //Update interrupt base rate.
     9a2:	e8 2f       	mov	r30, r24
     9a4:	ee 73       	andi	r30, 0x3E	; 62
     9a6:	f0 e0       	ldi	r31, 0x00	; 0
     9a8:	e6 57       	subi	r30, 0x76	; 118
     9aa:	fd 4f       	sbci	r31, 0xFD	; 253
     9ac:	20 81       	ld	r18, Z
     9ae:	31 81       	ldd	r19, Z+1	; 0x01
     9b0:	30 93 87 00 	sts	0x0087, r19
     9b4:	20 93 86 00 	sts	0x0086, r18
        
        distributionSegment(RA) = timeSegment + 1; //Increment time segement for next time.
     9b8:	8f 5f       	subi	r24, 0xFF	; 255
     9ba:	8b bd       	out	0x2b, r24	; 43

        unsigned int currentSpeed = currentMotorSpeed(RA); //Get the current motor speed
     9bc:	60 91 9a 00 	lds	r22, 0x009A
     9c0:	70 91 9b 00 	lds	r23, 0x009B
        irqToNextStep(RA) = currentSpeed; //Update interrupts to next step to be the current speed in case it changed (accel/decel)
     9c4:	70 93 8b 00 	sts	0x008B, r23
     9c8:	60 93 8a 00 	sts	0x008A, r22
        
        if (getPinValue(stepPin[RA])){
     9cc:	63 9b       	sbis	0x0c, 3	; 12
     9ce:	54 c0       	rjmp	.+168    	; 0xa78 <__vector_16+0x10c>
            //If the step pin is currently high...
            
            setPinValue(stepPin[RA],LOW); //set step pin low to complete step
     9d0:	73 98       	cbi	0x0e, 3	; 14
            
            //Then increment our encoder value by the required amount of encoder values per step (1 for low speed, 8 for high speed)
            //and in the correct direction (+ = forward, - = reverse).
            unsigned long jVal = cmd.jVal[RA]; 
     9d2:	80 91 16 03 	lds	r24, 0x0316
     9d6:	90 91 17 03 	lds	r25, 0x0317
     9da:	a0 91 18 03 	lds	r26, 0x0318
     9de:	b0 91 19 03 	lds	r27, 0x0319
            jVal = jVal + cmd.stepDir[RA];
     9e2:	20 91 30 03 	lds	r18, 0x0330
     9e6:	33 27       	eor	r19, r19
     9e8:	27 fd       	sbrc	r18, 7
     9ea:	30 95       	com	r19
     9ec:	43 2f       	mov	r20, r19
     9ee:	53 2f       	mov	r21, r19
     9f0:	28 0f       	add	r18, r24
     9f2:	39 1f       	adc	r19, r25
     9f4:	4a 1f       	adc	r20, r26
     9f6:	5b 1f       	adc	r21, r27
            cmd.jVal[RA] = jVal;
     9f8:	20 93 16 03 	sts	0x0316, r18
     9fc:	30 93 17 03 	sts	0x0317, r19
     a00:	40 93 18 03 	sts	0x0318, r20
     a04:	50 93 19 03 	sts	0x0319, r21
            
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
     a08:	f0 9b       	sbis	0x1e, 0	; 30
     a0a:	1b c0       	rjmp	.+54     	; 0xa42 <__vector_16+0xd6>
     a0c:	f2 99       	sbic	0x1e, 2	; 30
     a0e:	19 c0       	rjmp	.+50     	; 0xa42 <__vector_16+0xd6>
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
     a10:	80 91 7c 02 	lds	r24, 0x027C
     a14:	90 91 7d 02 	lds	r25, 0x027D
     a18:	a0 91 7e 02 	lds	r26, 0x027E
     a1c:	b0 91 7f 02 	lds	r27, 0x027F
     a20:	82 17       	cp	r24, r18
     a22:	93 07       	cpc	r25, r19
     a24:	a4 07       	cpc	r26, r20
     a26:	b5 07       	cpc	r27, r21
     a28:	61 f4       	brne	.+24     	; 0xa42 <__vector_16+0xd6>
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
}
inline void setGotoDecelerating(const byte axis) {
    gotoControlRegister |= gotoDeceleratingBitMask(axis);
     a2a:	f2 9a       	sbi	0x1e, 2	; 30
            if(gotoRunning(RA) && !gotoDecelerating(RA)){
                //If we are currently performing a Go-To and haven't yet started decelleration...
                if (gotoPosn[RA] == jVal){ 
                    //If we have reached the start decelleration marker...
                    setGotoDecelerating(RA); //Mark that we have started decelleration.
                    cmd.currentIVal[RA] = cmd.stopSpeed[RA]+1; //Set the new target speed to slower than the stop speed to cause decelleration to a stop.
     a2c:	80 91 79 03 	lds	r24, 0x0379
     a30:	90 91 7a 03 	lds	r25, 0x037A
     a34:	01 96       	adiw	r24, 0x01	; 1
     a36:	90 93 6e 03 	sts	0x036E, r25
     a3a:	80 93 6d 03 	sts	0x036D, r24
                    accelTableRepeatsLeft[RA] = 0;
     a3e:	10 92 12 03 	sts	0x0312, r1
                }
            } 
            
            if (currentSpeed > cmd.stopSpeed[RA]) {
     a42:	80 91 79 03 	lds	r24, 0x0379
     a46:	90 91 7a 03 	lds	r25, 0x037A
     a4a:	86 17       	cp	r24, r22
     a4c:	97 07       	cpc	r25, r23
     a4e:	08 f0       	brcs	.+2      	; 0xa52 <__vector_16+0xe6>
     a50:	74 c0       	rjmp	.+232    	; 0xb3a <__vector_16+0x1ce>
                //If the current speed is now slower than the stopping speed, we can stop moving. So...
                if(gotoRunning(RA)){ 
     a52:	f0 9b       	sbis	0x1e, 0	; 30
     a54:	03 c0       	rjmp	.+6      	; 0xa5c <__vector_16+0xf0>
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
     a56:	10 92 36 03 	sts	0x0336, r1
}
inline void setGotoRunning(const byte axis) {
    gotoControlRegister |= gotoRunningBitMask(axis);
}
inline void clearGotoRunning(const byte axis) {
    gotoControlRegister &= ~gotoRunningBitMask(axis);
     a5a:	f0 98       	cbi	0x1e, 0	; 30
inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	80 93 38 03 	sts	0x0338, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1));//00x
    timerPrescalarRegister(motor) |= (1<<CSn0);//xx1
}

inline void timerDisable(byte motor) {
    interruptControlRegister(motor) &= ~interruptControlBitMask(motor); //Disable timer interrupt
     a62:	80 91 6f 00 	lds	r24, 0x006F
     a66:	8f 7d       	andi	r24, 0xDF	; 223
     a68:	80 93 6f 00 	sts	0x006F, r24
    timerPrescalarRegister(motor) &= ~((1<<CSn2) | (1<<CSn1) | (1<<CSn0));//00x
     a6c:	80 91 81 00 	lds	r24, 0x0081
     a70:	88 7f       	andi	r24, 0xF8	; 248
     a72:	80 93 81 00 	sts	0x0081, r24
     a76:	61 c0       	rjmp	.+194    	; 0xb3a <__vector_16+0x1ce>
                cmd_setStopped(RA,CMD_STOPPED); //mark as stopped 
                timerDisable(RA);  //And stop the interrupt timer.
            } 
        } else {
            //If the step pin is currently low...
            setPinValue(stepPin[RA],HIGH); //Set it high to start next step.
     a78:	73 9a       	sbi	0x0e, 3	; 14
            
            //If the current speed is not the target speed, then we are in the accel/decel phase. So...
            byte repeatsReqd = accelTableRepeatsLeft[RA]; //load the number of repeats left for this accel table entry
     a7a:	80 91 12 03 	lds	r24, 0x0312
            if (repeatsReqd == 0) { 
     a7e:	88 23       	and	r24, r24
     a80:	09 f0       	breq	.+2      	; 0xa84 <__vector_16+0x118>
     a82:	53 c0       	rjmp	.+166    	; 0xb2a <__vector_16+0x1be>
                //If we have done enough repeats for this entry
                unsigned int targetSpeed = cmd.currentIVal[RA]; //Get the target speed
     a84:	20 91 6d 03 	lds	r18, 0x036D
     a88:	30 91 6e 03 	lds	r19, 0x036E
                if (currentSpeed > targetSpeed) {
     a8c:	26 17       	cp	r18, r22
     a8e:	37 07       	cpc	r19, r23
     a90:	d0 f4       	brcc	.+52     	; 0xac6 <__vector_16+0x15a>
                    //If we are going too slow
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
     a92:	80 91 14 03 	lds	r24, 0x0314
                    if (accelIndex >= AccelTableLength-1) {
     a96:	8f 33       	cpi	r24, 0x3F	; 63
     a98:	08 f0       	brcs	.+2      	; 0xa9c <__vector_16+0x130>
     a9a:	41 c0       	rjmp	.+130    	; 0xb1e <__vector_16+0x1b2>
                        //If we are at the top of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        accelIndex = AccelTableLength-1; //Ensure index remains in bounds.
                    } else {
                        //Otherwise, we need to accelerate.
                        accelIndex = accelIndex + 1; //Move to the next index
     a9c:	8f 5f       	subi	r24, 0xFF	; 255
                        accelTableIndex[RA] = accelIndex; //Save the new index back
     a9e:	80 93 14 03 	sts	0x0314, r24
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	fc 01       	movw	r30, r24
     aa6:	ee 0f       	add	r30, r30
     aa8:	ff 1f       	adc	r31, r31
     aaa:	e8 0f       	add	r30, r24
     aac:	f9 1f       	adc	r31, r25
     aae:	ea 5e       	subi	r30, 0xEA	; 234
     ab0:	fc 4f       	sbci	r31, 0xFC	; 252
     ab2:	e9 59       	subi	r30, 0x99	; 153
     ab4:	ff 4f       	sbci	r31, 0xFF	; 255
     ab6:	60 81       	ld	r22, Z
     ab8:	71 81       	ldd	r23, Z+1	; 0x01
     aba:	e7 56       	subi	r30, 0x67	; 103
     abc:	f0 40       	sbci	r31, 0x00	; 0
                        if (currentSpeed <= targetSpeed) {
     abe:	26 17       	cp	r18, r22
     ac0:	37 07       	cpc	r19, r23
     ac2:	e0 f0       	brcs	.+56     	; 0xafc <__vector_16+0x190>
     ac4:	2c c0       	rjmp	.+88     	; 0xb1e <__vector_16+0x1b2>
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
                            }
                        }
                    }
                } else if (currentSpeed < targetSpeed) {
     ac6:	62 17       	cp	r22, r18
     ac8:	73 07       	cpc	r23, r19
     aca:	50 f5       	brcc	.+84     	; 0xb20 <__vector_16+0x1b4>
                    //If we are going too fast
                    byte accelIndex = accelTableIndex[RA]; //Load the acceleration table index
     acc:	80 91 14 03 	lds	r24, 0x0314
                    if (accelIndex == 0) {
     ad0:	88 23       	and	r24, r24
     ad2:	29 f1       	breq	.+74     	; 0xb1e <__vector_16+0x1b2>
                        //If we are at the bottom of the accel table
                        currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                    } else {
                        //Otherwise, we need to decelerate.
                        accelIndex = accelIndex - 1; //Move to the next index
     ad4:	81 50       	subi	r24, 0x01	; 1
                        accelTableIndex[RA] = accelIndex; //Save the new index back
     ad6:	80 93 14 03 	sts	0x0314, r24
                        currentSpeed = cmd.accelTable[RA][accelIndex].speed;  //load the new speed from the table
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	fc 01       	movw	r30, r24
     ade:	ee 0f       	add	r30, r30
     ae0:	ff 1f       	adc	r31, r31
     ae2:	e8 0f       	add	r30, r24
     ae4:	f9 1f       	adc	r31, r25
     ae6:	ea 5e       	subi	r30, 0xEA	; 234
     ae8:	fc 4f       	sbci	r31, 0xFC	; 252
     aea:	e9 59       	subi	r30, 0x99	; 153
     aec:	ff 4f       	sbci	r31, 0xFF	; 255
     aee:	60 81       	ld	r22, Z
     af0:	71 81       	ldd	r23, Z+1	; 0x01
     af2:	e7 56       	subi	r30, 0x67	; 103
     af4:	f0 40       	sbci	r31, 0x00	; 0
                        if (currentSpeed >= targetSpeed) {
     af6:	62 17       	cp	r22, r18
     af8:	73 07       	cpc	r23, r19
     afa:	88 f4       	brcc	.+34     	; 0xb1e <__vector_16+0x1b2>
                            //If the new value is too slow
                            currentSpeed = targetSpeed; //Then the new speed is exactly the target speed.
                        } else {
                            //Load the new number of repeats required
                            if (cmd.highSpeedMode[RA]) {
     afc:	80 91 3a 03 	lds	r24, 0x033A
     b00:	e7 59       	subi	r30, 0x97	; 151
     b02:	ff 4f       	sbci	r31, 0xFF	; 255
     b04:	88 23       	and	r24, r24
     b06:	39 f0       	breq	.+14     	; 0xb16 <__vector_16+0x1aa>
                                //When in high-speed mode, we need to multiply by sqrt(8) ~= 3 to compensate for the change in steps per rev of the motor
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats * 3 + 2;
     b08:	80 81       	ld	r24, Z
     b0a:	23 e0       	ldi	r18, 0x03	; 3
     b0c:	82 9f       	mul	r24, r18
     b0e:	c0 01       	movw	r24, r0
     b10:	11 24       	eor	r1, r1
     b12:	8e 5f       	subi	r24, 0xFE	; 254
     b14:	01 c0       	rjmp	.+2      	; 0xb18 <__vector_16+0x1ac>
                            } else {
                                accelTableRepeatsLeft[RA] = cmd.accelTable[RA][accelIndex].repeats;
     b16:	80 81       	ld	r24, Z
     b18:	80 93 12 03 	sts	0x0312, r24
     b1c:	01 c0       	rjmp	.+2      	; 0xb20 <__vector_16+0x1b4>
     b1e:	b9 01       	movw	r22, r18
                            }
                        }
                    }
                }
                currentMotorSpeed(RA) = currentSpeed; //Update the current speed in case it has changed.
     b20:	70 93 9b 00 	sts	0x009B, r23
     b24:	60 93 9a 00 	sts	0x009A, r22
     b28:	08 c0       	rjmp	.+16     	; 0xb3a <__vector_16+0x1ce>
            } else {
                //Otherwise one more repeat done.
                accelTableRepeatsLeft[RA] = repeatsReqd - 1;
     b2a:	81 50       	subi	r24, 0x01	; 1
     b2c:	80 93 12 03 	sts	0x0312, r24
     b30:	04 c0       	rjmp	.+8      	; 0xb3a <__vector_16+0x1ce>
            }
        }
    } else {
        //The required number of interrupts have not yet occurred...
        irqToNextStep(RA) = irqToNext; //Update the number of IRQs remaining until the next step.
     b32:	90 93 8b 00 	sts	0x008B, r25
     b36:	80 93 8a 00 	sts	0x008A, r24
    }   


}
     b3a:	ff 91       	pop	r31
     b3c:	ef 91       	pop	r30
     b3e:	bf 91       	pop	r27
     b40:	af 91       	pop	r26
     b42:	9f 91       	pop	r25
     b44:	8f 91       	pop	r24
     b46:	7f 91       	pop	r23
     b48:	6f 91       	pop	r22
     b4a:	5f 91       	pop	r21
     b4c:	4f 91       	pop	r20
     b4e:	3f 91       	pop	r19
     b50:	2f 91       	pop	r18
     b52:	0f 90       	pop	r0
     b54:	0b be       	out	0x3b, r0	; 59
     b56:	0f 90       	pop	r0
     b58:	0f be       	out	0x3f, r0	; 63
     b5a:	0f 90       	pop	r0
     b5c:	1f 90       	pop	r1
     b5e:	18 95       	reti

00000b60 <storeEEPROM>:

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
}

void storeEEPROM(){
     b60:	1f 93       	push	r17
    EEPROM_writeLong(cmd.aVal[RA],aVal1_Address);
     b62:	60 91 44 03 	lds	r22, 0x0344
     b66:	70 91 45 03 	lds	r23, 0x0345
     b6a:	80 91 46 03 	lds	r24, 0x0346
     b6e:	90 91 47 03 	lds	r25, 0x0347
     b72:	4e e0       	ldi	r20, 0x0E	; 14
     b74:	50 e0       	ldi	r21, 0x00	; 0
     b76:	0e 94 30 11 	call	0x2260	; 0x2260 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.aVal[DC],aVal2_Address);
     b7a:	60 91 48 03 	lds	r22, 0x0348
     b7e:	70 91 49 03 	lds	r23, 0x0349
     b82:	80 91 4a 03 	lds	r24, 0x034A
     b86:	90 91 4b 03 	lds	r25, 0x034B
     b8a:	42 e1       	ldi	r20, 0x12	; 18
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	0e 94 30 11 	call	0x2260	; 0x2260 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.bVal[RA],bVal1_Address);
     b92:	60 91 4c 03 	lds	r22, 0x034C
     b96:	70 91 4d 03 	lds	r23, 0x034D
     b9a:	80 91 4e 03 	lds	r24, 0x034E
     b9e:	90 91 4f 03 	lds	r25, 0x034F
     ba2:	46 e1       	ldi	r20, 0x16	; 22
     ba4:	50 e0       	ldi	r21, 0x00	; 0
     ba6:	0e 94 30 11 	call	0x2260	; 0x2260 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.bVal[DC],bVal2_Address);
     baa:	60 91 50 03 	lds	r22, 0x0350
     bae:	70 91 51 03 	lds	r23, 0x0351
     bb2:	80 91 52 03 	lds	r24, 0x0352
     bb6:	90 91 53 03 	lds	r25, 0x0353
     bba:	4a e1       	ldi	r20, 0x1A	; 26
     bbc:	50 e0       	ldi	r21, 0x00	; 0
     bbe:	0e 94 30 11 	call	0x2260	; 0x2260 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.sVal[RA],sVal1_Address);
     bc2:	60 91 56 03 	lds	r22, 0x0356
     bc6:	70 91 57 03 	lds	r23, 0x0357
     bca:	80 91 58 03 	lds	r24, 0x0358
     bce:	90 91 59 03 	lds	r25, 0x0359
     bd2:	4e e1       	ldi	r20, 0x1E	; 30
     bd4:	50 e0       	ldi	r21, 0x00	; 0
     bd6:	0e 94 30 11 	call	0x2260	; 0x2260 <_Z16EEPROM_writeLongmj>
    EEPROM_writeLong(cmd.sVal[DC],sVal2_Address);
     bda:	60 91 5a 03 	lds	r22, 0x035A
     bde:	70 91 5b 03 	lds	r23, 0x035B
     be2:	80 91 5c 03 	lds	r24, 0x035C
     be6:	90 91 5d 03 	lds	r25, 0x035D
     bea:	42 e2       	ldi	r20, 0x22	; 34
     bec:	50 e0       	ldi	r21, 0x00	; 0
     bee:	0e 94 30 11 	call	0x2260	; 0x2260 <_Z16EEPROM_writeLongmj>
    EEPROM_writeByte(encodeDirection[RA],RAReverse_Address);
     bf2:	80 91 84 02 	lds	r24, 0x0284
     bf6:	69 e0       	ldi	r22, 0x09	; 9
     bf8:	70 e0       	ldi	r23, 0x00	; 0
     bfa:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(encodeDirection[DC],DECReverse_Address);
     bfe:	80 91 85 02 	lds	r24, 0x0285
     c02:	6a e0       	ldi	r22, 0x0A	; 10
     c04:	70 e0       	ldi	r23, 0x00	; 0
     c06:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(driverVersion,Driver_Address);
     c0a:	80 91 88 02 	lds	r24, 0x0288
     c0e:	6b e0       	ldi	r22, 0x0B	; 11
     c10:	70 e0       	ldi	r23, 0x00	; 0
     c12:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(microstepConf,Microstep_Address);
     c16:	80 91 87 02 	lds	r24, 0x0287
     c1a:	68 e0       	ldi	r22, 0x08	; 8
     c1c:	70 e0       	ldi	r23, 0x00	; 0
     c1e:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(cmd.normalGotoSpeed[RA],RAGoto_Address);
     c22:	80 91 75 03 	lds	r24, 0x0375
     c26:	6c e0       	ldi	r22, 0x0C	; 12
     c28:	70 e0       	ldi	r23, 0x00	; 0
     c2a:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(cmd.normalGotoSpeed[DC],DECGoto_Address);
     c2e:	80 91 77 03 	lds	r24, 0x0377
     c32:	6d e0       	ldi	r22, 0x0D	; 13
     c34:	70 e0       	ldi	r23, 0x00	; 0
     c36:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeInt(cmd.siderealIVal[RA],IVal1_Address);
     c3a:	80 91 69 03 	lds	r24, 0x0369
     c3e:	90 91 6a 03 	lds	r25, 0x036A
     c42:	66 e2       	ldi	r22, 0x26	; 38
     c44:	70 e0       	ldi	r23, 0x00	; 0
     c46:	0e 94 15 11 	call	0x222a	; 0x222a <_Z15EEPROM_writeIntjj>
    EEPROM_writeInt(cmd.siderealIVal[DC],IVal2_Address);
     c4a:	80 91 6b 03 	lds	r24, 0x036B
     c4e:	90 91 6c 03 	lds	r25, 0x036C
     c52:	68 e2       	ldi	r22, 0x28	; 40
     c54:	70 e0       	ldi	r23, 0x00	; 0
     c56:	0e 94 15 11 	call	0x222a	; 0x222a <_Z15EEPROM_writeIntjj>
    EEPROM_writeByte(!disableGearChange, GearEnable_Address);
     c5a:	80 91 0c 03 	lds	r24, 0x030C
     c5e:	11 e0       	ldi	r17, 0x01	; 1
     c60:	81 27       	eor	r24, r17
     c62:	6a e2       	ldi	r22, 0x2A	; 42
     c64:	70 e0       	ldi	r23, 0x00	; 0
     c66:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeByte(!allowAdvancedHCDetection, AdvHCEnable_Address);
     c6a:	80 91 0d 03 	lds	r24, 0x030D
     c6e:	81 27       	eor	r24, r17
     c70:	6b e2       	ldi	r22, 0x2B	; 43
     c72:	70 e0       	ldi	r23, 0x00	; 0
     c74:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeInt(cmd.st4DecBacklash, DecBacklash_Address);
     c78:	80 91 67 03 	lds	r24, 0x0367
     c7c:	90 91 68 03 	lds	r25, 0x0368
     c80:	6c e2       	ldi	r22, 0x2C	; 44
     c82:	70 e0       	ldi	r23, 0x00	; 0
     c84:	0e 94 15 11 	call	0x222a	; 0x222a <_Z15EEPROM_writeIntjj>
    EEPROM_writeByte(cmd.st4SpeedFactor, SpeedFactor_Address);
     c88:	80 91 5f 03 	lds	r24, 0x035F
     c8c:	6e e2       	ldi	r22, 0x2E	; 46
     c8e:	70 e0       	ldi	r23, 0x00	; 0
     c90:	0e 94 09 11 	call	0x2212	; 0x2212 <_Z16EEPROM_writeBytehj>
    EEPROM_writeAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address);
     c94:	8d e7       	ldi	r24, 0x7D	; 125
     c96:	93 e0       	ldi	r25, 0x03	; 3
     c98:	60 e4       	ldi	r22, 0x40	; 64
     c9a:	44 e6       	ldi	r20, 0x64	; 100
     c9c:	50 e0       	ldi	r21, 0x00	; 0
     c9e:	0e 94 60 11 	call	0x22c0	; 0x22c0 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>
    EEPROM_writeAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address);
     ca2:	8d e3       	ldi	r24, 0x3D	; 61
     ca4:	94 e0       	ldi	r25, 0x04	; 4
     ca6:	60 e4       	ldi	r22, 0x40	; 64
     ca8:	44 e2       	ldi	r20, 0x24	; 36
     caa:	51 e0       	ldi	r21, 0x01	; 1
     cac:	0e 94 60 11 	call	0x22c0	; 0x22c0 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>
}
     cb0:	1f 91       	pop	r17
     cb2:	08 95       	ret

00000cb4 <buildEEPROM>:
    }
    return true;
}

void buildEEPROM(){
    EEPROM_writeString("AstroEQ",8,AstroEQID_Address);
     cb4:	80 e0       	ldi	r24, 0x00	; 0
     cb6:	92 e0       	ldi	r25, 0x02	; 2
     cb8:	68 e0       	ldi	r22, 0x08	; 8
     cba:	40 e0       	ldi	r20, 0x00	; 0
     cbc:	50 e0       	ldi	r21, 0x00	; 0
     cbe:	0e 94 47 11 	call	0x228e	; 0x228e <_Z18EEPROM_writeStringPKchj>
}
     cc2:	08 95       	ret

00000cc4 <checkEEPROM>:

/*
 * EEPROM Validation and Programming Routines
 */

bool checkEEPROM(){
     cc4:	0f 93       	push	r16
     cc6:	1f 93       	push	r17
     cc8:	df 93       	push	r29
     cca:	cf 93       	push	r28
     ccc:	cd b7       	in	r28, 0x3d	; 61
     cce:	de b7       	in	r29, 0x3e	; 62
     cd0:	29 97       	sbiw	r28, 0x09	; 9
     cd2:	0f b6       	in	r0, 0x3f	; 63
     cd4:	f8 94       	cli
     cd6:	de bf       	out	0x3e, r29	; 62
     cd8:	0f be       	out	0x3f, r0	; 63
     cda:	cd bf       	out	0x3d, r28	; 61
    char temp[9] = {0};
     cdc:	8e 01       	movw	r16, r28
     cde:	0f 5f       	subi	r16, 0xFF	; 255
     ce0:	1f 4f       	sbci	r17, 0xFF	; 255
     ce2:	89 e0       	ldi	r24, 0x09	; 9
     ce4:	f8 01       	movw	r30, r16
     ce6:	11 92       	st	Z+, r1
     ce8:	8a 95       	dec	r24
     cea:	e9 f7       	brne	.-6      	; 0xce6 <checkEEPROM+0x22>
    EEPROM_readString(temp,8,AstroEQID_Address);
     cec:	c8 01       	movw	r24, r16
     cee:	68 e0       	ldi	r22, 0x08	; 8
     cf0:	40 e0       	ldi	r20, 0x00	; 0
     cf2:	50 e0       	ldi	r21, 0x00	; 0
     cf4:	0e 94 cb 10 	call	0x2196	; 0x2196 <_Z17EEPROM_readStringPchj>
    if(strncmp(temp,"AstroEQ",8)){
     cf8:	c8 01       	movw	r24, r16
     cfa:	60 e0       	ldi	r22, 0x00	; 0
     cfc:	72 e0       	ldi	r23, 0x02	; 2
     cfe:	48 e0       	ldi	r20, 0x08	; 8
     d00:	50 e0       	ldi	r21, 0x00	; 0
     d02:	0e 94 d6 00 	call	0x1ac	; 0x1ac <strncmp>
     d06:	00 97       	sbiw	r24, 0x00	; 0
     d08:	91 f5       	brne	.+100    	; 0xd6e <checkEEPROM+0xaa>
        return false;
    }
    if (driverVersion > DRV8834){
     d0a:	80 91 88 02 	lds	r24, 0x0288
     d0e:	83 30       	cpi	r24, 0x03	; 3
     d10:	70 f5       	brcc	.+92     	; 0xd6e <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((driverVersion == A498x) && microstepConf > 16){
     d12:	88 23       	and	r24, r24
     d14:	21 f4       	brne	.+8      	; 0xd1e <checkEEPROM+0x5a>
     d16:	80 91 87 02 	lds	r24, 0x0287
     d1a:	81 31       	cpi	r24, 0x11	; 17
     d1c:	40 f5       	brcc	.+80     	; 0xd6e <checkEEPROM+0xaa>
        return false; //invalid value.
    } else if (microstepConf > 32){
     d1e:	80 91 87 02 	lds	r24, 0x0287
     d22:	81 32       	cpi	r24, 0x21	; 33
     d24:	20 f5       	brcc	.+72     	; 0xd6e <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[RA] > 1200) || (cmd.siderealIVal[RA] < MIN_IVAL)) {
     d26:	80 91 69 03 	lds	r24, 0x0369
     d2a:	90 91 6a 03 	lds	r25, 0x036A
     d2e:	c2 97       	sbiw	r24, 0x32	; 50
     d30:	8f 57       	subi	r24, 0x7F	; 127
     d32:	94 40       	sbci	r25, 0x04	; 4
     d34:	e0 f4       	brcc	.+56     	; 0xd6e <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if ((cmd.siderealIVal[DC] > 1200) || (cmd.siderealIVal[DC] < MIN_IVAL)) {
     d36:	80 91 6b 03 	lds	r24, 0x036B
     d3a:	90 91 6c 03 	lds	r25, 0x036C
     d3e:	c2 97       	sbiw	r24, 0x32	; 50
     d40:	8f 57       	subi	r24, 0x7F	; 127
     d42:	94 40       	sbci	r25, 0x04	; 4
     d44:	a0 f4       	brcc	.+40     	; 0xd6e <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[RA] == 0){
     d46:	80 91 75 03 	lds	r24, 0x0375
     d4a:	90 91 76 03 	lds	r25, 0x0376
     d4e:	89 2b       	or	r24, r25
     d50:	71 f0       	breq	.+28     	; 0xd6e <checkEEPROM+0xaa>
        return false; //invalid value.
    }
    if(cmd.normalGotoSpeed[DC] == 0){
     d52:	80 91 77 03 	lds	r24, 0x0377
     d56:	90 91 78 03 	lds	r25, 0x0378
     d5a:	89 2b       	or	r24, r25
     d5c:	41 f0       	breq	.+16     	; 0xd6e <checkEEPROM+0xaa>
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	80 91 5f 03 	lds	r24, 0x035F
     d64:	81 50       	subi	r24, 0x01	; 1
     d66:	83 31       	cpi	r24, 0x13	; 19
     d68:	18 f4       	brcc	.+6      	; 0xd70 <checkEEPROM+0xac>
     d6a:	91 e0       	ldi	r25, 0x01	; 1
     d6c:	01 c0       	rjmp	.+2      	; 0xd70 <checkEEPROM+0xac>
     d6e:	90 e0       	ldi	r25, 0x00	; 0
    }
    if((cmd.st4SpeedFactor < 1) || (cmd.st4SpeedFactor > 19)){
        return false; //invalid value
    }
    return true;
}
     d70:	89 2f       	mov	r24, r25
     d72:	29 96       	adiw	r28, 0x09	; 9
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	f8 94       	cli
     d78:	de bf       	out	0x3e, r29	; 62
     d7a:	0f be       	out	0x3f, r0	; 63
     d7c:	cd bf       	out	0x3d, r28	; 61
     d7e:	cf 91       	pop	r28
     d80:	df 91       	pop	r29
     d82:	1f 91       	pop	r17
     d84:	0f 91       	pop	r16
     d86:	08 95       	ret

00000d88 <decodeCommand>:

/*
 * Decode and Perform the Command
 */

bool decodeCommand(char command, char* buffer){ //each command is axis specific. The axis being modified can be retrieved by calling synta_axis()
     d88:	8f 92       	push	r8
     d8a:	9f 92       	push	r9
     d8c:	af 92       	push	r10
     d8e:	bf 92       	push	r11
     d90:	cf 92       	push	r12
     d92:	df 92       	push	r13
     d94:	ef 92       	push	r14
     d96:	ff 92       	push	r15
     d98:	0f 93       	push	r16
     d9a:	1f 93       	push	r17
     d9c:	cf 93       	push	r28
     d9e:	df 93       	push	r29
     da0:	a8 2e       	mov	r10, r24
     da2:	4b 01       	movw	r8, r22
    unsigned long responseData = 0; //data for response
    bool success = true;
    byte axis = synta_axis();
     da4:	82 e0       	ldi	r24, 0x02	; 2
     da6:	0e 94 41 13 	call	0x2682	; 0x2682 <_Z10synta_axish>
     daa:	b8 2e       	mov	r11, r24
    unsigned int correction;
    byte oldSREG;
    switch(command) {
     dac:	0f e4       	ldi	r16, 0x4F	; 79
     dae:	a0 16       	cp	r10, r16
     db0:	09 f4       	brne	.+2      	; 0xdb4 <decodeCommand+0x2c>
     db2:	51 c1       	rjmp	.+674    	; 0x1056 <decodeCommand+0x2ce>
     db4:	0a 15       	cp	r16, r10
     db6:	fc f0       	brlt	.+62     	; 0xdf6 <decodeCommand+0x6e>
     db8:	18 e4       	ldi	r17, 0x48	; 72
     dba:	a1 16       	cp	r10, r17
     dbc:	09 f4       	brne	.+2      	; 0xdc0 <decodeCommand+0x38>
     dbe:	ea c0       	rjmp	.+468    	; 0xf94 <decodeCommand+0x20c>
     dc0:	1a 15       	cp	r17, r10
     dc2:	64 f0       	brlt	.+24     	; 0xddc <decodeCommand+0x54>
     dc4:	26 e4       	ldi	r18, 0x46	; 70
     dc6:	a2 16       	cp	r10, r18
     dc8:	09 f4       	brne	.+2      	; 0xdcc <decodeCommand+0x44>
     dca:	3c c1       	rjmp	.+632    	; 0x1044 <decodeCommand+0x2bc>
     dcc:	2a 15       	cp	r18, r10
     dce:	0c f4       	brge	.+2      	; 0xdd2 <decodeCommand+0x4a>
     dd0:	cb c0       	rjmp	.+406    	; 0xf68 <decodeCommand+0x1e0>
     dd2:	85 e4       	ldi	r24, 0x45	; 69
     dd4:	a8 16       	cp	r10, r24
     dd6:	09 f0       	breq	.+2      	; 0xdda <decodeCommand+0x52>
     dd8:	5e c1       	rjmp	.+700    	; 0x1096 <decodeCommand+0x30e>
     dda:	21 c1       	rjmp	.+578    	; 0x101e <decodeCommand+0x296>
     ddc:	ab e4       	ldi	r26, 0x4B	; 75
     dde:	aa 16       	cp	r10, r26
     de0:	09 f4       	brne	.+2      	; 0xde4 <decodeCommand+0x5c>
     de2:	b5 c0       	rjmp	.+362    	; 0xf4e <decodeCommand+0x1c6>
     de4:	bc e4       	ldi	r27, 0x4C	; 76
     de6:	ab 16       	cp	r10, r27
     de8:	09 f4       	brne	.+2      	; 0xdec <decodeCommand+0x64>
     dea:	b7 c0       	rjmp	.+366    	; 0xf5a <decodeCommand+0x1d2>
     dec:	e9 e4       	ldi	r30, 0x49	; 73
     dee:	ae 16       	cp	r10, r30
     df0:	09 f0       	breq	.+2      	; 0xdf4 <decodeCommand+0x6c>
     df2:	51 c1       	rjmp	.+674    	; 0x1096 <decodeCommand+0x30e>
     df4:	e3 c0       	rjmp	.+454    	; 0xfbc <decodeCommand+0x234>
     df6:	f6 e6       	ldi	r31, 0x66	; 102
     df8:	af 16       	cp	r10, r31
     dfa:	09 f4       	brne	.+2      	; 0xdfe <decodeCommand+0x76>
     dfc:	76 c0       	rjmp	.+236    	; 0xeea <decodeCommand+0x162>
     dfe:	fa 15       	cp	r31, r10
     e00:	5c f0       	brlt	.+22     	; 0xe18 <decodeCommand+0x90>
     e02:	02 e6       	ldi	r16, 0x62	; 98
     e04:	a0 16       	cp	r10, r16
     e06:	79 f1       	breq	.+94     	; 0xe66 <decodeCommand+0xde>
     e08:	15 e6       	ldi	r17, 0x65	; 101
     e0a:	a1 16       	cp	r10, r17
     e0c:	91 f0       	breq	.+36     	; 0xe32 <decodeCommand+0xaa>
     e0e:	21 e6       	ldi	r18, 0x61	; 97
     e10:	a2 16       	cp	r10, r18
     e12:	09 f0       	breq	.+2      	; 0xe16 <decodeCommand+0x8e>
     e14:	40 c1       	rjmp	.+640    	; 0x1096 <decodeCommand+0x30e>
     e16:	1a c0       	rjmp	.+52     	; 0xe4c <decodeCommand+0xc4>
     e18:	8a e6       	ldi	r24, 0x6A	; 106
     e1a:	a8 16       	cp	r10, r24
     e1c:	09 f4       	brne	.+2      	; 0xe20 <decodeCommand+0x98>
     e1e:	87 c0       	rjmp	.+270    	; 0xf2e <decodeCommand+0x1a6>
     e20:	a3 e7       	ldi	r26, 0x73	; 115
     e22:	aa 16       	cp	r10, r26
     e24:	09 f4       	brne	.+2      	; 0xe28 <decodeCommand+0xa0>
     e26:	54 c0       	rjmp	.+168    	; 0xed0 <decodeCommand+0x148>
     e28:	b7 e6       	ldi	r27, 0x67	; 103
     e2a:	ab 16       	cp	r10, r27
     e2c:	09 f0       	breq	.+2      	; 0xe30 <decodeCommand+0xa8>
     e2e:	33 c1       	rjmp	.+614    	; 0x1096 <decodeCommand+0x30e>
     e30:	4a c0       	rjmp	.+148    	; 0xec6 <decodeCommand+0x13e>
        case 'e': //readonly, return the eVal (version number)
            responseData = cmd.eVal[axis]; //response to the e command is stored in the eVal function for that axis.
     e32:	e8 2f       	mov	r30, r24
     e34:	f0 e0       	ldi	r31, 0x00	; 0
     e36:	ee 0f       	add	r30, r30
     e38:	ff 1f       	adc	r31, r31
     e3a:	ee 0f       	add	r30, r30
     e3c:	ff 1f       	adc	r31, r31
     e3e:	ea 5e       	subi	r30, 0xEA	; 234
     e40:	fc 4f       	sbci	r31, 0xFC	; 252
     e42:	26 a1       	ldd	r18, Z+38	; 0x26
     e44:	37 a1       	ldd	r19, Z+39	; 0x27
     e46:	40 a5       	ldd	r20, Z+40	; 0x28
     e48:	51 a5       	ldd	r21, Z+41	; 0x29
     e4a:	a1 c2       	rjmp	.+1346   	; 0x138e <decodeCommand+0x606>
            break;
        case 'a': //readonly, return the aVal (steps per axis)
            responseData = cmd.aVal[axis]; //response to the a command is stored in the aVal function for that axis.
     e4c:	e8 2f       	mov	r30, r24
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	ee 0f       	add	r30, r30
     e52:	ff 1f       	adc	r31, r31
     e54:	ee 0f       	add	r30, r30
     e56:	ff 1f       	adc	r31, r31
     e58:	ea 5e       	subi	r30, 0xEA	; 234
     e5a:	fc 4f       	sbci	r31, 0xFC	; 252
     e5c:	26 a5       	ldd	r18, Z+46	; 0x2e
     e5e:	37 a5       	ldd	r19, Z+47	; 0x2f
     e60:	40 a9       	ldd	r20, Z+48	; 0x30
     e62:	51 a9       	ldd	r21, Z+49	; 0x31
     e64:	94 c2       	rjmp	.+1320   	; 0x138e <decodeCommand+0x606>
            break;
        case 'b': //readonly, return the bVal (sidereal step rate)
            responseData = cmd.bVal[axis]; //response to the b command is stored in the bVal function for that axis.
     e66:	a8 2f       	mov	r26, r24
     e68:	b0 e0       	ldi	r27, 0x00	; 0
     e6a:	fd 01       	movw	r30, r26
     e6c:	ee 0f       	add	r30, r30
     e6e:	ff 1f       	adc	r31, r31
     e70:	ee 0f       	add	r30, r30
     e72:	ff 1f       	adc	r31, r31
     e74:	ea 5e       	subi	r30, 0xEA	; 234
     e76:	fc 4f       	sbci	r31, 0xFC	; 252
     e78:	26 a9       	ldd	r18, Z+54	; 0x36
     e7a:	37 a9       	ldd	r19, Z+55	; 0x37
     e7c:	40 ad       	ldd	r20, Z+56	; 0x38
     e7e:	51 ad       	ldd	r21, Z+57	; 0x39
            if (!progMode) {
     e80:	80 91 86 02 	lds	r24, 0x0286
     e84:	88 23       	and	r24, r24
     e86:	09 f0       	breq	.+2      	; 0xe8a <decodeCommand+0x102>
     e88:	82 c2       	rjmp	.+1284   	; 0x138e <decodeCommand+0x606>
                //If not in programming mode, we need to apply a correction factor to ensure that calculations in EQMOD round correctly
                correction = (cmd.siderealIVal[axis] << 1);
     e8a:	aa 0f       	add	r26, r26
     e8c:	bb 1f       	adc	r27, r27
     e8e:	a7 59       	subi	r26, 0x97	; 151
     e90:	bc 4f       	sbci	r27, 0xFC	; 252
     e92:	ed 90       	ld	r14, X+
     e94:	fc 90       	ld	r15, X
     e96:	ee 0c       	add	r14, r14
     e98:	ff 1c       	adc	r15, r15
                responseData = (responseData * (correction+1))/correction; //account for rounding inside Skywatcher DLL.
     e9a:	08 94       	sec
     e9c:	e1 1c       	adc	r14, r1
     e9e:	f1 1c       	adc	r15, r1
     ea0:	b7 01       	movw	r22, r14
     ea2:	80 e0       	ldi	r24, 0x00	; 0
     ea4:	90 e0       	ldi	r25, 0x00	; 0
     ea6:	08 94       	sec
     ea8:	e1 08       	sbc	r14, r1
     eaa:	f1 08       	sbc	r15, r1
     eac:	0e 94 81 16 	call	0x2d02	; 0x2d02 <__mulsi3>
     eb0:	00 e0       	ldi	r16, 0x00	; 0
     eb2:	10 e0       	ldi	r17, 0x00	; 0
     eb4:	a8 01       	movw	r20, r16
     eb6:	97 01       	movw	r18, r14
     eb8:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <__udivmodsi4>
     ebc:	c9 01       	movw	r24, r18
     ebe:	da 01       	movw	r26, r20
     ec0:	9c 01       	movw	r18, r24
     ec2:	ad 01       	movw	r20, r26
     ec4:	64 c2       	rjmp	.+1224   	; 0x138e <decodeCommand+0x606>
            }
            break;
        case 'g': //readonly, return the gVal (high speed multiplier)
            responseData = cmd.gVal[axis]; //response to the g command is stored in the gVal function for that axis.
     ec6:	eb 2d       	mov	r30, r11
     ec8:	f0 e0       	ldi	r31, 0x00	; 0
     eca:	ec 5a       	subi	r30, 0xAC	; 172
     ecc:	fc 4f       	sbci	r31, 0xFC	; 252
     ece:	a4 c1       	rjmp	.+840    	; 0x1218 <decodeCommand+0x490>
            break;
        case 's': //readonly, return the sVal (steps per worm rotation)
            responseData = cmd.sVal[axis]; //response to the s command is stored in the sVal function for that axis.
     ed0:	eb 2d       	mov	r30, r11
     ed2:	f0 e0       	ldi	r31, 0x00	; 0
     ed4:	ee 0f       	add	r30, r30
     ed6:	ff 1f       	adc	r31, r31
     ed8:	ee 0f       	add	r30, r30
     eda:	ff 1f       	adc	r31, r31
     edc:	ea 5a       	subi	r30, 0xAA	; 170
     ede:	fc 4f       	sbci	r31, 0xFC	; 252
     ee0:	20 81       	ld	r18, Z
     ee2:	31 81       	ldd	r19, Z+1	; 0x01
     ee4:	42 81       	ldd	r20, Z+2	; 0x02
     ee6:	53 81       	ldd	r21, Z+3	; 0x03
     ee8:	52 c2       	rjmp	.+1188   	; 0x138e <decodeCommand+0x606>
    }
}

inline unsigned int cmd_fVal(byte target){ //_fVal: 00ds000g000f; d = dir, s = stopped, g = goto, f = energised
    unsigned int fVal = 0;
    if (cmd.dir[target]) {
     eea:	a8 2f       	mov	r26, r24
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	fd 01       	movw	r30, r26
     ef0:	ea 5e       	subi	r30, 0xEA	; 234
     ef2:	fc 4f       	sbci	r31, 0xFC	; 252
     ef4:	84 8d       	ldd	r24, Z+28	; 0x1c
     ef6:	88 23       	and	r24, r24
     ef8:	19 f0       	breq	.+6      	; 0xf00 <decodeCommand+0x178>
     efa:	20 e0       	ldi	r18, 0x00	; 0
     efc:	32 e0       	ldi	r19, 0x02	; 2
     efe:	02 c0       	rjmp	.+4      	; 0xf04 <decodeCommand+0x17c>
     f00:	20 e0       	ldi	r18, 0x00	; 0
     f02:	30 e0       	ldi	r19, 0x00	; 0
        fVal |= (1 << 9);
    }
    if (cmd.stopped[target]) {
     f04:	fd 01       	movw	r30, r26
     f06:	ea 5e       	subi	r30, 0xEA	; 234
     f08:	fc 4f       	sbci	r31, 0xFC	; 252
     f0a:	82 a1       	ldd	r24, Z+34	; 0x22
     f0c:	81 11       	cpse	r24, r1
        fVal |= (1 << 8);
     f0e:	31 60       	ori	r19, 0x01	; 1
    }
    if (cmd.gotoEn[target]) {
     f10:	fd 01       	movw	r30, r26
     f12:	ea 5e       	subi	r30, 0xEA	; 234
     f14:	fc 4f       	sbci	r31, 0xFC	; 252
     f16:	80 a1       	ldd	r24, Z+32	; 0x20
     f18:	81 11       	cpse	r24, r1
        fVal |= (1 << 4);
     f1a:	20 61       	ori	r18, 0x10	; 16
    }
    if (cmd.FVal[target]){
     f1c:	aa 5e       	subi	r26, 0xEA	; 234
     f1e:	bc 4f       	sbci	r27, 0xFC	; 252
     f20:	5e 96       	adiw	r26, 0x1e	; 30
     f22:	8c 91       	ld	r24, X
     f24:	88 23       	and	r24, r24
     f26:	09 f4       	brne	.+2      	; 0xf2a <decodeCommand+0x1a2>
     f28:	09 c1       	rjmp	.+530    	; 0x113c <decodeCommand+0x3b4>
        fVal |= (1 << 0);
     f2a:	21 60       	ori	r18, 0x01	; 1
     f2c:	07 c1       	rjmp	.+526    	; 0x113c <decodeCommand+0x3b4>
            break;
        case 'f': //readonly, return the fVal (axis status)
            responseData = cmd_fVal(axis); //response to the f command is stored in the fVal function for that axis.
            break;
        case 'j': //readonly, return the jVal (current position)
            oldSREG = SREG; 
     f2e:	8f b7       	in	r24, 0x3f	; 63
            cli();  //The next bit needs to be atomic, just in case the motors are running
     f30:	f8 94       	cli
            responseData = cmd.jVal[axis]; //response to the j command is stored in the jVal function for that axis.
     f32:	eb 2d       	mov	r30, r11
     f34:	f0 e0       	ldi	r31, 0x00	; 0
     f36:	ee 0f       	add	r30, r30
     f38:	ff 1f       	adc	r31, r31
     f3a:	ee 0f       	add	r30, r30
     f3c:	ff 1f       	adc	r31, r31
     f3e:	ea 5e       	subi	r30, 0xEA	; 234
     f40:	fc 4f       	sbci	r31, 0xFC	; 252
     f42:	20 81       	ld	r18, Z
     f44:	31 81       	ldd	r19, Z+1	; 0x01
     f46:	42 81       	ldd	r20, Z+2	; 0x02
     f48:	53 81       	ldd	r21, Z+3	; 0x03
            SREG = oldSREG;
     f4a:	8f bf       	out	0x3f, r24	; 63
     f4c:	20 c2       	rjmp	.+1088   	; 0x138e <decodeCommand+0x606>
            break;
        case 'K': //stop the motor, return empty response
            motorStop(axis,0); //normal ISR based decelleration trigger.
     f4e:	60 e0       	ldi	r22, 0x00	; 0
     f50:	0e 94 af 03 	call	0x75e	; 0x75e <motorStop>
            readyToGo[axis] = 0;
     f54:	eb 2d       	mov	r30, r11
     f56:	f0 e0       	ldi	r31, 0x00	; 0
     f58:	19 c0       	rjmp	.+50     	; 0xf8c <decodeCommand+0x204>
            break;
        case 'L':
            motorStop(axis,1); //emergency axis stop.
     f5a:	61 e0       	ldi	r22, 0x01	; 1
     f5c:	0e 94 af 03 	call	0x75e	; 0x75e <motorStop>
            motorDisable(axis); //shutdown driver power.
     f60:	8b 2d       	mov	r24, r11
     f62:	0e 94 55 01 	call	0x2aa	; 0x2aa <motorDisable>
     f66:	0f c2       	rjmp	.+1054   	; 0x1386 <decodeCommand+0x5fe>
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
     f68:	e8 2f       	mov	r30, r24
     f6a:	f0 e0       	ldi	r31, 0x00	; 0
     f6c:	df 01       	movw	r26, r30
     f6e:	aa 5e       	subi	r26, 0xEA	; 234
     f70:	bc 4f       	sbci	r27, 0xFC	; 252
     f72:	e4 01       	movw	r28, r8
     f74:	88 81       	ld	r24, Y
     f76:	80 53       	subi	r24, 0x30	; 48
     f78:	50 96       	adiw	r26, 0x10	; 16
     f7a:	8c 93       	st	X, r24
     f7c:	50 97       	sbiw	r26, 0x10	; 16
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	89 81       	ldd	r24, Y+1	; 0x01
     f82:	80 33       	cpi	r24, 0x30	; 48
     f84:	09 f0       	breq	.+2      	; 0xf88 <decodeCommand+0x200>
     f86:	91 e0       	ldi	r25, 0x01	; 1
     f88:	5c 96       	adiw	r26, 0x1c	; 28
     f8a:	9c 93       	st	X, r25
            /*if (packetIn[0] == '0'){
              packetIn[0] = '2'; //don't allow a high torque goto. But do allow a high torque slew.
            }*/
            cmd_setGVal(axis, (buffer[0] - '0')); //Store the current mode for the axis
            cmd_setDir(axis, (buffer[1] != '0') ? CMD_REVERSE : CMD_FORWARD); //Store the current direction for that axis
            readyToGo[axis] = 0;
     f8c:	e6 58       	subi	r30, 0x86	; 134
     f8e:	fd 4f       	sbci	r31, 0xFD	; 253
     f90:	10 82       	st	Z, r1
     f92:	f9 c1       	rjmp	.+1010   	; 0x1386 <decodeCommand+0x5fe>
            break;
        case 'H': //set goto position, return empty response (this sets the number of steps to move from cuurent position if in goto mode)
            cmd_setHVal(axis, synta_hexToLong(buffer)); //set the goto position container (convert string to long first)
     f94:	c4 01       	movw	r24, r8
     f96:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
     f9a:	ab 2d       	mov	r26, r11
     f9c:	b0 e0       	ldi	r27, 0x00	; 0
     f9e:	fd 01       	movw	r30, r26
     fa0:	ee 0f       	add	r30, r30
     fa2:	ff 1f       	adc	r31, r31
     fa4:	ee 0f       	add	r30, r30
     fa6:	ff 1f       	adc	r31, r31
     fa8:	ea 5e       	subi	r30, 0xEA	; 234
     faa:	fc 4f       	sbci	r31, 0xFC	; 252
     fac:	62 8b       	std	Z+18, r22	; 0x12
     fae:	73 8b       	std	Z+19, r23	; 0x13
     fb0:	84 8b       	std	Z+20, r24	; 0x14
     fb2:	95 8b       	std	Z+21, r25	; 0x15
            readyToGo[axis] = 0;
     fb4:	a6 58       	subi	r26, 0x86	; 134
     fb6:	bd 4f       	sbci	r27, 0xFD	; 253
     fb8:	1c 92       	st	X, r1
     fba:	e5 c1       	rjmp	.+970    	; 0x1386 <decodeCommand+0x5fe>
            break;
        case 'I': //set slew speed, return empty response (this sets the speed to move at if in slew mode)
            responseData = synta_hexToLong(buffer); //convert string to long first
     fbc:	c4 01       	movw	r24, r8
     fbe:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
            if (responseData < cmd.accelTable[axis][AccelTableLength-1].speed) {
     fc2:	cb 2c       	mov	r12, r11
     fc4:	dd 24       	eor	r13, r13
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
     fc6:	e6 01       	movw	r28, r12
     fc8:	cc 0f       	add	r28, r28
     fca:	dd 1f       	adc	r29, r29
     fcc:	c2 5e       	subi	r28, 0xE2	; 226
     fce:	dc 4f       	sbci	r29, 0xFC	; 252
     fd0:	20 ec       	ldi	r18, 0xC0	; 192
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	c2 9e       	mul	r12, r18
     fd6:	f0 01       	movw	r30, r0
     fd8:	c3 9e       	mul	r12, r19
     fda:	f0 0d       	add	r31, r0
     fdc:	d2 9e       	mul	r13, r18
     fde:	f0 0d       	add	r31, r0
     fe0:	11 24       	eor	r1, r1
     fe2:	e6 5c       	subi	r30, 0xC6	; 198
     fe4:	fb 4f       	sbci	r31, 0xFB	; 251
     fe6:	20 81       	ld	r18, Z
     fe8:	31 81       	ldd	r19, Z+1	; 0x01
     fea:	79 01       	movw	r14, r18
     fec:	00 e0       	ldi	r16, 0x00	; 0
     fee:	10 e0       	ldi	r17, 0x00	; 0
     ff0:	ac 01       	movw	r20, r24
     ff2:	cb 01       	movw	r24, r22
     ff4:	da 01       	movw	r26, r20
     ff6:	8e 15       	cp	r24, r14
     ff8:	9f 05       	cpc	r25, r15
     ffa:	a0 07       	cpc	r26, r16
     ffc:	b1 07       	cpc	r27, r17
     ffe:	10 f4       	brcc	.+4      	; 0x1004 <decodeCommand+0x27c>
    1000:	d8 01       	movw	r26, r16
    1002:	c7 01       	movw	r24, r14
    1004:	99 83       	std	Y+1, r25	; 0x01
    1006:	88 83       	st	Y, r24
                //Limit the IVal to the largest speed in the acceleration table to prevent sudden rapid acceleration at the end.
                responseData = cmd.accelTable[axis][AccelTableLength-1].speed; 
            }
            cmd_setIVal(axis, responseData); //set the speed container
            responseData = 0;
            if (readyToGo[axis] == 2) {
    1008:	f6 01       	movw	r30, r12
    100a:	e6 58       	subi	r30, 0x86	; 134
    100c:	fd 4f       	sbci	r31, 0xFD	; 253
    100e:	80 81       	ld	r24, Z
    1010:	82 30       	cpi	r24, 0x02	; 2
    1012:	09 f0       	breq	.+2      	; 0x1016 <decodeCommand+0x28e>
    1014:	bd cf       	rjmp	.-134    	; 0xf90 <decodeCommand+0x208>
                //If we are in a running mode which allows speed update without motor reconfiguration
                motorStart(axis); //Simply update the speed.
    1016:	8b 2d       	mov	r24, r11
    1018:	0e 94 4d 02 	call	0x49a	; 0x49a <motorStart>
    101c:	b4 c1       	rjmp	.+872    	; 0x1386 <decodeCommand+0x5fe>
                //Otherwise we are no longer ready to go until the next :J command is received
                readyToGo[axis] = 0;
            }
            break;
        case 'E': //set the current position, return empty response
            oldSREG = SREG; 
    101e:	1f b7       	in	r17, 0x3f	; 63
            cli();  //The next bit needs to be atomic, just in case the motors are running
    1020:	f8 94       	cli
            cmd_setjVal(axis, synta_hexToLong(buffer)); //set the current position (used to sync to what EQMOD thinks is the current position at startup
    1022:	c4 01       	movw	r24, r8
    1024:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
    1028:	eb 2d       	mov	r30, r11
    102a:	f0 e0       	ldi	r31, 0x00	; 0
    102c:	ee 0f       	add	r30, r30
    102e:	ff 1f       	adc	r31, r31
    1030:	ee 0f       	add	r30, r30
    1032:	ff 1f       	adc	r31, r31
    1034:	ea 5e       	subi	r30, 0xEA	; 234
    1036:	fc 4f       	sbci	r31, 0xFC	; 252
    1038:	60 83       	st	Z, r22
    103a:	71 83       	std	Z+1, r23	; 0x01
    103c:	82 83       	std	Z+2, r24	; 0x02
    103e:	93 83       	std	Z+3, r25	; 0x03
            SREG = oldSREG;
    1040:	1f bf       	out	0x3f, r17	; 63
    1042:	a1 c1       	rjmp	.+834    	; 0x1386 <decodeCommand+0x5fe>
            break;
        case 'F': //Enable the motor driver, return empty response
            if (progMode == 0) { //only allow motors to be enabled outside of programming mode.
    1044:	80 91 86 02 	lds	r24, 0x0286
    1048:	88 23       	and	r24, r24
    104a:	09 f0       	breq	.+2      	; 0x104e <decodeCommand+0x2c6>
    104c:	9b c1       	rjmp	.+822    	; 0x1384 <decodeCommand+0x5fc>
                motorEnable(axis); //This enables the motors - gives the motor driver board power
    104e:	8b 2d       	mov	r24, r11
    1050:	0e 94 38 01 	call	0x270	; 0x270 <motorEnable>
    1054:	98 c1       	rjmp	.+816    	; 0x1386 <decodeCommand+0x5fe>
            }
            break;
            
        //Command required for entering programming mode. All other programming commands cannot be used when progMode = 0 (normal ops)
        case 'O': //set the programming mode.
            progMode = buffer[0] - '0';              //MODES:  0 = Normal Ops (EQMOD). 1 = Validate EEPROM. 2 = Store to EEPROM. 3 = Rebuild EEPROM
    1056:	f4 01       	movw	r30, r8
    1058:	80 81       	ld	r24, Z
    105a:	80 53       	subi	r24, 0x30	; 48
    105c:	80 93 86 02 	sts	0x0286, r24
            if (progMode != 0) {
    1060:	88 23       	and	r24, r24
    1062:	31 f4       	brne	.+12     	; 0x1070 <decodeCommand+0x2e8>
    1064:	20 e0       	ldi	r18, 0x00	; 0
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	40 e0       	ldi	r20, 0x00	; 0
    106a:	50 e0       	ldi	r21, 0x00	; 0
    106c:	10 e0       	ldi	r17, 0x00	; 0
    106e:	90 c1       	rjmp	.+800    	; 0x1390 <decodeCommand+0x608>
                motorStop(RA,1); //emergency axis stop.
    1070:	80 e0       	ldi	r24, 0x00	; 0
    1072:	61 e0       	ldi	r22, 0x01	; 1
    1074:	0e 94 af 03 	call	0x75e	; 0x75e <motorStop>
                motorDisable(RA); //shutdown driver power.
    1078:	80 e0       	ldi	r24, 0x00	; 0
    107a:	0e 94 55 01 	call	0x2aa	; 0x2aa <motorDisable>
                motorStop(DC,1); //emergency axis stop.
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	61 e0       	ldi	r22, 0x01	; 1
    1082:	0e 94 af 03 	call	0x75e	; 0x75e <motorStop>
                motorDisable(DC); //shutdown driver power.
    1086:	81 e0       	ldi	r24, 0x01	; 1
    1088:	0e 94 55 01 	call	0x2aa	; 0x2aa <motorDisable>
                readyToGo[RA] = 0;
    108c:	10 92 7a 02 	sts	0x027A, r1
                readyToGo[DC] = 0;
    1090:	10 92 7b 02 	sts	0x027B, r1
    1094:	78 c1       	rjmp	.+752    	; 0x1386 <decodeCommand+0x5fe>
            }
            break;

        default:
            //Prevent any chance of accidentally running configuration commands when not in programming mode.
            if (progMode != 0) {
    1096:	20 91 86 02 	lds	r18, 0x0286
    109a:	22 23       	and	r18, r18
    109c:	09 f4       	brne	.+2      	; 0x10a0 <decodeCommand+0x318>
    109e:	73 c1       	rjmp	.+742    	; 0x1386 <decodeCommand+0x5fe>
                //The following are used for configuration ----------
                switch(command) {
    10a0:	8a 2d       	mov	r24, r10
    10a2:	99 27       	eor	r25, r25
    10a4:	87 fd       	sbrc	r24, 7
    10a6:	90 95       	com	r25
    10a8:	a9 2f       	mov	r26, r25
    10aa:	b9 2f       	mov	r27, r25
    10ac:	fc 01       	movw	r30, r24
    10ae:	e1 54       	subi	r30, 0x41	; 65
    10b0:	f0 40       	sbci	r31, 0x00	; 0
    10b2:	ea 33       	cpi	r30, 0x3A	; 58
    10b4:	f1 05       	cpc	r31, r1
    10b6:	08 f0       	brcs	.+2      	; 0x10ba <decodeCommand+0x332>
    10b8:	66 c1       	rjmp	.+716    	; 0x1386 <decodeCommand+0x5fe>
    10ba:	ee 58       	subi	r30, 0x8E	; 142
    10bc:	ff 4f       	sbci	r31, 0xFF	; 255
    10be:	ee 0f       	add	r30, r30
    10c0:	ff 1f       	adc	r31, r31
    10c2:	05 90       	lpm	r0, Z+
    10c4:	f4 91       	lpm	r31, Z+
    10c6:	e0 2d       	mov	r30, r0
    10c8:	09 94       	ijmp
                    case 'A': //store the aVal (steps per axis)
                        cmd_setaVal(axis, synta_hexToLong(buffer)); //store aVal for that axis.
    10ca:	c4 01       	movw	r24, r8
    10cc:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
}

inline void cmd_setaVal(byte target, unsigned long _aVal){ //Set Method
    cmd.aVal[target] = _aVal;
    10d0:	eb 2d       	mov	r30, r11
    10d2:	f0 e0       	ldi	r31, 0x00	; 0
    10d4:	ee 0f       	add	r30, r30
    10d6:	ff 1f       	adc	r31, r31
    10d8:	ee 0f       	add	r30, r30
    10da:	ff 1f       	adc	r31, r31
    10dc:	ea 5e       	subi	r30, 0xEA	; 234
    10de:	fc 4f       	sbci	r31, 0xFC	; 252
    10e0:	66 a7       	std	Z+46, r22	; 0x2e
    10e2:	77 a7       	std	Z+47, r23	; 0x2f
    10e4:	80 ab       	std	Z+48, r24	; 0x30
    10e6:	91 ab       	std	Z+49, r25	; 0x31
    10e8:	4e c1       	rjmp	.+668    	; 0x1386 <decodeCommand+0x5fe>
                        break;
                    case 'B': //store the bVal (sidereal rate)
                        cmd_setbVal(axis, synta_hexToLong(buffer)); //store bVal for that axis.
    10ea:	c4 01       	movw	r24, r8
    10ec:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
}

inline void cmd_setbVal(byte target, unsigned long _bVal){ //Set Method
    cmd.bVal[target] = _bVal;
    10f0:	eb 2d       	mov	r30, r11
    10f2:	f0 e0       	ldi	r31, 0x00	; 0
    10f4:	ee 0f       	add	r30, r30
    10f6:	ff 1f       	adc	r31, r31
    10f8:	ee 0f       	add	r30, r30
    10fa:	ff 1f       	adc	r31, r31
    10fc:	ea 5e       	subi	r30, 0xEA	; 234
    10fe:	fc 4f       	sbci	r31, 0xFC	; 252
    1100:	66 ab       	std	Z+54, r22	; 0x36
    1102:	77 ab       	std	Z+55, r23	; 0x37
    1104:	80 af       	std	Z+56, r24	; 0x38
    1106:	91 af       	std	Z+57, r25	; 0x39
    1108:	3e c1       	rjmp	.+636    	; 0x1386 <decodeCommand+0x5fe>
                        break;
                    case 'S': //store the sVal (steps per worm rotation)
                        cmd_setsVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
    110a:	c4 01       	movw	r24, r8
    110c:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
}

inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
    1110:	eb 2d       	mov	r30, r11
    1112:	f0 e0       	ldi	r31, 0x00	; 0
    1114:	ee 0f       	add	r30, r30
    1116:	ff 1f       	adc	r31, r31
    1118:	ee 0f       	add	r30, r30
    111a:	ff 1f       	adc	r31, r31
    111c:	ea 5a       	subi	r30, 0xAA	; 170
    111e:	fc 4f       	sbci	r31, 0xFC	; 252
    1120:	60 83       	st	Z, r22
    1122:	71 83       	std	Z+1, r23	; 0x01
    1124:	82 83       	std	Z+2, r24	; 0x02
    1126:	93 83       	std	Z+3, r25	; 0x03
    1128:	2e c1       	rjmp	.+604    	; 0x1386 <decodeCommand+0x5fe>
                        break;
                    case 'n': //return the IVal (EQMOD Speed at sidereal)
                        responseData = cmd.siderealIVal[axis];
    112a:	eb 2d       	mov	r30, r11
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	ee 0f       	add	r30, r30
    1130:	ff 1f       	adc	r31, r31
    1132:	e7 59       	subi	r30, 0x97	; 151
    1134:	fc 4f       	sbci	r31, 0xFC	; 252
    1136:	80 81       	ld	r24, Z
    1138:	91 81       	ldd	r25, Z+1	; 0x01
    113a:	9c 01       	movw	r18, r24
    113c:	40 e0       	ldi	r20, 0x00	; 0
    113e:	50 e0       	ldi	r21, 0x00	; 0
    1140:	26 c1       	rjmp	.+588    	; 0x138e <decodeCommand+0x606>
                        break;
                    case 'N': //store the IVal (EQMOD Speed at sidereal)
                        cmd_setsideIVal(axis, synta_hexToLong(buffer)); //store sVal for that axis.
    1142:	c4 01       	movw	r24, r8
    1144:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
    }
    return fVal;
}

inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
    1148:	eb 2d       	mov	r30, r11
    114a:	f0 e0       	ldi	r31, 0x00	; 0
    114c:	ee 0f       	add	r30, r30
    114e:	ff 1f       	adc	r31, r31
    1150:	e7 59       	subi	r30, 0x97	; 151
    1152:	fc 4f       	sbci	r31, 0xFC	; 252
    1154:	71 83       	std	Z+1, r23	; 0x01
    1156:	60 83       	st	Z, r22
    1158:	16 c1       	rjmp	.+556    	; 0x1386 <decodeCommand+0x5fe>
                        break;
                    case 'd': //return the driver version or step mode
                        if (axis) {
    115a:	bb 20       	and	r11, r11
    115c:	19 f0       	breq	.+6      	; 0x1164 <decodeCommand+0x3dc>
                            responseData = microstepConf; 
    115e:	80 91 87 02 	lds	r24, 0x0287
    1162:	5b c0       	rjmp	.+182    	; 0x121a <decodeCommand+0x492>
                        } else {
                            responseData = driverVersion;
    1164:	80 91 88 02 	lds	r24, 0x0288
    1168:	58 c0       	rjmp	.+176    	; 0x121a <decodeCommand+0x492>
                        }
                        break;
                    case 'D': //store the driver verison and step modes
                        if (axis) {
    116a:	bb 20       	and	r11, r11
    116c:	81 f0       	breq	.+32     	; 0x118e <decodeCommand+0x406>
                            microstepConf = synta_hexToByte(buffer); //store step mode.
    116e:	c4 01       	movw	r24, r8
    1170:	0e 94 24 13 	call	0x2648	; 0x2648 <_Z15synta_hexToBytePc>
    1174:	80 93 87 02 	sts	0x0287, r24
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    1178:	88 30       	cpi	r24, 0x08	; 8
    117a:	10 f4       	brcc	.+4      	; 0x1180 <decodeCommand+0x3f8>
    117c:	90 e0       	ldi	r25, 0x00	; 0
    117e:	04 c0       	rjmp	.+8      	; 0x1188 <decodeCommand+0x400>
    1180:	90 91 0c 03 	lds	r25, 0x030C
    1184:	81 e0       	ldi	r24, 0x01	; 1
    1186:	98 27       	eor	r25, r24
    1188:	90 93 0a 03 	sts	0x030A, r25
    118c:	fc c0       	rjmp	.+504    	; 0x1386 <decodeCommand+0x5fe>
                        } else {
                            driverVersion = synta_hexToByte(buffer); //store driver version.
    118e:	c4 01       	movw	r24, r8
    1190:	0e 94 24 13 	call	0x2648	; 0x2648 <_Z15synta_hexToBytePc>
    1194:	80 93 88 02 	sts	0x0288, r24
    1198:	f6 c0       	rjmp	.+492    	; 0x1386 <decodeCommand+0x5fe>
                        }
                        break;
                    case 'r': //return the dec backlash or st4 speed factor
                        if (axis) {
    119a:	bb 20       	and	r11, r11
    119c:	29 f0       	breq	.+10     	; 0x11a8 <decodeCommand+0x420>
                            responseData = cmd.st4DecBacklash; 
    119e:	80 91 67 03 	lds	r24, 0x0367
    11a2:	90 91 68 03 	lds	r25, 0x0368
    11a6:	c9 cf       	rjmp	.-110    	; 0x113a <decodeCommand+0x3b2>
                        } else {
                            responseData = cmd.st4SpeedFactor;
    11a8:	80 91 5f 03 	lds	r24, 0x035F
    11ac:	36 c0       	rjmp	.+108    	; 0x121a <decodeCommand+0x492>
                        }
                        break;
                    case 'R': //store the dec backlash or st4 speed factor
                        if (axis) {
    11ae:	bb 20       	and	r11, r11
    11b0:	89 f0       	breq	.+34     	; 0x11d4 <decodeCommand+0x44c>
                            unsigned long dataIn = synta_hexToLong(buffer); //store step mode.
    11b2:	c4 01       	movw	r24, r8
    11b4:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
                            if (dataIn > 65535) {
    11b8:	60 30       	cpi	r22, 0x00	; 0
    11ba:	f0 e0       	ldi	r31, 0x00	; 0
    11bc:	7f 07       	cpc	r23, r31
    11be:	f1 e0       	ldi	r31, 0x01	; 1
    11c0:	8f 07       	cpc	r24, r31
    11c2:	f0 e0       	ldi	r31, 0x00	; 0
    11c4:	9f 07       	cpc	r25, r31
    11c6:	08 f0       	brcs	.+2      	; 0x11ca <decodeCommand+0x442>
    11c8:	dd c0       	rjmp	.+442    	; 0x1384 <decodeCommand+0x5fc>
inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
}

inline void cmd_setst4DecBacklash(unsigned int _backlash){ //Set Method
    cmd.st4DecBacklash = _backlash;
    11ca:	70 93 68 03 	sts	0x0368, r23
    11ce:	60 93 67 03 	sts	0x0367, r22
    11d2:	d9 c0       	rjmp	.+434    	; 0x1386 <decodeCommand+0x5fe>
                                command = '\0'; //If the step rate is out of range, force an error response packet.
                            } else {
                                cmd_setst4DecBacklash(dataIn); //store st4 speed factor
                            }
                        } else {
                            byte factor = synta_hexToByte(buffer);
    11d4:	c4 01       	movw	r24, r8
    11d6:	0e 94 24 13 	call	0x2648	; 0x2648 <_Z15synta_hexToBytePc>
    11da:	98 2f       	mov	r25, r24
                            if ((factor > 19) || (factor < 1)) {
    11dc:	81 50       	subi	r24, 0x01	; 1
    11de:	83 31       	cpi	r24, 0x13	; 19
    11e0:	08 f0       	brcs	.+2      	; 0x11e4 <decodeCommand+0x45c>
    11e2:	d0 c0       	rjmp	.+416    	; 0x1384 <decodeCommand+0x5fc>
inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
}

inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
    11e4:	90 93 5f 03 	sts	0x035F, r25
    11e8:	ce c0       	rjmp	.+412    	; 0x1386 <decodeCommand+0x5fe>
                                cmd_setst4SpeedFactor(factor); //store st4 speed factor
                            }
                        }
                        break;
                    case 'z': //return the Goto speed
                        responseData = cmd.normalGotoSpeed[axis];
    11ea:	eb 2d       	mov	r30, r11
    11ec:	f0 e0       	ldi	r31, 0x00	; 0
    11ee:	ee 0f       	add	r30, r30
    11f0:	ff 1f       	adc	r31, r31
    11f2:	eb 58       	subi	r30, 0x8B	; 139
    11f4:	fc 4f       	sbci	r31, 0xFC	; 252
    11f6:	9f cf       	rjmp	.-194    	; 0x1136 <decodeCommand+0x3ae>
                        break;
                    case 'Z': //return the Goto speed factor
                        cmd.normalGotoSpeed[axis] = synta_hexToByte(buffer); //store the goto speed factor
    11f8:	c4 01       	movw	r24, r8
    11fa:	0e 94 24 13 	call	0x2648	; 0x2648 <_Z15synta_hexToBytePc>
    11fe:	eb 2d       	mov	r30, r11
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	ee 0f       	add	r30, r30
    1204:	ff 1f       	adc	r31, r31
    1206:	eb 58       	subi	r30, 0x8B	; 139
    1208:	fc 4f       	sbci	r31, 0xFC	; 252
    120a:	80 83       	st	Z, r24
    120c:	11 82       	std	Z+1, r1	; 0x01
    120e:	bb c0       	rjmp	.+374    	; 0x1386 <decodeCommand+0x5fe>
                        break;
                    case 'c': //return the axisDirectionReverse
                        responseData = encodeDirection[axis];
    1210:	eb 2d       	mov	r30, r11
    1212:	f0 e0       	ldi	r31, 0x00	; 0
    1214:	ec 57       	subi	r30, 0x7C	; 124
    1216:	fd 4f       	sbci	r31, 0xFD	; 253
    1218:	80 81       	ld	r24, Z
    121a:	28 2f       	mov	r18, r24
    121c:	30 e0       	ldi	r19, 0x00	; 0
    121e:	8e cf       	rjmp	.-228    	; 0x113c <decodeCommand+0x3b4>
                        break;
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
    1220:	eb 2d       	mov	r30, r11
    1222:	f0 e0       	ldi	r31, 0x00	; 0
    1224:	ec 57       	subi	r30, 0x7C	; 124
    1226:	fd 4f       	sbci	r31, 0xFD	; 253
    1228:	90 e0       	ldi	r25, 0x00	; 0
    122a:	d4 01       	movw	r26, r8
    122c:	8c 91       	ld	r24, X
    122e:	80 33       	cpi	r24, 0x30	; 48
    1230:	09 f0       	breq	.+2      	; 0x1234 <decodeCommand+0x4ac>
    1232:	91 e0       	ldi	r25, 0x01	; 1
    1234:	90 83       	st	Z, r25
    1236:	a7 c0       	rjmp	.+334    	; 0x1386 <decodeCommand+0x5fe>
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
    1238:	bb 20       	and	r11, r11
    123a:	81 f0       	breq	.+32     	; 0x125c <decodeCommand+0x4d4>
                            responseData = disableGearChange; 
    123c:	20 91 0c 03 	lds	r18, 0x030C
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    1240:	80 91 87 02 	lds	r24, 0x0287
    1244:	88 30       	cpi	r24, 0x08	; 8
    1246:	10 f4       	brcc	.+4      	; 0x124c <decodeCommand+0x4c4>
    1248:	80 e0       	ldi	r24, 0x00	; 0
    124a:	02 c0       	rjmp	.+4      	; 0x1250 <decodeCommand+0x4c8>
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	82 27       	eor	r24, r18
                    case 'C': //store the axisDirectionReverse
                        encodeDirection[axis] = buffer[0] - '0'; //store sVal for that axis.
                        break;
                    case 'q': //return the disableGearChange/allowAdvancedHCDetection setting  
                        if (axis) {
                            responseData = disableGearChange; 
    1250:	30 e0       	ldi	r19, 0x00	; 0
    1252:	40 e0       	ldi	r20, 0x00	; 0
    1254:	50 e0       	ldi	r21, 0x00	; 0
                            canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    1256:	80 93 0a 03 	sts	0x030A, r24
    125a:	99 c0       	rjmp	.+306    	; 0x138e <decodeCommand+0x606>
                        } else {
                            responseData = allowAdvancedHCDetection;
    125c:	80 91 0d 03 	lds	r24, 0x030D
    1260:	dc cf       	rjmp	.-72     	; 0x121a <decodeCommand+0x492>
                        }
                        break;
                    case 'Q': //store the disableGearChange/allowAdvancedHCDetection setting
                        if (axis) {
    1262:	bb 20       	and	r11, r11
    1264:	61 f0       	breq	.+24     	; 0x127e <decodeCommand+0x4f6>
                            disableGearChange = synta_hexToByte(buffer); //store whether we can change gear
    1266:	c4 01       	movw	r24, r8
    1268:	0e 94 24 13 	call	0x2648	; 0x2648 <_Z15synta_hexToBytePc>
    126c:	10 92 0c 03 	sts	0x030C, r1
    1270:	88 23       	and	r24, r24
    1272:	09 f4       	brne	.+2      	; 0x1276 <decodeCommand+0x4ee>
    1274:	88 c0       	rjmp	.+272    	; 0x1386 <decodeCommand+0x5fe>
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	80 93 0c 03 	sts	0x030C, r24
    127c:	84 c0       	rjmp	.+264    	; 0x1386 <decodeCommand+0x5fe>
                        } else {
                            allowAdvancedHCDetection = synta_hexToByte(buffer); //store whether to allow advanced hand controller detection
    127e:	c4 01       	movw	r24, r8
    1280:	0e 94 24 13 	call	0x2648	; 0x2648 <_Z15synta_hexToBytePc>
    1284:	10 92 0d 03 	sts	0x030D, r1
    1288:	88 23       	and	r24, r24
    128a:	09 f4       	brne	.+2      	; 0x128e <decodeCommand+0x506>
    128c:	7c c0       	rjmp	.+248    	; 0x1386 <decodeCommand+0x5fe>
    128e:	81 e0       	ldi	r24, 0x01	; 1
    1290:	80 93 0d 03 	sts	0x030D, r24
    1294:	78 c0       	rjmp	.+240    	; 0x1386 <decodeCommand+0x5fe>
    struct {
        Byter lowByter;
        Byter highByter;
    };
    InterMaker(unsigned long _integer){
        integer = _integer;
    1296:	20 e0       	ldi	r18, 0x00	; 0
    1298:	30 e0       	ldi	r19, 0x00	; 0
    129a:	40 e0       	ldi	r20, 0x00	; 0
    129c:	50 e0       	ldi	r21, 0x00	; 0
                        }
                        break;
                    case 'x': {  //return the accelTable
                        Inter responsePack = InterMaker(0);
                        responsePack.lowByter.integer = cmd.accelTable[axis][accelTableIndex[axis]].speed;
    129e:	6b 2d       	mov	r22, r11
    12a0:	70 e0       	ldi	r23, 0x00	; 0
    12a2:	eb 01       	movw	r28, r22
    12a4:	cc 5e       	subi	r28, 0xEC	; 236
    12a6:	dc 4f       	sbci	r29, 0xFC	; 252
    12a8:	a8 81       	ld	r26, Y
    12aa:	8a 2f       	mov	r24, r26
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	fc 01       	movw	r30, r24
    12b0:	ee 0f       	add	r30, r30
    12b2:	ff 1f       	adc	r31, r31
    12b4:	e8 0f       	add	r30, r24
    12b6:	f9 1f       	adc	r31, r25
    12b8:	80 ec       	ldi	r24, 0xC0	; 192
    12ba:	90 e0       	ldi	r25, 0x00	; 0
    12bc:	8c 01       	movw	r16, r24
    12be:	60 9f       	mul	r22, r16
    12c0:	c0 01       	movw	r24, r0
    12c2:	61 9f       	mul	r22, r17
    12c4:	90 0d       	add	r25, r0
    12c6:	70 9f       	mul	r23, r16
    12c8:	90 0d       	add	r25, r0
    12ca:	11 24       	eor	r1, r1
    12cc:	e8 0f       	add	r30, r24
    12ce:	f9 1f       	adc	r31, r25
    12d0:	ea 5e       	subi	r30, 0xEA	; 234
    12d2:	fc 4f       	sbci	r31, 0xFC	; 252
    12d4:	e9 59       	subi	r30, 0x99	; 153
    12d6:	ff 4f       	sbci	r31, 0xFF	; 255
    12d8:	21 91       	ld	r18, Z+
    12da:	31 91       	ld	r19, Z+
                        responsePack.highByter.low = cmd.accelTable[axis][accelTableIndex[axis]].repeats; 
    12dc:	40 81       	ld	r20, Z
                        responseData = responsePack.integer;
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if reading sequentially.
    12de:	af 5f       	subi	r26, 0xFF	; 255
    12e0:	a8 83       	st	Y, r26
                        if (accelTableIndex[axis] >= AccelTableLength) {
    12e2:	a0 34       	cpi	r26, 0x40	; 64
    12e4:	08 f4       	brcc	.+2      	; 0x12e8 <decodeCommand+0x560>
    12e6:	53 c0       	rjmp	.+166    	; 0x138e <decodeCommand+0x606>
                            accelTableIndex[axis] = 0; //Wrap around
    12e8:	18 82       	st	Y, r1
    12ea:	51 c0       	rjmp	.+162    	; 0x138e <decodeCommand+0x606>
                        }
                        break;
                    }
                    case 'X': { //store the accelTable value for address set by 'Y', or next address after last 'X'
                        unsigned long dataIn = synta_hexToLong(buffer);
    12ec:	c4 01       	movw	r24, r8
    12ee:	0e 94 27 13 	call	0x264e	; 0x264e <_Z15synta_hexToLongPc>
                        cmd.accelTable[axis][accelTableIndex[axis]].speed = (unsigned int)dataIn; //lower two bytes is speed
    12f2:	4b 2d       	mov	r20, r11
    12f4:	50 e0       	ldi	r21, 0x00	; 0
    12f6:	ea 01       	movw	r28, r20
    12f8:	cc 5e       	subi	r28, 0xEC	; 236
    12fa:	dc 4f       	sbci	r29, 0xFC	; 252
    12fc:	a8 81       	ld	r26, Y
    12fe:	2a 2f       	mov	r18, r26
    1300:	30 e0       	ldi	r19, 0x00	; 0
    1302:	f9 01       	movw	r30, r18
    1304:	ee 0f       	add	r30, r30
    1306:	ff 1f       	adc	r31, r31
    1308:	e2 0f       	add	r30, r18
    130a:	f3 1f       	adc	r31, r19
    130c:	20 ec       	ldi	r18, 0xC0	; 192
    130e:	30 e0       	ldi	r19, 0x00	; 0
    1310:	89 01       	movw	r16, r18
    1312:	40 9f       	mul	r20, r16
    1314:	90 01       	movw	r18, r0
    1316:	41 9f       	mul	r20, r17
    1318:	30 0d       	add	r19, r0
    131a:	50 9f       	mul	r21, r16
    131c:	30 0d       	add	r19, r0
    131e:	11 24       	eor	r1, r1
    1320:	e2 0f       	add	r30, r18
    1322:	f3 1f       	adc	r31, r19
    1324:	ea 5e       	subi	r30, 0xEA	; 234
    1326:	fc 4f       	sbci	r31, 0xFC	; 252
    1328:	e9 59       	subi	r30, 0x99	; 153
    132a:	ff 4f       	sbci	r31, 0xFF	; 255
    132c:	61 93       	st	Z+, r22
    132e:	71 93       	st	Z+, r23
                        cmd.accelTable[axis][accelTableIndex[axis]].repeats = (byte)(dataIn>>16); //upper byte is repeats.
    1330:	bc 01       	movw	r22, r24
    1332:	88 27       	eor	r24, r24
    1334:	99 27       	eor	r25, r25
    1336:	60 83       	st	Z, r22
                        accelTableIndex[axis]++; //increment the index so we don't have to send :Y commands for every address if programming sequentially.
    1338:	af 5f       	subi	r26, 0xFF	; 255
    133a:	a8 83       	st	Y, r26
                        if (accelTableIndex[axis] >= AccelTableLength) {
    133c:	a0 34       	cpi	r26, 0x40	; 64
    133e:	18 f1       	brcs	.+70     	; 0x1386 <decodeCommand+0x5fe>
                            accelTableIndex[axis] = 0; //Wrap around
    1340:	18 82       	st	Y, r1
    1342:	21 c0       	rjmp	.+66     	; 0x1386 <decodeCommand+0x5fe>
                        }
                        break;
                    }
                    case 'Y': //store the accelTableIndex value
                        //Use axis=0 to set which address we are accessing (we'll repurpose accelTableIndex[RA] in prog mode for this)
                        accelTableIndex[axis] = synta_hexToByte(buffer);
    1344:	c4 01       	movw	r24, r8
    1346:	0e 94 24 13 	call	0x2648	; 0x2648 <_Z15synta_hexToBytePc>
    134a:	eb 2d       	mov	r30, r11
    134c:	f0 e0       	ldi	r31, 0x00	; 0
    134e:	ec 5e       	subi	r30, 0xEC	; 236
    1350:	fc 4f       	sbci	r31, 0xFC	; 252
    1352:	80 83       	st	Z, r24
                        if (accelTableIndex[axis] >= AccelTableLength) {
    1354:	80 34       	cpi	r24, 0x40	; 64
    1356:	b0 f4       	brcc	.+44     	; 0x1384 <decodeCommand+0x5fc>
    1358:	16 c0       	rjmp	.+44     	; 0x1386 <decodeCommand+0x5fe>
                            command = '\0'; //If the address out of range, force an error response packet.
                        }
                        break;
                    case 'T': //set mode, return empty response
                        if (progMode & 2) {
    135a:	82 2f       	mov	r24, r18
    135c:	90 e0       	ldi	r25, 0x00	; 0
    135e:	9c 01       	movw	r18, r24
    1360:	21 70       	andi	r18, 0x01	; 1
    1362:	30 70       	andi	r19, 0x00	; 0
    1364:	81 ff       	sbrs	r24, 1
    1366:	08 c0       	rjmp	.+16     	; 0x1378 <decodeCommand+0x5f0>
                        //proceed with eeprom write
                            if (progMode & 1) {
    1368:	23 2b       	or	r18, r19
    136a:	19 f0       	breq	.+6      	; 0x1372 <decodeCommand+0x5ea>
                                buildEEPROM();
    136c:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <buildEEPROM>
    1370:	0a c0       	rjmp	.+20     	; 0x1386 <decodeCommand+0x5fe>
                            } else {
                                storeEEPROM();
    1372:	0e 94 b0 05 	call	0xb60	; 0xb60 <storeEEPROM>
    1376:	07 c0       	rjmp	.+14     	; 0x1386 <decodeCommand+0x5fe>
                            }
                        } else if (progMode & 1) {
    1378:	23 2b       	or	r18, r19
    137a:	29 f0       	breq	.+10     	; 0x1386 <decodeCommand+0x5fe>
                            if (!checkEEPROM()) { //check if EEPROM contains valid data.
    137c:	0e 94 62 06 	call	0xcc4	; 0xcc4 <checkEEPROM>
    1380:	88 23       	and	r24, r24
    1382:	09 f4       	brne	.+2      	; 0x1386 <decodeCommand+0x5fe>
    1384:	aa 24       	eor	r10, r10
    1386:	20 e0       	ldi	r18, 0x00	; 0
    1388:	30 e0       	ldi	r19, 0x00	; 0
    138a:	40 e0       	ldi	r20, 0x00	; 0
    138c:	50 e0       	ldi	r21, 0x00	; 0
    138e:	11 e0       	ldi	r17, 0x01	; 1
                }
            }
            break;
    }
  
    synta_assembleResponse(buffer, command, responseData); //generate correct response (this is required as is)
    1390:	c4 01       	movw	r24, r8
    1392:	6a 2d       	mov	r22, r10
    1394:	0e 94 c2 13 	call	0x2784	; 0x2784 <_Z22synta_assembleResponsePccm>
    
    if ((command == 'J') && (progMode == 0)) { //J tells us we are ready to begin the requested movement.
    1398:	2a e4       	ldi	r18, 0x4A	; 74
    139a:	a2 16       	cp	r10, r18
    139c:	89 f4       	brne	.+34     	; 0x13c0 <decodeCommand+0x638>
    139e:	80 91 86 02 	lds	r24, 0x0286
    13a2:	88 23       	and	r24, r24
    13a4:	69 f4       	brne	.+26     	; 0x13c0 <decodeCommand+0x638>
        readyToGo[axis] = 1; //So signal we are ready to go and when the last movement complets this one will execute.
    13a6:	8b 2d       	mov	r24, r11
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	fc 01       	movw	r30, r24
    13ac:	e6 58       	subi	r30, 0x86	; 134
    13ae:	fd 4f       	sbci	r31, 0xFD	; 253
    13b0:	21 e0       	ldi	r18, 0x01	; 1
    13b2:	20 83       	st	Z, r18
        if (!(cmd.GVal[axis] & 1)){
    13b4:	fc 01       	movw	r30, r24
    13b6:	ea 5e       	subi	r30, 0xEA	; 234
    13b8:	fc 4f       	sbci	r31, 0xFC	; 252
    13ba:	80 89       	ldd	r24, Z+16	; 0x10
    13bc:	80 ff       	sbrs	r24, 0
inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
    13be:	20 a3       	std	Z+32, r18	; 0x20
            //If go-to mode requested
            cmd_setGotoEn(axis,CMD_ENABLED);
        }
    }
    return success;
}
    13c0:	81 2f       	mov	r24, r17
    13c2:	df 91       	pop	r29
    13c4:	cf 91       	pop	r28
    13c6:	1f 91       	pop	r17
    13c8:	0f 91       	pop	r16
    13ca:	ff 90       	pop	r15
    13cc:	ef 90       	pop	r14
    13ce:	df 90       	pop	r13
    13d0:	cf 90       	pop	r12
    13d2:	bf 90       	pop	r11
    13d4:	af 90       	pop	r10
    13d6:	9f 90       	pop	r9
    13d8:	8f 90       	pop	r8
    13da:	08 95       	ret

000013dc <calculateRate>:
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
}

void calculateRate(byte axis){
    13dc:	2f 92       	push	r2
    13de:	3f 92       	push	r3
    13e0:	4f 92       	push	r4
    13e2:	5f 92       	push	r5
    13e4:	6f 92       	push	r6
    13e6:	7f 92       	push	r7
    13e8:	8f 92       	push	r8
    13ea:	9f 92       	push	r9
    13ec:	af 92       	push	r10
    13ee:	bf 92       	push	r11
    13f0:	cf 92       	push	r12
    13f2:	df 92       	push	r13
    13f4:	ef 92       	push	r14
    13f6:	ff 92       	push	r15
    13f8:	0f 93       	push	r16
    13fa:	1f 93       	push	r17
    13fc:	cf 93       	push	r28
    13fe:	df 93       	push	r29
  
    unsigned long rate;
    unsigned long remainder;
    float floatRemainder;
    unsigned long divisor = cmd.bVal[axis];
    1400:	c8 2f       	mov	r28, r24
    1402:	d0 e0       	ldi	r29, 0x00	; 0
    1404:	fe 01       	movw	r30, r28
    1406:	ee 0f       	add	r30, r30
    1408:	ff 1f       	adc	r31, r31
    140a:	ee 0f       	add	r30, r30
    140c:	ff 1f       	adc	r31, r31
    140e:	ea 5e       	subi	r30, 0xEA	; 234
    1410:	fc 4f       	sbci	r31, 0xFC	; 252
    1412:	a6 a8       	ldd	r10, Z+54	; 0x36
    1414:	b7 a8       	ldd	r11, Z+55	; 0x37
    1416:	c0 ac       	ldd	r12, Z+56	; 0x38
    1418:	d1 ac       	ldd	r13, Z+57	; 0x39
    byte distWidth = DecimalDistnWidth;
    
    //When dividing a very large number by a much smaller on, float accuracy is abismal. So firstly we use integer math to split the division into quotient and remainder
    rate = timerCountRate / divisor; //Calculate the quotient
    141a:	60 e0       	ldi	r22, 0x00	; 0
    141c:	72 e1       	ldi	r23, 0x12	; 18
    141e:	8a e7       	ldi	r24, 0x7A	; 122
    1420:	90 e0       	ldi	r25, 0x00	; 0
    1422:	a6 01       	movw	r20, r12
    1424:	95 01       	movw	r18, r10
    1426:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <__udivmodsi4>
    142a:	c9 01       	movw	r24, r18
    142c:	da 01       	movw	r26, r20
    142e:	3c 01       	movw	r6, r24
    1430:	4d 01       	movw	r8, r26
    remainder = timerCountRate % divisor; //Calculate the remainder
    
    //Then convert the remainder into a decimal number (division of a small number by a larger one, improving accuracy)
    floatRemainder = (float)remainder/(float)divisor; //Convert the remainder to a decimal.
    1432:	60 e0       	ldi	r22, 0x00	; 0
    1434:	72 e1       	ldi	r23, 0x12	; 18
    1436:	8a e7       	ldi	r24, 0x7A	; 122
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	a6 01       	movw	r20, r12
    143c:	95 01       	movw	r18, r10
    143e:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <__udivmodsi4>
    1442:	0e 94 4e 15 	call	0x2a9c	; 0x2a9c <__floatunsisf>
    1446:	7b 01       	movw	r14, r22
    1448:	8c 01       	movw	r16, r24
    144a:	c6 01       	movw	r24, r12
    144c:	b5 01       	movw	r22, r10
    144e:	0e 94 4e 15 	call	0x2a9c	; 0x2a9c <__floatunsisf>
    1452:	9b 01       	movw	r18, r22
    1454:	ac 01       	movw	r20, r24
    1456:	c8 01       	movw	r24, r16
    1458:	b7 01       	movw	r22, r14
    145a:	0e 94 ba 14 	call	0x2974	; 0x2974 <__divsf3>
    
    //Multiply the remainder by distributionWidth to work out an approximate number of extra clocks needed per full step (each step is 'distributionWidth' microsteps)
    floatRemainder *= (float)distWidth; 
    //This many extra cycles are needed:
    remainder = (unsigned long)(floatRemainder+0.5f); 
    145e:	20 e0       	ldi	r18, 0x00	; 0
    1460:	30 e0       	ldi	r19, 0x00	; 0
    1462:	40 e0       	ldi	r20, 0x00	; 0
    1464:	52 e4       	ldi	r21, 0x42	; 66
    1466:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <__mulsf3>
    146a:	20 e0       	ldi	r18, 0x00	; 0
    146c:	30 e0       	ldi	r19, 0x00	; 0
    146e:	40 e0       	ldi	r20, 0x00	; 0
    1470:	5f e3       	ldi	r21, 0x3F	; 63
    1472:	0e 94 43 14 	call	0x2886	; 0x2886 <__addsf3>
    1476:	0e 94 22 15 	call	0x2a44	; 0x2a44 <__fixunssfsi>
    147a:	1b 01       	movw	r2, r22
    147c:	2c 01       	movw	r4, r24
    
    //Now truncate to an unsigned int with a sensible max value (the int is to avoid register issues with the 16 bit timer)
    if((unsigned int)(rate >> 16)){
    147e:	c4 01       	movw	r24, r8
    1480:	aa 27       	eor	r26, r26
    1482:	bb 27       	eor	r27, r27
    1484:	89 2b       	or	r24, r25
    1486:	39 f0       	breq	.+14     	; 0x1496 <calculateRate+0xba>
    1488:	5f ef       	ldi	r21, 0xFF	; 255
    148a:	65 2e       	mov	r6, r21
    148c:	5f ef       	ldi	r21, 0xFF	; 255
    148e:	75 2e       	mov	r7, r21
    1490:	81 2c       	mov	r8, r1
    1492:	91 2c       	mov	r9, r1
    1494:	0b c0       	rjmp	.+22     	; 0x14ac <calculateRate+0xd0>
        rate = 65535UL;
    } else if (rate < 128UL) {
    1496:	80 e8       	ldi	r24, 0x80	; 128
    1498:	68 16       	cp	r6, r24
    149a:	71 04       	cpc	r7, r1
    149c:	81 04       	cpc	r8, r1
    149e:	91 04       	cpc	r9, r1
    14a0:	28 f4       	brcc	.+10     	; 0x14ac <calculateRate+0xd0>
    14a2:	40 e8       	ldi	r20, 0x80	; 128
    14a4:	64 2e       	mov	r6, r20
    14a6:	71 2c       	mov	r7, r1
    14a8:	81 2c       	mov	r8, r1
    14aa:	91 2c       	mov	r9, r1
    14ac:	fe 01       	movw	r30, r28
    14ae:	36 e0       	ldi	r19, 0x06	; 6
    14b0:	ee 0f       	add	r30, r30
    14b2:	ff 1f       	adc	r31, r31
    14b4:	3a 95       	dec	r19
    14b6:	e1 f7       	brne	.-8      	; 0x14b0 <calculateRate+0xd4>
    14b8:	e6 57       	subi	r30, 0x76	; 118
    14ba:	fd 4f       	sbci	r31, 0xFD	; 253
    14bc:	80 e0       	ldi	r24, 0x00	; 0
  
    for (byte i = 0; i < distWidth; i++){
#if defined(__AVR_ATmega162__)
        timerOVF[axis][i] = rate; //Subtract 1 as timer is 0 indexed.
#else
        timerOVF[axis][i] = rate; //Hmm, for some reason this one doesn't need 1 subtracting???
    14be:	61 92       	st	Z+, r6
    14c0:	71 92       	st	Z+, r7
    }
#if defined(__AVR_ATmega162__)
    rate--;
#endif
  
    for (byte i = 0; i < distWidth; i++){
    14c2:	8f 5f       	subi	r24, 0xFF	; 255
    14c4:	80 32       	cpi	r24, 0x20	; 32
    14c6:	d9 f7       	brne	.-10     	; 0x14be <calculateRate+0xe2>
    14c8:	aa 24       	eor	r10, r10
    14ca:	bb 24       	eor	r11, r11
    14cc:	65 01       	movw	r12, r10
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
        distn *= (float)distWidth;
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    14ce:	25 e0       	ldi	r18, 0x05	; 5
    14d0:	cc 0f       	add	r28, r28
    14d2:	dd 1f       	adc	r29, r29
    14d4:	2a 95       	dec	r18
    14d6:	e1 f7       	brne	.-8      	; 0x14d0 <calculateRate+0xf4>
    14d8:	2b c0       	rjmp	.+86     	; 0x1530 <calculateRate+0x154>
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
        float distn = i;
    14da:	c6 01       	movw	r24, r12
    14dc:	b5 01       	movw	r22, r10
    14de:	0e 94 4e 15 	call	0x2a9c	; 0x2a9c <__floatunsisf>
        distn *= (float)distWidth;
    14e2:	20 e0       	ldi	r18, 0x00	; 0
    14e4:	30 e0       	ldi	r19, 0x00	; 0
    14e6:	40 e0       	ldi	r20, 0x00	; 0
    14e8:	52 e4       	ldi	r21, 0x42	; 66
    14ea:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <__mulsf3>
    14ee:	7b 01       	movw	r14, r22
    14f0:	8c 01       	movw	r16, r24
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
    14f2:	c2 01       	movw	r24, r4
    14f4:	b1 01       	movw	r22, r2
    14f6:	0e 94 4e 15 	call	0x2a9c	; 0x2a9c <__floatunsisf>
    14fa:	9b 01       	movw	r18, r22
    14fc:	ac 01       	movw	r20, r24
    14fe:	c8 01       	movw	r24, r16
    1500:	b7 01       	movw	r22, r14
    1502:	0e 94 ba 14 	call	0x2974	; 0x2974 <__divsf3>
    1506:	0e 94 a7 14 	call	0x294e	; 0x294e <ceil>
        timerOVF[axis][index] += 1;
    150a:	0e 94 22 15 	call	0x2a44	; 0x2a44 <__fixunssfsi>
    150e:	fe 01       	movw	r30, r28
    1510:	e6 0f       	add	r30, r22
    1512:	f1 1d       	adc	r31, r1
    1514:	ee 0f       	add	r30, r30
    1516:	ff 1f       	adc	r31, r31
    1518:	e6 57       	subi	r30, 0x76	; 118
    151a:	fd 4f       	sbci	r31, 0xFD	; 253
    151c:	80 81       	ld	r24, Z
    151e:	91 81       	ldd	r25, Z+1	; 0x01
    1520:	01 96       	adiw	r24, 0x01	; 1
    1522:	91 83       	std	Z+1, r25	; 0x01
    1524:	80 83       	st	Z, r24
        timerOVF[axis][i] = rate; //Hmm, for some reason this one doesn't need 1 subtracting???
#endif
    }
  
    //evenly distribute the required number of extra clocks over the full step.
    for (unsigned long i = 0; i < remainder; i++){
    1526:	08 94       	sec
    1528:	a1 1c       	adc	r10, r1
    152a:	b1 1c       	adc	r11, r1
    152c:	c1 1c       	adc	r12, r1
    152e:	d1 1c       	adc	r13, r1
    1530:	a2 14       	cp	r10, r2
    1532:	b3 04       	cpc	r11, r3
    1534:	c4 04       	cpc	r12, r4
    1536:	d5 04       	cpc	r13, r5
    1538:	80 f2       	brcs	.-96     	; 0x14da <calculateRate+0xfe>
        distn /= (float)remainder;
        byte index = (byte)ceil(distn);
        timerOVF[axis][index] += 1;
    }
    
}
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	1f 91       	pop	r17
    1540:	0f 91       	pop	r16
    1542:	ff 90       	pop	r15
    1544:	ef 90       	pop	r14
    1546:	df 90       	pop	r13
    1548:	cf 90       	pop	r12
    154a:	bf 90       	pop	r11
    154c:	af 90       	pop	r10
    154e:	9f 90       	pop	r9
    1550:	8f 90       	pop	r8
    1552:	7f 90       	pop	r7
    1554:	6f 90       	pop	r6
    1556:	5f 90       	pop	r5
    1558:	4f 90       	pop	r4
    155a:	3f 90       	pop	r3
    155c:	2f 90       	pop	r2
    155e:	08 95       	ret

00001560 <systemInitialiser>:

void systemInitialiser(){    
    
    encodeDirection[RA] = EEPROM_readByte(RAReverse_Address) ? CMD_REVERSE : CMD_FORWARD;  //reverse the right ascension if 1
    1560:	89 e0       	ldi	r24, 0x09	; 9
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    1568:	10 92 84 02 	sts	0x0284, r1
    156c:	88 23       	and	r24, r24
    156e:	19 f0       	breq	.+6      	; 0x1576 <systemInitialiser+0x16>
    1570:	81 e0       	ldi	r24, 0x01	; 1
    1572:	80 93 84 02 	sts	0x0284, r24
    encodeDirection[DC] = EEPROM_readByte(DECReverse_Address) ? CMD_REVERSE : CMD_FORWARD; //reverse the declination if 1
    1576:	8a e0       	ldi	r24, 0x0A	; 10
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    157e:	10 92 85 02 	sts	0x0285, r1
    1582:	88 23       	and	r24, r24
    1584:	19 f0       	breq	.+6      	; 0x158c <systemInitialiser+0x2c>
    1586:	81 e0       	ldi	r24, 0x01	; 1
    1588:	80 93 85 02 	sts	0x0285, r24
    
    driverVersion = EEPROM_readByte(Driver_Address);
    158c:	8b e0       	ldi	r24, 0x0B	; 11
    158e:	90 e0       	ldi	r25, 0x00	; 0
    1590:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    1594:	80 93 88 02 	sts	0x0288, r24
    microstepConf = EEPROM_readByte(Microstep_Address);
    1598:	88 e0       	ldi	r24, 0x08	; 8
    159a:	90 e0       	ldi	r25, 0x00	; 0
    159c:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    15a0:	80 93 87 02 	sts	0x0287, r24

    allowAdvancedHCDetection = !EEPROM_readByte(AdvHCEnable_Address);
    15a4:	8b e2       	ldi	r24, 0x2B	; 43
    15a6:	90 e0       	ldi	r25, 0x00	; 0
    15a8:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    15ac:	10 92 0d 03 	sts	0x030D, r1
    15b0:	88 23       	and	r24, r24
    15b2:	19 f4       	brne	.+6      	; 0x15ba <systemInitialiser+0x5a>
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	80 93 0d 03 	sts	0x030D, r24
    
    defaultSpeedState = (microstepConf >= 8) ? SPEEDNORM : SPEEDFAST;
    15ba:	10 92 0b 03 	sts	0x030B, r1
    15be:	80 91 87 02 	lds	r24, 0x0287
    15c2:	88 30       	cpi	r24, 0x08	; 8
    15c4:	18 f4       	brcc	.+6      	; 0x15cc <systemInitialiser+0x6c>
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	80 93 0b 03 	sts	0x030B, r24
    disableGearChange = !EEPROM_readByte(GearEnable_Address);
    15cc:	8a e2       	ldi	r24, 0x2A	; 42
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    15d4:	90 e0       	ldi	r25, 0x00	; 0
    15d6:	88 23       	and	r24, r24
    15d8:	09 f4       	brne	.+2      	; 0x15dc <systemInitialiser+0x7c>
    15da:	91 e0       	ldi	r25, 0x01	; 1
    15dc:	90 93 0c 03 	sts	0x030C, r25
    canJumpToHighspeed = (microstepConf >= 8) && !disableGearChange; //Gear change is enabled if the microstep mode can change by a factor of 8.
    15e0:	80 91 87 02 	lds	r24, 0x0287
    15e4:	88 30       	cpi	r24, 0x08	; 8
    15e6:	10 f4       	brcc	.+4      	; 0x15ec <systemInitialiser+0x8c>
    15e8:	80 e0       	ldi	r24, 0x00	; 0
    15ea:	02 c0       	rjmp	.+4      	; 0x15f0 <systemInitialiser+0x90>
    15ec:	81 e0       	ldi	r24, 0x01	; 1
    15ee:	89 27       	eor	r24, r25
    15f0:	80 93 0a 03 	sts	0x030A, r24
        
    synta_initialise(ASTROEQ_VER,(canJumpToHighspeed ? 8 : 1)); //initialise mount instance, specify version!
    15f4:	88 23       	and	r24, r24
    15f6:	11 f4       	brne	.+4      	; 0x15fc <systemInitialiser+0x9c>
    15f8:	41 e0       	ldi	r20, 0x01	; 1
    15fa:	01 c0       	rjmp	.+2      	; 0x15fe <systemInitialiser+0x9e>
    15fc:	48 e0       	ldi	r20, 0x08	; 8
    15fe:	62 e2       	ldi	r22, 0x22	; 34
    1600:	73 e0       	ldi	r23, 0x03	; 3
    1602:	80 e0       	ldi	r24, 0x00	; 0
    1604:	90 e0       	ldi	r25, 0x00	; 0
    1606:	0e 94 32 14 	call	0x2864	; 0x2864 <_Z16synta_initialisemh>
    
    buildModeMapping(microstepConf, driverVersion);
    160a:	80 91 87 02 	lds	r24, 0x0287
    160e:	60 91 88 02 	lds	r22, 0x0288
    1612:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <buildModeMapping>
    
    if(!checkEEPROM()){
    1616:	0e 94 62 06 	call	0xcc4	; 0xcc4 <checkEEPROM>
    161a:	88 23       	and	r24, r24
    161c:	19 f4       	brne	.+6      	; 0x1624 <systemInitialiser+0xc4>
        progMode = PROGMODE; //prevent AstroEQ startup if EEPROM is blank.
    161e:	81 e0       	ldi	r24, 0x01	; 1
    1620:	80 93 86 02 	sts	0x0286, r24
    }

    calculateRate(RA); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	0e 94 ee 09 	call	0x13dc	; 0x13dc <calculateRate>
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    162a:	81 e0       	ldi	r24, 0x01	; 1
    162c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <calculateRate>
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    1630:	40 91 75 03 	lds	r20, 0x0375
    1634:	50 91 76 03 	lds	r21, 0x0376
    1638:	ed e7       	ldi	r30, 0x7D	; 125
    163a:	f3 e0       	ldi	r31, 0x03	; 3
    163c:	20 e0       	ldi	r18, 0x00	; 0
    163e:	30 e0       	ldi	r19, 0x00	; 0
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
    1640:	80 81       	ld	r24, Z
    1642:	91 81       	ldd	r25, Z+1	; 0x01
    1644:	48 17       	cp	r20, r24
    1646:	59 07       	cpc	r21, r25
    1648:	50 f4       	brcc	.+20     	; 0x165e <systemInitialiser+0xfe>
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
    164a:	82 81       	ldd	r24, Z+2	; 0x02
    164c:	90 e0       	ldi	r25, 0x00	; 0
    164e:	01 96       	adiw	r24, 0x01	; 1
    1650:	28 0f       	add	r18, r24
    1652:	39 1f       	adc	r19, r25
    1654:	33 96       	adiw	r30, 0x03	; 3

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
    1656:	84 e0       	ldi	r24, 0x04	; 4
    1658:	ed 33       	cpi	r30, 0x3D	; 61
    165a:	f8 07       	cpc	r31, r24
    165c:	89 f7       	brne	.-30     	; 0x1640 <systemInitialiser+0xe0>
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
    165e:	30 93 0f 03 	sts	0x030F, r19
    1662:	20 93 0e 03 	sts	0x030E, r18
 * System Initialisation Routines
 */

void calculateDecelerationLength (byte axis){

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    1666:	40 91 77 03 	lds	r20, 0x0377
    166a:	50 91 78 03 	lds	r21, 0x0378
    166e:	ed e3       	ldi	r30, 0x3D	; 61
    1670:	f4 e0       	ldi	r31, 0x04	; 4
    1672:	20 e0       	ldi	r18, 0x00	; 0
    1674:	30 e0       	ldi	r19, 0x00	; 0
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
        if (cmd.accelTable[axis][lookupTableIndex].speed <= gotoSpeed) {
    1676:	80 81       	ld	r24, Z
    1678:	91 81       	ldd	r25, Z+1	; 0x01
    167a:	48 17       	cp	r20, r24
    167c:	59 07       	cpc	r21, r25
    167e:	50 f4       	brcc	.+20     	; 0x1694 <systemInitialiser+0x134>
            //If we have reached the element at which we are now at the right speed
            break; //We have calculated the number of accel steps and therefore number of decel steps.
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
    1680:	82 81       	ldd	r24, Z+2	; 0x02
    1682:	90 e0       	ldi	r25, 0x00	; 0
    1684:	01 96       	adiw	r24, 0x01	; 1
    1686:	28 0f       	add	r18, r24
    1688:	39 1f       	adc	r19, r25
    168a:	33 96       	adiw	r30, 0x03	; 3

    unsigned int gotoSpeed = cmd.normalGotoSpeed[axis];
    byte lookupTableIndex = 0;
    unsigned int numberOfSteps = 0;
    //Work through the acceleration table until we get to the right speed (accel and decel are same number of steps)
    while(lookupTableIndex < AccelTableLength) {
    168c:	84 e0       	ldi	r24, 0x04	; 4
    168e:	ed 3f       	cpi	r30, 0xFD	; 253
    1690:	f8 07       	cpc	r31, r24
    1692:	89 f7       	brne	.-30     	; 0x1676 <systemInitialiser+0x116>
        }
        numberOfSteps = numberOfSteps + cmd.accelTable[axis][lookupTableIndex].repeats + 1; //Add on the number of steps at this speed (1 step + number of repeats)
        lookupTableIndex++;
    }
    //number of steps now contains how many steps required to slow to a stop.
    gotoDecelerationLength[axis] = numberOfSteps;
    1694:	30 93 11 03 	sts	0x0311, r19
    1698:	20 93 10 03 	sts	0x0310, r18
    calculateRate(DC); //Initialise the interrupt speed table. This now only has to be done once at the beginning.
    calculateDecelerationLength(RA);
    calculateDecelerationLength(DC);
    
    //Status pin to output low
    setPinDir  (statusPin,OUTPUT);
    169c:	27 9a       	sbi	0x04, 7	; 4
    setPinValue(statusPin,   LOW);
    169e:	2f 98       	cbi	0x05, 7	; 5

    //Standalone Speed/IRQ pin to input no-pullup
    setPinDir  (standalonePin[  STANDALONE_IRQ], INPUT);
    16a0:	50 98       	cbi	0x0a, 0	; 10
    setPinValue(standalonePin[  STANDALONE_IRQ],  HIGH); //enable pull-up to pull IRQ high.
    16a2:	58 9a       	sbi	0x0b, 0	; 11

    //Standalone Pullup/Pulldown pin to output high
    setPinDir  (standalonePin[ STANDALONE_PULL],OUTPUT);
    16a4:	09 9a       	sbi	0x01, 1	; 1
    setPinValue(standalonePin[ STANDALONE_PULL],  HIGH);
    16a6:	11 9a       	sbi	0x02, 1	; 2
    
    //ST4 pins to input with pullup
    setPinDir  (st4Pins[RA][ST4P],INPUT);
    16a8:	23 98       	cbi	0x04, 3	; 4
    setPinValue(st4Pins[RA][ST4P],HIGH );
    16aa:	2b 9a       	sbi	0x05, 3	; 5
    setPinDir  (st4Pins[RA][ST4N],INPUT);
    16ac:	20 98       	cbi	0x04, 0	; 4
    setPinValue(st4Pins[RA][ST4N],HIGH );
    16ae:	28 9a       	sbi	0x05, 0	; 5
    setPinDir  (st4Pins[DC][ST4P],INPUT);
    16b0:	22 98       	cbi	0x04, 2	; 4
    setPinValue(st4Pins[DC][ST4P],HIGH );
    16b2:	2a 9a       	sbi	0x05, 2	; 5
    setPinDir  (st4Pins[DC][ST4N],INPUT);
    16b4:	21 98       	cbi	0x04, 1	; 4
    setPinValue(st4Pins[DC][ST4N],HIGH );
    16b6:	29 9a       	sbi	0x05, 1	; 5
    
    //Reset pins to output
    setPinDir  (resetPin[RA],OUTPUT);
    16b8:	81 9a       	sbi	0x10, 1	; 16
    setPinValue(resetPin[RA],   LOW);  //Motor driver in Reset
    16ba:	89 98       	cbi	0x11, 1	; 17
    setPinDir  (resetPin[DC],OUTPUT);
    16bc:	80 9a       	sbi	0x10, 0	; 16
    setPinValue(resetPin[DC],   LOW);  //Motor driver in Reset 
    16be:	88 98       	cbi	0x11, 0	; 17
    
    //Enable pins to output
    setPinDir  (enablePin[RA],OUTPUT);
    16c0:	9d 9a       	sbi	0x13, 5	; 19
    setPinValue(enablePin[RA],  HIGH); //Motor Driver Disabled
    16c2:	a5 9a       	sbi	0x14, 5	; 20
    setPinDir  (enablePin[DC],OUTPUT);
    16c4:	80 91 01 01 	lds	r24, 0x0101
    16c8:	80 62       	ori	r24, 0x20	; 32
    16ca:	80 93 01 01 	sts	0x0101, r24
    setPinValue(enablePin[DC],  HIGH); //Motor Driver Disabled
    16ce:	80 91 02 01 	lds	r24, 0x0102
    16d2:	80 62       	ori	r24, 0x20	; 32
    16d4:	80 93 02 01 	sts	0x0102, r24
    
    //Step pins to output
    setPinDir  (stepPin[RA],OUTPUT);
    16d8:	6b 9a       	sbi	0x0d, 3	; 13
    setPinValue(stepPin[RA],   LOW);
    16da:	73 98       	cbi	0x0e, 3	; 14
    setPinDir  (stepPin[DC],OUTPUT);
    16dc:	26 9a       	sbi	0x04, 6	; 4
    setPinValue(stepPin[DC],   LOW);
    16de:	2e 98       	cbi	0x05, 6	; 5
    
    //Direction pins to output
    setPinDir  (dirPin[RA],OUTPUT);
    16e0:	6d 9a       	sbi	0x0d, 5	; 13
    setPinValue(dirPin[RA],   LOW);
    16e2:	75 98       	cbi	0x0e, 5	; 14
    setPinDir  (dirPin[DC],OUTPUT);
    16e4:	80 91 01 01 	lds	r24, 0x0101
    16e8:	80 61       	ori	r24, 0x10	; 16
    16ea:	80 93 01 01 	sts	0x0101, r24
    setPinValue(dirPin[DC],   LOW);
    16ee:	80 91 02 01 	lds	r24, 0x0102
    16f2:	8f 7e       	andi	r24, 0xEF	; 239
    16f4:	80 93 02 01 	sts	0x0102, r24
    
    //Load the correct mode
    byte state = modeState[defaultSpeedState]; //Extract the default mode - If the microstep mode is >= then we start in NORMAL mode, otherwise we use FAST mode

    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    16f8:	e0 91 0b 03 	lds	r30, 0x030B
    16fc:	f0 e0       	ldi	r31, 0x00	; 0
    16fe:	e7 5f       	subi	r30, 0xF7	; 247
    1700:	fd 4f       	sbci	r31, 0xFD	; 253
    1702:	80 81       	ld	r24, Z
    1704:	28 2f       	mov	r18, r24
    1706:	30 e0       	ldi	r19, 0x00	; 0
    1708:	a9 01       	movw	r20, r18
    170a:	41 70       	andi	r20, 0x01	; 1
    170c:	50 70       	andi	r21, 0x00	; 0
    170e:	80 ff       	sbrs	r24, 0
    1710:	04 c0       	rjmp	.+8      	; 0x171a <systemInitialiser+0x1ba>
    1712:	80 91 05 01 	lds	r24, 0x0105
    1716:	81 60       	ori	r24, 0x01	; 1
    1718:	03 c0       	rjmp	.+6      	; 0x1720 <systemInitialiser+0x1c0>
    171a:	80 91 05 01 	lds	r24, 0x0105
    171e:	8e 7f       	andi	r24, 0xFE	; 254
    1720:	80 93 05 01 	sts	0x0105, r24
    setPinDir  (modePins[RA][MODE0],  OUTPUT                      ); 
    1724:	80 91 04 01 	lds	r24, 0x0104
    1728:	81 60       	ori	r24, 0x01	; 1
    172a:	80 93 04 01 	sts	0x0104, r24
    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    172e:	45 2b       	or	r20, r21
    1730:	11 f0       	breq	.+4      	; 0x1736 <systemInitialiser+0x1d6>
    1732:	59 9a       	sbi	0x0b, 1	; 11
    1734:	01 c0       	rjmp	.+2      	; 0x1738 <systemInitialiser+0x1d8>
    1736:	59 98       	cbi	0x0b, 1	; 11
    setPinDir  (modePins[DC][MODE0],  OUTPUT                      );
    1738:	51 9a       	sbi	0x0a, 1	; 10
    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    173a:	a9 01       	movw	r20, r18
    173c:	42 70       	andi	r20, 0x02	; 2
    173e:	50 70       	andi	r21, 0x00	; 0
    1740:	21 ff       	sbrs	r18, 1
    1742:	04 c0       	rjmp	.+8      	; 0x174c <systemInitialiser+0x1ec>
    1744:	80 91 02 01 	lds	r24, 0x0102
    1748:	82 60       	ori	r24, 0x02	; 2
    174a:	03 c0       	rjmp	.+6      	; 0x1752 <systemInitialiser+0x1f2>
    174c:	80 91 02 01 	lds	r24, 0x0102
    1750:	8d 7f       	andi	r24, 0xFD	; 253
    1752:	80 93 02 01 	sts	0x0102, r24
    setPinDir  (modePins[RA][MODE1],  OUTPUT                      );
    1756:	80 91 01 01 	lds	r24, 0x0101
    175a:	82 60       	ori	r24, 0x02	; 2
    175c:	80 93 01 01 	sts	0x0101, r24
    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    1760:	45 2b       	or	r20, r21
    1762:	11 f0       	breq	.+4      	; 0x1768 <systemInitialiser+0x208>
    1764:	5a 9a       	sbi	0x0b, 2	; 11
    1766:	01 c0       	rjmp	.+2      	; 0x176a <systemInitialiser+0x20a>
    1768:	5a 98       	cbi	0x0b, 2	; 11
    setPinDir  (modePins[DC][MODE1],  OUTPUT                      );
    176a:	52 9a       	sbi	0x0a, 2	; 10
    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    176c:	b9 01       	movw	r22, r18
    176e:	64 70       	andi	r22, 0x04	; 4
    1770:	70 70       	andi	r23, 0x00	; 0
    1772:	22 ff       	sbrs	r18, 2
    1774:	04 c0       	rjmp	.+8      	; 0x177e <systemInitialiser+0x21e>
    1776:	80 91 02 01 	lds	r24, 0x0102
    177a:	81 60       	ori	r24, 0x01	; 1
    177c:	03 c0       	rjmp	.+6      	; 0x1784 <systemInitialiser+0x224>
    177e:	80 91 02 01 	lds	r24, 0x0102
    1782:	8e 7f       	andi	r24, 0xFE	; 254
    1784:	80 93 02 01 	sts	0x0102, r24
    setPinDir  (modePins[RA][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    1788:	a9 01       	movw	r20, r18
    178a:	40 72       	andi	r20, 0x20	; 32
    178c:	50 70       	andi	r21, 0x00	; 0
    178e:	25 fd       	sbrc	r18, 5
    1790:	04 c0       	rjmp	.+8      	; 0x179a <systemInitialiser+0x23a>
    1792:	80 91 01 01 	lds	r24, 0x0101
    1796:	81 60       	ori	r24, 0x01	; 1
    1798:	03 c0       	rjmp	.+6      	; 0x17a0 <systemInitialiser+0x240>
    179a:	80 91 01 01 	lds	r24, 0x0101
    179e:	8e 7f       	andi	r24, 0xFE	; 254
    17a0:	80 93 01 01 	sts	0x0101, r24
    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    17a4:	67 2b       	or	r22, r23
    17a6:	11 f0       	breq	.+4      	; 0x17ac <systemInitialiser+0x24c>
    17a8:	5b 9a       	sbi	0x0b, 3	; 11
    17aa:	01 c0       	rjmp	.+2      	; 0x17ae <systemInitialiser+0x24e>
    17ac:	5b 98       	cbi	0x0b, 3	; 11
    setPinDir  (modePins[DC][MODE2],!(state & (byte)(1<<MODE2DIR))); //For the DRV8834 type, we also need to set the direction of the Mode2 bit to be an input if floating is required for this step mode.
    17ae:	45 2b       	or	r20, r21
    17b0:	11 f4       	brne	.+4      	; 0x17b6 <systemInitialiser+0x256>
    17b2:	53 9a       	sbi	0x0a, 3	; 10
    17b4:	01 c0       	rjmp	.+2      	; 0x17b8 <systemInitialiser+0x258>
    17b6:	53 98       	cbi	0x0a, 3	; 10
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    17b8:	80 ea       	ldi	r24, 0xA0	; 160
    17ba:	9f e0       	ldi	r25, 0x0F	; 15
    17bc:	01 97       	sbiw	r24, 0x01	; 1
    17be:	f1 f7       	brne	.-4      	; 0x17bc <systemInitialiser+0x25c>

    //Give some time for the Motor Drivers to reset.
    _delay_ms(1);

    //Then bring them out of reset.
    setPinValue(resetPin[RA],HIGH);
    17c0:	89 9a       	sbi	0x11, 1	; 17
    setPinValue(resetPin[DC],HIGH);
    17c2:	88 9a       	sbi	0x11, 0	; 17
    TIMSK &= ~(_BV(TOIE0) | _BV(OCIE0));
    TCCR0 = 0;
#endif

    //Ensure SPI is disabled
    SPI_disable();
    17c4:	0e 94 18 12 	call	0x2430	; 0x2430 <_Z11SPI_disablev>
    
    //Initialise the Serial port:
    Serial_initialise(BAUD_RATE); //SyncScan runs at 9600Baud, use a serial port of your choice as defined in SerialLink.h
    17c8:	60 e8       	ldi	r22, 0x80	; 128
    17ca:	75 e2       	ldi	r23, 0x25	; 37
    17cc:	80 e0       	ldi	r24, 0x00	; 0
    17ce:	90 e0       	ldi	r25, 0x00	; 0
    17d0:	0e 94 8b 11 	call	0x2316	; 0x2316 <_Z17Serial_initialisem>
      
}
    17d4:	08 95       	ret

000017d6 <main>:

/*
 * AstroEQ firmware main() function
 */

int main(void) {
    17d6:	2f 92       	push	r2
    17d8:	3f 92       	push	r3
    17da:	4f 92       	push	r4
    17dc:	5f 92       	push	r5
    17de:	6f 92       	push	r6
    17e0:	7f 92       	push	r7
    17e2:	8f 92       	push	r8
    17e4:	9f 92       	push	r9
    17e6:	af 92       	push	r10
    17e8:	bf 92       	push	r11
    17ea:	cf 92       	push	r12
    17ec:	df 92       	push	r13
    17ee:	ef 92       	push	r14
    17f0:	ff 92       	push	r15
    17f2:	0f 93       	push	r16
    17f4:	1f 93       	push	r17
    17f6:	df 93       	push	r29
    17f8:	cf 93       	push	r28
    17fa:	cd b7       	in	r28, 0x3d	; 61
    17fc:	de b7       	in	r29, 0x3e	; 62
    17fe:	2e 97       	sbiw	r28, 0x0e	; 14
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	de bf       	out	0x3e, r29	; 62
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	cd bf       	out	0x3d, r28	; 61
    //Enable global interrupt flag
    sei();
    180a:	78 94       	sei
    //Initialise global variables from the EEPROM
    systemInitialiser();
    180c:	0e 94 b0 0a 	call	0x1560	; 0x1560 <systemInitialiser>
    1810:	ee 24       	eor	r14, r14
    1812:	ff 24       	eor	r15, r15
    1814:	aa 24       	eor	r10, r10
    1816:	00 e0       	ldi	r16, 0x00	; 0
    1818:	cc 24       	eor	r12, r12
    181a:	bb 24       	eor	r11, r11
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
    181c:	41 2c       	mov	r4, r1
    181e:	51 2c       	mov	r5, r1
    1820:	80 e8       	ldi	r24, 0x80	; 128
    1822:	68 2e       	mov	r6, r24
    1824:	71 2c       	mov	r7, r1
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
    1826:	1e 01       	movw	r2, r28
    1828:	08 94       	sec
    182a:	21 1c       	adc	r2, r1
    182c:	31 1c       	adc	r3, r1
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    182e:	dd 24       	eor	r13, r13
    1830:	da 94       	dec	r13
                if (decoded != -2) {
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
    1832:	14 e0       	ldi	r17, 0x04	; 4
    1834:	81 2e       	mov	r8, r17
    1836:	91 2c       	mov	r9, r1
    1838:	8c 0e       	add	r8, r28
    183a:	9d 1e       	adc	r9, r29
    int8_t decoded = 0; //Whether we have decoded the packet
    char decodedPacket[11]; //temporary store for completed command ready to be processed
    
    for(;;){ //Run loop

        loopCount++; //Counter used to time events based on number of loops.
    183c:	08 94       	sec
    183e:	e1 1c       	adc	r14, r1
    1840:	f1 1c       	adc	r15, r1

        if (!standaloneMode && (loopCount == 0)) { 
    1842:	80 91 89 02 	lds	r24, 0x0289
    1846:	88 23       	and	r24, r24
    1848:	09 f0       	breq	.+2      	; 0x184c <main+0x76>
    184a:	95 c0       	rjmp	.+298    	; 0x1976 <main+0x1a0>
    184c:	e1 14       	cp	r14, r1
    184e:	f1 04       	cpc	r15, r1
    1850:	09 f0       	breq	.+2      	; 0x1854 <main+0x7e>
    1852:	91 c0       	rjmp	.+290    	; 0x1976 <main+0x1a0>
            //If we are not in standalone mode, periodically check if we have just entered it
            byte mode = standaloneModeTest();
    1854:	0e 94 10 01 	call	0x220	; 0x220 <standaloneModeTest>
    1858:	18 2f       	mov	r17, r24
            if (mode != EQMOD_MODE) {
    185a:	88 23       	and	r24, r24
    185c:	09 f4       	brne	.+2      	; 0x1860 <main+0x8a>
    185e:	8b c0       	rjmp	.+278    	; 0x1976 <main+0x1a0>
                //If we have just entered stand-alone mode, then we enable the motors and configure the mount
                motorStop(RA, true); //Ensure both motors are stopped
    1860:	80 e0       	ldi	r24, 0x00	; 0
    1862:	61 e0       	ldi	r22, 0x01	; 1
    1864:	0e 94 af 03 	call	0x75e	; 0x75e <motorStop>
                motorStop(DC, true);
    1868:	81 e0       	ldi	r24, 0x01	; 1
    186a:	61 e0       	ldi	r22, 0x01	; 1
    186c:	0e 94 af 03 	call	0x75e	; 0x75e <motorStop>
                
                //This next bit needs to be atomic
                byte oldSREG = SREG; 
    1870:	8f b7       	in	r24, 0x3f	; 63
                cli();  
    1872:	f8 94       	cli
inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
    1874:	40 92 16 03 	sts	0x0316, r4
    1878:	50 92 17 03 	sts	0x0317, r5
    187c:	60 92 18 03 	sts	0x0318, r6
    1880:	70 92 19 03 	sts	0x0319, r7
                cmd_setjVal(RA, 0x800000); //set the current position to the middle
                cmd_setjVal(DC, 0x800000); //set the current position to the middle
                SREG = oldSREG;
    1884:	40 92 1a 03 	sts	0x031A, r4
    1888:	50 92 1b 03 	sts	0x031B, r5
    188c:	60 92 1c 03 	sts	0x031C, r6
    1890:	70 92 1d 03 	sts	0x031D, r7
    1894:	8f bf       	out	0x3f, r24	; 63
                //End atomic
                //Disable Serial
                Serial_disable();
    1896:	0e 94 e6 11 	call	0x23cc	; 0x23cc <_Z14Serial_disablev>
    
                //We are now in standalone mode.
                standaloneMode = true; 
    189a:	81 e0       	ldi	r24, 0x01	; 1
    189c:	80 93 89 02 	sts	0x0289, r24
                
                //Next check what type of hand controller we have
                if (mode == ADVANCED_HC_MODE) {
    18a0:	12 30       	cpi	r17, 0x02	; 2
    18a2:	81 f4       	brne	.+32     	; 0x18c4 <main+0xee>
                    //We pulled low, but pin stayed high
                    //This means we must have an advanced controller actively pulling the line high
                    syntaMode = true; 
    18a4:	80 93 08 02 	sts	0x0208, r24
                    
                    //Initialise SPI for advanced comms
                    SPI_initialise();
    18a8:	0e 94 00 12 	call	0x2400	; 0x2400 <_Z14SPI_initialisev>
    
                    //And send welcome message
                    char welcome[3];
                    synta_assembleResponse(welcome, '\0', 0 );
    18ac:	c1 01       	movw	r24, r2
    18ae:	60 e0       	ldi	r22, 0x00	; 0
    18b0:	20 e0       	ldi	r18, 0x00	; 0
    18b2:	30 e0       	ldi	r19, 0x00	; 0
    18b4:	40 e0       	ldi	r20, 0x00	; 0
    18b6:	50 e0       	ldi	r21, 0x00	; 0
    18b8:	0e 94 c2 13 	call	0x2784	; 0x2784 <_Z22synta_assembleResponsePccm>
                    Serial_writeStr(welcome); //Send error packet to trigger controller state machine.
    18bc:	c1 01       	movw	r24, r2
    18be:	0e 94 c4 12 	call	0x2588	; 0x2588 <_Z15Serial_writeStrPc>
    18c2:	59 c0       	rjmp	.+178    	; 0x1976 <main+0x1a0>
                    
                } else {
                    //Pin either is being pulled low by us or by something else
                    //This means we might have a basic controller actively pulling the line low
                    //Even if we don't we would default to basic mode.
                    syntaMode = false;
    18c4:	10 92 08 02 	sts	0x0208, r1
                    
                    //High speed not supported in Basic HC
                    canJumpToHighspeed = false;
    18c8:	10 92 0a 03 	sts	0x030A, r1
                    
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    18cc:	11 9a       	sbi	0x02, 1	; 2
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    18ce:	e0 91 0b 03 	lds	r30, 0x030B
    18d2:	f0 e0       	ldi	r31, 0x00	; 0
    18d4:	e7 5f       	subi	r30, 0xF7	; 247
    18d6:	fd 4f       	sbci	r31, 0xFD	; 253
    18d8:	80 81       	ld	r24, Z
    18da:	98 2f       	mov	r25, r24
    18dc:	80 ff       	sbrs	r24, 0
    18de:	07 c0       	rjmp	.+14     	; 0x18ee <main+0x118>
    18e0:	80 91 05 01 	lds	r24, 0x0105
    18e4:	81 60       	ori	r24, 0x01	; 1
    18e6:	80 93 05 01 	sts	0x0105, r24
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    18ea:	59 9a       	sbi	0x0b, 1	; 11
    18ec:	06 c0       	rjmp	.+12     	; 0x18fa <main+0x124>
                    //For basic mode we need a pull up resistor on the speed/irq line
                    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
    18ee:	80 91 05 01 	lds	r24, 0x0105
    18f2:	8e 7f       	andi	r24, 0xFE	; 254
    18f4:	80 93 05 01 	sts	0x0105, r24
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
    18f8:	59 98       	cbi	0x0b, 1	; 11
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    18fa:	91 ff       	sbrs	r25, 1
    18fc:	07 c0       	rjmp	.+14     	; 0x190c <main+0x136>
    18fe:	80 91 02 01 	lds	r24, 0x0102
    1902:	82 60       	ori	r24, 0x02	; 2
    1904:	80 93 02 01 	sts	0x0102, r24
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    1908:	5a 9a       	sbi	0x0b, 2	; 11
    190a:	06 c0       	rjmp	.+12     	; 0x1918 <main+0x142>
                    
                    //And then we need to initialise the controller manually so the basic controller can help us move
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
    190c:	80 91 02 01 	lds	r24, 0x0102
    1910:	8d 7f       	andi	r24, 0xFD	; 253
    1912:	80 93 02 01 	sts	0x0102, r24
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
    1916:	5a 98       	cbi	0x0b, 2	; 11
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    1918:	92 ff       	sbrs	r25, 2
    191a:	07 c0       	rjmp	.+14     	; 0x192a <main+0x154>
    191c:	80 91 02 01 	lds	r24, 0x0102
    1920:	81 60       	ori	r24, 0x01	; 1
    1922:	80 93 02 01 	sts	0x0102, r24
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    1926:	5b 9a       	sbi	0x0b, 3	; 11
    1928:	06 c0       	rjmp	.+12     	; 0x1936 <main+0x160>
                    byte state = modeState[defaultSpeedState]; //Extract the default mode - for basic HC we won't change from default mode.
                    setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0   )));
                    setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1   )));
                    setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2   )));
    192a:	80 91 02 01 	lds	r24, 0x0102
    192e:	8e 7f       	andi	r24, 0xFE	; 254
    1930:	80 93 02 01 	sts	0x0102, r24
                    setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2   )));
    1934:	5b 98       	cbi	0x0b, 3	; 11
                    
                    Commands_configureST4Speed(CMD_ST4_DEFAULT); //Change the ST4 speeds to default
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <_Z26Commands_configureST4Speedh>
                    
                    motorEnable(RA); //Ensure the motors are enabled
    193c:	80 e0       	ldi	r24, 0x00	; 0
    193e:	0e 94 38 01 	call	0x270	; 0x270 <motorEnable>
                    motorEnable(DC);
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	0e 94 38 01 	call	0x270	; 0x270 <motorEnable>
inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
    1948:	21 e0       	ldi	r18, 0x01	; 1
    194a:	20 93 26 03 	sts	0x0326, r18
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    194e:	20 93 27 03 	sts	0x0327, r18
    1952:	10 92 32 03 	sts	0x0332, r1

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1956:	20 93 30 03 	sts	0x0330, r18
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    195a:	10 92 33 03 	sts	0x0333, r1

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    195e:	20 93 30 03 	sts	0x0330, r18
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1962:	80 91 69 03 	lds	r24, 0x0369
    1966:	90 91 6a 03 	lds	r25, 0x036A
    196a:	90 93 1f 03 	sts	0x031F, r25
    196e:	80 93 1e 03 	sts	0x031E, r24
                    cmd_updateStepDir(RA ,1);
                    cmd_setDir       (DC, CMD_FORWARD); //Store the current direction for that axis
                    cmd_updateStepDir(RA,1);
                    cmd_setIVal      (RA, cmd.siderealIVal[RA]); //Set RA speed to sidereal
                    
                    readyToGo[RA] = 1; //Signal we are ready to go on the RA axis to start sideral tracking
    1972:	20 93 7a 02 	sts	0x027A, r18
            }
            //If we end up in standalone mode, we don't exit until a reset.
        }

        /////////////
        if (syntaMode) {
    1976:	80 91 08 02 	lds	r24, 0x0208
    197a:	88 23       	and	r24, r24
    197c:	09 f4       	brne	.+2      	; 0x1980 <main+0x1aa>
    197e:	65 c1       	rjmp	.+714    	; 0x1c4a <main+0x474>
        //
        // EQMOD or Advanced Hand Controller Synta Mode
        //
            //Check if we need to run the command parser
            
            if ((decoded == -2) || Serial_available()) { //is there a byte in buffer or we still need to process the previous byte?
    1980:	0e 3f       	cpi	r16, 0xFE	; 254
    1982:	21 f0       	breq	.+8      	; 0x198c <main+0x1b6>
    1984:	0e 94 63 12 	call	0x24c6	; 0x24c6 <_Z16Serial_availablev>
    1988:	88 23       	and	r24, r24
    198a:	71 f1       	breq	.+92     	; 0x19e8 <main+0x212>
                //Toggle on the LED to indicate activity.
                togglePin(statusPin);
    198c:	85 b1       	in	r24, 0x05	; 5
    198e:	80 58       	subi	r24, 0x80	; 128
    1990:	85 b9       	out	0x05, r24	; 5
                //See what character we need to parse
                if (decoded != -2) {
    1992:	0e 3f       	cpi	r16, 0xFE	; 254
    1994:	19 f0       	breq	.+6      	; 0x199c <main+0x1c6>
                    //get the next character in buffer
                    recievedChar = Serial_read(); 
    1996:	0e 94 70 12 	call	0x24e0	; 0x24e0 <_Z11Serial_readv>
    199a:	a8 2e       	mov	r10, r24
                } //otherwise we will try to parse the previous character again.
                //Append the current character and try to parse the command
                decoded = synta_recieveCommand(decodedPacket,recievedChar); 
    199c:	c4 01       	movw	r24, r8
    199e:	6a 2d       	mov	r22, r10
    19a0:	0e 94 80 13 	call	0x2700	; 0x2700 <_Z20synta_recieveCommandPcc>
    19a4:	08 2f       	mov	r16, r24
                //Once full command packet recieved, synta_recieveCommand populates either an error packet (and returns -1), or data packet (returns 1). If incomplete, decodedPacket is unchanged and 0 is returned
                if (decoded != 0){ //Send a response
    19a6:	88 23       	and	r24, r24
    19a8:	f9 f0       	breq	.+62     	; 0x19e8 <main+0x212>
                    if (decoded > 0){ //Valid Packet, current command is in decoded variable.
    19aa:	18 16       	cp	r1, r24
    19ac:	14 f0       	brlt	.+4      	; 0x19b2 <main+0x1dc>
    19ae:	10 e0       	ldi	r17, 0x00	; 0
    19b0:	05 c0       	rjmp	.+10     	; 0x19bc <main+0x1e6>
                        mcuReset = !decodeCommand(decoded,decodedPacket); //decode the valid packet and populate response.
    19b2:	b4 01       	movw	r22, r8
    19b4:	0e 94 c4 06 	call	0xd88	; 0xd88 <decodeCommand>
    19b8:	11 e0       	ldi	r17, 0x01	; 1
    19ba:	18 27       	eor	r17, r24
                    }
                    Serial_writeStr(decodedPacket); //send the response packet (recieveCommand() generated the error packet, or decodeCommand() a valid response)
    19bc:	c4 01       	movw	r24, r8
    19be:	0e 94 c4 12 	call	0x2588	; 0x2588 <_Z15Serial_writeStrPc>
                } //otherwise command not yet fully recieved, so wait for next byte
                
                if (mcuReset) {
    19c2:	11 23       	and	r17, r17
    19c4:	89 f0       	breq	.+34     	; 0x19e8 <main+0x212>
                    //Special case. We were asked to reset the MCU.
                    Serial_flush(); //Flush out last response.
    19c6:	0e 94 ae 12 	call	0x255c	; 0x255c <_Z12Serial_flushv>
                    wdt_enable(WDTO_120MS); //WDT has been set to reset MCU.
    19ca:	2b e0       	ldi	r18, 0x0B	; 11
    19cc:	88 e1       	ldi	r24, 0x18	; 24
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	0f b6       	in	r0, 0x3f	; 63
    19d2:	f8 94       	cli
    19d4:	a8 95       	wdr
    19d6:	80 93 60 00 	sts	0x0060, r24
    19da:	0f be       	out	0x3f, r0	; 63
    19dc:	20 93 60 00 	sts	0x0060, r18
                    exit(0); //Done
    19e0:	80 e0       	ldi	r24, 0x00	; 0
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	0e 94 d6 16 	call	0x2dac	; 0x2dac <_exit>
                }
            }
            if (loopCount == 0) {
    19e8:	e1 14       	cp	r14, r1
    19ea:	f1 04       	cpc	r15, r1
    19ec:	09 f4       	brne	.+2      	; 0x19f0 <main+0x21a>
                setPinValue(statusPin, 0);
    19ee:	2f 98       	cbi	0x05, 7	; 5
            }
            
            //
            //ST4 button handling
            //
            if (!standaloneMode && ((loopCount & 0xFF) == 0)){
    19f0:	80 91 89 02 	lds	r24, 0x0289
    19f4:	88 23       	and	r24, r24
    19f6:	09 f0       	breq	.+2      	; 0x19fa <main+0x224>
    19f8:	62 c0       	rjmp	.+196    	; 0x1abe <main+0x2e8>
    19fa:	ee 20       	and	r14, r14
    19fc:	09 f0       	breq	.+2      	; 0x1a00 <main+0x22a>
    19fe:	5f c0       	rjmp	.+190    	; 0x1abe <main+0x2e8>
                //We only check the ST-4 buttons in EQMOD mode when not doing Go-To, and only every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //In Synta mode, we only allow the ST-4 port to move forward, and only if EQMOD has configured us previously to be in tracking mode
                    if ((cmd.dir[RA] == CMD_FORWARD) && (readyToGo[RA] == 2)) {
    1a00:	80 91 32 03 	lds	r24, 0x0332
    1a04:	88 23       	and	r24, r24
    1a06:	b9 f4       	brne	.+46     	; 0x1a36 <main+0x260>
    1a08:	80 91 7a 02 	lds	r24, 0x027A
    1a0c:	82 30       	cpi	r24, 0x02	; 2
    1a0e:	99 f4       	brne	.+38     	; 0x1a36 <main+0x260>
                        //Determine which ST4 pin if any
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    1a10:	19 99       	sbic	0x03, 1	; 3
    1a12:	02 c0       	rjmp	.+4      	; 0x1a18 <main+0x242>
    1a14:	e1 e0       	ldi	r30, 0x01	; 1
    1a16:	c6 c1       	rjmp	.+908    	; 0x1da4 <main+0x5ce>
    1a18:	1a 9b       	sbis	0x03, 2	; 3
    1a1a:	c3 c1       	rjmp	.+902    	; 0x1da2 <main+0x5cc>
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
                            isST4Move[RA] = true; //Now doing ST4 movement
                        }
                        else if (isST4Move[RA]) { 
    1a1c:	bb 20       	and	r11, r11
    1a1e:	59 f0       	breq	.+22     	; 0x1a36 <main+0x260>
    1a20:	80 91 69 03 	lds	r24, 0x0369
    1a24:	90 91 6a 03 	lds	r25, 0x036A
    1a28:	90 93 1f 03 	sts	0x031F, r25
    1a2c:	80 93 1e 03 	sts	0x031E, r24
                            //Only return to sidereal speed if we are in an ST4 move.
                            cmd_setIVal(RA,cmd.siderealIVal[RA]);
                            motorStartRA();
    1a30:	0e 94 63 01 	call	0x2c6	; 0x2c6 <motorStartRA>
    1a34:	bb 24       	eor	r11, r11
                            isST4Move[RA] = false; //No longer ST4 movement
                        }
                    }
                }//End RA
                
                if (!cmd.gotoEn[DC]) {//Start DEC
    1a36:	80 91 37 03 	lds	r24, 0x0337
    1a3a:	88 23       	and	r24, r24
    1a3c:	09 f0       	breq	.+2      	; 0x1a40 <main+0x26a>
    1a3e:	3f c0       	rjmp	.+126    	; 0x1abe <main+0x2e8>
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    1a40:	19 99       	sbic	0x03, 1	; 3
    1a42:	03 c0       	rjmp	.+6      	; 0x1a4a <main+0x274>
    1a44:	51 e0       	ldi	r21, 0x01	; 1
    1a46:	41 e0       	ldi	r20, 0x01	; 1
    1a48:	06 c0       	rjmp	.+12     	; 0x1a56 <main+0x280>
    1a4a:	1a 9b       	sbis	0x03, 2	; 3
    1a4c:	02 c0       	rjmp	.+4      	; 0x1a52 <main+0x27c>
    1a4e:	4f ef       	ldi	r20, 0xFF	; 255
    1a50:	01 c0       	rjmp	.+2      	; 0x1a54 <main+0x27e>
    1a52:	40 e0       	ldi	r20, 0x00	; 0
    1a54:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir)) {
    1a56:	80 91 39 03 	lds	r24, 0x0339
    1a5a:	88 23       	and	r24, r24
    1a5c:	71 f4       	brne	.+28     	; 0x1a7a <main+0x2a4>
    1a5e:	80 91 33 03 	lds	r24, 0x0333
    1a62:	90 e0       	ldi	r25, 0x00	; 0
    1a64:	25 2f       	mov	r18, r21
    1a66:	30 e0       	ldi	r19, 0x00	; 0
    1a68:	82 17       	cp	r24, r18
    1a6a:	93 07       	cpc	r25, r19
    1a6c:	31 f0       	breq	.+12     	; 0x1a7a <main+0x2a4>
                        //If we are currently moving in the wrong direction
                        motorStopDC(false); //Stop the Dec motor
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
    1a70:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <motorStopDC>
                        readyToGo[DC]=0;    //No longer ready to go as we have now deleted any pre-running EQMOD movement.
    1a74:	10 92 7b 02 	sts	0x027B, r1
    1a78:	22 c0       	rjmp	.+68     	; 0x1abe <main+0x2e8>
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
    1a7a:	4f 3f       	cpi	r20, 0xFF	; 255
    1a7c:	d1 f0       	breq	.+52     	; 0x1ab2 <main+0x2dc>
    1a7e:	80 91 65 03 	lds	r24, 0x0365
    1a82:	90 91 66 03 	lds	r25, 0x0366
    1a86:	90 93 21 03 	sts	0x0321, r25
    1a8a:	80 93 20 03 	sts	0x0320, r24
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
    1a8e:	25 2f       	mov	r18, r21
    1a90:	51 11       	cpse	r21, r1
    1a92:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1a94:	20 93 33 03 	sts	0x0333, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1a98:	22 23       	and	r18, r18
    1a9a:	19 f0       	breq	.+6      	; 0x1aa2 <main+0x2cc>
        cmd.stepDir[target] = -stepSize; //set step direction
    1a9c:	d0 92 31 03 	sts	0x0331, r13
    1aa0:	03 c0       	rjmp	.+6      	; 0x1aa8 <main+0x2d2>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1aa2:	81 e0       	ldi	r24, 0x01	; 1
    1aa4:	80 93 31 03 	sts	0x0331, r24
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
    1aa8:	0e 94 d5 01 	call	0x3aa	; 0x3aa <motorStartDC>
    1aac:	cc 24       	eor	r12, r12
    1aae:	c3 94       	inc	r12
    1ab0:	06 c0       	rjmp	.+12     	; 0x1abe <main+0x2e8>
                            isST4Move[DC] = true; //Now doing ST4 movement
                        } else if (isST4Move[DC]) {
    1ab2:	cc 20       	and	r12, r12
    1ab4:	21 f0       	breq	.+8      	; 0x1abe <main+0x2e8>
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
    1ab6:	80 e0       	ldi	r24, 0x00	; 0
    1ab8:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <motorStopDC>
    1abc:	cc 24       	eor	r12, r12
                    }
                }//End DEC
            }
            
            //Check both axes - loop unravelled for speed efficiency - lots of Flash available.
            if(readyToGo[RA]==1){
    1abe:	90 91 7a 02 	lds	r25, 0x027A
    1ac2:	91 30       	cpi	r25, 0x01	; 1
    1ac4:	09 f0       	breq	.+2      	; 0x1ac8 <main+0x2f2>
    1ac6:	67 c0       	rjmp	.+206    	; 0x1b96 <main+0x3c0>
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[RA] == CMD_STOPPED){
    1ac8:	80 91 38 03 	lds	r24, 0x0338
    1acc:	88 23       	and	r24, r24
    1ace:	09 f4       	brne	.+2      	; 0x1ad2 <main+0x2fc>
    1ad0:	62 c0       	rjmp	.+196    	; 0x1b96 <main+0x3c0>
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[RA];
    1ad2:	30 91 26 03 	lds	r19, 0x0326
                    if (canJumpToHighspeed){
    1ad6:	80 91 0a 03 	lds	r24, 0x030A
    1ada:	88 23       	and	r24, r24
    1adc:	09 f4       	brne	.+2      	; 0x1ae0 <main+0x30a>
    1ade:	42 c0       	rjmp	.+132    	; 0x1b64 <main+0x38e>
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
    1ae0:	83 2f       	mov	r24, r19
    1ae2:	81 50       	subi	r24, 0x01	; 1
    1ae4:	82 30       	cpi	r24, 0x02	; 2
    1ae6:	70 f4       	brcc	.+28     	; 0x1b04 <main+0x32e>
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
    1ae8:	20 91 09 02 	lds	r18, 0x0209
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1aec:	80 91 32 03 	lds	r24, 0x0332
    1af0:	88 23       	and	r24, r24
    1af2:	19 f0       	breq	.+6      	; 0x1afa <main+0x324>
        cmd.stepDir[target] = -stepSize; //set step direction
    1af4:	d0 92 30 03 	sts	0x0330, r13
    1af8:	02 c0       	rjmp	.+4      	; 0x1afe <main+0x328>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1afa:	90 93 30 03 	sts	0x0330, r25
                            cmd_updateStepDir(RA,1);
                            cmd.highSpeedMode[RA] = false;
    1afe:	10 92 3a 03 	sts	0x033A, r1
    1b02:	0d c0       	rjmp	.+26     	; 0x1b1e <main+0x348>
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
    1b04:	20 91 0a 02 	lds	r18, 0x020A
                            cmd_updateStepDir(RA,cmd.gVal[RA]);
    1b08:	90 91 54 03 	lds	r25, 0x0354
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1b0c:	80 91 32 03 	lds	r24, 0x0332
    1b10:	81 11       	cpse	r24, r1
        cmd.stepDir[target] = -stepSize; //set step direction
    1b12:	91 95       	neg	r25
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1b14:	90 93 30 03 	sts	0x0330, r25
                            cmd.highSpeedMode[RA] = true;
    1b18:	81 e0       	ldi	r24, 0x01	; 1
    1b1a:	80 93 3a 03 	sts	0x033A, r24
                        }
                        setPinValue(modePins[RA][MODE0], (state & (byte)(1<<MODE0)));
    1b1e:	92 2f       	mov	r25, r18
    1b20:	20 ff       	sbrs	r18, 0
    1b22:	04 c0       	rjmp	.+8      	; 0x1b2c <main+0x356>
    1b24:	80 91 05 01 	lds	r24, 0x0105
    1b28:	81 60       	ori	r24, 0x01	; 1
    1b2a:	03 c0       	rjmp	.+6      	; 0x1b32 <main+0x35c>
    1b2c:	80 91 05 01 	lds	r24, 0x0105
    1b30:	8e 7f       	andi	r24, 0xFE	; 254
    1b32:	80 93 05 01 	sts	0x0105, r24
                        setPinValue(modePins[RA][MODE1], (state & (byte)(1<<MODE1)));
    1b36:	91 ff       	sbrs	r25, 1
    1b38:	04 c0       	rjmp	.+8      	; 0x1b42 <main+0x36c>
    1b3a:	80 91 02 01 	lds	r24, 0x0102
    1b3e:	82 60       	ori	r24, 0x02	; 2
    1b40:	03 c0       	rjmp	.+6      	; 0x1b48 <main+0x372>
    1b42:	80 91 02 01 	lds	r24, 0x0102
    1b46:	8d 7f       	andi	r24, 0xFD	; 253
    1b48:	80 93 02 01 	sts	0x0102, r24
                        setPinValue(modePins[RA][MODE2], (state & (byte)(1<<MODE2)));
    1b4c:	92 ff       	sbrs	r25, 2
    1b4e:	04 c0       	rjmp	.+8      	; 0x1b58 <main+0x382>
    1b50:	80 91 02 01 	lds	r24, 0x0102
    1b54:	81 60       	ori	r24, 0x01	; 1
    1b56:	03 c0       	rjmp	.+6      	; 0x1b5e <main+0x388>
    1b58:	80 91 02 01 	lds	r24, 0x0102
    1b5c:	8e 7f       	andi	r24, 0xFE	; 254
    1b5e:	80 93 02 01 	sts	0x0102, r24
    1b62:	0b c0       	rjmp	.+22     	; 0x1b7a <main+0x3a4>
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1b64:	80 91 32 03 	lds	r24, 0x0332
    1b68:	88 23       	and	r24, r24
    1b6a:	19 f0       	breq	.+6      	; 0x1b72 <main+0x39c>
        cmd.stepDir[target] = -stepSize; //set step direction
    1b6c:	d0 92 30 03 	sts	0x0330, r13
    1b70:	02 c0       	rjmp	.+4      	; 0x1b76 <main+0x3a0>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1b72:	90 93 30 03 	sts	0x0330, r25
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(RA,1); //Just move along at one step per step
                        cmd.highSpeedMode[RA] = false;
    1b76:	10 92 3a 03 	sts	0x033A, r1
                    }
                    if(GVal & 1){
    1b7a:	30 ff       	sbrs	r19, 0
    1b7c:	07 c0       	rjmp	.+14     	; 0x1b8c <main+0x3b6>
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
    1b7e:	80 e0       	ldi	r24, 0x00	; 0
    1b80:	0e 94 4d 02 	call	0x49a	; 0x49a <motorStart>
                        cmd.highSpeedMode[RA] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(RA); //Slew type
                        readyToGo[RA] = 2;
    1b84:	82 e0       	ldi	r24, 0x02	; 2
    1b86:	80 93 7a 02 	sts	0x027A, r24
    1b8a:	05 c0       	rjmp	.+10     	; 0x1b96 <main+0x3c0>
                    } else {
                        //This is the function for goto mode. You may need to customise it for a different motor driver
                        gotoMode(RA); //Goto Mode
    1b8c:	80 e0       	ldi	r24, 0x00	; 0
    1b8e:	0e 94 55 02 	call	0x4aa	; 0x4aa <gotoMode>
                        readyToGo[RA] = 0;
    1b92:	10 92 7a 02 	sts	0x027A, r1
                    }
                } //Otherwise don't start the next movement until we have stopped.
            }
            
            if(readyToGo[DC]==1){
    1b96:	90 91 7b 02 	lds	r25, 0x027B
    1b9a:	91 30       	cpi	r25, 0x01	; 1
    1b9c:	09 f0       	breq	.+2      	; 0x1ba0 <main+0x3ca>
    1b9e:	4e ce       	rjmp	.-868    	; 0x183c <main+0x66>
                //If we are ready to begin a movement which requires the motors to be reconfigured
                if(cmd.stopped[DC] == CMD_STOPPED){
    1ba0:	80 91 39 03 	lds	r24, 0x0339
    1ba4:	88 23       	and	r24, r24
    1ba6:	09 f4       	brne	.+2      	; 0x1baa <main+0x3d4>
    1ba8:	49 ce       	rjmp	.-878    	; 0x183c <main+0x66>
                    //Once the motor is stopped, we can accelerate to target speed.
                    signed char GVal = cmd.GVal[DC];
    1baa:	30 91 27 03 	lds	r19, 0x0327
                    if (canJumpToHighspeed){
    1bae:	80 91 0a 03 	lds	r24, 0x030A
    1bb2:	88 23       	and	r24, r24
    1bb4:	81 f1       	breq	.+96     	; 0x1c16 <main+0x440>
                        //If we are allowed to enable high speed, see if we need to
                        byte state;
                        if ((GVal == 1) || (GVal == 2)) {
    1bb6:	83 2f       	mov	r24, r19
    1bb8:	81 50       	subi	r24, 0x01	; 1
    1bba:	82 30       	cpi	r24, 0x02	; 2
    1bbc:	70 f4       	brcc	.+28     	; 0x1bda <main+0x404>
                            //If a low speed mode command
                            state = modeState[SPEEDNORM]; //Select the normal speed mode
    1bbe:	20 91 09 02 	lds	r18, 0x0209
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1bc2:	80 91 33 03 	lds	r24, 0x0333
    1bc6:	88 23       	and	r24, r24
    1bc8:	19 f0       	breq	.+6      	; 0x1bd0 <main+0x3fa>
        cmd.stepDir[target] = -stepSize; //set step direction
    1bca:	d0 92 31 03 	sts	0x0331, r13
    1bce:	02 c0       	rjmp	.+4      	; 0x1bd4 <main+0x3fe>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1bd0:	90 93 31 03 	sts	0x0331, r25
                            cmd_updateStepDir(DC,1);
                            cmd.highSpeedMode[DC] = false;
    1bd4:	10 92 3b 03 	sts	0x033B, r1
    1bd8:	0d c0       	rjmp	.+26     	; 0x1bf4 <main+0x41e>
                        } else {
                            state = modeState[SPEEDFAST]; //Select the high speed mode
    1bda:	20 91 0a 02 	lds	r18, 0x020A
                            cmd_updateStepDir(DC,cmd.gVal[DC]);
    1bde:	90 91 55 03 	lds	r25, 0x0355
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1be2:	80 91 33 03 	lds	r24, 0x0333
    1be6:	81 11       	cpse	r24, r1
        cmd.stepDir[target] = -stepSize; //set step direction
    1be8:	91 95       	neg	r25
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1bea:	90 93 31 03 	sts	0x0331, r25
                            cmd.highSpeedMode[DC] = true;
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	80 93 3b 03 	sts	0x033B, r24
                        }
                        setPinValue(modePins[DC][MODE0], (state & (byte)(1<<MODE0)));
    1bf4:	82 2f       	mov	r24, r18
    1bf6:	20 ff       	sbrs	r18, 0
    1bf8:	02 c0       	rjmp	.+4      	; 0x1bfe <main+0x428>
    1bfa:	59 9a       	sbi	0x0b, 1	; 11
    1bfc:	01 c0       	rjmp	.+2      	; 0x1c00 <main+0x42a>
    1bfe:	59 98       	cbi	0x0b, 1	; 11
                        setPinValue(modePins[DC][MODE1], (state & (byte)(1<<MODE1)));
    1c00:	81 ff       	sbrs	r24, 1
    1c02:	02 c0       	rjmp	.+4      	; 0x1c08 <main+0x432>
    1c04:	5a 9a       	sbi	0x0b, 2	; 11
    1c06:	01 c0       	rjmp	.+2      	; 0x1c0a <main+0x434>
    1c08:	5a 98       	cbi	0x0b, 2	; 11
                        setPinValue(modePins[DC][MODE2], (state & (byte)(1<<MODE2)));
    1c0a:	82 ff       	sbrs	r24, 2
    1c0c:	02 c0       	rjmp	.+4      	; 0x1c12 <main+0x43c>
    1c0e:	5b 9a       	sbi	0x0b, 3	; 11
    1c10:	0d c0       	rjmp	.+26     	; 0x1c2c <main+0x456>
    1c12:	5b 98       	cbi	0x0b, 3	; 11
    1c14:	0b c0       	rjmp	.+22     	; 0x1c2c <main+0x456>
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1c16:	80 91 33 03 	lds	r24, 0x0333
    1c1a:	88 23       	and	r24, r24
    1c1c:	19 f0       	breq	.+6      	; 0x1c24 <main+0x44e>
        cmd.stepDir[target] = -stepSize; //set step direction
    1c1e:	d0 92 31 03 	sts	0x0331, r13
    1c22:	02 c0       	rjmp	.+4      	; 0x1c28 <main+0x452>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1c24:	90 93 31 03 	sts	0x0331, r25
                    } else {
                        //Otherwise we never need to change the speed
                        cmd_updateStepDir(DC,1); //Just move along at one step per step
                        cmd.highSpeedMode[DC] = false;
    1c28:	10 92 3b 03 	sts	0x033B, r1
                    }
                    if(GVal & 1){
    1c2c:	30 ff       	sbrs	r19, 0
    1c2e:	07 c0       	rjmp	.+14     	; 0x1c3e <main+0x468>
        cmd_setFVal(DC,CMD_DISABLED);
    }
}

void slewMode(byte axis){
    motorStart(axis); //Begin PWM
    1c30:	81 e0       	ldi	r24, 0x01	; 1
    1c32:	0e 94 4d 02 	call	0x49a	; 0x49a <motorStart>
                        cmd.highSpeedMode[DC] = false;
                    }
                    if(GVal & 1){
                        //This is the funtion that enables a slew type move.
                        slewMode(DC); //Slew type
                        readyToGo[DC] = 2; //We are now in a running mode which speed can be changed without stopping motor (unless a command changes the direction)
    1c36:	82 e0       	ldi	r24, 0x02	; 2
    1c38:	80 93 7b 02 	sts	0x027B, r24
    1c3c:	ff cd       	rjmp	.-1026   	; 0x183c <main+0x66>
                    } else {
                        //This is the function for goto mode.
                        gotoMode(DC); //Goto Mode
    1c3e:	81 e0       	ldi	r24, 0x01	; 1
    1c40:	0e 94 55 02 	call	0x4aa	; 0x4aa <gotoMode>
                        readyToGo[DC] = 0; //We are now in a mode where no further changes can be made to the motor (apart from requesting a stop) until the go-to movement is done.
    1c44:	10 92 7b 02 	sts	0x027B, r1
    1c48:	f9 cd       	rjmp	.-1038   	; 0x183c <main+0x66>
        //////////
        } else {
        //
        // ST4 Basic Hand Controller Mode
        //
            if (loopCount == 0) {
    1c4a:	e1 14       	cp	r14, r1
    1c4c:	f1 04       	cpc	r15, r1
    1c4e:	71 f4       	brne	.+28     	; 0x1c6c <main+0x496>
                //we run these checks every so often, not all the time.
                
                //Update status LED
                togglePin(statusPin); //Toggle status pin at roughly constant rate in basic mode as indicator
    1c50:	85 b1       	in	r24, 0x05	; 5
    1c52:	80 58       	subi	r24, 0x80	; 128
    1c54:	85 b9       	out	0x05, r24	; 5
                
                //Check the speed
                byte newBasicHCSpeed = checkBasicHCSpeed();
    1c56:	0e 94 26 01 	call	0x24c	; 0x24c <_Z17checkBasicHCSpeedv>
    1c5a:	98 2f       	mov	r25, r24
                if (newBasicHCSpeed != cmd.st4Mode) {
    1c5c:	80 91 5e 03 	lds	r24, 0x035E
    1c60:	98 17       	cp	r25, r24
    1c62:	39 f0       	breq	.+14     	; 0x1c72 <main+0x49c>
                    //Only update speed if changed.
                    Commands_configureST4Speed(newBasicHCSpeed); //Change the ST4 speeds
    1c64:	89 2f       	mov	r24, r25
    1c66:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <_Z26Commands_configureST4Speedh>
    1c6a:	03 c0       	rjmp	.+6      	; 0x1c72 <main+0x49c>
            }
            
            //
            //NESW button handling - uses ST4 pins
            //
            if ((loopCount & 0xFF) == 0){
    1c6c:	ee 20       	and	r14, r14
    1c6e:	09 f0       	breq	.+2      	; 0x1c72 <main+0x49c>
    1c70:	e5 cd       	rjmp	.-1078   	; 0x183c <main+0x66>
                //We only check the buttons every so often - this adds a little bit of debouncing time.
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
    1c72:	18 9b       	sbis	0x03, 0	; 3
    1c74:	aa c0       	rjmp	.+340    	; 0x1dca <main+0x5f4>
    1c76:	1b 9b       	sbis	0x03, 3	; 3
    1c78:	02 c0       	rjmp	.+4      	; 0x1c7e <main+0x4a8>
    1c7a:	4f ef       	ldi	r20, 0xFF	; 255
    1c7c:	01 c0       	rjmp	.+2      	; 0x1c80 <main+0x4aa>
    1c7e:	40 e0       	ldi	r20, 0x00	; 0
    1c80:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
    1c82:	1f b7       	in	r17, 0x3f	; 63
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
    1c84:	f8 94       	cli
                    if ((cmd.stopped[RA] != CMD_STOPPED) && (cmd.dir[RA] != dir) && (currentMotorSpeed(RA) < cmd.minSpeed[RA])) {
    1c86:	80 91 38 03 	lds	r24, 0x0338
    1c8a:	88 23       	and	r24, r24
    1c8c:	09 f0       	breq	.+2      	; 0x1c90 <main+0x4ba>
    1c8e:	a6 c0       	rjmp	.+332    	; 0x1ddc <main+0x606>
    1c90:	80 91 32 03 	lds	r24, 0x0332
    1c94:	90 e0       	ldi	r25, 0x00	; 0
    1c96:	25 2f       	mov	r18, r21
    1c98:	30 e0       	ldi	r19, 0x00	; 0
    1c9a:	82 17       	cp	r24, r18
    1c9c:	93 07       	cpc	r25, r19
    1c9e:	09 f4       	brne	.+2      	; 0x1ca2 <main+0x4cc>
    1ca0:	9d c0       	rjmp	.+314    	; 0x1ddc <main+0x606>
    1ca2:	20 91 9a 00 	lds	r18, 0x009A
    1ca6:	30 91 9b 00 	lds	r19, 0x009B
    1caa:	80 91 71 03 	lds	r24, 0x0371
    1cae:	90 91 72 03 	lds	r25, 0x0372
    1cb2:	28 17       	cp	r18, r24
    1cb4:	39 07       	cpc	r19, r25
    1cb6:	08 f0       	brcs	.+2      	; 0x1cba <main+0x4e4>
    1cb8:	91 c0       	rjmp	.+290    	; 0x1ddc <main+0x606>
    1cba:	27 c0       	rjmp	.+78     	; 0x1d0a <main+0x534>
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
    1cbc:	e0 91 69 03 	lds	r30, 0x0369
    1cc0:	f0 91 6a 03 	lds	r31, 0x036A
    1cc4:	0b c0       	rjmp	.+22     	; 0x1cdc <main+0x506>
    1cc6:	e4 2f       	mov	r30, r20
    1cc8:	ff 27       	eor	r31, r31
    1cca:	e7 fd       	sbrc	r30, 7
    1ccc:	f0 95       	com	r31
    1cce:	ee 0f       	add	r30, r30
    1cd0:	ff 1f       	adc	r31, r31
    1cd2:	e0 5a       	subi	r30, 0xA0	; 160
    1cd4:	fc 4f       	sbci	r31, 0xFC	; 252
    1cd6:	01 90       	ld	r0, Z+
    1cd8:	f0 81       	ld	r31, Z
    1cda:	e0 2d       	mov	r30, r0
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1cdc:	f0 93 1f 03 	sts	0x031F, r31
    1ce0:	e0 93 1e 03 	sts	0x031E, r30
                        cmd_setDir(RA,dir);
    1ce4:	25 2f       	mov	r18, r21
    1ce6:	51 11       	cpse	r21, r1
    1ce8:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1cea:	20 93 32 03 	sts	0x0332, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1cee:	22 23       	and	r18, r18
    1cf0:	19 f0       	breq	.+6      	; 0x1cf8 <main+0x522>
        cmd.stepDir[target] = -stepSize; //set step direction
    1cf2:	d0 92 30 03 	sts	0x0330, r13
    1cf6:	03 c0       	rjmp	.+6      	; 0x1cfe <main+0x528>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1cf8:	81 e0       	ldi	r24, 0x01	; 1
    1cfa:	80 93 30 03 	sts	0x0330, r24
                        cmd_updateStepDir(RA,1);
                        if ((st4Pin == ST4O) && (cmd.st4Mode == CMD_ST4_HIGHSPEED)) {
    1cfe:	4f 3f       	cpi	r20, 0xFF	; 255
    1d00:	41 f4       	brne	.+16     	; 0x1d12 <main+0x53c>
    1d02:	80 91 5e 03 	lds	r24, 0x035E
    1d06:	82 30       	cpi	r24, 0x02	; 2
    1d08:	21 f4       	brne	.+8      	; 0x1d12 <main+0x53c>
                            motorStopRA(false); //If no buttons pressed and in high speed mode, we stop entirely rather than going to tracking
    1d0a:	80 e0       	ldi	r24, 0x00	; 0
    1d0c:	0e 94 29 03 	call	0x652	; 0x652 <motorStopRA>
    1d10:	02 c0       	rjmp	.+4      	; 0x1d16 <main+0x540>
                                                //This ensures that the motors stop if the handcontroller is subsequently unplugged.
                        } else {
                            motorStartRA(); //If the motor is currently stopped at this point, this will automatically start them.
    1d12:	0e 94 63 01 	call	0x2c6	; 0x2c6 <motorStartRA>
                        }
                    }
                    SREG = oldSREG; //End atomic
    1d16:	1f bf       	out	0x3f, r17	; 63
                }//End RA
                
                {//Start DEC
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
    1d18:	19 99       	sbic	0x03, 1	; 3
    1d1a:	03 c0       	rjmp	.+6      	; 0x1d22 <main+0x54c>
    1d1c:	51 e0       	ldi	r21, 0x01	; 1
    1d1e:	41 e0       	ldi	r20, 0x01	; 1
    1d20:	06 c0       	rjmp	.+12     	; 0x1d2e <main+0x558>
    1d22:	1a 9b       	sbis	0x03, 2	; 3
    1d24:	02 c0       	rjmp	.+4      	; 0x1d2a <main+0x554>
    1d26:	4f ef       	ldi	r20, 0xFF	; 255
    1d28:	01 c0       	rjmp	.+2      	; 0x1d2c <main+0x556>
    1d2a:	40 e0       	ldi	r20, 0x00	; 0
    1d2c:	50 e0       	ldi	r21, 0x00	; 0
                    byte dir = CMD_FORWARD;
                    if (st4Pin == ST4N) {
                        //If we need to be going in reverse, switch direction
                        dir = CMD_REVERSE;
                    }
                    byte oldSREG = SREG;
    1d2e:	1f b7       	in	r17, 0x3f	; 63
                    cli(); //We are playing with motor ISR values, so ensure we are atomic.
    1d30:	f8 94       	cli
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
    1d32:	80 91 39 03 	lds	r24, 0x0339
    1d36:	88 23       	and	r24, r24
    1d38:	09 f0       	breq	.+2      	; 0x1d3c <main+0x566>
    1d3a:	54 c0       	rjmp	.+168    	; 0x1de4 <main+0x60e>
    1d3c:	80 91 33 03 	lds	r24, 0x0333
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	25 2f       	mov	r18, r21
    1d44:	30 e0       	ldi	r19, 0x00	; 0
    1d46:	82 17       	cp	r24, r18
    1d48:	93 07       	cpc	r25, r19
    1d4a:	09 f4       	brne	.+2      	; 0x1d4e <main+0x578>
    1d4c:	4b c0       	rjmp	.+150    	; 0x1de4 <main+0x60e>
    1d4e:	20 91 98 00 	lds	r18, 0x0098
    1d52:	30 91 99 00 	lds	r19, 0x0099
    1d56:	80 91 73 03 	lds	r24, 0x0373
    1d5a:	90 91 74 03 	lds	r25, 0x0374
    1d5e:	28 17       	cp	r18, r24
    1d60:	39 07       	cpc	r19, r25
    1d62:	08 f0       	brcs	.+2      	; 0x1d66 <main+0x590>
    1d64:	3f c0       	rjmp	.+126    	; 0x1de4 <main+0x60e>
    1d66:	18 c0       	rjmp	.+48     	; 0x1d98 <main+0x5c2>
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1d68:	80 91 65 03 	lds	r24, 0x0365
    1d6c:	90 91 66 03 	lds	r25, 0x0366
    1d70:	90 93 21 03 	sts	0x0321, r25
    1d74:	80 93 20 03 	sts	0x0320, r24
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
                            //If an ST4 Dec pin is pressed
                            cmd_setIVal(DC,cmd.st4DecIVal);
                            cmd_setDir (DC,dir);
    1d78:	25 2f       	mov	r18, r21
    1d7a:	51 11       	cpse	r21, r1
    1d7c:	21 e0       	ldi	r18, 0x01	; 1
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
    1d7e:	20 93 33 03 	sts	0x0333, r18
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
    1d82:	22 23       	and	r18, r18
    1d84:	19 f0       	breq	.+6      	; 0x1d8c <main+0x5b6>
        cmd.stepDir[target] = -stepSize; //set step direction
    1d86:	d0 92 31 03 	sts	0x0331, r13
    1d8a:	03 c0       	rjmp	.+6      	; 0x1d92 <main+0x5bc>
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    1d8c:	81 e0       	ldi	r24, 0x01	; 1
    1d8e:	80 93 31 03 	sts	0x0331, r24
                            cmd_updateStepDir(DC,1);
                            motorStartDC(); //If the motor is currently stopped at this point, this will automatically start them.
    1d92:	0e 94 d5 01 	call	0x3aa	; 0x3aa <motorStartDC>
    1d96:	03 c0       	rjmp	.+6      	; 0x1d9e <main+0x5c8>
                        } else {
                            //Otherwise stop th DEC motor
                            motorStopDC(false);
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <motorStopDC>
                        }
                    }
                    SREG = oldSREG; //End atomic
    1d9e:	1f bf       	out	0x3f, r17	; 63
    1da0:	4d cd       	rjmp	.-1382   	; 0x183c <main+0x66>
    1da2:	e0 e0       	ldi	r30, 0x00	; 0
inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
    1da4:	ff 27       	eor	r31, r31
    1da6:	e7 fd       	sbrc	r30, 7
    1da8:	f0 95       	com	r31
    1daa:	b5 96       	adiw	r30, 0x25	; 37
    1dac:	ee 0f       	add	r30, r30
    1dae:	ff 1f       	adc	r31, r31
    1db0:	ea 5e       	subi	r30, 0xEA	; 234
    1db2:	fc 4f       	sbci	r31, 0xFC	; 252
    1db4:	80 81       	ld	r24, Z
    1db6:	91 81       	ldd	r25, Z+1	; 0x01
    1db8:	90 93 1f 03 	sts	0x031F, r25
    1dbc:	80 93 1e 03 	sts	0x031E, r24
                        char st4Pin = !getPinValue(st4Pins[DC][ST4N]) ? ST4N : (!getPinValue(st4Pins[DC][ST4P]) ? ST4P : ST4O);
                        //Update target speed.
                        if (st4Pin != ST4O) {
                            //If RA+/- pressed:
                            cmd_setIVal(RA,cmd.st4RAIVal[st4Pin]);
                            motorStartRA();
    1dc0:	0e 94 63 01 	call	0x2c6	; 0x2c6 <motorStartRA>
    1dc4:	bb 24       	eor	r11, r11
    1dc6:	b3 94       	inc	r11
    1dc8:	36 ce       	rjmp	.-916    	; 0x1a36 <main+0x260>
                {//Start RA
                    //Determine which if any ST4 Pin
                    char st4Pin = !getPinValue(st4Pins[RA][ST4N]) ? ST4N : (!getPinValue(st4Pins[RA][ST4P]) ? ST4P : ST4O);
                    //Determine the new direction
                    byte dir = CMD_FORWARD;
                    if ((st4Pin == ST4N) && (cmd.st4RAReverse == CMD_REVERSE)) {
    1dca:	80 91 64 03 	lds	r24, 0x0364
    1dce:	88 23       	and	r24, r24
    1dd0:	11 f0       	breq	.+4      	; 0x1dd6 <main+0x600>
    1dd2:	51 e0       	ldi	r21, 0x01	; 1
    1dd4:	01 c0       	rjmp	.+2      	; 0x1dd8 <main+0x602>
    1dd6:	50 e0       	ldi	r21, 0x00	; 0
    1dd8:	41 e0       	ldi	r20, 0x01	; 1
    1dda:	53 cf       	rjmp	.-346    	; 0x1c82 <main+0x4ac>
                        motorStopRA(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed
                        // - If no RA button is pressed, go at sidereal rate
                        // - Otherwise go at rate corresponding with the pressed button
                        cmd_setIVal(RA, (st4Pin == ST4O) ? cmd.siderealIVal[RA] : cmd.st4RAIVal[st4Pin]);
    1ddc:	4f 3f       	cpi	r20, 0xFF	; 255
    1dde:	09 f0       	breq	.+2      	; 0x1de2 <main+0x60c>
    1de0:	72 cf       	rjmp	.-284    	; 0x1cc6 <main+0x4f0>
    1de2:	6c cf       	rjmp	.-296    	; 0x1cbc <main+0x4e6>
                    if ((cmd.stopped[DC] != CMD_STOPPED) && (cmd.dir[DC] != dir) && (currentMotorSpeed(DC) < cmd.minSpeed[DC])) {
                        //If we are currently moving in the wrong direction and are travelling too fast to instantly reverse
                        motorStopDC(false);
                    } else {
                        //Otherwise we are now free to change to the new required speed.
                        if (st4Pin != ST4O) {
    1de4:	4f 3f       	cpi	r20, 0xFF	; 255
    1de6:	09 f0       	breq	.+2      	; 0x1dea <main+0x614>
    1de8:	bf cf       	rjmp	.-130    	; 0x1d68 <main+0x592>
    1dea:	d6 cf       	rjmp	.-84     	; 0x1d98 <main+0x5c2>

00001dec <_Z26Commands_configureST4Speedh>:
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
}

void Commands_configureST4Speed(byte mode) {
    1dec:	0f 93       	push	r16
    1dee:	1f 93       	push	r17
    1df0:	48 2f       	mov	r20, r24
    cmd.st4Mode = mode;
    1df2:	80 93 5e 03 	sts	0x035E, r24
    if (mode == CMD_ST4_HIGHSPEED) {
    1df6:	82 30       	cpi	r24, 0x02	; 2
    1df8:	a1 f4       	brne	.+40     	; 0x1e22 <_Z26Commands_configureST4Speedh+0x36>
        //Set the ST4 speeds to highspeed standalone mode (goto speeds)
        cmd.st4RAIVal[ST4P] = cmd.normalGotoSpeed[RA];
    1dfa:	80 91 75 03 	lds	r24, 0x0375
    1dfe:	90 91 76 03 	lds	r25, 0x0376
    1e02:	90 93 61 03 	sts	0x0361, r25
    1e06:	80 93 60 03 	sts	0x0360, r24
        cmd.st4RAIVal[ST4N] = cmd.normalGotoSpeed[RA];
    1e0a:	90 93 63 03 	sts	0x0363, r25
    1e0e:	80 93 62 03 	sts	0x0362, r24
        cmd.st4RAReverse    = CMD_REVERSE;
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	80 93 64 03 	sts	0x0364, r24
        cmd.st4DecIVal      = cmd.normalGotoSpeed[DC];
    1e18:	80 91 77 03 	lds	r24, 0x0377
    1e1c:	90 91 78 03 	lds	r25, 0x0378
    1e20:	1b c0       	rjmp	.+54     	; 0x1e58 <_Z26Commands_configureST4Speedh+0x6c>
    } else if (mode == CMD_ST4_STANDALONE) {
    1e22:	81 30       	cpi	r24, 0x01	; 1
    1e24:	f1 f4       	brne	.+60     	; 0x1e62 <_Z26Commands_configureST4Speedh+0x76>
        //Set the ST4 speeds to standalone mode (2x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA])/3; //3x speed
    1e26:	20 91 69 03 	lds	r18, 0x0369
    1e2a:	30 91 6a 03 	lds	r19, 0x036A
    1e2e:	c9 01       	movw	r24, r18
    1e30:	63 e0       	ldi	r22, 0x03	; 3
    1e32:	70 e0       	ldi	r23, 0x00	; 0
    1e34:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <__udivmodhi4>
    1e38:	70 93 61 03 	sts	0x0361, r23
    1e3c:	60 93 60 03 	sts	0x0360, r22
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA])  ; //-1x speed
    1e40:	30 93 63 03 	sts	0x0363, r19
    1e44:	20 93 62 03 	sts	0x0362, r18
        cmd.st4RAReverse    = CMD_REVERSE;
    1e48:	40 93 64 03 	sts	0x0364, r20
        cmd.st4DecIVal      =(cmd.siderealIVal[DC])/2; //2x speed
    1e4c:	80 91 6b 03 	lds	r24, 0x036B
    1e50:	90 91 6c 03 	lds	r25, 0x036C
    1e54:	96 95       	lsr	r25
    1e56:	87 95       	ror	r24
    1e58:	90 93 66 03 	sts	0x0366, r25
    1e5c:	80 93 65 03 	sts	0x0365, r24
    1e60:	3b c0       	rjmp	.+118    	; 0x1ed8 <_Z26Commands_configureST4Speedh+0xec>
    } else {
        //Set the ST4 speeds to normal mode (0.25x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA] * 20)/(20 + cmd.st4SpeedFactor); //(1+SpeedFactor)x speed   -- Max. IVal = 1200, so this will never overflow.
    1e62:	80 91 69 03 	lds	r24, 0x0369
    1e66:	90 91 6a 03 	lds	r25, 0x036A
    1e6a:	24 e1       	ldi	r18, 0x14	; 20
    1e6c:	30 e0       	ldi	r19, 0x00	; 0
    1e6e:	82 9f       	mul	r24, r18
    1e70:	80 01       	movw	r16, r0
    1e72:	83 9f       	mul	r24, r19
    1e74:	10 0d       	add	r17, r0
    1e76:	92 9f       	mul	r25, r18
    1e78:	10 0d       	add	r17, r0
    1e7a:	11 24       	eor	r1, r1
    1e7c:	40 91 5f 03 	lds	r20, 0x035F
    1e80:	e4 2f       	mov	r30, r20
    1e82:	f0 e0       	ldi	r31, 0x00	; 0
    1e84:	bf 01       	movw	r22, r30
    1e86:	6c 5e       	subi	r22, 0xEC	; 236
    1e88:	7f 4f       	sbci	r23, 0xFF	; 255
    1e8a:	c8 01       	movw	r24, r16
    1e8c:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <__udivmodhi4>
    1e90:	70 93 61 03 	sts	0x0361, r23
    1e94:	60 93 60 03 	sts	0x0360, r22
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA] * 20)/(20 - cmd.st4SpeedFactor); //(1-SpeedFactor)x speed
    1e98:	b9 01       	movw	r22, r18
    1e9a:	6e 1b       	sub	r22, r30
    1e9c:	7f 0b       	sbc	r23, r31
    1e9e:	c8 01       	movw	r24, r16
    1ea0:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <__udivmodhi4>
    1ea4:	70 93 63 03 	sts	0x0363, r23
    1ea8:	60 93 62 03 	sts	0x0362, r22
        cmd.st4RAReverse    = CMD_FORWARD;
    1eac:	10 92 64 03 	sts	0x0364, r1
        cmd.st4DecIVal      =(cmd.siderealIVal[DC] * 20)/( 0 + cmd.st4SpeedFactor); //(SpeedFactor)x speed
    1eb0:	80 91 6b 03 	lds	r24, 0x036B
    1eb4:	90 91 6c 03 	lds	r25, 0x036C
    1eb8:	bc 01       	movw	r22, r24
    1eba:	62 9f       	mul	r22, r18
    1ebc:	c0 01       	movw	r24, r0
    1ebe:	63 9f       	mul	r22, r19
    1ec0:	90 0d       	add	r25, r0
    1ec2:	72 9f       	mul	r23, r18
    1ec4:	90 0d       	add	r25, r0
    1ec6:	11 24       	eor	r1, r1
    1ec8:	64 2f       	mov	r22, r20
    1eca:	70 e0       	ldi	r23, 0x00	; 0
    1ecc:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <__udivmodhi4>
    1ed0:	70 93 66 03 	sts	0x0366, r23
    1ed4:	60 93 65 03 	sts	0x0365, r22
    }
}
    1ed8:	1f 91       	pop	r17
    1eda:	0f 91       	pop	r16
    1edc:	08 95       	ret

00001ede <_Z18Commands_getLengthcb>:
                                                 {'x', 0, 6},
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    1ede:	98 2f       	mov	r25, r24
    1ee0:	eb e0       	ldi	r30, 0x0B	; 11
    1ee2:	f2 e0       	ldi	r31, 0x02	; 2
    1ee4:	20 e0       	ldi	r18, 0x00	; 0
    1ee6:	30 e0       	ldi	r19, 0x00	; 0
    for(byte i = 0;i < numberOfCommands;i++){
        if(cmd_commands[i][0] == cmd){
    1ee8:	80 81       	ld	r24, Z
    1eea:	89 17       	cp	r24, r25
    1eec:	89 f4       	brne	.+34     	; 0x1f10 <_Z18Commands_getLengthcb+0x32>
    1eee:	f9 01       	movw	r30, r18
    1ef0:	ee 0f       	add	r30, r30
    1ef2:	ff 1f       	adc	r31, r31
            if(sendRecieve){
    1ef4:	66 23       	and	r22, r22
    1ef6:	31 f0       	breq	.+12     	; 0x1f04 <_Z18Commands_getLengthcb+0x26>
                return cmd_commands[i][1];
    1ef8:	e2 0f       	add	r30, r18
    1efa:	f3 1f       	adc	r31, r19
    1efc:	e5 5f       	subi	r30, 0xF5	; 245
    1efe:	fd 4f       	sbci	r31, 0xFD	; 253
    1f00:	81 81       	ldd	r24, Z+1	; 0x01
    1f02:	08 95       	ret
            } else {
                return cmd_commands[i][2];
    1f04:	e2 0f       	add	r30, r18
    1f06:	f3 1f       	adc	r31, r19
    1f08:	e5 5f       	subi	r30, 0xF5	; 245
    1f0a:	fd 4f       	sbci	r31, 0xFD	; 253
    1f0c:	82 81       	ldd	r24, Z+2	; 0x02
    1f0e:	08 95       	ret
    1f10:	2f 5f       	subi	r18, 0xFF	; 255
    1f12:	3f 4f       	sbci	r19, 0xFF	; 255
    1f14:	33 96       	adiw	r30, 0x03	; 3
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    for(byte i = 0;i < numberOfCommands;i++){
    1f16:	25 32       	cpi	r18, 0x25	; 37
    1f18:	31 05       	cpc	r19, r1
    1f1a:	31 f7       	brne	.-52     	; 0x1ee8 <_Z18Commands_getLengthcb+0xa>
    1f1c:	8f ef       	ldi	r24, 0xFF	; 255
                return cmd_commands[i][2];
            }
        }
    }
    return -1;
}
    1f1e:	08 95       	ret

00001f20 <_Z13Commands_initmh>:

#include "commands.h"

Commands cmd = {0};

void Commands_init(unsigned long _eVal, byte _gVal){
    1f20:	4f 92       	push	r4
    1f22:	5f 92       	push	r5
    1f24:	6f 92       	push	r6
    1f26:	7f 92       	push	r7
    1f28:	8f 92       	push	r8
    1f2a:	9f 92       	push	r9
    1f2c:	af 92       	push	r10
    1f2e:	bf 92       	push	r11
    1f30:	cf 92       	push	r12
    1f32:	df 92       	push	r13
    1f34:	ef 92       	push	r14
    1f36:	ff 92       	push	r15
    1f38:	0f 93       	push	r16
    1f3a:	1f 93       	push	r17
    1f3c:	cf 93       	push	r28
    1f3e:	df 93       	push	r29
    1f40:	3b 01       	movw	r6, r22
    1f42:	4c 01       	movw	r8, r24
    1f44:	44 2e       	mov	r4, r20
    cmd.aVal[RA] = EEPROM_readLong(aVal1_Address);              //steps/axis
    1f46:	8e e0       	ldi	r24, 0x0E	; 14
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	0e 94 ad 10 	call	0x215a	; 0x215a <_Z15EEPROM_readLongj>
    1f4e:	60 93 44 03 	sts	0x0344, r22
    1f52:	70 93 45 03 	sts	0x0345, r23
    1f56:	80 93 46 03 	sts	0x0346, r24
    1f5a:	90 93 47 03 	sts	0x0347, r25
    cmd.aVal[DC] = EEPROM_readLong(aVal2_Address);              //steps/axis
    1f5e:	82 e1       	ldi	r24, 0x12	; 18
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	0e 94 ad 10 	call	0x215a	; 0x215a <_Z15EEPROM_readLongj>
    1f66:	60 93 48 03 	sts	0x0348, r22
    1f6a:	70 93 49 03 	sts	0x0349, r23
    1f6e:	80 93 4a 03 	sts	0x034A, r24
    1f72:	90 93 4b 03 	sts	0x034B, r25
    cmd.bVal[RA] = EEPROM_readLong(bVal1_Address);              //sidereal rate
    1f76:	86 e1       	ldi	r24, 0x16	; 22
    1f78:	90 e0       	ldi	r25, 0x00	; 0
    1f7a:	0e 94 ad 10 	call	0x215a	; 0x215a <_Z15EEPROM_readLongj>
    1f7e:	60 93 4c 03 	sts	0x034C, r22
    1f82:	70 93 4d 03 	sts	0x034D, r23
    1f86:	80 93 4e 03 	sts	0x034E, r24
    1f8a:	90 93 4f 03 	sts	0x034F, r25
    cmd.bVal[DC] = EEPROM_readLong(bVal2_Address);              //sidereal rate
    1f8e:	8a e1       	ldi	r24, 0x1A	; 26
    1f90:	90 e0       	ldi	r25, 0x00	; 0
    1f92:	0e 94 ad 10 	call	0x215a	; 0x215a <_Z15EEPROM_readLongj>
    1f96:	60 93 50 03 	sts	0x0350, r22
    1f9a:	70 93 51 03 	sts	0x0351, r23
    1f9e:	80 93 52 03 	sts	0x0352, r24
    1fa2:	90 93 53 03 	sts	0x0353, r25
    cmd.sVal[RA] = EEPROM_readLong(sVal1_Address);              //steps/worm rotation
    1fa6:	8e e1       	ldi	r24, 0x1E	; 30
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	0e 94 ad 10 	call	0x215a	; 0x215a <_Z15EEPROM_readLongj>
    1fae:	60 93 56 03 	sts	0x0356, r22
    1fb2:	70 93 57 03 	sts	0x0357, r23
    1fb6:	80 93 58 03 	sts	0x0358, r24
    1fba:	90 93 59 03 	sts	0x0359, r25
    cmd.sVal[DC] = EEPROM_readLong(sVal2_Address);              //steps/worm rotation
    1fbe:	82 e2       	ldi	r24, 0x22	; 34
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	0e 94 ad 10 	call	0x215a	; 0x215a <_Z15EEPROM_readLongj>
    1fc6:	60 93 5a 03 	sts	0x035A, r22
    1fca:	70 93 5b 03 	sts	0x035B, r23
    1fce:	80 93 5c 03 	sts	0x035C, r24
    1fd2:	90 93 5d 03 	sts	0x035D, r25
    
    cmd.siderealIVal[RA] = EEPROM_readInt(IVal1_Address);       //steps/worm rotation
    1fd6:	86 e2       	ldi	r24, 0x26	; 38
    1fd8:	90 e0       	ldi	r25, 0x00	; 0
    1fda:	0e 94 9e 10 	call	0x213c	; 0x213c <_Z14EEPROM_readIntj>
    1fde:	90 93 6a 03 	sts	0x036A, r25
    1fe2:	80 93 69 03 	sts	0x0369, r24
    cmd.siderealIVal[DC] = EEPROM_readInt(IVal2_Address);       //steps/worm rotation
    1fe6:	88 e2       	ldi	r24, 0x28	; 40
    1fe8:	90 e0       	ldi	r25, 0x00	; 0
    1fea:	0e 94 9e 10 	call	0x213c	; 0x213c <_Z14EEPROM_readIntj>
    1fee:	90 93 6c 03 	sts	0x036C, r25
    1ff2:	80 93 6b 03 	sts	0x036B, r24
    cmd.normalGotoSpeed[RA] = EEPROM_readByte(RAGoto_Address);  //IVal for normal goto speed
    1ff6:	8c e0       	ldi	r24, 0x0C	; 12
    1ff8:	90 e0       	ldi	r25, 0x00	; 0
    1ffa:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    1ffe:	05 e7       	ldi	r16, 0x75	; 117
    2000:	13 e0       	ldi	r17, 0x03	; 3
    2002:	80 93 75 03 	sts	0x0375, r24
    2006:	10 92 76 03 	sts	0x0376, r1
    cmd.normalGotoSpeed[DC] = EEPROM_readByte(DECGoto_Address); //IVal for normal goto speed
    200a:	8d e0       	ldi	r24, 0x0D	; 13
    200c:	90 e0       	ldi	r25, 0x00	; 0
    200e:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    2012:	80 93 77 03 	sts	0x0377, r24
    2016:	f8 01       	movw	r30, r16
    2018:	13 82       	std	Z+3, r1	; 0x03
    cmd.st4SpeedFactor = EEPROM_readByte(SpeedFactor_Address);  //ST4 speed factor
    201a:	8e e2       	ldi	r24, 0x2E	; 46
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	0e 94 97 10 	call	0x212e	; 0x212e <_Z15EEPROM_readBytej>
    2022:	80 93 5f 03 	sts	0x035F, r24
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    2026:	8c e2       	ldi	r24, 0x2C	; 44
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	0e 94 9e 10 	call	0x213c	; 0x213c <_Z14EEPROM_readIntj>
    202e:	90 93 68 03 	sts	0x0368, r25
    2032:	80 93 67 03 	sts	0x0367, r24
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    2036:	c8 01       	movw	r24, r16
    2038:	08 96       	adiw	r24, 0x08	; 8
    203a:	60 e4       	ldi	r22, 0x40	; 64
    203c:	44 e6       	ldi	r20, 0x64	; 100
    203e:	50 e0       	ldi	r21, 0x00	; 0
    2040:	0e 94 dd 10 	call	0x21ba	; 0x21ba <_Z21EEPROM_readAccelTableP16AccelTableStructhj>
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    2044:	8d e3       	ldi	r24, 0x3D	; 61
    2046:	94 e0       	ldi	r25, 0x04	; 4
    2048:	60 e4       	ldi	r22, 0x40	; 64
    204a:	44 e2       	ldi	r20, 0x24	; 36
    204c:	51 e0       	ldi	r21, 0x01	; 1
    204e:	0e 94 dd 10 	call	0x21ba	; 0x21ba <_Z21EEPROM_readAccelTableP16AccelTableStructhj>
    2052:	26 e1       	ldi	r18, 0x16	; 22
    2054:	33 e0       	ldi	r19, 0x03	; 3
    2056:	79 01       	movw	r14, r18
    2058:	6d e7       	ldi	r22, 0x7D	; 125
    205a:	73 e0       	ldi	r23, 0x03	; 3
    205c:	09 e7       	ldi	r16, 0x79	; 121
    205e:	13 e0       	ldi	r17, 0x03	; 3
    2060:	e9 01       	movw	r28, r18
    2062:	d9 01       	movw	r26, r18
    2064:	40 e0       	ldi	r20, 0x00	; 0
    2066:	50 e0       	ldi	r21, 0x00	; 0
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
        cmd.stepDir[i] = 1; //1-dir*2
    2068:	55 24       	eor	r5, r5
    206a:	53 94       	inc	r5
        cmd.highSpeedMode[i] = false;
        cmd.stopped[i] = CMD_STOPPED;
        cmd.gotoEn[i] = CMD_DISABLED;
        cmd.FVal[i] = CMD_DISABLED;
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
    206c:	a1 2c       	mov	r10, r1
    206e:	b1 2c       	mov	r11, r1
    2070:	e0 e8       	ldi	r30, 0x80	; 128
    2072:	ce 2e       	mov	r12, r30
    2074:	d1 2c       	mov	r13, r1
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
    2076:	1c 8e       	std	Y+28, r1	; 0x1c
        cmd.stepDir[i] = 1; //1-dir*2
    2078:	fa 01       	movw	r30, r20
    207a:	ea 5e       	subi	r30, 0xEA	; 234
    207c:	fc 4f       	sbci	r31, 0xFC	; 252
    207e:	52 8e       	std	Z+26, r5	; 0x1a
        cmd.highSpeedMode[i] = false;
    2080:	1c a2       	std	Y+36, r1	; 0x24
        cmd.stopped[i] = CMD_STOPPED;
    2082:	5a a2       	std	Y+34, r5	; 0x22
        cmd.gotoEn[i] = CMD_DISABLED;
    2084:	18 a2       	std	Y+32, r1	; 0x20
        cmd.FVal[i] = CMD_DISABLED;
    2086:	1e 8e       	std	Y+30, r1	; 0x1e
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
    2088:	f7 01       	movw	r30, r14
    208a:	a1 92       	st	Z+, r10
    208c:	b1 92       	st	Z+, r11
    208e:	c1 92       	st	Z+, r12
    2090:	d1 92       	st	Z+, r13
    2092:	7f 01       	movw	r14, r30
        cmd.IVal[i] = cmd.siderealIVal[i]; //Recieved Speed will be set by :I command.
    2094:	ad 5a       	subi	r26, 0xAD	; 173
    2096:	bf 4f       	sbci	r27, 0xFF	; 255
    2098:	8d 91       	ld	r24, X+
    209a:	9c 91       	ld	r25, X
    209c:	11 97       	sbiw	r26, 0x01	; 1
    209e:	a3 55       	subi	r26, 0x53	; 83
    20a0:	b0 40       	sbci	r27, 0x00	; 0
    20a2:	19 96       	adiw	r26, 0x09	; 9
    20a4:	9c 93       	st	X, r25
    20a6:	8e 93       	st	-X, r24
    20a8:	18 97       	sbiw	r26, 0x08	; 8
        cmd.GVal[i] = 0; //Mode recieved from :G command
    20aa:	18 8a       	std	Y+16, r1	; 0x10
        cmd.HVal[i] = 0; //Value recieved from :H command
    20ac:	f9 01       	movw	r30, r18
    20ae:	12 8a       	std	Z+18, r1	; 0x12
    20b0:	13 8a       	std	Z+19, r1	; 0x13
    20b2:	14 8a       	std	Z+20, r1	; 0x14
    20b4:	15 8a       	std	Z+21, r1	; 0x15
        cmd.eVal[i] = _eVal; //version number
    20b6:	66 a2       	std	Z+38, r6	; 0x26
    20b8:	77 a2       	std	Z+39, r7	; 0x27
    20ba:	80 a6       	std	Z+40, r8	; 0x28
    20bc:	91 a6       	std	Z+41, r9	; 0x29
        cmd.gVal[i] = _gVal; //High speed scalar
    20be:	4e ae       	std	Y+62, r4	; 0x3e
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
    20c0:	fb 01       	movw	r30, r22
    20c2:	80 81       	ld	r24, Z
    20c4:	91 81       	ldd	r25, Z+1	; 0x01
    20c6:	a5 5a       	subi	r26, 0xA5	; 165
    20c8:	bf 4f       	sbci	r27, 0xFF	; 255
    20ca:	11 96       	adiw	r26, 0x01	; 1
    20cc:	9c 93       	st	X, r25
    20ce:	8e 93       	st	-X, r24
        cmd.stopSpeed[i] = cmd.minSpeed[i];
    20d0:	f8 01       	movw	r30, r16
    20d2:	81 93       	st	Z+, r24
    20d4:	91 93       	st	Z+, r25
    20d6:	8f 01       	movw	r16, r30
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
    20d8:	14 97       	sbiw	r26, 0x04	; 4
    20da:	01 96       	adiw	r24, 0x01	; 1
    20dc:	11 96       	adiw	r26, 0x01	; 1
    20de:	9c 93       	st	X, r25
    20e0:	8e 93       	st	-X, r24
    20e2:	a7 55       	subi	r26, 0x57	; 87
    20e4:	b0 40       	sbci	r27, 0x00	; 0
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    20e6:	1d 96       	adiw	r26, 0x0d	; 13
    20e8:	9c 93       	st	X, r25
    20ea:	8e 93       	st	-X, r24
    20ec:	1c 97       	sbiw	r26, 0x0c	; 12
    20ee:	4f 5f       	subi	r20, 0xFF	; 255
    20f0:	5f 4f       	sbci	r21, 0xFF	; 255
    20f2:	21 96       	adiw	r28, 0x01	; 1
    20f4:	12 96       	adiw	r26, 0x02	; 2
    20f6:	2c 5f       	subi	r18, 0xFC	; 252
    20f8:	3f 4f       	sbci	r19, 0xFF	; 255
    20fa:	60 54       	subi	r22, 0x40	; 64
    20fc:	7f 4f       	sbci	r23, 0xFF	; 255
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
    20fe:	42 30       	cpi	r20, 0x02	; 2
    2100:	51 05       	cpc	r21, r1
    2102:	09 f0       	breq	.+2      	; 0x2106 <_Z13Commands_initmh+0x1e6>
    2104:	b8 cf       	rjmp	.-144    	; 0x2076 <_Z13Commands_initmh+0x156>
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
        cmd.stopSpeed[i] = cmd.minSpeed[i];
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
    2106:	80 e0       	ldi	r24, 0x00	; 0
    2108:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <_Z26Commands_configureST4Speedh>
}
    210c:	df 91       	pop	r29
    210e:	cf 91       	pop	r28
    2110:	1f 91       	pop	r17
    2112:	0f 91       	pop	r16
    2114:	ff 90       	pop	r15
    2116:	ef 90       	pop	r14
    2118:	df 90       	pop	r13
    211a:	cf 90       	pop	r12
    211c:	bf 90       	pop	r11
    211e:	af 90       	pop	r10
    2120:	9f 90       	pop	r9
    2122:	8f 90       	pop	r8
    2124:	7f 90       	pop	r7
    2126:	6f 90       	pop	r6
    2128:	5f 90       	pop	r5
    212a:	4f 90       	pop	r4
    212c:	08 95       	ret

0000212e <_Z15EEPROM_readBytej>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    212e:	f9 99       	sbic	0x1f, 1	; 31
    2130:	fe cf       	rjmp	.-4      	; 0x212e <_Z15EEPROM_readBytej>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2132:	92 bd       	out	0x22, r25	; 34
    2134:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2136:	f8 9a       	sbi	0x1f, 0	; 31
    2138:	80 b5       	in	r24, 0x20	; 32
#include <avr/eeprom.h>
#include "EEPROMReader.h"
 
byte EEPROM_readByte(unsigned int address) {
    return eeprom_read_byte((byte*) address);
}
    213a:	08 95       	ret

0000213c <_Z14EEPROM_readIntj>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    213c:	f9 99       	sbic	0x1f, 1	; 31
    213e:	fe cf       	rjmp	.-4      	; 0x213c <_Z14EEPROM_readIntj>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2140:	92 bd       	out	0x22, r25	; 34
    2142:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2144:	f8 9a       	sbi	0x1f, 0	; 31
    2146:	20 b5       	in	r18, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2148:	f9 99       	sbic	0x1f, 1	; 31
    214a:	fe cf       	rjmp	.-4      	; 0x2148 <_Z14EEPROM_readIntj+0xc>

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    214c:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    214e:	92 bd       	out	0x22, r25	; 34
    2150:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2152:	f8 9a       	sbi	0x1f, 0	; 31
    2154:	90 b5       	in	r25, 0x20	; 32
    return fetcher.integer;
}
    2156:	82 2f       	mov	r24, r18
    2158:	08 95       	ret

0000215a <_Z15EEPROM_readLongj>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    215a:	f9 99       	sbic	0x1f, 1	; 31
    215c:	fe cf       	rjmp	.-4      	; 0x215a <_Z15EEPROM_readLongj>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    215e:	92 bd       	out	0x22, r25	; 34
    2160:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2162:	f8 9a       	sbi	0x1f, 0	; 31
    2164:	20 b5       	in	r18, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2166:	f9 99       	sbic	0x1f, 1	; 31
    2168:	fe cf       	rjmp	.-4      	; 0x2166 <_Z15EEPROM_readLongj+0xc>
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    216a:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    216c:	92 bd       	out	0x22, r25	; 34
    216e:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2170:	f8 9a       	sbi	0x1f, 0	; 31
    2172:	70 b5       	in	r23, 0x20	; 32
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    fetcher.array[1] = EEPROM_readInt(address+2);
    2174:	01 96       	adiw	r24, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2176:	f9 99       	sbic	0x1f, 1	; 31
    2178:	fe cf       	rjmp	.-4      	; 0x2176 <_Z15EEPROM_readLongj+0x1c>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    217a:	92 bd       	out	0x22, r25	; 34
    217c:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    217e:	f8 9a       	sbi	0x1f, 0	; 31
    2180:	30 b5       	in	r19, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2182:	f9 99       	sbic	0x1f, 1	; 31
    2184:	fe cf       	rjmp	.-4      	; 0x2182 <_Z15EEPROM_readLongj+0x28>
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    2186:	01 96       	adiw	r24, 0x01	; 1
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    2188:	92 bd       	out	0x22, r25	; 34
    218a:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    218c:	f8 9a       	sbi	0x1f, 0	; 31
    218e:	90 b5       	in	r25, 0x20	; 32
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    2190:	62 2f       	mov	r22, r18
    fetcher.array[1] = EEPROM_readInt(address+2);
    2192:	83 2f       	mov	r24, r19
    return fetcher.integer;
}
    2194:	08 95       	ret

00002196 <_Z17EEPROM_readStringPchj>:

void EEPROM_readString(char* string, byte len, unsigned int address) {
    2196:	fc 01       	movw	r30, r24
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	0c c0       	rjmp	.+24     	; 0x21b4 <_Z17EEPROM_readStringPchj+0x1e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    219c:	f9 99       	sbic	0x1f, 1	; 31
    219e:	fe cf       	rjmp	.-4      	; 0x219c <_Z17EEPROM_readStringPchj+0x6>
    for(byte i = 0; i < len; i++) {
        string[i] = EEPROM_readByte(address++);
    21a0:	9a 01       	movw	r18, r20
    21a2:	2f 5f       	subi	r18, 0xFF	; 255
    21a4:	3f 4f       	sbci	r19, 0xFF	; 255
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21a6:	52 bd       	out	0x22, r21	; 34
    21a8:	41 bd       	out	0x21, r20	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    21aa:	f8 9a       	sbi	0x1f, 0	; 31
    21ac:	80 b5       	in	r24, 0x20	; 32
    21ae:	81 93       	st	Z+, r24
    fetcher.array[1] = EEPROM_readInt(address+2);
    return fetcher.integer;
}

void EEPROM_readString(char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
    21b0:	9f 5f       	subi	r25, 0xFF	; 255
    21b2:	a9 01       	movw	r20, r18
    21b4:	96 17       	cp	r25, r22
    21b6:	90 f3       	brcs	.-28     	; 0x219c <_Z17EEPROM_readStringPchj+0x6>
        string[i] = EEPROM_readByte(address++);
    }
}
    21b8:	08 95       	ret

000021ba <_Z21EEPROM_readAccelTableP16AccelTableStructhj>:

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    21ba:	fc 01       	movw	r30, r24
    21bc:	20 e0       	ldi	r18, 0x00	; 0
    21be:	25 c0       	rjmp	.+74     	; 0x220a <__stack+0xb>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21c0:	f9 99       	sbic	0x1f, 1	; 31
    21c2:	fe cf       	rjmp	.-4      	; 0x21c0 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x6>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21c4:	52 bd       	out	0x22, r21	; 34
    21c6:	41 bd       	out	0x21, r20	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    21c8:	f8 9a       	sbi	0x1f, 0	; 31
    21ca:	90 b5       	in	r25, 0x20	; 32
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21cc:	f9 99       	sbic	0x1f, 1	; 31
    21ce:	fe cf       	rjmp	.-4      	; 0x21cc <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x12>
    21d0:	4f 5f       	subi	r20, 0xFF	; 255
    21d2:	5f 4f       	sbci	r21, 0xFF	; 255
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21d4:	52 bd       	out	0x22, r21	; 34
    21d6:	41 bd       	out	0x21, r20	; 33
    21d8:	41 50       	subi	r20, 0x01	; 1
    21da:	50 40       	sbci	r21, 0x00	; 0
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    21dc:	f8 9a       	sbi	0x1f, 0	; 31
    21de:	80 b5       	in	r24, 0x20	; 32
    for(byte i = 0; i < elements; i++) {
        table[i].speed = EEPROM_readInt(address);
    21e0:	90 83       	st	Z, r25
    21e2:	81 83       	std	Z+1, r24	; 0x01
    21e4:	ca 01       	movw	r24, r20
    21e6:	02 96       	adiw	r24, 0x02	; 2
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21e8:	f9 99       	sbic	0x1f, 1	; 31
    21ea:	fe cf       	rjmp	.-4      	; 0x21e8 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x2e>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21ec:	92 bd       	out	0x22, r25	; 34
    21ee:	81 bd       	out	0x21, r24	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    21f0:	f8 9a       	sbi	0x1f, 0	; 31
    21f2:	80 b5       	in	r24, 0x20	; 32
    21f4:	4d 5f       	subi	r20, 0xFD	; 253
    21f6:	5f 4f       	sbci	r21, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    21f8:	f9 99       	sbic	0x1f, 1	; 31
    21fa:	fe cf       	rjmp	.-4      	; 0x21f8 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x3e>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    21fc:	52 bd       	out	0x22, r21	; 34
    21fe:	41 bd       	out	0x21, r20	; 33
        "/* END EEPROM READ CRITICAL SECTION */ \n\t"
        : "=r" (__result)
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    2200:	f8 9a       	sbi	0x1f, 0	; 31
    2202:	90 b5       	in	r25, 0x20	; 32
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
    2204:	82 83       	std	Z+2, r24	; 0x02
        string[i] = EEPROM_readByte(address++);
    }
}

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
    2206:	2f 5f       	subi	r18, 0xFF	; 255
    2208:	33 96       	adiw	r30, 0x03	; 3
    220a:	26 17       	cp	r18, r22
    220c:	08 f4       	brcc	.+2      	; 0x2210 <__stack+0x11>
    220e:	d8 cf       	rjmp	.-80     	; 0x21c0 <_Z21EEPROM_readAccelTableP16AccelTableStructhj+0x6>
        table[i].speed = EEPROM_readInt(address);
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
        address = address + sizeof(byte);
    }
}
    2210:	08 95       	ret

00002212 <_Z16EEPROM_writeBytehj>:
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2212:	f9 99       	sbic	0x1f, 1	; 31
    2214:	fe cf       	rjmp	.-4      	; 0x2212 <_Z16EEPROM_writeBytehj>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2216:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2218:	72 bd       	out	0x22, r23	; 34
    221a:	61 bd       	out	0x21, r22	; 33
#endif
    EEDR = __value;
    221c:	80 bd       	out	0x20, r24	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    221e:	0f b6       	in	r0, 0x3f	; 63
    2220:	f8 94       	cli
    2222:	fa 9a       	sbi	0x1f, 2	; 31
    2224:	f9 9a       	sbi	0x1f, 1	; 31
    2226:	0f be       	out	0x3f, r0	; 63

void EEPROM_writeByte(byte val, unsigned int address) {
    return eeprom_write_byte((byte*) address, val);
}
    2228:	08 95       	ret

0000222a <_Z15EEPROM_writeIntjj>:

void EEPROM_writeInt(unsigned int val, unsigned int address) {
    TwoBytes storer = {val};
    222a:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    222c:	f9 99       	sbic	0x1f, 1	; 31
    222e:	fe cf       	rjmp	.-4      	; 0x222c <_Z15EEPROM_writeIntjj+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2230:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    2232:	72 bd       	out	0x22, r23	; 34
    2234:	61 bd       	out	0x21, r22	; 33
#endif
    EEDR = __value;
    2236:	20 bd       	out	0x20, r18	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    2238:	0f b6       	in	r0, 0x3f	; 63
    223a:	f8 94       	cli
    223c:	fa 9a       	sbi	0x1f, 2	; 31
    223e:	f9 9a       	sbi	0x1f, 1	; 31
    2240:	0f be       	out	0x3f, r0	; 63
    EEPROM_writeByte(storer.array[0], address);
    EEPROM_writeByte(storer.array[1], address+1);
    2242:	93 2f       	mov	r25, r19
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2244:	f9 99       	sbic	0x1f, 1	; 31
    2246:	fe cf       	rjmp	.-4      	; 0x2244 <_Z15EEPROM_writeIntjj+0x1a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    2248:	1f ba       	out	0x1f, r1	; 31
    224a:	6f 5f       	subi	r22, 0xFF	; 255
    224c:	7f 4f       	sbci	r23, 0xFF	; 255
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    224e:	72 bd       	out	0x22, r23	; 34
    2250:	61 bd       	out	0x21, r22	; 33
#endif
    EEDR = __value;
    2252:	90 bd       	out	0x20, r25	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    2254:	0f b6       	in	r0, 0x3f	; 63
    2256:	f8 94       	cli
    2258:	fa 9a       	sbi	0x1f, 2	; 31
    225a:	f9 9a       	sbi	0x1f, 1	; 31
    225c:	0f be       	out	0x3f, r0	; 63
}
    225e:	08 95       	ret

00002260 <_Z16EEPROM_writeLongmj>:

void EEPROM_writeLong(unsigned long val, unsigned int address) {
    2260:	ef 92       	push	r14
    2262:	ff 92       	push	r15
    2264:	0f 93       	push	r16
    2266:	1f 93       	push	r17
    2268:	8a 01       	movw	r16, r20
    FourBytes storer = {val};
    226a:	f8 2e       	mov	r15, r24
    226c:	e9 2e       	mov	r14, r25
    EEPROM_writeInt(storer.array[0], address);
    226e:	cb 01       	movw	r24, r22
    2270:	ba 01       	movw	r22, r20
    2272:	0e 94 15 11 	call	0x222a	; 0x222a <_Z15EEPROM_writeIntjj>
    EEPROM_writeInt(storer.array[1], address+2);
    2276:	0e 5f       	subi	r16, 0xFE	; 254
    2278:	1f 4f       	sbci	r17, 0xFF	; 255
    227a:	8f 2d       	mov	r24, r15
    227c:	9e 2d       	mov	r25, r14
    227e:	b8 01       	movw	r22, r16
    2280:	0e 94 15 11 	call	0x222a	; 0x222a <_Z15EEPROM_writeIntjj>
}
    2284:	1f 91       	pop	r17
    2286:	0f 91       	pop	r16
    2288:	ff 90       	pop	r15
    228a:	ef 90       	pop	r14
    228c:	08 95       	ret

0000228e <_Z18EEPROM_writeStringPKchj>:

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    228e:	fc 01       	movw	r30, r24
    2290:	20 e0       	ldi	r18, 0x00	; 0
    2292:	30 e0       	ldi	r19, 0x00	; 0
    2294:	12 c0       	rjmp	.+36     	; 0x22ba <_Z18EEPROM_writeStringPKchj+0x2c>
    for(byte i = 0; i < len; i++) {
        EEPROM_writeByte(string[i], address+i);
    2296:	70 81       	ld	r23, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2298:	f9 99       	sbic	0x1f, 1	; 31
    229a:	fe cf       	rjmp	.-4      	; 0x2298 <_Z18EEPROM_writeStringPKchj+0xa>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    229c:	1f ba       	out	0x1f, r1	; 31
    229e:	c9 01       	movw	r24, r18
    22a0:	84 0f       	add	r24, r20
    22a2:	95 1f       	adc	r25, r21
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    22a4:	92 bd       	out	0x22, r25	; 34
    22a6:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    22a8:	70 bd       	out	0x20, r23	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    22aa:	0f b6       	in	r0, 0x3f	; 63
    22ac:	f8 94       	cli
    22ae:	fa 9a       	sbi	0x1f, 2	; 31
    22b0:	f9 9a       	sbi	0x1f, 1	; 31
    22b2:	0f be       	out	0x3f, r0	; 63
    22b4:	2f 5f       	subi	r18, 0xFF	; 255
    22b6:	3f 4f       	sbci	r19, 0xFF	; 255
    22b8:	31 96       	adiw	r30, 0x01	; 1
    EEPROM_writeInt(storer.array[0], address);
    EEPROM_writeInt(storer.array[1], address+2);
}

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
    22ba:	26 17       	cp	r18, r22
    22bc:	60 f3       	brcs	.-40     	; 0x2296 <_Z18EEPROM_writeStringPKchj+0x8>
        EEPROM_writeByte(string[i], address+i);
    }
}
    22be:	08 95       	ret

000022c0 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj>:

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    22c0:	ef 92       	push	r14
    22c2:	ff 92       	push	r15
    22c4:	0f 93       	push	r16
    22c6:	1f 93       	push	r17
    22c8:	cf 93       	push	r28
    22ca:	df 93       	push	r29
    22cc:	e6 2e       	mov	r14, r22
    22ce:	8a 01       	movw	r16, r20
    22d0:	ec 01       	movw	r28, r24
    22d2:	ff 24       	eor	r15, r15
    22d4:	17 c0       	rjmp	.+46     	; 0x2304 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x44>
    for(byte i = 0; i < elements; i++) {
        EEPROM_writeInt(table[i].speed,address);
    22d6:	88 81       	ld	r24, Y
    22d8:	99 81       	ldd	r25, Y+1	; 0x01
    22da:	b8 01       	movw	r22, r16
    22dc:	0e 94 15 11 	call	0x222a	; 0x222a <_Z15EEPROM_writeIntjj>
    22e0:	c8 01       	movw	r24, r16
    22e2:	02 96       	adiw	r24, 0x02	; 2
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
    22e4:	2a 81       	ldd	r18, Y+2	; 0x02
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    22e6:	f9 99       	sbic	0x1f, 1	; 31
    22e8:	fe cf       	rjmp	.-4      	; 0x22e6 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x26>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    22ea:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    22ec:	92 bd       	out	0x22, r25	; 34
    22ee:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    22f0:	20 bd       	out	0x20, r18	; 32
        : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
    22f2:	0f b6       	in	r0, 0x3f	; 63
    22f4:	f8 94       	cli
    22f6:	fa 9a       	sbi	0x1f, 2	; 31
    22f8:	f9 9a       	sbi	0x1f, 1	; 31
    22fa:	0f be       	out	0x3f, r0	; 63
    22fc:	0d 5f       	subi	r16, 0xFD	; 253
    22fe:	1f 4f       	sbci	r17, 0xFF	; 255
        EEPROM_writeByte(string[i], address+i);
    }
}

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
    2300:	f3 94       	inc	r15
    2302:	23 96       	adiw	r28, 0x03	; 3
    2304:	fe 14       	cp	r15, r14
    2306:	38 f3       	brcs	.-50     	; 0x22d6 <_Z22EEPROM_writeAccelTableP16AccelTableStructhj+0x16>
        EEPROM_writeInt(table[i].speed,address);
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
        address = address + sizeof(byte);
    }
}
    2308:	df 91       	pop	r29
    230a:	cf 91       	pop	r28
    230c:	1f 91       	pop	r17
    230e:	0f 91       	pop	r16
    2310:	ff 90       	pop	r15
    2312:	ef 90       	pop	r14
    2314:	08 95       	ret

00002316 <_Z17Serial_initialisem>:
RingBuffer rxBuf = {{0},0,0};

bool softSPIEnabled = false;

//Initialise the hardware UART port and set baud rate.
void Serial_initialise(const unsigned long baud) {
    2316:	ef 92       	push	r14
    2318:	ff 92       	push	r15
    231a:	0f 93       	push	r16
    231c:	1f 93       	push	r17
    231e:	7b 01       	movw	r14, r22
    2320:	8c 01       	movw	r16, r24
    Byter baud_setting;

    UCSRnA = _BV(U2Xn);
    2322:	82 e0       	ldi	r24, 0x02	; 2
    2324:	80 93 c0 00 	sts	0x00C0, r24
    baud_setting.integer = (F_CPU / 4 / baud - 1) / 2;
    2328:	60 e0       	ldi	r22, 0x00	; 0
    232a:	79 e0       	ldi	r23, 0x09	; 9
    232c:	8d e3       	ldi	r24, 0x3D	; 61
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	a8 01       	movw	r20, r16
    2332:	97 01       	movw	r18, r14
    2334:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <__udivmodsi4>
    2338:	21 50       	subi	r18, 0x01	; 1
    233a:	30 40       	sbci	r19, 0x00	; 0
    233c:	40 40       	sbci	r20, 0x00	; 0
    233e:	50 40       	sbci	r21, 0x00	; 0
    2340:	56 95       	lsr	r21
    2342:	47 95       	ror	r20
    2344:	37 95       	ror	r19
    2346:	27 95       	ror	r18
    2348:	92 2f       	mov	r25, r18
    234a:	23 2f       	mov	r18, r19

    if (baud_setting.high & 0xF0) {
    234c:	83 2f       	mov	r24, r19
    234e:	80 7f       	andi	r24, 0xF0	; 240
    2350:	a1 f0       	breq	.+40     	; 0x237a <_Z17Serial_initialisem+0x64>
        UCSRnA = 0;
    2352:	10 92 c0 00 	sts	0x00C0, r1
        baud_setting.integer = (F_CPU / 8 / baud - 1) / 2;
    2356:	60 e8       	ldi	r22, 0x80	; 128
    2358:	74 e8       	ldi	r23, 0x84	; 132
    235a:	8e e1       	ldi	r24, 0x1E	; 30
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	a8 01       	movw	r20, r16
    2360:	97 01       	movw	r18, r14
    2362:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <__udivmodsi4>
    2366:	21 50       	subi	r18, 0x01	; 1
    2368:	30 40       	sbci	r19, 0x00	; 0
    236a:	40 40       	sbci	r20, 0x00	; 0
    236c:	50 40       	sbci	r21, 0x00	; 0
    236e:	56 95       	lsr	r21
    2370:	47 95       	ror	r20
    2372:	37 95       	ror	r19
    2374:	27 95       	ror	r18
    2376:	92 2f       	mov	r25, r18
    2378:	23 2f       	mov	r18, r19
    }

    // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
    UBRRnH = baud_setting.high & 0x0F;
    237a:	2f 70       	andi	r18, 0x0F	; 15
    237c:	20 93 c5 00 	sts	0x00C5, r18
    UBRRnL = baud_setting.low;
    2380:	90 93 c4 00 	sts	0x00C4, r25
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    2384:	8f b7       	in	r24, 0x3f	; 63
    cli();
    2386:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    2388:	10 92 1d 05 	sts	0x051D, r1
    txBuf.tail = 0;
    238c:	10 92 1e 05 	sts	0x051E, r1
    rxBuf.head = 0;
    2390:	10 92 3f 05 	sts	0x053F, r1
    rxBuf.tail = 0;
    2394:	10 92 40 05 	sts	0x0540, r1
    SREG = oldSREG;
    2398:	8f bf       	out	0x3f, r24	; 63

    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.

    //And enable
    sbi(UCSRnB, RXENn);
    239a:	80 91 c1 00 	lds	r24, 0x00C1
    239e:	80 61       	ori	r24, 0x10	; 16
    23a0:	80 93 c1 00 	sts	0x00C1, r24
    sbi(UCSRnB, TXENn);
    23a4:	80 91 c1 00 	lds	r24, 0x00C1
    23a8:	88 60       	ori	r24, 0x08	; 8
    23aa:	80 93 c1 00 	sts	0x00C1, r24
    sbi(UCSRnB, RXCIEn);
    23ae:	80 91 c1 00 	lds	r24, 0x00C1
    23b2:	80 68       	ori	r24, 0x80	; 128
    23b4:	80 93 c1 00 	sts	0x00C1, r24
    cbi(UCSRnB, UDRIEn);
    23b8:	80 91 c1 00 	lds	r24, 0x00C1
    23bc:	8f 7d       	andi	r24, 0xDF	; 223
    23be:	80 93 c1 00 	sts	0x00C1, r24
}
    23c2:	1f 91       	pop	r17
    23c4:	0f 91       	pop	r16
    23c6:	ff 90       	pop	r15
    23c8:	ef 90       	pop	r14
    23ca:	08 95       	ret

000023cc <_Z14Serial_disablev>:

//Disable the hardware UART port
void Serial_disable() {
    cbi(UCSRnB, RXENn);
    23cc:	e1 ec       	ldi	r30, 0xC1	; 193
    23ce:	f0 e0       	ldi	r31, 0x00	; 0
    23d0:	80 81       	ld	r24, Z
    23d2:	8f 7e       	andi	r24, 0xEF	; 239
    23d4:	80 83       	st	Z, r24
    cbi(UCSRnB, TXENn);
    23d6:	80 81       	ld	r24, Z
    23d8:	87 7f       	andi	r24, 0xF7	; 247
    23da:	80 83       	st	Z, r24
    cbi(UCSRnB, RXCIEn);
    23dc:	80 81       	ld	r24, Z
    23de:	8f 77       	andi	r24, 0x7F	; 127
    23e0:	80 83       	st	Z, r24
    cbi(UCSRnB, UDRIEn);
    23e2:	80 81       	ld	r24, Z
    23e4:	8f 7d       	andi	r24, 0xDF	; 223
    23e6:	80 83       	st	Z, r24
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    23e8:	8f b7       	in	r24, 0x3f	; 63
    cli();
    23ea:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    23ec:	10 92 1d 05 	sts	0x051D, r1
    txBuf.tail = 0;
    23f0:	10 92 1e 05 	sts	0x051E, r1
    rxBuf.head = 0;
    23f4:	10 92 3f 05 	sts	0x053F, r1
    rxBuf.tail = 0;
    23f8:	10 92 40 05 	sts	0x0540, r1
    SREG = oldSREG;
    23fc:	8f bf       	out	0x3f, r24	; 63
    cbi(UCSRnB, RXENn);
    cbi(UCSRnB, TXENn);
    cbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}
    23fe:	08 95       	ret

00002400 <_Z14SPI_initialisev>:
}

//Initialise the Software SPI by setting ports to correct direction and state.
void SPI_initialise() {
    //Set all SPI pins to idle levels
    setPinDir  (SPIClockPin_Define,OUTPUT); //Clock is output idle high
    2400:	21 9a       	sbi	0x04, 1	; 4
    setPinValue(SPIClockPin_Define,  HIGH);
    2402:	29 9a       	sbi	0x05, 1	; 5
    setPinDir  (SPIMISOPin_Define,  INPUT); //MISO is input pull-up
    2404:	23 98       	cbi	0x04, 3	; 4
    setPinValue(SPIMISOPin_Define,   HIGH);
    2406:	2b 9a       	sbi	0x05, 3	; 5
    setPinDir  (SPIMOSIPin_Define, OUTPUT); //MOSI is output idle high
    2408:	22 9a       	sbi	0x04, 2	; 4
    setPinValue(SPIMOSIPin_Define,   HIGH);
    240a:	2a 9a       	sbi	0x05, 2	; 5
    setPinDir  (SPISSnPin_Define,  OUTPUT); //SSn is output idle high
    240c:	20 9a       	sbi	0x04, 0	; 4
    setPinValue(SPISSnPin_Define,    HIGH);
    240e:	28 9a       	sbi	0x05, 0	; 5
    //Standalone pin is switching to SPI ready, so ensure we out pull-up is to high.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    2410:	11 9a       	sbi	0x02, 1	; 2
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    2412:	8f b7       	in	r24, 0x3f	; 63
    cli();
    2414:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    2416:	10 92 1d 05 	sts	0x051D, r1
    txBuf.tail = 0;
    241a:	10 92 1e 05 	sts	0x051E, r1
    rxBuf.head = 0;
    241e:	10 92 3f 05 	sts	0x053F, r1
    rxBuf.tail = 0;
    2422:	10 92 40 05 	sts	0x0540, r1
    SREG = oldSREG;
    2426:	8f bf       	out	0x3f, r24	; 63
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.
    
    //Now enabled
    softSPIEnabled = true;
    2428:	81 e0       	ldi	r24, 0x01	; 1
    242a:	80 93 41 05 	sts	0x0541, r24
}
    242e:	08 95       	ret

00002430 <_Z11SPI_disablev>:

//Disable the Software SPI by setting all ports back to input pull-up
void SPI_disable() {
    //Set all SPI pins to High-Z
    setPinDir  (SPIClockPin_Define, INPUT);
    2430:	21 98       	cbi	0x04, 1	; 4
    setPinValue(SPIClockPin_Define,  HIGH);
    2432:	29 9a       	sbi	0x05, 1	; 5
    setPinDir  (SPIMISOPin_Define,  INPUT);
    2434:	23 98       	cbi	0x04, 3	; 4
    setPinValue(SPIMISOPin_Define,   HIGH);
    2436:	2b 9a       	sbi	0x05, 3	; 5
    setPinDir  (SPIMOSIPin_Define,  INPUT);
    2438:	22 98       	cbi	0x04, 2	; 4
    setPinValue(SPIMOSIPin_Define,   HIGH);
    243a:	2a 9a       	sbi	0x05, 2	; 5
    setPinDir  (SPISSnPin_Define,   INPUT);
    243c:	20 98       	cbi	0x04, 0	; 4
    setPinValue(SPISSnPin_Define,    HIGH);
    243e:	28 9a       	sbi	0x05, 0	; 5
    //Now disabled
    softSPIEnabled = false;
    2440:	10 92 41 05 	sts	0x0541, r1
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    2444:	8f b7       	in	r24, 0x3f	; 63
    cli();
    2446:	f8 94       	cli
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    2448:	10 92 1d 05 	sts	0x051D, r1
    txBuf.tail = 0;
    244c:	10 92 1e 05 	sts	0x051E, r1
    rxBuf.head = 0;
    2450:	10 92 3f 05 	sts	0x053F, r1
    rxBuf.tail = 0;
    2454:	10 92 40 05 	sts	0x0540, r1
    SREG = oldSREG;
    2458:	8f bf       	out	0x3f, r24	; 63
    setPinDir  (SPISSnPin_Define,   INPUT);
    setPinValue(SPISSnPin_Define,    HIGH);
    //Now disabled
    softSPIEnabled = false;
    Serial_clear(); //Empty the buffer of any outstanding data.
}
    245a:	08 95       	ret

0000245c <_Z12SPI_transferh>:

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    245c:	98 e0       	ldi	r25, 0x08	; 8
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
        setPinValue(SPIClockPin_Define,LOW); //Falling Edge   //--     2 cycles         .
    245e:	29 98       	cbi	0x05, 1	; 5
        if (data & 0x80) { //Send MSB first                   //-- 2 cycles | 1 cycle    |
    2460:	87 ff       	sbrs	r24, 7
    2462:	02 c0       	rjmp	.+4      	; 0x2468 <_Z12SPI_transferh+0xc>
            setPinValue(SPIMOSIPin_Define,HIGH);              //-- 2 cycles | -          |
    2464:	2a 9a       	sbi	0x05, 2	; 5
    2466:	02 c0       	rjmp	.+4      	; 0x246c <_Z12SPI_transferh+0x10>
        } else {                                              //--          | 2 cycles    > 8 cycles for both paths
            nop();                                            //--          | 1 cycle    |
    2468:	00 00       	nop
            setPinValue(SPIMOSIPin_Define,LOW);               //--          | 2 cycles   |
    246a:	2a 98       	cbi	0x05, 2	; 5
        }                                                     //-- 2 cycles | -         '
        setPinValue(SPIClockPin_Define,HIGH); //Rising Edge   //--      2 cycles        .
    246c:	29 9a       	sbi	0x05, 1	; 5
        data = data << 1; //Shift MSB-1 to MSB                //--      1 cycle          |
    246e:	88 0f       	add	r24, r24
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
    2470:	1b 99       	sbic	0x03, 3	; 3
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
    2472:	8f 5f       	subi	r24, 0xFF	; 255
}

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
    2474:	91 50       	subi	r25, 0x01	; 1
    2476:	99 f7       	brne	.-26     	; 0x245e <_Z12SPI_transferh+0x2>
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
        }                                                     //--       3 cycles       '
    }                                                         //-- Total Path is 16 cycles = 1MHz @ 16MHz clock
    return data; //Return shifted in data.                    //-- 5 Cycles on entry (including CALL), 3 cycles on exit (including RET)
}
    2478:	08 95       	ret

0000247a <_Z8SPI_readv>:
//Performs an SPI read request and stores the data in the RX buffer.
// - If there is no space in the buffer, a read request will *not* be performed
//   The buffer should be first emptied by using Serial_read()
void SPI_read(void) {
    //First we check if there is space in the buffer, and that the slave has data to send
    if ((rxBuf.tail != rxBuf.head) && !(getPinValue(standalonePin[STANDALONE_IRQ]))) {
    247a:	90 91 40 05 	lds	r25, 0x0540
    247e:	80 91 3f 05 	lds	r24, 0x053F
    2482:	98 17       	cp	r25, r24
    2484:	c9 f0       	breq	.+50     	; 0x24b8 <_Z8SPI_readv+0x3e>
    2486:	48 99       	sbic	0x09, 0	; 9
    2488:	17 c0       	rjmp	.+46     	; 0x24b8 <_Z8SPI_readv+0x3e>
        //If there is, then do a read request  
        setPinValue(SPISSnPin_Define,LOW); //Select the slave
    248a:	28 98       	cbi	0x05, 0	; 5
        SPI_transfer(SPI_READ); //First send a read request
    248c:	81 e8       	ldi	r24, 0x81	; 129
    248e:	0e 94 2e 12 	call	0x245c	; 0x245c <_Z12SPI_transferh>
        while(!getPinValue(standalonePin[STANDALONE_IRQ])); //Wait for the slave to have loaded its data
    2492:	48 9b       	sbis	0x09, 0	; 9
    2494:	fe cf       	rjmp	.-4      	; 0x2492 <_Z8SPI_readv+0x18>
        byte data = SPI_transfer(SPI_RESP); //Then send a response request (clocks data from slave to master and informs slave that transfer is done)
    2496:	80 e8       	ldi	r24, 0x80	; 128
    2498:	0e 94 2e 12 	call	0x245c	; 0x245c <_Z12SPI_transferh>
        if (SPI_ISDATA(data)) {
    249c:	87 fd       	sbrc	r24, 7
    249e:	0b c0       	rjmp	.+22     	; 0x24b6 <_Z8SPI_readv+0x3c>
            //If the slave had data available (indicated by the MSB being clear)
            rxBuf.buffer[rxBuf.head] = data; //Store the data
    24a0:	e0 91 3f 05 	lds	r30, 0x053F
    24a4:	f0 e0       	ldi	r31, 0x00	; 0
    24a6:	e1 5e       	subi	r30, 0xE1	; 225
    24a8:	fa 4f       	sbci	r31, 0xFA	; 250
    24aa:	80 83       	st	Z, r24
            rxBuf.head++; //And increment the head
    24ac:	80 91 3f 05 	lds	r24, 0x053F
    24b0:	8f 5f       	subi	r24, 0xFF	; 255
    24b2:	80 93 3f 05 	sts	0x053F, r24
        }
        setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    24b6:	28 9a       	sbi	0x05, 0	; 5
    24b8:	08 95       	ret

000024ba <_Z9SPI_writeh>:
    }
}

//Performs an SPI write request.
void SPI_write(byte data) {
    setPinValue(SPISSnPin_Define,LOW); //Select the slave
    24ba:	28 98       	cbi	0x05, 0	; 5
    SPI_transfer(data & SPI_DATA); 
    24bc:	8f 77       	andi	r24, 0x7F	; 127
    24be:	0e 94 2e 12 	call	0x245c	; 0x245c <_Z12SPI_transferh>
    setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    24c2:	28 9a       	sbi	0x05, 0	; 5
}
    24c4:	08 95       	ret

000024c6 <_Z16Serial_availablev>:

//Checks if there is any data available in the RX buffer.
// - If in SPI mode, this will also perform an SPI read transfer to see if there is any valid data.
byte Serial_available(void) {
    if (softSPIEnabled) {
    24c6:	80 91 41 05 	lds	r24, 0x0541
    24ca:	88 23       	and	r24, r24
    24cc:	11 f0       	breq	.+4      	; 0x24d2 <_Z16Serial_availablev+0xc>
        //If SPI is enabled, we do a read to check if there is any data.
        SPI_read();
    24ce:	0e 94 3d 12 	call	0x247a	; 0x247a <_Z8SPI_readv>
    }
    return ((rxBuf.head - rxBuf.tail) & BUFFER_PTR_MASK); //number of bytes available
    24d2:	80 91 3f 05 	lds	r24, 0x053F
    24d6:	90 91 40 05 	lds	r25, 0x0540
    24da:	89 1b       	sub	r24, r25
}
    24dc:	8f 71       	andi	r24, 0x1F	; 31
    24de:	08 95       	ret

000024e0 <_Z11Serial_readv>:

//Returns the next available data byte in the buffer
// - If there is nothing there, -1 is returned.
char Serial_read(void) {
    //If UART is enabled
    byte tail = rxBuf.tail;
    24e0:	90 91 40 05 	lds	r25, 0x0540
    if (rxBuf.head == tail) {
    24e4:	80 91 3f 05 	lds	r24, 0x053F
    24e8:	89 17       	cp	r24, r25
    24ea:	11 f4       	brne	.+4      	; 0x24f0 <_Z11Serial_readv+0x10>
    24ec:	8f ef       	ldi	r24, 0xFF	; 255
    24ee:	08 95       	ret
        return -1;
    } else {
        char c = rxBuf.buffer[tail];
    24f0:	e9 2f       	mov	r30, r25
    24f2:	f0 e0       	ldi	r31, 0x00	; 0
    24f4:	e1 5e       	subi	r30, 0xE1	; 225
    24f6:	fa 4f       	sbci	r31, 0xFA	; 250
    24f8:	80 81       	ld	r24, Z
        rxBuf.tail = ((tail + 1) & BUFFER_PTR_MASK);
    24fa:	9f 5f       	subi	r25, 0xFF	; 255
    24fc:	9f 71       	andi	r25, 0x1F	; 31
    24fe:	90 93 40 05 	sts	0x0540, r25
        return c;
    }
}
    2502:	08 95       	ret

00002504 <_Z12Serial_writec>:

//Write a byte of data
// - If in UART mode, the byte is stored into the TX buffer when there is space.
// - If in SPI mode, a write transfer is performed.
void Serial_write(char ch) {
    2504:	28 2f       	mov	r18, r24
    if (UCSRnB & _BV(TXENn)) { 
    2506:	80 91 c1 00 	lds	r24, 0x00C1
    250a:	83 ff       	sbrs	r24, 3
    250c:	1f c0       	rjmp	.+62     	; 0x254c <_Z12Serial_writec+0x48>
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
    250e:	90 91 1d 05 	lds	r25, 0x051D
    2512:	9f 5f       	subi	r25, 0xFF	; 255
    2514:	9f 71       	andi	r25, 0x1F	; 31
        if (head == txBuf.tail) {
    2516:	80 91 1e 05 	lds	r24, 0x051E
    251a:	98 17       	cp	r25, r24
    251c:	49 f4       	brne	.+18     	; 0x2530 <_Z12Serial_writec+0x2c>
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
    251e:	80 91 c1 00 	lds	r24, 0x00C1
    2522:	80 62       	ori	r24, 0x20	; 32
    2524:	80 93 c1 00 	sts	0x00C1, r24
            while (head == txBuf.tail); //wait for buffer to have some space
    2528:	80 91 1e 05 	lds	r24, 0x051E
    252c:	98 17       	cp	r25, r24
    252e:	e1 f3       	breq	.-8      	; 0x2528 <_Z12Serial_writec+0x24>
        }
        
        txBuf.buffer[txBuf.head] = ch; //Load the new data into the buffer
    2530:	e0 91 1d 05 	lds	r30, 0x051D
    2534:	f0 e0       	ldi	r31, 0x00	; 0
    2536:	e3 50       	subi	r30, 0x03	; 3
    2538:	fb 4f       	sbci	r31, 0xFB	; 251
    253a:	20 83       	st	Z, r18
        txBuf.head = head; //And store the new head.
    253c:	90 93 1d 05 	sts	0x051D, r25
        sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled if not already
    2540:	80 91 c1 00 	lds	r24, 0x00C1
    2544:	80 62       	ori	r24, 0x20	; 32
    2546:	80 93 c1 00 	sts	0x00C1, r24
    254a:	08 95       	ret
    } else if (softSPIEnabled) {
    254c:	80 91 41 05 	lds	r24, 0x0541
    2550:	88 23       	and	r24, r24
    2552:	19 f0       	breq	.+6      	; 0x255a <_Z12Serial_writec+0x56>
        //If SPI is enabled, we do an SPI write.
        SPI_write(ch);
    2554:	82 2f       	mov	r24, r18
    2556:	0e 94 5d 12 	call	0x24ba	; 0x24ba <_Z9SPI_writeh>
    255a:	08 95       	ret

0000255c <_Z12Serial_flushv>:
    }
}

//Flushes data from TX buffer
void Serial_flush() {
    if (UCSRnB & _BV(TXENn)) { 
    255c:	80 91 c1 00 	lds	r24, 0x00C1
    2560:	83 ff       	sbrs	r24, 3
    2562:	11 c0       	rjmp	.+34     	; 0x2586 <_Z12Serial_flushv+0x2a>
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
    2564:	90 91 1d 05 	lds	r25, 0x051D
    2568:	9f 5f       	subi	r25, 0xFF	; 255
    256a:	9f 71       	andi	r25, 0x1F	; 31
        if (head == txBuf.tail) {
    256c:	80 91 1e 05 	lds	r24, 0x051E
    2570:	98 17       	cp	r25, r24
    2572:	49 f4       	brne	.+18     	; 0x2586 <_Z12Serial_flushv+0x2a>
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
    2574:	80 91 c1 00 	lds	r24, 0x00C1
    2578:	80 62       	ori	r24, 0x20	; 32
    257a:	80 93 c1 00 	sts	0x00C1, r24
            while (head == txBuf.tail); //wait for buffer to have some space
    257e:	80 91 1e 05 	lds	r24, 0x051E
    2582:	98 17       	cp	r25, r24
    2584:	e1 f3       	breq	.-8      	; 0x257e <_Z12Serial_flushv+0x22>
    2586:	08 95       	ret

00002588 <_Z15Serial_writeStrPc>:
        }
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    2588:	cf 93       	push	r28
    258a:	df 93       	push	r29
    258c:	ec 01       	movw	r28, r24
    258e:	03 c0       	rjmp	.+6      	; 0x2596 <_Z15Serial_writeStrPc+0xe>
    while (*str) {
        Serial_write(*str++);
    2590:	21 96       	adiw	r28, 0x01	; 1
    2592:	0e 94 82 12 	call	0x2504	; 0x2504 <_Z12Serial_writec>
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    while (*str) {
    2596:	88 81       	ld	r24, Y
    2598:	88 23       	and	r24, r24
    259a:	d1 f7       	brne	.-12     	; 0x2590 <_Z15Serial_writeStrPc+0x8>
        Serial_write(*str++);
    }
}
    259c:	df 91       	pop	r29
    259e:	cf 91       	pop	r28
    25a0:	08 95       	ret

000025a2 <__vector_25>:
        "push r30    \n\t"
        "push r31    \n\t"
        :
        : "a" (c), "r" (head), "r" (tail), "I" (_SFR_IO_ADDR(SREG))
        :
    );
    25a2:	2f 93       	push	r18
    25a4:	2f b7       	in	r18, 0x3f	; 63
    25a6:	2f 93       	push	r18
    25a8:	9f 93       	push	r25
    25aa:	8f 93       	push	r24
    25ac:	ef 93       	push	r30
    25ae:	ff 93       	push	r31

    //Read in from the serial data register
    c = UDRn;
    25b0:	20 91 c6 00 	lds	r18, 0x00C6
    //get the current head
    head = rxBuf.head;
    25b4:	90 91 3f 05 	lds	r25, 0x053F
    head++;
    head &= BUFFER_PTR_MASK;
    25b8:	9f 5f       	subi	r25, 0xFF	; 255
    25ba:	9f 71       	andi	r25, 0x1F	; 31
    tail = rxBuf.tail;
    25bc:	80 91 40 05 	lds	r24, 0x0540

    if (head != tail) {
    25c0:	98 17       	cp	r25, r24
    25c2:	41 f0       	breq	.+16     	; 0x25d4 <__vector_25+0x32>
        rxBuf.buffer[rxBuf.head] = c;
    25c4:	e0 91 3f 05 	lds	r30, 0x053F
    25c8:	f0 e0       	ldi	r31, 0x00	; 0
    25ca:	e1 5e       	subi	r30, 0xE1	; 225
    25cc:	fa 4f       	sbci	r31, 0xFA	; 250
    25ce:	20 83       	st	Z, r18
        rxBuf.head = head;
    25d0:	90 93 3f 05 	sts	0x053F, r25
        "pop %0     \n\t"
        "reti       \n\t"
        : "=a" (c), "=r" (head), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
    25d4:	ff 91       	pop	r31
    25d6:	ef 91       	pop	r30
    25d8:	8f 91       	pop	r24
    25da:	9f 91       	pop	r25
    25dc:	2f 91       	pop	r18
    25de:	2f bf       	out	0x3f, r18	; 63
    25e0:	2f 91       	pop	r18
    25e2:	18 95       	reti

000025e4 <__vector_26>:
        "push %0       \n\t"
        "push %1       \n\t"
        "push r30      \n\t"
        "push r31      \n\t"
        :: "r" (temp), "r" (tail), "I" (_SFR_IO_ADDR(SREG)):
    );
    25e4:	8f 93       	push	r24
    25e6:	8f b7       	in	r24, 0x3f	; 63
    25e8:	8f 93       	push	r24
    25ea:	9f 93       	push	r25
    25ec:	ef 93       	push	r30
    25ee:	ff 93       	push	r31
    tail = txBuf.tail;
    25f0:	90 91 1e 05 	lds	r25, 0x051E
    temp = txBuf.head;
    25f4:	80 91 1d 05 	lds	r24, 0x051D
    if (temp == tail) {
    25f8:	89 17       	cp	r24, r25
    25fa:	31 f4       	brne	.+12     	; 0x2608 <__vector_26+0x24>
        // Buffer empty, so disable interrupts
        cbi(UCSRnB, UDRIEn);
    25fc:	80 91 c1 00 	lds	r24, 0x00C1
    2600:	8f 7d       	andi	r24, 0xDF	; 223
    2602:	80 93 c1 00 	sts	0x00C1, r24
    2606:	0b c0       	rjmp	.+22     	; 0x261e <__vector_26+0x3a>
    } else {
        // There is more data in the output buffer. Send the next byte
        temp = txBuf.buffer[tail];
    2608:	e9 2f       	mov	r30, r25
    260a:	f0 e0       	ldi	r31, 0x00	; 0
    260c:	e3 50       	subi	r30, 0x03	; 3
    260e:	fb 4f       	sbci	r31, 0xFB	; 251
    2610:	80 81       	ld	r24, Z
        tail++;
    2612:	9f 5f       	subi	r25, 0xFF	; 255
        tail &= BUFFER_PTR_MASK;
    2614:	9f 71       	andi	r25, 0x1F	; 31
        txBuf.tail = tail;
    2616:	90 93 1e 05 	sts	0x051E, r25
        UDRn = temp;
    261a:	80 93 c6 00 	sts	0x00C6, r24
        "pop %0     \n\t"
        "reti       \n\t"
        : "=r" (temp), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
    261e:	ff 91       	pop	r31
    2620:	ef 91       	pop	r30
    2622:	9f 91       	pop	r25
    2624:	8f 91       	pop	r24
    2626:	8f bf       	out	0x3f, r24	; 63
    2628:	8f 91       	pop	r24
    262a:	18 95       	reti

0000262c <_Z9hexToBytePc>:
    if (hex > '9'){
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    }
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    262c:	fc 01       	movw	r30, r24
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    262e:	91 81       	ldd	r25, Z+1	; 0x01
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
    2630:	9a 33       	cpi	r25, 0x3A	; 58
    2632:	0c f0       	brlt	.+2      	; 0x2636 <_Z9hexToBytePc+0xa>
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    2634:	97 50       	subi	r25, 0x07	; 7
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    2636:	80 81       	ld	r24, Z
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
    2638:	8a 33       	cpi	r24, 0x3A	; 58
    263a:	0c f0       	brlt	.+2      	; 0x263e <_Z9hexToBytePc+0x12>
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    263c:	87 50       	subi	r24, 0x07	; 7
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
    263e:	82 95       	swap	r24
    2640:	80 7f       	andi	r24, 0xF0	; 240
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    2642:	9f 70       	andi	r25, 0x0F	; 15
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
}
    2644:	89 2b       	or	r24, r25
    2646:	08 95       	ret

00002648 <_Z15synta_hexToBytePc>:

byte synta_hexToByte(char* hex){
    return hexToByte(hex);
    2648:	0e 94 16 13 	call	0x262c	; 0x262c <_Z9hexToBytePc>
}
    264c:	08 95       	ret

0000264e <_Z15synta_hexToLongPc>:
unsigned long synta_hexToLong(char* hex){
    264e:	ef 92       	push	r14
    2650:	ff 92       	push	r15
    2652:	0f 93       	push	r16
    2654:	1f 93       	push	r17
    2656:	8c 01       	movw	r16, r24
    //  strncpy(str+2,&hex[2],2); //Middle Byte
    //  strncpy(str+4,hex,2); //Upper Byte
    //  str[6] = 0;
    //  return strtol(str,&boo,16); //convert hex to long integer

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    2658:	04 96       	adiw	r24, 0x04	; 4
    265a:	0e 94 16 13 	call	0x262c	; 0x262c <_Z9hexToBytePc>
    265e:	e8 2e       	mov	r14, r24
    2660:	c8 01       	movw	r24, r16
    2662:	02 96       	adiw	r24, 0x02	; 2
    2664:	0e 94 16 13 	call	0x262c	; 0x262c <_Z9hexToBytePc>
    2668:	f8 2e       	mov	r15, r24
    266a:	c8 01       	movw	r24, r16
    266c:	0e 94 16 13 	call	0x262c	; 0x262c <_Z9hexToBytePc>
    return inter.integer; //and convert it to an integer
}
    2670:	68 2f       	mov	r22, r24
    2672:	7f 2d       	mov	r23, r15
    2674:	8e 2d       	mov	r24, r14
    2676:	90 e0       	ldi	r25, 0x00	; 0
    2678:	1f 91       	pop	r17
    267a:	0f 91       	pop	r16
    267c:	ff 90       	pop	r15
    267e:	ef 90       	pop	r14
    2680:	08 95       	ret

00002682 <_Z10synta_axish>:
char synta_command(){
    return _command;
}

byte synta_axis(byte axis){
    if(axis < 2){
    2682:	82 30       	cpi	r24, 0x02	; 2
    2684:	10 f4       	brcc	.+4      	; 0x268a <_Z10synta_axish+0x8>
        _axis = axis;
    2686:	80 93 4f 05 	sts	0x054F, r24
    }
    return _axis;
}
    268a:	80 91 4f 05 	lds	r24, 0x054F
    268e:	08 95       	ret

00002690 <_Z21synta_validateCommandhPc>:
    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    2690:	ef 92       	push	r14
    2692:	ff 92       	push	r15
    2694:	1f 93       	push	r17
    2696:	cf 93       	push	r28
    2698:	df 93       	push	r29
    269a:	18 2f       	mov	r17, r24
    269c:	7b 01       	movw	r14, r22
    _command = commandString[0]; //first byte is command
    269e:	90 91 43 05 	lds	r25, 0x0543
    26a2:	90 93 50 05 	sts	0x0550, r25
    _axis = commandString[1] - 49; //second byte is axis
    26a6:	80 91 44 05 	lds	r24, 0x0544
    26aa:	81 53       	subi	r24, 0x31	; 49
    26ac:	80 93 4f 05 	sts	0x054F, r24
    if(_axis > 1){
    26b0:	82 30       	cpi	r24, 0x02	; 2
    26b2:	f8 f4       	brcc	.+62     	; 0x26f2 <_Z21synta_validateCommandhPc+0x62>
        return false; //incorrect axis
    }
    char requiredLength = Commands_getLength(_command,1); //get the required length of this command
    26b4:	89 2f       	mov	r24, r25
    26b6:	61 e0       	ldi	r22, 0x01	; 1
    26b8:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <_Z18Commands_getLengthcb>
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    26bc:	13 50       	subi	r17, 0x03	; 3
    if(requiredLength != len){ //If invalid command, or not required length
    26be:	28 2f       	mov	r18, r24
    26c0:	33 27       	eor	r19, r19
    26c2:	27 fd       	sbrc	r18, 7
    26c4:	30 95       	com	r19
    26c6:	81 2f       	mov	r24, r17
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	28 17       	cp	r18, r24
    26cc:	39 07       	cpc	r19, r25
    26ce:	89 f4       	brne	.+34     	; 0x26f2 <_Z21synta_validateCommandhPc+0x62>
    26d0:	a5 e4       	ldi	r26, 0x45	; 69
    26d2:	b5 e0       	ldi	r27, 0x05	; 5
    26d4:	e7 01       	movw	r28, r14
    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    26d6:	f9 01       	movw	r30, r18
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
    26d8:	2a 0f       	add	r18, r26
    26da:	3b 1f       	adc	r19, r27
    26dc:	02 c0       	rjmp	.+4      	; 0x26e2 <_Z21synta_validateCommandhPc+0x52>
        decoded[i] = commandString[i + 2];
    26de:	8d 91       	ld	r24, X+
    26e0:	89 93       	st	Y+, r24
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
    26e2:	a2 17       	cp	r26, r18
    26e4:	b3 07       	cpc	r27, r19
    26e6:	d9 f7       	brne	.-10     	; 0x26de <_Z21synta_validateCommandhPc+0x4e>
        decoded[i] = commandString[i + 2];
    }
    decoded[i] = '\0'; //Null
    26e8:	ee 0d       	add	r30, r14
    26ea:	ff 1d       	adc	r31, r15
    26ec:	10 82       	st	Z, r1
    26ee:	81 e0       	ldi	r24, 0x01	; 1
    26f0:	01 c0       	rjmp	.+2      	; 0x26f4 <_Z21synta_validateCommandhPc+0x64>
    return true;
    26f2:	80 e0       	ldi	r24, 0x00	; 0
}
    26f4:	df 91       	pop	r29
    26f6:	cf 91       	pop	r28
    26f8:	1f 91       	pop	r17
    26fa:	ff 90       	pop	r15
    26fc:	ef 90       	pop	r14
    26fe:	08 95       	ret

00002700 <_Z20synta_recieveCommandPcc>:

char synta_recieveCommand(char* dataPacket, char character){
    2700:	cf 93       	push	r28
    2702:	df 93       	push	r29
    2704:	ec 01       	movw	r28, r24
    if(validPacket){
    2706:	80 91 42 05 	lds	r24, 0x0542
    270a:	88 23       	and	r24, r24
    270c:	21 f1       	breq	.+72     	; 0x2756 <_Z20synta_recieveCommandPcc+0x56>
        if (character == startInChar){
    270e:	6a 33       	cpi	r22, 0x3A	; 58
    2710:	49 f4       	brne	.+18     	; 0x2724 <_Z20synta_recieveCommandPcc+0x24>
            dataPacket[0] = errorChar;
    2712:	81 e2       	ldi	r24, 0x21	; 33
    2714:	88 83       	st	Y, r24
            dataPacket[1] = endChar;
    2716:	8d e0       	ldi	r24, 0x0D	; 13
    2718:	89 83       	std	Y+1, r24	; 0x01
            dataPacket[2] = '\0';
    271a:	1a 82       	std	Y+2, r1	; 0x02
            validPacket = 0; //new command without old finishing! (dataPacket contains error message)
    271c:	10 92 42 05 	sts	0x0542, r1
    2720:	8e ef       	ldi	r24, 0xFE	; 254
    2722:	2d c0       	rjmp	.+90     	; 0x277e <_Z20synta_recieveCommandPcc+0x7e>
            return -2;
        }

        commandString[commandIndex++] = character; //Add character to current string build
    2724:	80 91 4e 05 	lds	r24, 0x054E
    2728:	e8 2f       	mov	r30, r24
    272a:	f0 e0       	ldi	r31, 0x00	; 0
    272c:	ed 5b       	subi	r30, 0xBD	; 189
    272e:	fa 4f       	sbci	r31, 0xFA	; 250
    2730:	60 83       	st	Z, r22
    2732:	8f 5f       	subi	r24, 0xFF	; 255
    2734:	80 93 4e 05 	sts	0x054E, r24

        if(character == endChar){
    2738:	6d 30       	cpi	r22, 0x0D	; 13
    273a:	51 f4       	brne	.+20     	; 0x2750 <_Z20synta_recieveCommandPcc+0x50>
            if(synta_validateCommand(commandIndex, dataPacket)){
    273c:	be 01       	movw	r22, r28
    273e:	0e 94 48 13 	call	0x2690	; 0x2690 <_Z21synta_validateCommandhPc>
    2742:	88 23       	and	r24, r24
    2744:	91 f0       	breq	.+36     	; 0x276a <_Z20synta_recieveCommandPcc+0x6a>
                validPacket = 0;
    2746:	10 92 42 05 	sts	0x0542, r1
                return _command; //Successful decode (dataPacket contains decoded packet, return value is the current command)
    274a:	80 91 50 05 	lds	r24, 0x0550
    274e:	17 c0       	rjmp	.+46     	; 0x277e <_Z20synta_recieveCommandPcc+0x7e>
            } else {
                goto error; //Decode Failed (dataPacket contains error message)
            }
        } else if (commandIndex == sizeof(commandString)){
    2750:	8b 30       	cpi	r24, 0x0B	; 11
    2752:	a1 f4       	brne	.+40     	; 0x277c <_Z20synta_recieveCommandPcc+0x7c>
    2754:	0a c0       	rjmp	.+20     	; 0x276a <_Z20synta_recieveCommandPcc+0x6a>
            goto error; //Message too long! (dataPacket contains error message)
        }
    } else if (character == startInChar){
    2756:	6a 33       	cpi	r22, 0x3A	; 58
    2758:	89 f4       	brne	.+34     	; 0x277c <_Z20synta_recieveCommandPcc+0x7c>
        //Begin new command
        commandIndex = 0;
    275a:	10 92 4e 05 	sts	0x054E, r1
        validPacket = 1;
    275e:	81 e0       	ldi	r24, 0x01	; 1
    2760:	80 93 42 05 	sts	0x0542, r24
        commandString[0] = '\0';
    2764:	10 92 43 05 	sts	0x0543, r1
    2768:	09 c0       	rjmp	.+18     	; 0x277c <_Z20synta_recieveCommandPcc+0x7c>
    }
    return 0; //Decode not finished (dataPacket unchanged)
error:
    dataPacket[0] = errorChar;
    276a:	81 e2       	ldi	r24, 0x21	; 33
    276c:	88 83       	st	Y, r24
    dataPacket[1] = endChar;
    276e:	8d e0       	ldi	r24, 0x0D	; 13
    2770:	89 83       	std	Y+1, r24	; 0x01
    dataPacket[2] = '\0';
    2772:	1a 82       	std	Y+2, r1	; 0x02
    validPacket = 0;
    2774:	10 92 42 05 	sts	0x0542, r1
    2778:	8f ef       	ldi	r24, 0xFF	; 255
    277a:	01 c0       	rjmp	.+2      	; 0x277e <_Z20synta_recieveCommandPcc+0x7e>
    return -1;
    277c:	80 e0       	ldi	r24, 0x00	; 0
}
    277e:	df 91       	pop	r29
    2780:	cf 91       	pop	r28
    2782:	08 95       	ret

00002784 <_Z22synta_assembleResponsePccm>:
inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
}

void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData){
    2784:	ff 92       	push	r15
    2786:	0f 93       	push	r16
    2788:	1f 93       	push	r17
    278a:	cf 93       	push	r28
    278c:	df 93       	push	r29
    278e:	ec 01       	movw	r28, r24
    2790:	12 2f       	mov	r17, r18
    2792:	03 2f       	mov	r16, r19
    2794:	f4 2e       	mov	r15, r20
    char replyLength = (commandOrError == '\0') ? -1 : Commands_getLength(commandOrError,0); //get the number of data bytes for response
    2796:	66 23       	and	r22, r22
    2798:	39 f0       	breq	.+14     	; 0x27a8 <_Z22synta_assembleResponsePccm+0x24>
    279a:	86 2f       	mov	r24, r22
    279c:	60 e0       	ldi	r22, 0x00	; 0
    279e:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <_Z18Commands_getLengthcb>
    27a2:	98 2f       	mov	r25, r24

    if (replyLength < 0) {
    27a4:	87 ff       	sbrs	r24, 7
    27a6:	04 c0       	rjmp	.+8      	; 0x27b0 <_Z22synta_assembleResponsePccm+0x2c>
        replyLength = 0;
        dataPacket[0] = errorChar;  
    27a8:	81 e2       	ldi	r24, 0x21	; 33
    27aa:	88 83       	st	Y, r24
    27ac:	90 e0       	ldi	r25, 0x00	; 0
    27ae:	4e c0       	rjmp	.+156    	; 0x284c <_Z22synta_assembleResponsePccm+0xc8>
    } else {
        dataPacket[0] = startOutChar;
    27b0:	8d e3       	ldi	r24, 0x3D	; 61
    27b2:	88 83       	st	Y, r24

        if (replyLength == 2) {
    27b4:	92 30       	cpi	r25, 0x02	; 2
    27b6:	d9 f1       	breq	.+118    	; 0x282e <_Z22synta_assembleResponsePccm+0xaa>
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
    27b8:	93 30       	cpi	r25, 0x03	; 3
    27ba:	c9 f4       	brne	.+50     	; 0x27ee <_Z22synta_assembleResponsePccm+0x6a>
            DoubleNibbler nibble = { responseData };
    27bc:	21 2f       	mov	r18, r17
    27be:	30 2f       	mov	r19, r16
            nibbleToHex(dataPacket+3, nibble.low);
    27c0:	81 2f       	mov	r24, r17
    27c2:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    27c4:	8a 30       	cpi	r24, 0x0A	; 10
    27c6:	08 f0       	brcs	.+2      	; 0x27ca <_Z22synta_assembleResponsePccm+0x46>
        nibble += (('A'-'0')-0xA);
    27c8:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    27ca:	80 5d       	subi	r24, 0xD0	; 208
    27cc:	8b 83       	std	Y+3, r24	; 0x03
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
    27ce:	82 2f       	mov	r24, r18
    27d0:	82 95       	swap	r24
    27d2:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    27d4:	8a 30       	cpi	r24, 0x0A	; 10
    27d6:	08 f0       	brcs	.+2      	; 0x27da <_Z22synta_assembleResponsePccm+0x56>
        nibble += (('A'-'0')-0xA);
    27d8:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    27da:	80 5d       	subi	r24, 0xD0	; 208
    27dc:	8a 83       	std	Y+2, r24	; 0x02
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
    27de:	83 2f       	mov	r24, r19
    27e0:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    27e2:	8a 30       	cpi	r24, 0x0A	; 10
    27e4:	08 f0       	brcs	.+2      	; 0x27e8 <_Z22synta_assembleResponsePccm+0x64>
        nibble += (('A'-'0')-0xA);
    27e6:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    27e8:	80 5d       	subi	r24, 0xD0	; 208
    27ea:	89 83       	std	Y+1, r24	; 0x01
    27ec:	2f c0       	rjmp	.+94     	; 0x284c <_Z22synta_assembleResponsePccm+0xc8>
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
        } else if (replyLength == 6) {
    27ee:	96 30       	cpi	r25, 0x06	; 6
    27f0:	69 f5       	brne	.+90     	; 0x284c <_Z22synta_assembleResponsePccm+0xc8>
    }
    *hex = (nibble + '0');
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    27f2:	8f 2d       	mov	r24, r15
    27f4:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    27f6:	8a 30       	cpi	r24, 0x0A	; 10
    27f8:	08 f0       	brcs	.+2      	; 0x27fc <_Z22synta_assembleResponsePccm+0x78>
        nibble += (('A'-'0')-0xA);
    27fa:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    27fc:	80 5d       	subi	r24, 0xD0	; 208
    27fe:	8e 83       	std	Y+6, r24	; 0x06
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    2800:	4f 2d       	mov	r20, r15
    2802:	42 95       	swap	r20
    2804:	4f 70       	andi	r20, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2806:	4a 30       	cpi	r20, 0x0A	; 10
    2808:	08 f0       	brcs	.+2      	; 0x280c <_Z22synta_assembleResponsePccm+0x88>
        nibble += (('A'-'0')-0xA);
    280a:	49 5f       	subi	r20, 0xF9	; 249
    }
    *hex = (nibble + '0');
    280c:	40 5d       	subi	r20, 0xD0	; 208
    280e:	4d 83       	std	Y+5, r20	; 0x05
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    2810:	80 2f       	mov	r24, r16
    2812:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2814:	8a 30       	cpi	r24, 0x0A	; 10
    2816:	08 f0       	brcs	.+2      	; 0x281a <_Z22synta_assembleResponsePccm+0x96>
        nibble += (('A'-'0')-0xA);
    2818:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    281a:	80 5d       	subi	r24, 0xD0	; 208
    281c:	8c 83       	std	Y+4, r24	; 0x04
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    281e:	30 2f       	mov	r19, r16
    2820:	32 95       	swap	r19
    2822:	3f 70       	andi	r19, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2824:	3a 30       	cpi	r19, 0x0A	; 10
    2826:	08 f0       	brcs	.+2      	; 0x282a <_Z22synta_assembleResponsePccm+0xa6>
        nibble += (('A'-'0')-0xA);
    2828:	39 5f       	subi	r19, 0xF9	; 249
    }
    *hex = (nibble + '0');
    282a:	30 5d       	subi	r19, 0xD0	; 208
    282c:	3b 83       	std	Y+3, r19	; 0x03
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    282e:	81 2f       	mov	r24, r17
    2830:	8f 70       	andi	r24, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2832:	8a 30       	cpi	r24, 0x0A	; 10
    2834:	08 f0       	brcs	.+2      	; 0x2838 <_Z22synta_assembleResponsePccm+0xb4>
        nibble += (('A'-'0')-0xA);
    2836:	89 5f       	subi	r24, 0xF9	; 249
    }
    *hex = (nibble + '0');
    2838:	80 5d       	subi	r24, 0xD0	; 208
    283a:	8a 83       	std	Y+2, r24	; 0x02
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
    283c:	21 2f       	mov	r18, r17
    283e:	22 95       	swap	r18
    2840:	2f 70       	andi	r18, 0x0F	; 15
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
    2842:	2a 30       	cpi	r18, 0x0A	; 10
    2844:	08 f0       	brcs	.+2      	; 0x2848 <_Z22synta_assembleResponsePccm+0xc4>
        nibble += (('A'-'0')-0xA);
    2846:	29 5f       	subi	r18, 0xF9	; 249
    }
    *hex = (nibble + '0');
    2848:	20 5d       	subi	r18, 0xD0	; 208
    284a:	29 83       	std	Y+1, r18	; 0x01
            private_byteToHex(dataPacket+2,dataPacket+1,inter.lowByter.lowNibbler);
        }

    }

    dataPacket[(byte)replyLength + 1] = endChar;
    284c:	fe 01       	movw	r30, r28
    284e:	e9 0f       	add	r30, r25
    2850:	f1 1d       	adc	r31, r1
    2852:	8d e0       	ldi	r24, 0x0D	; 13
    2854:	81 83       	std	Z+1, r24	; 0x01
    dataPacket[(byte)replyLength + 2] = '\0';  
    2856:	12 82       	std	Z+2, r1	; 0x02
    return;
}
    2858:	df 91       	pop	r29
    285a:	cf 91       	pop	r28
    285c:	1f 91       	pop	r17
    285e:	0f 91       	pop	r16
    2860:	ff 90       	pop	r15
    2862:	08 95       	ret

00002864 <_Z16synta_initialisemh>:

byte _axis;
char _command;

void synta_initialise(unsigned long eVal, byte gVal){
    validPacket = 0;
    2864:	10 92 42 05 	sts	0x0542, r1
    commandIndex = 0;
    2868:	10 92 4e 05 	sts	0x054E, r1
    memset(commandString,0,sizeof(commandString));
    286c:	2b e0       	ldi	r18, 0x0B	; 11
    286e:	e3 e4       	ldi	r30, 0x43	; 67
    2870:	f5 e0       	ldi	r31, 0x05	; 5
    2872:	df 01       	movw	r26, r30
    2874:	1d 92       	st	X+, r1
    2876:	2a 95       	dec	r18
    2878:	e9 f7       	brne	.-6      	; 0x2874 <_Z16synta_initialisemh+0x10>
    _axis = 0;
    287a:	10 92 4f 05 	sts	0x054F, r1
    Commands_init(eVal, gVal);
    287e:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <_Z13Commands_initmh>
}
    2882:	08 95       	ret

00002884 <__subsf3>:
    2884:	50 58       	subi	r21, 0x80	; 128

00002886 <__addsf3>:
    2886:	bb 27       	eor	r27, r27
    2888:	aa 27       	eor	r26, r26
    288a:	0e d0       	rcall	.+28     	; 0x28a8 <__addsf3x>
    288c:	86 c1       	rjmp	.+780    	; 0x2b9a <__fp_round>
    288e:	77 d1       	rcall	.+750    	; 0x2b7e <__fp_pscA>
    2890:	30 f0       	brcs	.+12     	; 0x289e <__addsf3+0x18>
    2892:	7c d1       	rcall	.+760    	; 0x2b8c <__fp_pscB>
    2894:	20 f0       	brcs	.+8      	; 0x289e <__addsf3+0x18>
    2896:	31 f4       	brne	.+12     	; 0x28a4 <__addsf3+0x1e>
    2898:	9f 3f       	cpi	r25, 0xFF	; 255
    289a:	11 f4       	brne	.+4      	; 0x28a0 <__addsf3+0x1a>
    289c:	1e f4       	brtc	.+6      	; 0x28a4 <__addsf3+0x1e>
    289e:	6c c1       	rjmp	.+728    	; 0x2b78 <__fp_nan>
    28a0:	0e f4       	brtc	.+2      	; 0x28a4 <__addsf3+0x1e>
    28a2:	e0 95       	com	r30
    28a4:	e7 fb       	bst	r30, 7
    28a6:	37 c1       	rjmp	.+622    	; 0x2b16 <__fp_inf>

000028a8 <__addsf3x>:
    28a8:	e9 2f       	mov	r30, r25
    28aa:	88 d1       	rcall	.+784    	; 0x2bbc <__fp_split3>
    28ac:	80 f3       	brcs	.-32     	; 0x288e <__addsf3+0x8>
    28ae:	ba 17       	cp	r27, r26
    28b0:	62 07       	cpc	r22, r18
    28b2:	73 07       	cpc	r23, r19
    28b4:	84 07       	cpc	r24, r20
    28b6:	95 07       	cpc	r25, r21
    28b8:	18 f0       	brcs	.+6      	; 0x28c0 <__addsf3x+0x18>
    28ba:	71 f4       	brne	.+28     	; 0x28d8 <__addsf3x+0x30>
    28bc:	9e f5       	brtc	.+102    	; 0x2924 <__addsf3x+0x7c>
    28be:	b7 c1       	rjmp	.+878    	; 0x2c2e <__fp_zero>
    28c0:	0e f4       	brtc	.+2      	; 0x28c4 <__addsf3x+0x1c>
    28c2:	e0 95       	com	r30
    28c4:	0b 2e       	mov	r0, r27
    28c6:	ba 2f       	mov	r27, r26
    28c8:	a0 2d       	mov	r26, r0
    28ca:	0b 01       	movw	r0, r22
    28cc:	b9 01       	movw	r22, r18
    28ce:	90 01       	movw	r18, r0
    28d0:	0c 01       	movw	r0, r24
    28d2:	ca 01       	movw	r24, r20
    28d4:	a0 01       	movw	r20, r0
    28d6:	11 24       	eor	r1, r1
    28d8:	ff 27       	eor	r31, r31
    28da:	59 1b       	sub	r21, r25
    28dc:	99 f0       	breq	.+38     	; 0x2904 <__addsf3x+0x5c>
    28de:	59 3f       	cpi	r21, 0xF9	; 249
    28e0:	50 f4       	brcc	.+20     	; 0x28f6 <__addsf3x+0x4e>
    28e2:	50 3e       	cpi	r21, 0xE0	; 224
    28e4:	68 f1       	brcs	.+90     	; 0x2940 <__addsf3x+0x98>
    28e6:	1a 16       	cp	r1, r26
    28e8:	f0 40       	sbci	r31, 0x00	; 0
    28ea:	a2 2f       	mov	r26, r18
    28ec:	23 2f       	mov	r18, r19
    28ee:	34 2f       	mov	r19, r20
    28f0:	44 27       	eor	r20, r20
    28f2:	58 5f       	subi	r21, 0xF8	; 248
    28f4:	f3 cf       	rjmp	.-26     	; 0x28dc <__addsf3x+0x34>
    28f6:	46 95       	lsr	r20
    28f8:	37 95       	ror	r19
    28fa:	27 95       	ror	r18
    28fc:	a7 95       	ror	r26
    28fe:	f0 40       	sbci	r31, 0x00	; 0
    2900:	53 95       	inc	r21
    2902:	c9 f7       	brne	.-14     	; 0x28f6 <__addsf3x+0x4e>
    2904:	7e f4       	brtc	.+30     	; 0x2924 <__addsf3x+0x7c>
    2906:	1f 16       	cp	r1, r31
    2908:	ba 0b       	sbc	r27, r26
    290a:	62 0b       	sbc	r22, r18
    290c:	73 0b       	sbc	r23, r19
    290e:	84 0b       	sbc	r24, r20
    2910:	ba f0       	brmi	.+46     	; 0x2940 <__addsf3x+0x98>
    2912:	91 50       	subi	r25, 0x01	; 1
    2914:	a1 f0       	breq	.+40     	; 0x293e <__addsf3x+0x96>
    2916:	ff 0f       	add	r31, r31
    2918:	bb 1f       	adc	r27, r27
    291a:	66 1f       	adc	r22, r22
    291c:	77 1f       	adc	r23, r23
    291e:	88 1f       	adc	r24, r24
    2920:	c2 f7       	brpl	.-16     	; 0x2912 <__addsf3x+0x6a>
    2922:	0e c0       	rjmp	.+28     	; 0x2940 <__addsf3x+0x98>
    2924:	ba 0f       	add	r27, r26
    2926:	62 1f       	adc	r22, r18
    2928:	73 1f       	adc	r23, r19
    292a:	84 1f       	adc	r24, r20
    292c:	48 f4       	brcc	.+18     	; 0x2940 <__addsf3x+0x98>
    292e:	87 95       	ror	r24
    2930:	77 95       	ror	r23
    2932:	67 95       	ror	r22
    2934:	b7 95       	ror	r27
    2936:	f7 95       	ror	r31
    2938:	9e 3f       	cpi	r25, 0xFE	; 254
    293a:	08 f0       	brcs	.+2      	; 0x293e <__addsf3x+0x96>
    293c:	b3 cf       	rjmp	.-154    	; 0x28a4 <__addsf3+0x1e>
    293e:	93 95       	inc	r25
    2940:	88 0f       	add	r24, r24
    2942:	08 f0       	brcs	.+2      	; 0x2946 <__addsf3x+0x9e>
    2944:	99 27       	eor	r25, r25
    2946:	ee 0f       	add	r30, r30
    2948:	97 95       	ror	r25
    294a:	87 95       	ror	r24
    294c:	08 95       	ret

0000294e <ceil>:
    294e:	58 d1       	rcall	.+688    	; 0x2c00 <__fp_trunc>
    2950:	80 f0       	brcs	.+32     	; 0x2972 <ceil+0x24>
    2952:	9f 37       	cpi	r25, 0x7F	; 127
    2954:	40 f4       	brcc	.+16     	; 0x2966 <ceil+0x18>
    2956:	91 11       	cpse	r25, r1
    2958:	0e f4       	brtc	.+2      	; 0x295c <ceil+0xe>
    295a:	6a c1       	rjmp	.+724    	; 0x2c30 <__fp_szero>
    295c:	60 e0       	ldi	r22, 0x00	; 0
    295e:	70 e0       	ldi	r23, 0x00	; 0
    2960:	80 e8       	ldi	r24, 0x80	; 128
    2962:	9f e3       	ldi	r25, 0x3F	; 63
    2964:	08 95       	ret
    2966:	26 f0       	brts	.+8      	; 0x2970 <ceil+0x22>
    2968:	1b 16       	cp	r1, r27
    296a:	61 1d       	adc	r22, r1
    296c:	71 1d       	adc	r23, r1
    296e:	81 1d       	adc	r24, r1
    2970:	d8 c0       	rjmp	.+432    	; 0x2b22 <__fp_mintl>
    2972:	f2 c0       	rjmp	.+484    	; 0x2b58 <__fp_mpack>

00002974 <__divsf3>:
    2974:	0c d0       	rcall	.+24     	; 0x298e <__divsf3x>
    2976:	11 c1       	rjmp	.+546    	; 0x2b9a <__fp_round>
    2978:	09 d1       	rcall	.+530    	; 0x2b8c <__fp_pscB>
    297a:	40 f0       	brcs	.+16     	; 0x298c <__divsf3+0x18>
    297c:	00 d1       	rcall	.+512    	; 0x2b7e <__fp_pscA>
    297e:	30 f0       	brcs	.+12     	; 0x298c <__divsf3+0x18>
    2980:	21 f4       	brne	.+8      	; 0x298a <__divsf3+0x16>
    2982:	5f 3f       	cpi	r21, 0xFF	; 255
    2984:	19 f0       	breq	.+6      	; 0x298c <__divsf3+0x18>
    2986:	c7 c0       	rjmp	.+398    	; 0x2b16 <__fp_inf>
    2988:	51 11       	cpse	r21, r1
    298a:	52 c1       	rjmp	.+676    	; 0x2c30 <__fp_szero>
    298c:	f5 c0       	rjmp	.+490    	; 0x2b78 <__fp_nan>

0000298e <__divsf3x>:
    298e:	16 d1       	rcall	.+556    	; 0x2bbc <__fp_split3>
    2990:	98 f3       	brcs	.-26     	; 0x2978 <__divsf3+0x4>

00002992 <__divsf3_pse>:
    2992:	99 23       	and	r25, r25
    2994:	c9 f3       	breq	.-14     	; 0x2988 <__divsf3+0x14>
    2996:	55 23       	and	r21, r21
    2998:	b1 f3       	breq	.-20     	; 0x2986 <__divsf3+0x12>
    299a:	95 1b       	sub	r25, r21
    299c:	55 0b       	sbc	r21, r21
    299e:	bb 27       	eor	r27, r27
    29a0:	aa 27       	eor	r26, r26
    29a2:	62 17       	cp	r22, r18
    29a4:	73 07       	cpc	r23, r19
    29a6:	84 07       	cpc	r24, r20
    29a8:	38 f0       	brcs	.+14     	; 0x29b8 <__divsf3_pse+0x26>
    29aa:	9f 5f       	subi	r25, 0xFF	; 255
    29ac:	5f 4f       	sbci	r21, 0xFF	; 255
    29ae:	22 0f       	add	r18, r18
    29b0:	33 1f       	adc	r19, r19
    29b2:	44 1f       	adc	r20, r20
    29b4:	aa 1f       	adc	r26, r26
    29b6:	a9 f3       	breq	.-22     	; 0x29a2 <__divsf3_pse+0x10>
    29b8:	33 d0       	rcall	.+102    	; 0x2a20 <__divsf3_pse+0x8e>
    29ba:	0e 2e       	mov	r0, r30
    29bc:	3a f0       	brmi	.+14     	; 0x29cc <__divsf3_pse+0x3a>
    29be:	e0 e8       	ldi	r30, 0x80	; 128
    29c0:	30 d0       	rcall	.+96     	; 0x2a22 <__divsf3_pse+0x90>
    29c2:	91 50       	subi	r25, 0x01	; 1
    29c4:	50 40       	sbci	r21, 0x00	; 0
    29c6:	e6 95       	lsr	r30
    29c8:	00 1c       	adc	r0, r0
    29ca:	ca f7       	brpl	.-14     	; 0x29be <__divsf3_pse+0x2c>
    29cc:	29 d0       	rcall	.+82     	; 0x2a20 <__divsf3_pse+0x8e>
    29ce:	fe 2f       	mov	r31, r30
    29d0:	27 d0       	rcall	.+78     	; 0x2a20 <__divsf3_pse+0x8e>
    29d2:	66 0f       	add	r22, r22
    29d4:	77 1f       	adc	r23, r23
    29d6:	88 1f       	adc	r24, r24
    29d8:	bb 1f       	adc	r27, r27
    29da:	26 17       	cp	r18, r22
    29dc:	37 07       	cpc	r19, r23
    29de:	48 07       	cpc	r20, r24
    29e0:	ab 07       	cpc	r26, r27
    29e2:	b0 e8       	ldi	r27, 0x80	; 128
    29e4:	09 f0       	breq	.+2      	; 0x29e8 <__divsf3_pse+0x56>
    29e6:	bb 0b       	sbc	r27, r27
    29e8:	80 2d       	mov	r24, r0
    29ea:	bf 01       	movw	r22, r30
    29ec:	ff 27       	eor	r31, r31
    29ee:	93 58       	subi	r25, 0x83	; 131
    29f0:	5f 4f       	sbci	r21, 0xFF	; 255
    29f2:	2a f0       	brmi	.+10     	; 0x29fe <__divsf3_pse+0x6c>
    29f4:	9e 3f       	cpi	r25, 0xFE	; 254
    29f6:	51 05       	cpc	r21, r1
    29f8:	68 f0       	brcs	.+26     	; 0x2a14 <__divsf3_pse+0x82>
    29fa:	8d c0       	rjmp	.+282    	; 0x2b16 <__fp_inf>
    29fc:	19 c1       	rjmp	.+562    	; 0x2c30 <__fp_szero>
    29fe:	5f 3f       	cpi	r21, 0xFF	; 255
    2a00:	ec f3       	brlt	.-6      	; 0x29fc <__divsf3_pse+0x6a>
    2a02:	98 3e       	cpi	r25, 0xE8	; 232
    2a04:	dc f3       	brlt	.-10     	; 0x29fc <__divsf3_pse+0x6a>
    2a06:	86 95       	lsr	r24
    2a08:	77 95       	ror	r23
    2a0a:	67 95       	ror	r22
    2a0c:	b7 95       	ror	r27
    2a0e:	f7 95       	ror	r31
    2a10:	9f 5f       	subi	r25, 0xFF	; 255
    2a12:	c9 f7       	brne	.-14     	; 0x2a06 <__divsf3_pse+0x74>
    2a14:	88 0f       	add	r24, r24
    2a16:	91 1d       	adc	r25, r1
    2a18:	96 95       	lsr	r25
    2a1a:	87 95       	ror	r24
    2a1c:	97 f9       	bld	r25, 7
    2a1e:	08 95       	ret
    2a20:	e1 e0       	ldi	r30, 0x01	; 1
    2a22:	66 0f       	add	r22, r22
    2a24:	77 1f       	adc	r23, r23
    2a26:	88 1f       	adc	r24, r24
    2a28:	bb 1f       	adc	r27, r27
    2a2a:	62 17       	cp	r22, r18
    2a2c:	73 07       	cpc	r23, r19
    2a2e:	84 07       	cpc	r24, r20
    2a30:	ba 07       	cpc	r27, r26
    2a32:	20 f0       	brcs	.+8      	; 0x2a3c <__divsf3_pse+0xaa>
    2a34:	62 1b       	sub	r22, r18
    2a36:	73 0b       	sbc	r23, r19
    2a38:	84 0b       	sbc	r24, r20
    2a3a:	ba 0b       	sbc	r27, r26
    2a3c:	ee 1f       	adc	r30, r30
    2a3e:	88 f7       	brcc	.-30     	; 0x2a22 <__divsf3_pse+0x90>
    2a40:	e0 95       	com	r30
    2a42:	08 95       	ret

00002a44 <__fixunssfsi>:
    2a44:	c3 d0       	rcall	.+390    	; 0x2bcc <__fp_splitA>
    2a46:	88 f0       	brcs	.+34     	; 0x2a6a <__fixunssfsi+0x26>
    2a48:	9f 57       	subi	r25, 0x7F	; 127
    2a4a:	90 f0       	brcs	.+36     	; 0x2a70 <__fixunssfsi+0x2c>
    2a4c:	b9 2f       	mov	r27, r25
    2a4e:	99 27       	eor	r25, r25
    2a50:	b7 51       	subi	r27, 0x17	; 23
    2a52:	a0 f0       	brcs	.+40     	; 0x2a7c <__fixunssfsi+0x38>
    2a54:	d1 f0       	breq	.+52     	; 0x2a8a <__fixunssfsi+0x46>
    2a56:	66 0f       	add	r22, r22
    2a58:	77 1f       	adc	r23, r23
    2a5a:	88 1f       	adc	r24, r24
    2a5c:	99 1f       	adc	r25, r25
    2a5e:	1a f0       	brmi	.+6      	; 0x2a66 <__fixunssfsi+0x22>
    2a60:	ba 95       	dec	r27
    2a62:	c9 f7       	brne	.-14     	; 0x2a56 <__fixunssfsi+0x12>
    2a64:	12 c0       	rjmp	.+36     	; 0x2a8a <__fixunssfsi+0x46>
    2a66:	b1 30       	cpi	r27, 0x01	; 1
    2a68:	81 f0       	breq	.+32     	; 0x2a8a <__fixunssfsi+0x46>
    2a6a:	e1 d0       	rcall	.+450    	; 0x2c2e <__fp_zero>
    2a6c:	b1 e0       	ldi	r27, 0x01	; 1
    2a6e:	08 95       	ret
    2a70:	de c0       	rjmp	.+444    	; 0x2c2e <__fp_zero>
    2a72:	67 2f       	mov	r22, r23
    2a74:	78 2f       	mov	r23, r24
    2a76:	88 27       	eor	r24, r24
    2a78:	b8 5f       	subi	r27, 0xF8	; 248
    2a7a:	39 f0       	breq	.+14     	; 0x2a8a <__fixunssfsi+0x46>
    2a7c:	b9 3f       	cpi	r27, 0xF9	; 249
    2a7e:	cc f3       	brlt	.-14     	; 0x2a72 <__fixunssfsi+0x2e>
    2a80:	86 95       	lsr	r24
    2a82:	77 95       	ror	r23
    2a84:	67 95       	ror	r22
    2a86:	b3 95       	inc	r27
    2a88:	d9 f7       	brne	.-10     	; 0x2a80 <__fixunssfsi+0x3c>
    2a8a:	3e f4       	brtc	.+14     	; 0x2a9a <__fixunssfsi+0x56>
    2a8c:	90 95       	com	r25
    2a8e:	80 95       	com	r24
    2a90:	70 95       	com	r23
    2a92:	61 95       	neg	r22
    2a94:	7f 4f       	sbci	r23, 0xFF	; 255
    2a96:	8f 4f       	sbci	r24, 0xFF	; 255
    2a98:	9f 4f       	sbci	r25, 0xFF	; 255
    2a9a:	08 95       	ret

00002a9c <__floatunsisf>:
    2a9c:	e8 94       	clt
    2a9e:	09 c0       	rjmp	.+18     	; 0x2ab2 <__floatsisf+0x12>

00002aa0 <__floatsisf>:
    2aa0:	97 fb       	bst	r25, 7
    2aa2:	3e f4       	brtc	.+14     	; 0x2ab2 <__floatsisf+0x12>
    2aa4:	90 95       	com	r25
    2aa6:	80 95       	com	r24
    2aa8:	70 95       	com	r23
    2aaa:	61 95       	neg	r22
    2aac:	7f 4f       	sbci	r23, 0xFF	; 255
    2aae:	8f 4f       	sbci	r24, 0xFF	; 255
    2ab0:	9f 4f       	sbci	r25, 0xFF	; 255
    2ab2:	99 23       	and	r25, r25
    2ab4:	a9 f0       	breq	.+42     	; 0x2ae0 <__floatsisf+0x40>
    2ab6:	f9 2f       	mov	r31, r25
    2ab8:	96 e9       	ldi	r25, 0x96	; 150
    2aba:	bb 27       	eor	r27, r27
    2abc:	93 95       	inc	r25
    2abe:	f6 95       	lsr	r31
    2ac0:	87 95       	ror	r24
    2ac2:	77 95       	ror	r23
    2ac4:	67 95       	ror	r22
    2ac6:	b7 95       	ror	r27
    2ac8:	f1 11       	cpse	r31, r1
    2aca:	f8 cf       	rjmp	.-16     	; 0x2abc <__floatsisf+0x1c>
    2acc:	fa f4       	brpl	.+62     	; 0x2b0c <__floatsisf+0x6c>
    2ace:	bb 0f       	add	r27, r27
    2ad0:	11 f4       	brne	.+4      	; 0x2ad6 <__floatsisf+0x36>
    2ad2:	60 ff       	sbrs	r22, 0
    2ad4:	1b c0       	rjmp	.+54     	; 0x2b0c <__floatsisf+0x6c>
    2ad6:	6f 5f       	subi	r22, 0xFF	; 255
    2ad8:	7f 4f       	sbci	r23, 0xFF	; 255
    2ada:	8f 4f       	sbci	r24, 0xFF	; 255
    2adc:	9f 4f       	sbci	r25, 0xFF	; 255
    2ade:	16 c0       	rjmp	.+44     	; 0x2b0c <__floatsisf+0x6c>
    2ae0:	88 23       	and	r24, r24
    2ae2:	11 f0       	breq	.+4      	; 0x2ae8 <__floatsisf+0x48>
    2ae4:	96 e9       	ldi	r25, 0x96	; 150
    2ae6:	11 c0       	rjmp	.+34     	; 0x2b0a <__floatsisf+0x6a>
    2ae8:	77 23       	and	r23, r23
    2aea:	21 f0       	breq	.+8      	; 0x2af4 <__floatsisf+0x54>
    2aec:	9e e8       	ldi	r25, 0x8E	; 142
    2aee:	87 2f       	mov	r24, r23
    2af0:	76 2f       	mov	r23, r22
    2af2:	05 c0       	rjmp	.+10     	; 0x2afe <__floatsisf+0x5e>
    2af4:	66 23       	and	r22, r22
    2af6:	71 f0       	breq	.+28     	; 0x2b14 <__floatsisf+0x74>
    2af8:	96 e8       	ldi	r25, 0x86	; 134
    2afa:	86 2f       	mov	r24, r22
    2afc:	70 e0       	ldi	r23, 0x00	; 0
    2afe:	60 e0       	ldi	r22, 0x00	; 0
    2b00:	2a f0       	brmi	.+10     	; 0x2b0c <__floatsisf+0x6c>
    2b02:	9a 95       	dec	r25
    2b04:	66 0f       	add	r22, r22
    2b06:	77 1f       	adc	r23, r23
    2b08:	88 1f       	adc	r24, r24
    2b0a:	da f7       	brpl	.-10     	; 0x2b02 <__floatsisf+0x62>
    2b0c:	88 0f       	add	r24, r24
    2b0e:	96 95       	lsr	r25
    2b10:	87 95       	ror	r24
    2b12:	97 f9       	bld	r25, 7
    2b14:	08 95       	ret

00002b16 <__fp_inf>:
    2b16:	97 f9       	bld	r25, 7
    2b18:	9f 67       	ori	r25, 0x7F	; 127
    2b1a:	80 e8       	ldi	r24, 0x80	; 128
    2b1c:	70 e0       	ldi	r23, 0x00	; 0
    2b1e:	60 e0       	ldi	r22, 0x00	; 0
    2b20:	08 95       	ret

00002b22 <__fp_mintl>:
    2b22:	88 23       	and	r24, r24
    2b24:	71 f4       	brne	.+28     	; 0x2b42 <__fp_mintl+0x20>
    2b26:	77 23       	and	r23, r23
    2b28:	21 f0       	breq	.+8      	; 0x2b32 <__fp_mintl+0x10>
    2b2a:	98 50       	subi	r25, 0x08	; 8
    2b2c:	87 2b       	or	r24, r23
    2b2e:	76 2f       	mov	r23, r22
    2b30:	07 c0       	rjmp	.+14     	; 0x2b40 <__fp_mintl+0x1e>
    2b32:	66 23       	and	r22, r22
    2b34:	11 f4       	brne	.+4      	; 0x2b3a <__fp_mintl+0x18>
    2b36:	99 27       	eor	r25, r25
    2b38:	0d c0       	rjmp	.+26     	; 0x2b54 <__fp_mintl+0x32>
    2b3a:	90 51       	subi	r25, 0x10	; 16
    2b3c:	86 2b       	or	r24, r22
    2b3e:	70 e0       	ldi	r23, 0x00	; 0
    2b40:	60 e0       	ldi	r22, 0x00	; 0
    2b42:	2a f0       	brmi	.+10     	; 0x2b4e <__fp_mintl+0x2c>
    2b44:	9a 95       	dec	r25
    2b46:	66 0f       	add	r22, r22
    2b48:	77 1f       	adc	r23, r23
    2b4a:	88 1f       	adc	r24, r24
    2b4c:	da f7       	brpl	.-10     	; 0x2b44 <__fp_mintl+0x22>
    2b4e:	88 0f       	add	r24, r24
    2b50:	96 95       	lsr	r25
    2b52:	87 95       	ror	r24
    2b54:	97 f9       	bld	r25, 7
    2b56:	08 95       	ret

00002b58 <__fp_mpack>:
    2b58:	9f 3f       	cpi	r25, 0xFF	; 255
    2b5a:	49 f0       	breq	.+18     	; 0x2b6e <__fp_mpack+0x16>
    2b5c:	91 50       	subi	r25, 0x01	; 1
    2b5e:	28 f4       	brcc	.+10     	; 0x2b6a <__fp_mpack+0x12>
    2b60:	86 95       	lsr	r24
    2b62:	77 95       	ror	r23
    2b64:	67 95       	ror	r22
    2b66:	b7 95       	ror	r27
    2b68:	9f 5f       	subi	r25, 0xFF	; 255
    2b6a:	80 38       	cpi	r24, 0x80	; 128
    2b6c:	9f 4f       	sbci	r25, 0xFF	; 255
    2b6e:	88 0f       	add	r24, r24
    2b70:	96 95       	lsr	r25
    2b72:	87 95       	ror	r24
    2b74:	97 f9       	bld	r25, 7
    2b76:	08 95       	ret

00002b78 <__fp_nan>:
    2b78:	9f ef       	ldi	r25, 0xFF	; 255
    2b7a:	80 ec       	ldi	r24, 0xC0	; 192
    2b7c:	08 95       	ret

00002b7e <__fp_pscA>:
    2b7e:	00 24       	eor	r0, r0
    2b80:	0a 94       	dec	r0
    2b82:	16 16       	cp	r1, r22
    2b84:	17 06       	cpc	r1, r23
    2b86:	18 06       	cpc	r1, r24
    2b88:	09 06       	cpc	r0, r25
    2b8a:	08 95       	ret

00002b8c <__fp_pscB>:
    2b8c:	00 24       	eor	r0, r0
    2b8e:	0a 94       	dec	r0
    2b90:	12 16       	cp	r1, r18
    2b92:	13 06       	cpc	r1, r19
    2b94:	14 06       	cpc	r1, r20
    2b96:	05 06       	cpc	r0, r21
    2b98:	08 95       	ret

00002b9a <__fp_round>:
    2b9a:	09 2e       	mov	r0, r25
    2b9c:	03 94       	inc	r0
    2b9e:	00 0c       	add	r0, r0
    2ba0:	11 f4       	brne	.+4      	; 0x2ba6 <__fp_round+0xc>
    2ba2:	88 23       	and	r24, r24
    2ba4:	52 f0       	brmi	.+20     	; 0x2bba <__fp_round+0x20>
    2ba6:	bb 0f       	add	r27, r27
    2ba8:	40 f4       	brcc	.+16     	; 0x2bba <__fp_round+0x20>
    2baa:	bf 2b       	or	r27, r31
    2bac:	11 f4       	brne	.+4      	; 0x2bb2 <__fp_round+0x18>
    2bae:	60 ff       	sbrs	r22, 0
    2bb0:	04 c0       	rjmp	.+8      	; 0x2bba <__fp_round+0x20>
    2bb2:	6f 5f       	subi	r22, 0xFF	; 255
    2bb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2bb6:	8f 4f       	sbci	r24, 0xFF	; 255
    2bb8:	9f 4f       	sbci	r25, 0xFF	; 255
    2bba:	08 95       	ret

00002bbc <__fp_split3>:
    2bbc:	57 fd       	sbrc	r21, 7
    2bbe:	90 58       	subi	r25, 0x80	; 128
    2bc0:	44 0f       	add	r20, r20
    2bc2:	55 1f       	adc	r21, r21
    2bc4:	59 f0       	breq	.+22     	; 0x2bdc <__fp_splitA+0x10>
    2bc6:	5f 3f       	cpi	r21, 0xFF	; 255
    2bc8:	71 f0       	breq	.+28     	; 0x2be6 <__fp_splitA+0x1a>
    2bca:	47 95       	ror	r20

00002bcc <__fp_splitA>:
    2bcc:	88 0f       	add	r24, r24
    2bce:	97 fb       	bst	r25, 7
    2bd0:	99 1f       	adc	r25, r25
    2bd2:	61 f0       	breq	.+24     	; 0x2bec <__fp_splitA+0x20>
    2bd4:	9f 3f       	cpi	r25, 0xFF	; 255
    2bd6:	79 f0       	breq	.+30     	; 0x2bf6 <__fp_splitA+0x2a>
    2bd8:	87 95       	ror	r24
    2bda:	08 95       	ret
    2bdc:	12 16       	cp	r1, r18
    2bde:	13 06       	cpc	r1, r19
    2be0:	14 06       	cpc	r1, r20
    2be2:	55 1f       	adc	r21, r21
    2be4:	f2 cf       	rjmp	.-28     	; 0x2bca <__fp_split3+0xe>
    2be6:	46 95       	lsr	r20
    2be8:	f1 df       	rcall	.-30     	; 0x2bcc <__fp_splitA>
    2bea:	08 c0       	rjmp	.+16     	; 0x2bfc <__fp_splitA+0x30>
    2bec:	16 16       	cp	r1, r22
    2bee:	17 06       	cpc	r1, r23
    2bf0:	18 06       	cpc	r1, r24
    2bf2:	99 1f       	adc	r25, r25
    2bf4:	f1 cf       	rjmp	.-30     	; 0x2bd8 <__fp_splitA+0xc>
    2bf6:	86 95       	lsr	r24
    2bf8:	71 05       	cpc	r23, r1
    2bfa:	61 05       	cpc	r22, r1
    2bfc:	08 94       	sec
    2bfe:	08 95       	ret

00002c00 <__fp_trunc>:
    2c00:	e5 df       	rcall	.-54     	; 0x2bcc <__fp_splitA>
    2c02:	a0 f0       	brcs	.+40     	; 0x2c2c <__fp_trunc+0x2c>
    2c04:	be e7       	ldi	r27, 0x7E	; 126
    2c06:	b9 17       	cp	r27, r25
    2c08:	88 f4       	brcc	.+34     	; 0x2c2c <__fp_trunc+0x2c>
    2c0a:	bb 27       	eor	r27, r27
    2c0c:	9f 38       	cpi	r25, 0x8F	; 143
    2c0e:	60 f4       	brcc	.+24     	; 0x2c28 <__fp_trunc+0x28>
    2c10:	16 16       	cp	r1, r22
    2c12:	b1 1d       	adc	r27, r1
    2c14:	67 2f       	mov	r22, r23
    2c16:	78 2f       	mov	r23, r24
    2c18:	88 27       	eor	r24, r24
    2c1a:	98 5f       	subi	r25, 0xF8	; 248
    2c1c:	f7 cf       	rjmp	.-18     	; 0x2c0c <__fp_trunc+0xc>
    2c1e:	86 95       	lsr	r24
    2c20:	77 95       	ror	r23
    2c22:	67 95       	ror	r22
    2c24:	b1 1d       	adc	r27, r1
    2c26:	93 95       	inc	r25
    2c28:	96 39       	cpi	r25, 0x96	; 150
    2c2a:	c8 f3       	brcs	.-14     	; 0x2c1e <__fp_trunc+0x1e>
    2c2c:	08 95       	ret

00002c2e <__fp_zero>:
    2c2e:	e8 94       	clt

00002c30 <__fp_szero>:
    2c30:	bb 27       	eor	r27, r27
    2c32:	66 27       	eor	r22, r22
    2c34:	77 27       	eor	r23, r23
    2c36:	cb 01       	movw	r24, r22
    2c38:	97 f9       	bld	r25, 7
    2c3a:	08 95       	ret

00002c3c <__mulsf3>:
    2c3c:	0b d0       	rcall	.+22     	; 0x2c54 <__mulsf3x>
    2c3e:	ad cf       	rjmp	.-166    	; 0x2b9a <__fp_round>
    2c40:	9e df       	rcall	.-196    	; 0x2b7e <__fp_pscA>
    2c42:	28 f0       	brcs	.+10     	; 0x2c4e <__mulsf3+0x12>
    2c44:	a3 df       	rcall	.-186    	; 0x2b8c <__fp_pscB>
    2c46:	18 f0       	brcs	.+6      	; 0x2c4e <__mulsf3+0x12>
    2c48:	95 23       	and	r25, r21
    2c4a:	09 f0       	breq	.+2      	; 0x2c4e <__mulsf3+0x12>
    2c4c:	64 cf       	rjmp	.-312    	; 0x2b16 <__fp_inf>
    2c4e:	94 cf       	rjmp	.-216    	; 0x2b78 <__fp_nan>
    2c50:	11 24       	eor	r1, r1
    2c52:	ee cf       	rjmp	.-36     	; 0x2c30 <__fp_szero>

00002c54 <__mulsf3x>:
    2c54:	b3 df       	rcall	.-154    	; 0x2bbc <__fp_split3>
    2c56:	a0 f3       	brcs	.-24     	; 0x2c40 <__mulsf3+0x4>

00002c58 <__mulsf3_pse>:
    2c58:	95 9f       	mul	r25, r21
    2c5a:	d1 f3       	breq	.-12     	; 0x2c50 <__mulsf3+0x14>
    2c5c:	95 0f       	add	r25, r21
    2c5e:	50 e0       	ldi	r21, 0x00	; 0
    2c60:	55 1f       	adc	r21, r21
    2c62:	62 9f       	mul	r22, r18
    2c64:	f0 01       	movw	r30, r0
    2c66:	72 9f       	mul	r23, r18
    2c68:	bb 27       	eor	r27, r27
    2c6a:	f0 0d       	add	r31, r0
    2c6c:	b1 1d       	adc	r27, r1
    2c6e:	63 9f       	mul	r22, r19
    2c70:	aa 27       	eor	r26, r26
    2c72:	f0 0d       	add	r31, r0
    2c74:	b1 1d       	adc	r27, r1
    2c76:	aa 1f       	adc	r26, r26
    2c78:	64 9f       	mul	r22, r20
    2c7a:	66 27       	eor	r22, r22
    2c7c:	b0 0d       	add	r27, r0
    2c7e:	a1 1d       	adc	r26, r1
    2c80:	66 1f       	adc	r22, r22
    2c82:	82 9f       	mul	r24, r18
    2c84:	22 27       	eor	r18, r18
    2c86:	b0 0d       	add	r27, r0
    2c88:	a1 1d       	adc	r26, r1
    2c8a:	62 1f       	adc	r22, r18
    2c8c:	73 9f       	mul	r23, r19
    2c8e:	b0 0d       	add	r27, r0
    2c90:	a1 1d       	adc	r26, r1
    2c92:	62 1f       	adc	r22, r18
    2c94:	83 9f       	mul	r24, r19
    2c96:	a0 0d       	add	r26, r0
    2c98:	61 1d       	adc	r22, r1
    2c9a:	22 1f       	adc	r18, r18
    2c9c:	74 9f       	mul	r23, r20
    2c9e:	33 27       	eor	r19, r19
    2ca0:	a0 0d       	add	r26, r0
    2ca2:	61 1d       	adc	r22, r1
    2ca4:	23 1f       	adc	r18, r19
    2ca6:	84 9f       	mul	r24, r20
    2ca8:	60 0d       	add	r22, r0
    2caa:	21 1d       	adc	r18, r1
    2cac:	82 2f       	mov	r24, r18
    2cae:	76 2f       	mov	r23, r22
    2cb0:	6a 2f       	mov	r22, r26
    2cb2:	11 24       	eor	r1, r1
    2cb4:	9f 57       	subi	r25, 0x7F	; 127
    2cb6:	50 40       	sbci	r21, 0x00	; 0
    2cb8:	8a f0       	brmi	.+34     	; 0x2cdc <__mulsf3_pse+0x84>
    2cba:	e1 f0       	breq	.+56     	; 0x2cf4 <__mulsf3_pse+0x9c>
    2cbc:	88 23       	and	r24, r24
    2cbe:	4a f0       	brmi	.+18     	; 0x2cd2 <__mulsf3_pse+0x7a>
    2cc0:	ee 0f       	add	r30, r30
    2cc2:	ff 1f       	adc	r31, r31
    2cc4:	bb 1f       	adc	r27, r27
    2cc6:	66 1f       	adc	r22, r22
    2cc8:	77 1f       	adc	r23, r23
    2cca:	88 1f       	adc	r24, r24
    2ccc:	91 50       	subi	r25, 0x01	; 1
    2cce:	50 40       	sbci	r21, 0x00	; 0
    2cd0:	a9 f7       	brne	.-22     	; 0x2cbc <__mulsf3_pse+0x64>
    2cd2:	9e 3f       	cpi	r25, 0xFE	; 254
    2cd4:	51 05       	cpc	r21, r1
    2cd6:	70 f0       	brcs	.+28     	; 0x2cf4 <__mulsf3_pse+0x9c>
    2cd8:	1e cf       	rjmp	.-452    	; 0x2b16 <__fp_inf>
    2cda:	aa cf       	rjmp	.-172    	; 0x2c30 <__fp_szero>
    2cdc:	5f 3f       	cpi	r21, 0xFF	; 255
    2cde:	ec f3       	brlt	.-6      	; 0x2cda <__mulsf3_pse+0x82>
    2ce0:	98 3e       	cpi	r25, 0xE8	; 232
    2ce2:	dc f3       	brlt	.-10     	; 0x2cda <__mulsf3_pse+0x82>
    2ce4:	86 95       	lsr	r24
    2ce6:	77 95       	ror	r23
    2ce8:	67 95       	ror	r22
    2cea:	b7 95       	ror	r27
    2cec:	f7 95       	ror	r31
    2cee:	e7 95       	ror	r30
    2cf0:	9f 5f       	subi	r25, 0xFF	; 255
    2cf2:	c1 f7       	brne	.-16     	; 0x2ce4 <__mulsf3_pse+0x8c>
    2cf4:	fe 2b       	or	r31, r30
    2cf6:	88 0f       	add	r24, r24
    2cf8:	91 1d       	adc	r25, r1
    2cfa:	96 95       	lsr	r25
    2cfc:	87 95       	ror	r24
    2cfe:	97 f9       	bld	r25, 7
    2d00:	08 95       	ret

00002d02 <__mulsi3>:
    2d02:	62 9f       	mul	r22, r18
    2d04:	d0 01       	movw	r26, r0
    2d06:	73 9f       	mul	r23, r19
    2d08:	f0 01       	movw	r30, r0
    2d0a:	82 9f       	mul	r24, r18
    2d0c:	e0 0d       	add	r30, r0
    2d0e:	f1 1d       	adc	r31, r1
    2d10:	64 9f       	mul	r22, r20
    2d12:	e0 0d       	add	r30, r0
    2d14:	f1 1d       	adc	r31, r1
    2d16:	92 9f       	mul	r25, r18
    2d18:	f0 0d       	add	r31, r0
    2d1a:	83 9f       	mul	r24, r19
    2d1c:	f0 0d       	add	r31, r0
    2d1e:	74 9f       	mul	r23, r20
    2d20:	f0 0d       	add	r31, r0
    2d22:	65 9f       	mul	r22, r21
    2d24:	f0 0d       	add	r31, r0
    2d26:	99 27       	eor	r25, r25
    2d28:	72 9f       	mul	r23, r18
    2d2a:	b0 0d       	add	r27, r0
    2d2c:	e1 1d       	adc	r30, r1
    2d2e:	f9 1f       	adc	r31, r25
    2d30:	63 9f       	mul	r22, r19
    2d32:	b0 0d       	add	r27, r0
    2d34:	e1 1d       	adc	r30, r1
    2d36:	f9 1f       	adc	r31, r25
    2d38:	bd 01       	movw	r22, r26
    2d3a:	cf 01       	movw	r24, r30
    2d3c:	11 24       	eor	r1, r1
    2d3e:	08 95       	ret

00002d40 <__udivmodhi4>:
    2d40:	aa 1b       	sub	r26, r26
    2d42:	bb 1b       	sub	r27, r27
    2d44:	51 e1       	ldi	r21, 0x11	; 17
    2d46:	07 c0       	rjmp	.+14     	; 0x2d56 <__udivmodhi4_ep>

00002d48 <__udivmodhi4_loop>:
    2d48:	aa 1f       	adc	r26, r26
    2d4a:	bb 1f       	adc	r27, r27
    2d4c:	a6 17       	cp	r26, r22
    2d4e:	b7 07       	cpc	r27, r23
    2d50:	10 f0       	brcs	.+4      	; 0x2d56 <__udivmodhi4_ep>
    2d52:	a6 1b       	sub	r26, r22
    2d54:	b7 0b       	sbc	r27, r23

00002d56 <__udivmodhi4_ep>:
    2d56:	88 1f       	adc	r24, r24
    2d58:	99 1f       	adc	r25, r25
    2d5a:	5a 95       	dec	r21
    2d5c:	a9 f7       	brne	.-22     	; 0x2d48 <__udivmodhi4_loop>
    2d5e:	80 95       	com	r24
    2d60:	90 95       	com	r25
    2d62:	bc 01       	movw	r22, r24
    2d64:	cd 01       	movw	r24, r26
    2d66:	08 95       	ret

00002d68 <__udivmodsi4>:
    2d68:	a1 e2       	ldi	r26, 0x21	; 33
    2d6a:	1a 2e       	mov	r1, r26
    2d6c:	aa 1b       	sub	r26, r26
    2d6e:	bb 1b       	sub	r27, r27
    2d70:	fd 01       	movw	r30, r26
    2d72:	0d c0       	rjmp	.+26     	; 0x2d8e <__udivmodsi4_ep>

00002d74 <__udivmodsi4_loop>:
    2d74:	aa 1f       	adc	r26, r26
    2d76:	bb 1f       	adc	r27, r27
    2d78:	ee 1f       	adc	r30, r30
    2d7a:	ff 1f       	adc	r31, r31
    2d7c:	a2 17       	cp	r26, r18
    2d7e:	b3 07       	cpc	r27, r19
    2d80:	e4 07       	cpc	r30, r20
    2d82:	f5 07       	cpc	r31, r21
    2d84:	20 f0       	brcs	.+8      	; 0x2d8e <__udivmodsi4_ep>
    2d86:	a2 1b       	sub	r26, r18
    2d88:	b3 0b       	sbc	r27, r19
    2d8a:	e4 0b       	sbc	r30, r20
    2d8c:	f5 0b       	sbc	r31, r21

00002d8e <__udivmodsi4_ep>:
    2d8e:	66 1f       	adc	r22, r22
    2d90:	77 1f       	adc	r23, r23
    2d92:	88 1f       	adc	r24, r24
    2d94:	99 1f       	adc	r25, r25
    2d96:	1a 94       	dec	r1
    2d98:	69 f7       	brne	.-38     	; 0x2d74 <__udivmodsi4_loop>
    2d9a:	60 95       	com	r22
    2d9c:	70 95       	com	r23
    2d9e:	80 95       	com	r24
    2da0:	90 95       	com	r25
    2da2:	9b 01       	movw	r18, r22
    2da4:	ac 01       	movw	r20, r24
    2da6:	bd 01       	movw	r22, r26
    2da8:	cf 01       	movw	r24, r30
    2daa:	08 95       	ret

00002dac <_exit>:
    2dac:	f8 94       	cli

00002dae <__stop_program>:
    2dae:	ff cf       	rjmp	.-2      	; 0x2dae <__stop_program>
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\commands.cpp"
//Command Structures ---------------------------------------------------------
//
// Definition of the commands used by the Synta protocol, and variables in which responses
// are storedz
//
// Data structure of flag Flag:
//   flag = xxxx00ds000g000f where bits:
//   x = dont care
//   d = dir
//   s = stopped
//   g = goto
//   f = energised
//
// Only dir can be used to set the direction, but stepDir method can be used
// to returns it in a more useful format
//
//----------------------------------------------------------------------------

#include "commands.h"

Commands cmd = {0};

void Commands_init(unsigned long _eVal, byte _gVal){
    cmd.aVal[RA] = EEPROM_readLong(aVal1_Address);              //steps/axis
    cmd.aVal[DC] = EEPROM_readLong(aVal2_Address);              //steps/axis
    cmd.bVal[RA] = EEPROM_readLong(bVal1_Address);              //sidereal rate
    cmd.bVal[DC] = EEPROM_readLong(bVal2_Address);              //sidereal rate
    cmd.sVal[RA] = EEPROM_readLong(sVal1_Address);              //steps/worm rotation
    cmd.sVal[DC] = EEPROM_readLong(sVal2_Address);              //steps/worm rotation
    
    cmd.siderealIVal[RA] = EEPROM_readInt(IVal1_Address);       //steps/worm rotation
    cmd.siderealIVal[DC] = EEPROM_readInt(IVal2_Address);       //steps/worm rotation
    cmd.normalGotoSpeed[RA] = EEPROM_readByte(RAGoto_Address);  //IVal for normal goto speed
    cmd.normalGotoSpeed[DC] = EEPROM_readByte(DECGoto_Address); //IVal for normal goto speed
    cmd.st4SpeedFactor = EEPROM_readByte(SpeedFactor_Address);  //ST4 speed factor
    cmd.st4DecBacklash = EEPROM_readInt(DecBacklash_Address);   //DEC backlash steps
    
    EEPROM_readAccelTable(cmd.accelTable[RA],AccelTableLength,AccelTable1_Address); //Load the RA accel/decel table
    EEPROM_readAccelTable(cmd.accelTable[DC],AccelTableLength,AccelTable2_Address); //Load the DC accel/decel table
    
    for(byte i = 0;i < 2;i++){
        cmd.dir[i] = CMD_FORWARD;
        cmd.stepDir[i] = 1; //1-dir*2
        cmd.highSpeedMode[i] = false;
        cmd.stopped[i] = CMD_STOPPED;
        cmd.gotoEn[i] = CMD_DISABLED;
        cmd.FVal[i] = CMD_DISABLED;
        cmd.jVal[i] = 0x800000; //Current position, 0x800000 is the centre
        cmd.IVal[i] = cmd.siderealIVal[i]; //Recieved Speed will be set by :I command.
        cmd.GVal[i] = 0; //Mode recieved from :G command
        cmd.HVal[i] = 0; //Value recieved from :H command
        cmd.eVal[i] = _eVal; //version number
        cmd.gVal[i] = _gVal; //High speed scalar
        cmd.minSpeed[i] = cmd.accelTable[i][0].speed;//2x sidereal rate. [minspeed is the point at which acceleration curves are enabled]
        cmd.stopSpeed[i] = cmd.minSpeed[i];
        cmd.currentIVal[i] = cmd.stopSpeed[i]+1; //just slower than stop speed as axes are stopped.
        cmd.motorSpeed[i] = cmd.stopSpeed[i]+1; //same as above.
    }
    Commands_configureST4Speed(CMD_ST4_DEFAULT);
}

void Commands_configureST4Speed(byte mode) {
    cmd.st4Mode = mode;
    if (mode == CMD_ST4_HIGHSPEED) {
        //Set the ST4 speeds to highspeed standalone mode (goto speeds)
        cmd.st4RAIVal[ST4P] = cmd.normalGotoSpeed[RA];
        cmd.st4RAIVal[ST4N] = cmd.normalGotoSpeed[RA];
        cmd.st4RAReverse    = CMD_REVERSE;
        cmd.st4DecIVal      = cmd.normalGotoSpeed[DC];
    } else if (mode == CMD_ST4_STANDALONE) {
        //Set the ST4 speeds to standalone mode (2x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA])/3; //3x speed
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA])  ; //-1x speed
        cmd.st4RAReverse    = CMD_REVERSE;
        cmd.st4DecIVal      =(cmd.siderealIVal[DC])/2; //2x speed
    } else {
        //Set the ST4 speeds to normal mode (0.25x around sidereal speed)
        cmd.st4RAIVal[ST4P] =(cmd.siderealIVal[RA] * 20)/(20 + cmd.st4SpeedFactor); //(1+SpeedFactor)x speed   -- Max. IVal = 1200, so this will never overflow.
        cmd.st4RAIVal[ST4N] =(cmd.siderealIVal[RA] * 20)/(20 - cmd.st4SpeedFactor); //(1-SpeedFactor)x speed
        cmd.st4RAReverse    = CMD_FORWARD;
        cmd.st4DecIVal      =(cmd.siderealIVal[DC] * 20)/( 0 + cmd.st4SpeedFactor); //(SpeedFactor)x speed
    }
}

const char cmd_commands[numberOfCommands][3] = { {'j', 0, 6}, //arranged in order of most frequently used to reduce searching time.
                                                 {'f', 0, 3},
                                                 {'I', 6, 0},
                                                 {'G', 2, 0},
                                                 {'J', 0, 0},
                                                 {'K', 0, 0},
                                                 {'H', 6, 0},
                                                 {'M', 6, 0},
                                                 {'e', 0, 6},
                                                 {'a', 0, 6},
                                                 {'b', 0, 6},
                                                 {'g', 0, 2},
                                                 {'s', 0, 6},
                                                 {'E', 6, 0},
                                                 {'P', 1, 0},
                                                 {'F', 0, 0},
                                                 {'L', 0, 0},
                                                 //Programmer Commands
                                                 {'A', 6, 0},
                                                 {'B', 6, 0},
                                                 {'S', 6, 0},
                                                 {'n', 0, 6},
                                                 {'N', 6, 0},
                                                 {'D', 2, 0},
                                                 {'d', 0, 2},
                                                 {'C', 1, 0},
                                                 {'c', 0, 2},
                                                 {'Z', 2, 0},
                                                 {'z', 0, 2},
                                                 {'R', 6, 0},
                                                 {'r', 0, 6},
                                                 {'O', 1, 0},
                                                 {'Q', 2, 0},
                                                 {'q', 0, 2},
                                                 {'X', 6, 0},
                                                 {'x', 0, 6},
                                                 {'Y', 2, 0},
                                                 {'T', 0, 0}
                                               };

char Commands_getLength(char cmd, bool sendRecieve){
    for(byte i = 0;i < numberOfCommands;i++){
        if(cmd_commands[i][0] == cmd){
            if(sendRecieve){
                return cmd_commands[i][1];
            } else {
                return cmd_commands[i][2];
            }
        }
    }
    return -1;
}

//void Commands::setStepLength(byte target, byte stepLength) {
//  if (stepDir[target] > 0) {
//    stepDir[target] = stepLength;
//  } else {
//    stepDir[target] = -stepLength;
//  }
//}

ELF          S                 4     (   %RU  $ >   :;I  $ >  $ >  :;   :;I8
  :;  	 :;I8
  
I  ! I/  5 I  .?:;@@
   :;I  .?:;@I@
   :;I   :;I
  4 :;I    4 :;I  & I  4 :;I  4 :;I?
  4 :;I
   Y                                       z7       int                         ,       n       oE   #     ph   #     #;      %;  #     &K  #    'K  #    ([  #    );  #    *  #/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\commands.h"
//_fVal Flag get/set callers -------------------------------------------------
//
//Data structure of _fVal Flag:
//  _fVal = xxxx00ds000g000f where bits:
//  x = dont care
//  d = dir
//  s = stopped
//  g = goto
//  f = energised
//
//Only dir can be used to set the direction, but stepDir method can be used
//to returns it in a more useful format
//
//----------------------------------------------------------------------------

#ifndef __COMMANDS_H__
#define __COMMANDS_H__
  
#include "AstroEQ.h"
#include "EEPROMReader.h" //Read config file

#define CMD_ST4_HIGHSPEED   2
#define CMD_ST4_STANDALONE  1
#define CMD_ST4_DEFAULT     0

#define CMD_FORWARD         false
#define CMD_REVERSE         true

#define CMD_STOPPED         true
#define CMD_RUNNING         false

#define CMD_ENABLED         true
#define CMD_DISABLED        false

typedef struct{        
    //class variables
    unsigned long    jVal           [2]; //_jVal: Current position
    unsigned int     IVal           [2]; //_IVal: speed to move if in slew mode
    unsigned int     motorSpeed     [2]; //speed at which moving. Accelerates to IVal.
    byte             GVal           [2]; //_GVal: slew/goto mode
    unsigned long    HVal           [2]; //_HVal: steps to move if in goto mode
    volatile char    stepDir        [2]; 
    bool             dir            [2];
    bool             FVal           [2];
    bool             gotoEn         [2];
    bool             stopped        [2];
    bool             highSpeedMode  [2];
    unsigned long    eVal           [2]; //_eVal: Version number
    unsigned long    aVal           [2]; //_aVal: Steps per axis revolution
    unsigned long    bVal           [2]; //_bVal: Sidereal Rate of axis
    byte             gVal           [2]; //_gVal: Speed scalar for highspeed slew
    unsigned long    sVal           [2]; //_sVal: Steps per worm gear revolution
    byte             st4Mode;            //Current ST-4 mode
    byte             st4SpeedFactor;     //Multiplication factor to get st4 speed. min = 1 = 0.05x, max = 19 = 0.95x.
    unsigned int     st4RAIVal      [2]; //_IVal: for RA ST4 movements ({RA+,RA-});
    bool             st4RAReverse;       //Reverse RA- axis direction if true.
    unsigned int     st4DecIVal;         //_IVal: for declination ST4 movements
    unsigned int     st4DecBacklash;     //Number of steps to perform on ST-4 direction change ---- Not yet implemented.
    unsigned int     siderealIVal   [2]; //_IVal: at sidereal rate
    unsigned int     currentIVal    [2]; //this will be upldated to match the requested IVal once the motors are stopped.
    unsigned int     minSpeed       [2]; //slowest speed allowed
    unsigned int     normalGotoSpeed[2]; //IVal for normal goto movement.
    unsigned int     stopSpeed      [2]; //Speed at which mount should stop. May be lower than minSpeed if doing a very slow IVal.
    AccelTableStruct accelTable     [2][AccelTableLength]; //Acceleration profile now controlled via lookup table. The first element will be used for cmd.minSpeed[]. max repeat=85
} Commands;

#define numberOfCommands 37

void Commands_init(unsigned long _eVal, byte _gVal);
void Commands_configureST4Speed(byte mode);
char Commands_getLength(char cmd, bool sendRecieve);
  
//Command definitions
extern const char command[numberOfCommands][3];
extern Commands cmd;

//Methods for accessing command variables
inline void cmd_setDir(byte target, bool _dir){ //Set Method
    cmd.dir[target] = _dir ? CMD_REVERSE : CMD_FORWARD; //set direction
}

inline void cmd_updateStepDir(byte target, byte stepSize){
    if(cmd.dir[target] == CMD_REVERSE){
        cmd.stepDir[target] = -stepSize; //set step direction
    } else {
        cmd.stepDir[target] = stepSize; //set step direction
    }
}

inline unsigned int cmd_fVal(byte target){ //_fVal: 00ds000g000f; d = dir, s = stopped, g = goto, f = energised
    unsigned int fVal = 0;
    if (cmd.dir[target]) {
        fVal |= (1 << 9);
    }
    if (cmd.stopped[target]) {
        fVal |= (1 << 8);
    }
    if (cmd.gotoEn[target]) {
        fVal |= (1 << 4);
    }
    if (cmd.FVal[target]){
        fVal |= (1 << 0);
    }
    return fVal;
}

inline void cmd_setsideIVal(byte target, unsigned int _sideIVal){ //set Method
    cmd.siderealIVal[target] = _sideIVal;
}

inline void cmd_setStopped(byte target, bool _stopped){ //Set Method
    cmd.stopped[target] = _stopped;
}

inline void cmd_setGotoEn(byte target, bool _gotoEn){ //Set Method
    cmd.gotoEn[target] = _gotoEn;
}

inline void cmd_setFVal(byte target, bool _FVal){ //Set Method
    cmd.FVal[target] = _FVal;
}

inline void cmd_setjVal(byte target, unsigned long _jVal){ //Set Method
    cmd.jVal[target] = _jVal;
}

inline void cmd_setIVal(byte target, unsigned int _IVal){ //Set Method
    cmd.IVal[target] = _IVal;
}

inline void cmd_setaVal(byte target, unsigned long _aVal){ //Set Method
    cmd.aVal[target] = _aVal;
}

inline void cmd_setbVal(byte target, unsigned long _bVal){ //Set Method
    cmd.bVal[target] = _bVal;
}

inline void cmd_setsVal(byte target, unsigned long _sVal){ //Set Method
    cmd.sVal[target] = _sVal;
}

inline void cmd_setHVal(byte target, unsigned long _HVal){ //Set Method
    cmd.HVal[target] = _HVal;
}

inline void cmd_setGVal(byte target, byte _GVal){ //Set Method
    cmd.GVal[target] = _GVal;
}

inline void cmd_setst4SpeedFactor(byte _factor){ //Set Method
    cmd.st4SpeedFactor = _factor;
}

inline void cmd_setst4DecBacklash(unsigned int _backlash){ //Set Method
    cmd.st4DecBacklash = _backlash;
}


#endif //__COMMANDS_H__
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMAddresses.h"
#include "avr/io.h"

#define EEPROMStart_Address (                      0 )
#define AstroEQID_Address   (EEPROMStart_Address + 0 )
#define Microstep_Address   (EEPROMStart_Address + 8 ) //whether to use microstepping.
#define RAReverse_Address   (EEPROMStart_Address + 9 )
#define DECReverse_Address  (EEPROMStart_Address + 10)
#define Driver_Address      (EEPROMStart_Address + 11)
#define RAGoto_Address      (EEPROMStart_Address + 12)
#define DECGoto_Address     (EEPROMStart_Address + 13)
#define aVal1_Address       (EEPROMStart_Address + 14) //steps/axis
#define aVal2_Address       (EEPROMStart_Address + 18) //steps/axis
#define bVal1_Address       (EEPROMStart_Address + 22) //sidereal rate
#define bVal2_Address       (EEPROMStart_Address + 26) //sidereal rate
#define sVal1_Address       (EEPROMStart_Address + 30) //steps/worm rotation
#define sVal2_Address       (EEPROMStart_Address + 34) //steps/worm rotation
#define IVal1_Address       (EEPROMStart_Address + 38) //steps/worm rotation
#define IVal2_Address       (EEPROMStart_Address + 40) //steps/worm rotation
#define GearEnable_Address  (EEPROMStart_Address + 42) //Allow "gear change"
#define AdvHCEnable_Address (EEPROMStart_Address + 43) //Allow advanced controller detection
#define DecBacklash_Address (EEPROMStart_Address + 44) //DEC backlash correction factor
#define SpeedFactor_Address (EEPROMStart_Address + 46) //ST4 Speed Factor (0.05x to 0.95x sidereal as multiple of 1/20)

#define AccelTableLength 64
#define AccelTable1_Address (EEPROMStart_Address + 100) //Leave a gap so we can add more settings later.
#define AccelTable2_Address (EEPROMStart_Address + 100 + AccelTableLength*3)

#if ((EEPROMStart_Address + 100 + (6*AccelTableLength) - 1) > E2END)
    #error "AccelTable too large for EEPROM"
#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMReader.cpp"

#include <avr/eeprom.h>
#include "EEPROMReader.h"
 
byte EEPROM_readByte(unsigned int address) {
    return eeprom_read_byte((byte*) address);
}

unsigned int EEPROM_readInt(unsigned int address) {
    TwoBytes fetcher;
    fetcher.array[0] = EEPROM_readByte(address);
    fetcher.array[1] = EEPROM_readByte(address+1);
    return fetcher.integer;
}
unsigned long EEPROM_readLong(unsigned int address) {
    FourBytes fetcher;
    fetcher.array[0] = EEPROM_readInt(address);
    fetcher.array[1] = EEPROM_readInt(address+2);
    return fetcher.integer;
}

void EEPROM_readString(char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
        string[i] = EEPROM_readByte(address++);
    }
}

void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
        table[i].speed = EEPROM_readInt(address);
        address = address + sizeof(unsigned int);
        table[i].repeats = EEPROM_readInt(address);
        address = address + sizeof(byte);
    }
}

void EEPROM_writeByte(byte val, unsigned int address) {
    return eeprom_write_byte((byte*) address, val);
}

void EEPROM_writeInt(unsigned int val, unsigned int address) {
    TwoBytes storer = {val};
    EEPROM_writeByte(storer.array[0], address);
    EEPROM_writeByte(storer.array[1], address+1);
}

void EEPROM_writeLong(unsigned long val, unsigned int address) {
    FourBytes storer = {val};
    EEPROM_writeInt(storer.array[0], address);
    EEPROM_writeInt(storer.array[1], address+2);
}

void EEPROM_writeString(const char* string, byte len, unsigned int address) {
    for(byte i = 0; i < len; i++) {
        EEPROM_writeByte(string[i], address+i);
    }
}

void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address){
    for(byte i = 0; i < elements; i++) {
        EEPROM_writeInt(table[i].speed,address);
        address = address + sizeof(unsigned int);
        EEPROM_writeByte(table[i].repeats,address);
        address = address + sizeof(byte);
    }
}
ELF          S                 4     ( + ( %RU  $ >   :;I  $ >  :;   :;I  I  ! I/  	$ >  
:;   :;I8
  .:;I    :;I  4 :;I   I  & I  .?:;I    :;I     1  4 1    .:;    :;I   :;I  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\EEPROMReader.h"
#ifndef __EEPROM_H__
#define __EEPROM_H__

#include "AstroEQ.h"

byte EEPROM_readByte(unsigned int address);
unsigned int EEPROM_readInt(unsigned int address);
unsigned long EEPROM_readLong(unsigned int address);
void EEPROM_readString(char* string, byte len, unsigned int address);
void EEPROM_readAccelTable(AccelTableStruct* table, byte elements, unsigned int address);
void EEPROM_writeByte(byte val,unsigned int address);
void EEPROM_writeInt(unsigned int val,unsigned int address);
void EEPROM_writeLong(unsigned long val,unsigned int address);
void EEPROM_writeString(const char* string, byte len, unsigned int address);
void EEPROM_writeAccelTable(AccelTableStruct* table, byte elements, unsigned int address);

#endif //__EEPROM_H__
ELF          S                  4     ( 7 4 %RU   :;I  $ >  $ >  $ >   I  & I  <  	.?:;@I<  
 I4   I   :;  :;   I8
2   :;I8
2  .?@I4<  .?4<  .?:;@I2<  .?:;<  .?:;@ILM
<   I8
4  I  ! I/   I  I  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\PinMappings.h"

//
// Useful Macros
//

#define setPinDir(p,d) {if(d){*digitalPinToDirectionReg((p)) |= _BV(digitalPinToBit((p)));}else{*digitalPinToDirectionReg((p)) &= ~_BV(digitalPinToBit((p)));}}
#define setPinValue(p,v) {if(v){*digitalPinToPortReg((p)) |= _BV(digitalPinToBit((p)));}else{*digitalPinToPortReg((p)) &= ~_BV(digitalPinToBit((p)));}}
#define getPinValue(p) (!!(*digitalPinToPinReg((p)) & _BV(digitalPinToBit((p)))))
#define togglePin(p) {*digitalPinToPortReg((p)) ^= _BV(digitalPinToBit((p)));}


//
// Pin Mappings
//

#if defined(__AVR_ATmega162__)

//----- User Configurable Pin Definitions for ATMega162 Variants -----
//Warning: D20 to D27 inclusive are NOT allowed

//GPIO Header:
                             //VCC (Header Pin 5)
#define gpioPin_0_Define 2   //IO0 (Header Pin 4) [ATMega PD2] - Interrupt Capable (INT0)
#define gpioPin_1_Define 29  //IO1 (Header Pin 3) [ATMega PE1] - GPIO Pin
#define gpioPin_2_Define 28  //IO2 (Header Pin 2) [ATMega PE0] - GPIO Pin
                             //GND (Header Pin 1)

//Status Pins:
#define statusPin_Define 13 

//Motor Driver Pins:
#define resetPin_0_Define 15
#define resetPin_1_Define 14

#define dirPin_0_Define 3
#define dirPin_1_Define 7

#define enablePin_0_Define 4
#define enablePin_1_Define 8

#define stepPin_0_Define 5
#define stepPin_1_Define 30

#define modePins0_0_Define 6
#define modePins1_0_Define 17
#define modePins2_0_Define 16
#define modePins0_1_Define 10
#define modePins1_1_Define 18
#define modePins2_1_Define 19

//ST4 Pins:
#define ST4AddPin_0_Define 34
#define ST4AddPin_1_Define 33
#define ST4SubPin_0_Define 31
#define ST4SubPin_1_Define 32

//SPI Pins:
#define SPIClockPin_Define 32 //(13)
#define SPIMISOPin_Define  34 //(12) - Comments are hardware SPI pin. These are sadly partly used for other things.
#define SPIMOSIPin_Define  33 //(11) - Instead we are currently doing software SPI on same pins as ST4.
#define SPISSnPin_Define   31 //(6)


#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)

//---- User Configurable Pin Definitions for ATMegaXXX0 Variants -----
//Warning: D30 to D37 inclusive are NOT allowed

//GPIO Pins:
#define gpioPin_0_Define 21  //IO0 [ATMega PD0] - Interrupt Capable (INT0)
#define gpioPin_1_Define 22  //IO1 [ATMega PA0] - GPIO Pin
#define gpioPin_2_Define 23  //IO2 [ATMega PA1] - GPIO Pin

//Status Pins:
#define statusPin_Define 13

//Motor Driver Pins:
#define resetPin_0_Define 55 //Analog 1
#define resetPin_1_Define 54 //Analog 0

#define dirPin_0_Define 3
#define dirPin_1_Define 7

#define enablePin_0_Define 4
#define enablePin_1_Define 8

#define stepPin_0_Define 5
#define stepPin_1_Define 12

#define modePins0_0_Define 15
#define modePins1_0_Define 16
#define modePins2_0_Define 17
#define modePins0_1_Define 20
#define modePins1_1_Define 19
#define modePins2_1_Define 18

//ST4 Pins:
//#define ALTERNATE_ST4 //Uncomment this line to use the alternate mapping for the ST4 port, using A8 to A11 instead of 50 to 53

//You only have a choice between two locations for the ST4 pins as controlled by the above #define.
#ifdef ALTERNATE_ST4
#define ST4AddPin_0_Define 62 //Analog 8
#define ST4AddPin_1_Define 63 //Analog 9
#define ST4SubPin_0_Define 64 //Analog 10
#define ST4SubPin_1_Define 65 //Analog 11
#else
#define ST4AddPin_0_Define 50
#define ST4AddPin_1_Define 51
#define ST4SubPin_0_Define 53
#define ST4SubPin_1_Define 52
#endif

//SPI Pins:
#define SPIClockPin_Define 52
#define SPIMISOPin_Define  50
#define SPIMOSIPin_Define  51
#define SPISSnPin_Define   53


#endif








// Do not modify anything below this line! ---------------------------------------


#if (CS10 != CS30) || (CS11 != CS31) || (CS12 != CS32)
#error incorrect assumption about prescale bits being equal between timer 1 and 3.
#endif
#define CSn0 CS10
#define CSn1 CS11
#define CSn2 CS12



#if defined(__AVR_ATmega162__)


#ifndef USART0_TX_vect
#define USART0_TX_vect USART0_TXC_vect
#endif
#ifndef USART0_RX_vect
#define USART0_RX_vect USART0_RXC_vect
#endif

#ifndef USART1_TX_vect
#define USART1_TX_vect USART1_TXC_vect
#endif
#ifndef USART1_RX_vect
#define USART1_RX_vect USART1_RXC_vect
#endif

//Pick some registers we are not going use for GPIOR
#define GPIOR0 PORTC
#define GPIOR1 OCR0
#define GPIOR2 TCNT0

#define PCICR GICR

#ifndef TIMSK3
#define TIMSK3 ETIMSK
#endif
#ifndef TIMSK1
#define TIMSK1 TIMSK
#endif
#ifndef ICIE3
#define ICIE3 TICIE3
#endif
#ifndef ICIE1
#define ICIE1 TICIE1
#endif

#define digitalPinToPortReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &PORTA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &PORTB : \
((((P) >= 20 && (P) <= 27)                            ) ? &PORTC : \
((((P) <= 7              )                            ) ? &PORTD : &PORTE ))))

#define digitalPinToDirectionReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &DDRA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &DDRB : \
((((P) >= 20 && (P) <= 27)                            ) ? &DDRC : \
((((P) <= 7              )                            ) ? &DDRD : &DDRE ))))

#define digitalPinToPinReg(P) \
((((P) >= 14 && (P) <= 17) || ((P) >= 31 && (P) <= 34)) ? &PINA : \
((((P) >= 8  && (P) <= 13) || ((P) >= 18 && (P) <= 19)) ? &PINB : \
((((P) >= 20 && (P) <= 27)                            ) ? &PINC : \
((((P) <= 7              )                            ) ? &PIND : &PINE ))))

#define digitalPinToBit(P) \
(((P) >=  0 && (P) <=  3) ? (P)      : \
(((P) >= 10 && (P) <= 13) ? (P) - 6  : \
(((P) >=  8 && (P) <=  9) ? (P) - 8  : \
(((P) >= 18 && (P) <= 19) ? 21 - (P) : \
(((P) >= 20 && (P) <= 27) ? (P) - 20 : \
(((P) >= 28 && (P) <= 30) ? (P) - 28 : \
(((P) >= 31 && (P) <= 34) ? (P) - 27 : \
(((P) >= 14 && (P) <= 17) ? (P) - 14 : \
(((P) >=  5 && (P) <=  6) ? (P) - 1  : \
(((P) == 7              ) ? (P)      : 6 ))))))))))


#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)


#define digitalPinToPortReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &PORTA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PORTB : \
((((P) >= 30 && (P) <= 37)                            ) ? &PORTC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &PORTD : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &PORTE : \
((((P) >= 54 && (P) <= 61)                            ) ? &PORTF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &PORTG : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &PORTH : \
((((P) >= 14 && (P) <= 15)                            ) ? &PORTJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &PORTK : &PORTL))))))))))

#define digitalPinToDirectionReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &DDRA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &DDRB : \
((((P) >= 30 && (P) <= 37)                            ) ? &DDRC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &DDRD : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &DDRE : \
((((P) >= 54 && (P) <= 61)                            ) ? &DDRF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &DDRG : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &DDRH : \
((((P) >= 14 && (P) <= 15)                            ) ? &DDRJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &DDRK : &DDRL))))))))))

#define digitalPinToPinReg(P) \
((((P) >= 22 && (P) <= 29)                            ) ? &PINA : \
((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PINB : \
((((P) >= 30 && (P) <= 37)                            ) ? &PINC : \
((((P) >= 18 && (P) <= 21) || ((P) == 38             )) ? &PIND : \
((((P) >= 0  && (P) <= 3 ) || ((P) == 5              )) ? &PINE : \
((((P) >= 54 && (P) <= 61)                            ) ? &PINF : \
((((P) >= 39 && (P) <= 41) || ((P) == 4              )) ? &PING : \
((((P) >= 6  && (P) <= 9 ) || ((P) >= 16 && (P) <= 17)) ? &PINH : \
((((P) >= 14 && (P) <= 15)                            ) ? &PINJ : \
((((P) >= 62 && (P) <= 69)                            ) ? &PINK : &PINL))))))))))

#define digitalPinToBit(P) \
(((P) >=  7 && (P) <=  9) ? (P) - 3 : \
(((P) >= 10 && (P) <= 13) ? (P) - 6 : \
(((P) >= 22 && (P) <= 29) ? (P) - 22 : \
(((P) >= 30 && (P) <= 37) ? 37 - (P) : \
(((P) >= 39 && (P) <= 41) ? 41 - (P) : \
(((P) >= 42 && (P) <= 49) ? 49 - (P) : \
(((P) >= 50 && (P) <= 53) ? 53 - (P) : \
(((P) >= 54 && (P) <= 61) ? (P) - 54 : \
(((P) >= 62 && (P) <= 69) ? (P) - 62 : \
(((P) >= 0  && (P) <= 1 ) ? (P)      : \
(((P) >= 14 && (P) <= 15) ? 15 - (P) : \
(((P) >= 16 && (P) <= 17) ? 17 - (P) : \
(((P) >= 20 && (P) <= 21) ? 21 - (P) : \
(((P) == 19             ) ?       2  : \
(((P) >= 5  && (P) <= 6 ) ?       3  : \
(((P) == 18             ) ?       3  : \
(((P) == 2              ) ?       4  : \
(((P) >= 3  && (P) <= 4 ) ?       5  : 7))))))))))))))))))



#endif
ELF          S            HS     4     ( K H nan inf ovf . %RU   :;I  $ >  $ >   I  $ >  :;   :;I8
2  	 :;I8
2  
.?:;@2<   I4  .?:;<   I  .?:;@I<  .?:;@<  .?:;@I2<  .?:;@I2<  :;   :;I8
    & I   I  :;   :;   I8
4  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\SerialLink.cpp"

#include "SerialLink.h"
#include <avr/io.h>
#include <avr/interrupt.h>

//This stuff is needed for GCC to correctly append in the value from SERIALn above
#define __REGnD(r,n,d) r##n##d
#define __REGn(r,n) r##n
#define _REGnD(r,n,d) __REGnD(r,n,d)
#define _REGn(r,n) __REGn(r,n)

//Two macros to make things like UCSRA0A and U2X0
#define REGnD(r,d) _REGnD(r,SERIALn,d)
#define REGn(r) _REGn(r,SERIALn)

//Registers
#define UCSRnA REGnD(UCSR,A)
#define UCSRnB REGnD(UCSR,B)
#define UBRRnH REGnD(UBRR,H)
#define UBRRnL REGnD(UBRR,L)
#define UDRn REGn(UDR)

//Bits
#define U2Xn REGn(U2X)
#define RXENn REGn(RXEN)
#define TXENn REGn(TXEN)
#define RXCIEn REGn(RXCIE)
#define UDRIEn REGn(UDRIE)

//Vectors
#define USARTn_RX_vect REGnD(USART,_RX_vect)
#define USARTn_UDRE_vect REGnD(USART,_UDRE_vect)

#define SPI_NULL 0xFF //NULL means ignore
#define SPI_DATA 0x7F //And-ed with all outgoing write packets. An incoming byte is ignored if bits outside this mask are set.
#define SPI_READ 0x81 //SPI read request command
#define SPI_RESP 0x80 //SPI read response request command
#define SPI_ISDATA(a) (!((a) & (~SPI_DATA))) //Returns true if SPI_DATA
#define SPI_ISREAD(a) ( ((a) == ( SPI_READ))) //Returns true if SPI_READ

#define BUFFER_SIZE 32 //Must be power of 2!
#define BUFFER_PTR_MASK (BUFFER_SIZE - 1)
typedef struct {
    unsigned char buffer[BUFFER_SIZE];
    volatile unsigned char head;
    volatile unsigned char tail;
} 
RingBuffer;

RingBuffer txBuf = {{0},0,0};
RingBuffer rxBuf = {{0},0,0};

bool softSPIEnabled = false;

//Initialise the hardware UART port and set baud rate.
void Serial_initialise(const unsigned long baud) {
    Byter baud_setting;

    UCSRnA = _BV(U2Xn);
    baud_setting.integer = (F_CPU / 4 / baud - 1) / 2;

    if (baud_setting.high & 0xF0) {
        UCSRnA = 0;
        baud_setting.integer = (F_CPU / 8 / baud - 1) / 2;
    }

    // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
    UBRRnH = baud_setting.high & 0x0F;
    UBRRnL = baud_setting.low;

    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.

    //And enable
    sbi(UCSRnB, RXENn);
    sbi(UCSRnB, TXENn);
    sbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
}

//Disable the hardware UART port
void Serial_disable() {
    cbi(UCSRnB, RXENn);
    cbi(UCSRnB, TXENn);
    cbi(UCSRnB, RXCIEn);
    cbi(UCSRnB, UDRIEn);
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Clear the serial buffers
void Serial_clear(void) {
    byte oldSREG = SREG;
    cli();
    //Clear the buffers by resetting the heads and tails to be equal.
    txBuf.head = 0;
    txBuf.tail = 0;
    rxBuf.head = 0;
    rxBuf.tail = 0;
    SREG = oldSREG;
}

//Initialise the Software SPI by setting ports to correct direction and state.
void SPI_initialise() {
    //Set all SPI pins to idle levels
    setPinDir  (SPIClockPin_Define,OUTPUT); //Clock is output idle high
    setPinValue(SPIClockPin_Define,  HIGH);
    setPinDir  (SPIMISOPin_Define,  INPUT); //MISO is input pull-up
    setPinValue(SPIMISOPin_Define,   HIGH);
    setPinDir  (SPIMOSIPin_Define, OUTPUT); //MOSI is output idle high
    setPinValue(SPIMOSIPin_Define,   HIGH);
    setPinDir  (SPISSnPin_Define,  OUTPUT); //SSn is output idle high
    setPinValue(SPISSnPin_Define,    HIGH);
    //Standalone pin is switching to SPI ready, so ensure we out pull-up is to high.
    setPinValue(standalonePin[STANDALONE_PULL],HIGH); //Pull high
    //Drain the serial port of anything that might be in the buffer
    Serial_clear(); //Empty the buffer of any outstanding data.
    
    //Now enabled
    softSPIEnabled = true;
}

//Disable the Software SPI by setting all ports back to input pull-up
void SPI_disable() {
    //Set all SPI pins to High-Z
    setPinDir  (SPIClockPin_Define, INPUT);
    setPinValue(SPIClockPin_Define,  HIGH);
    setPinDir  (SPIMISOPin_Define,  INPUT);
    setPinValue(SPIMISOPin_Define,   HIGH);
    setPinDir  (SPIMOSIPin_Define,  INPUT);
    setPinValue(SPIMOSIPin_Define,   HIGH);
    setPinDir  (SPISSnPin_Define,   INPUT);
    setPinValue(SPISSnPin_Define,    HIGH);
    //Now disabled
    softSPIEnabled = false;
    Serial_clear(); //Empty the buffer of any outstanding data.
}

//Software SPI Mode 3 Transfer
//One byte of data is sent and at the same time a byte is received.
byte SPI_transfer(byte data) {
    for (byte i = 8;i > 0; i--){ //Count through all 8 bits.
        setPinValue(SPIClockPin_Define,LOW); //Falling Edge   //--     2 cycles         .
        if (data & 0x80) { //Send MSB first                   //-- 2 cycles | 1 cycle    |
            setPinValue(SPIMOSIPin_Define,HIGH);              //-- 2 cycles | -          |
        } else {                                              //--          | 2 cycles    > 8 cycles for both paths
            nop();                                            //--          | 1 cycle    |
            setPinValue(SPIMOSIPin_Define,LOW);               //--          | 2 cycles   |
        }                                                     //-- 2 cycles | -         '
        setPinValue(SPIClockPin_Define,HIGH); //Rising Edge   //--      2 cycles        .
        data = data << 1; //Shift MSB-1 to MSB                //--      1 cycle          |
        if (getPinValue(SPIMISOPin_Define)) {                 //-- 2 cycle  | 1 cycles    > 8 cycles for both paths
            data = data + 1;//and set LSB to the new data     //--          | 1 cycle    |
        }                                                     //--       3 cycles       '
    }                                                         //-- Total Path is 16 cycles = 1MHz @ 16MHz clock
    return data; //Return shifted in data.                    //-- 5 Cycles on entry (including CALL), 3 cycles on exit (including RET)
}

//Performs an SPI read request and stores the data in the RX buffer.
// - If there is no space in the buffer, a read request will *not* be performed
//   The buffer should be first emptied by using Serial_read()
void SPI_read(void) {
    //First we check if there is space in the buffer, and that the slave has data to send
    if ((rxBuf.tail != rxBuf.head) && !(getPinValue(standalonePin[STANDALONE_IRQ]))) {
        //If there is, then do a read request  
        setPinValue(SPISSnPin_Define,LOW); //Select the slave
        SPI_transfer(SPI_READ); //First send a read request
        while(!getPinValue(standalonePin[STANDALONE_IRQ])); //Wait for the slave to have loaded its data
        byte data = SPI_transfer(SPI_RESP); //Then send a response request (clocks data from slave to master and informs slave that transfer is done)
        if (SPI_ISDATA(data)) {
            //If the slave had data available (indicated by the MSB being clear)
            rxBuf.buffer[rxBuf.head] = data; //Store the data
            rxBuf.head++; //And increment the head
        }
        setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
    }
}

//Performs an SPI write request.
void SPI_write(byte data) {
    setPinValue(SPISSnPin_Define,LOW); //Select the slave
    SPI_transfer(data & SPI_DATA); 
    setPinValue(SPISSnPin_Define,HIGH); //Deselect the slave
}

//Checks if there is any data available in the RX buffer.
// - If in SPI mode, this will also perform an SPI read transfer to see if there is any valid data.
byte Serial_available(void) {
    if (softSPIEnabled) {
        //If SPI is enabled, we do a read to check if there is any data.
        SPI_read();
    }
    return ((rxBuf.head - rxBuf.tail) & BUFFER_PTR_MASK); //number of bytes available
}

//Returns the next available data byte in the buffer
// - If there is nothing there, -1 is returned.
char Serial_read(void) {
    //If UART is enabled
    byte tail = rxBuf.tail;
    if (rxBuf.head == tail) {
        return -1;
    } else {
        char c = rxBuf.buffer[tail];
        rxBuf.tail = ((tail + 1) & BUFFER_PTR_MASK);
        return c;
    }
}

//Write a byte of data
// - If in UART mode, the byte is stored into the TX buffer when there is space.
// - If in SPI mode, a write transfer is performed.
void Serial_write(char ch) {
    if (UCSRnB & _BV(TXENn)) { 
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
        if (head == txBuf.tail) {
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
            while (head == txBuf.tail); //wait for buffer to have some space
        }
        
        txBuf.buffer[txBuf.head] = ch; //Load the new data into the buffer
        txBuf.head = head; //And store the new head.
        sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled if not already
    } else if (softSPIEnabled) {
        //If SPI is enabled, we do an SPI write.
        SPI_write(ch);
    }
}

//Flushes data from TX buffer
void Serial_flush() {
    if (UCSRnB & _BV(TXENn)) { 
        //If UART is enabled
        unsigned char head = ((txBuf.head + 1) & BUFFER_PTR_MASK); //Calculate the new head
        if (head == txBuf.tail) {
            //If there is no space in the buffer
            sbi(UCSRnB, UDRIEn); //Ensure TX IRQ is enabled before our busy wait - otherwise we lock up!
            while (head == txBuf.tail); //wait for buffer to have some space
        }
    }
}

//Convert string to bytes
void Serial_writeStr(char* str) {
    while (*str) {
        Serial_write(*str++);
    }
}

//Convert array to bytes
void Serial_writeArr(char* arr, byte len) {
    while (len--) {
        Serial_write(*arr++);
    }
}

//UART RX IRQ
// - Stores data from UART port into RX ring buffer
ISR(USARTn_RX_vect,ISR_NAKED) {
    register unsigned char c asm("r18");
    register unsigned char head asm("r25");
    register unsigned char tail asm("r24");
    asm volatile (
        "push %0     \n\t"
        "in   %0, %3 \n\t" 
        "push %0     \n\t"
        "push %1     \n\t"
        "push %2     \n\t"
        "push r30    \n\t"
        "push r31    \n\t"
        :
        : "a" (c), "r" (head), "r" (tail), "I" (_SFR_IO_ADDR(SREG))
        :
    );

    //Read in from the serial data register
    c = UDRn;
    //get the current head
    head = rxBuf.head;
    head++;
    head &= BUFFER_PTR_MASK;
    tail = rxBuf.tail;

    if (head != tail) {
        rxBuf.buffer[rxBuf.head] = c;
        rxBuf.head = head;
    } 

    asm volatile (
        "pop r31    \n\t"
        "pop r30    \n\t"
        "pop %2     \n\t"
        "pop %1     \n\t"
        "pop %0     \n\t"
        "out %3, %0 \n\t"
        "pop %0     \n\t"
        "reti       \n\t"
        : "=a" (c), "=r" (head), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
}

//UART TX IRQ
// - Writes data to UART port from TX ring buffer
ISR(USARTn_UDRE_vect, ISR_NAKED)
{
    register unsigned char tail asm("r25");
    register unsigned char temp asm("r24");
    asm volatile (
        "push %0       \n\t"
        "in   %0, %2   \n\t" 
        "push %0       \n\t"
        "push %1       \n\t"
        "push r30      \n\t"
        "push r31      \n\t"
        :: "r" (temp), "r" (tail), "I" (_SFR_IO_ADDR(SREG)):
    );
    tail = txBuf.tail;
    temp = txBuf.head;
    if (temp == tail) {
        // Buffer empty, so disable interrupts
        cbi(UCSRnB, UDRIEn);
    } else {
        // There is more data in the output buffer. Send the next byte
        temp = txBuf.buffer[tail];
        tail++;
        tail &= BUFFER_PTR_MASK;
        txBuf.tail = tail;
        UDRn = temp;
    }

    asm volatile (
        "pop r31    \n\t"
        "pop r30    \n\t"
        "pop %1     \n\t"
        "pop %0     \n\t"
        "out %2, %0 \n\t"
        "pop %0     \n\t"
        "reti       \n\t"
        : "=r" (temp), "=r" (tail) 
        : "I" (_SFR_IO_ADDR(SREG)) 
        :
    );
}
ELF          S                 4     ( : 7 %RU  $ >   :;I  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  I  ! I/  5 I  .?:;   4 :;I  .?:;@@
   :;I  4 :;I  1XY  4 1  & I  4 1
  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\SerialLink.h"
#ifndef __SERIAL_LINK_H__
#define __SERIAL_LINK_H__

#include "AstroEQ.h"

//Serial Defines
//Select the required serial port with the #define below.
//For ATMega162, valid options are 0. USART1 on the ATMega162 variants must not be used for AstroEQ.
//For Arduino Mega, valid options are 0,1,(2,3) the latter two are untested but should work.
#define SERIALn 0

//Serial Functions
void Serial_initialise(const unsigned long baud);
void Serial_disable();

//SPI Functions
void SPI_initialise();
void SPI_disable();

//Common Functions
byte Serial_available(void);
void Serial_clear(void);
char Serial_read(void);
void Serial_flush(void);
void Serial_write(char ch);
void Serial_writeStr(char* str);
void Serial_writeArr(char* arr, byte len);

#endif //__SERIAL_LINK_H__

/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\synta.cpp"

#include "synta.h"
#include <string.h>


bool validateCommand(byte len);
bool validPacket;
char commandString[11];
byte commandIndex;

byte _axis;
char _command;

void synta_initialise(unsigned long eVal, byte gVal){
    validPacket = 0;
    commandIndex = 0;
    memset(commandString,0,sizeof(commandString));
    _axis = 0;
    Commands_init(eVal, gVal);
}

const char startInChar = ':';
const char startOutChar = '=';
const char errorChar = '!';
const char endChar = '\r';

inline void nibbleToHex(char* hex, byte nibble) {
    if (nibble > 9){
        nibble += (('A'-'0')-0xA);
    }
    *hex = (nibble + '0');
}

inline void private_byteToHex(char* lower, char* upper, Nibbler nibbler){
    nibbleToHex(lower, nibbler.low);
    nibbleToHex(upper, nibbler.high);
}

void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData){
    char replyLength = (commandOrError == '\0') ? -1 : Commands_getLength(commandOrError,0); //get the number of data bytes for response

    if (replyLength < 0) {
        replyLength = 0;
        dataPacket[0] = errorChar;  
    } else {
        dataPacket[0] = startOutChar;

        if (replyLength == 2) {
            Nibbler nibble = { responseData };
            private_byteToHex(dataPacket+2,dataPacket+1,nibble);
        } else if (replyLength == 3) {
            DoubleNibbler nibble = { responseData };
            nibbleToHex(dataPacket+3, nibble.low);
            nibbleToHex(dataPacket+2, nibble.mid);
            nibbleToHex(dataPacket+1, nibble.high);
        } else if (replyLength == 6) {
            Inter inter = Inter(responseData);
            private_byteToHex(dataPacket+6,dataPacket+5,inter.highByter.lowNibbler);
            private_byteToHex(dataPacket+4,dataPacket+3,inter.lowByter.highNibbler);
            private_byteToHex(dataPacket+2,dataPacket+1,inter.lowByter.lowNibbler);
        }

    }

    dataPacket[(byte)replyLength + 1] = endChar;
    dataPacket[(byte)replyLength + 2] = '\0';  
    return;
}

bool synta_validateCommand(byte len, char* decoded){
    _command = commandString[0]; //first byte is command
    _axis = commandString[1] - 49; //second byte is axis
    if(_axis > 1){
        return false; //incorrect axis
    }
    char requiredLength = Commands_getLength(_command,1); //get the required length of this command
    len -= 3; //Remove the command and axis bytes, aswell as the end char;
    if(requiredLength != len){ //If invalid command, or not required length
        return false;
    }
    byte i;
    for(i = 0;i < len;i++){
        decoded[i] = commandString[i + 2];
    }
    decoded[i] = '\0'; //Null
    return true;
}

char synta_recieveCommand(char* dataPacket, char character){
    if(validPacket){
        if (character == startInChar){
            dataPacket[0] = errorChar;
            dataPacket[1] = endChar;
            dataPacket[2] = '\0';
            validPacket = 0; //new command without old finishing! (dataPacket contains error message)
            return -2;
        }

        commandString[commandIndex++] = character; //Add character to current string build

        if(character == endChar){
            if(synta_validateCommand(commandIndex, dataPacket)){
                validPacket = 0;
                return _command; //Successful decode (dataPacket contains decoded packet, return value is the current command)
            } else {
                goto error; //Decode Failed (dataPacket contains error message)
            }
        } else if (commandIndex == sizeof(commandString)){
            goto error; //Message too long! (dataPacket contains error message)
        }
    } else if (character == startInChar){
        //Begin new command
        commandIndex = 0;
        validPacket = 1;
        commandString[0] = '\0';
    }
    return 0; //Decode not finished (dataPacket unchanged)
error:
    dataPacket[0] = errorChar;
    dataPacket[1] = endChar;
    dataPacket[2] = '\0';
    validPacket = 0;
    return -1;
}

inline byte hexToNibbler(char hex) {
    if (hex > '9'){
        hex -= (('A'-'0')-0xA); //even if hex is lower case (e.g. 'a'), the lower nibble will have the correct value as (('a'-'A')&0x0F) = 0.
    }
    return (hex - '0'); //as we are keeping the lower nibble, the -'0' gets optimised away.
}
inline byte hexToByte(char* hex){
    //nibble.low = hexToNibbler(hex[1]);
    //nibble.high = hexToNibbler(hex[0]);
    Nibbler low = {hexToNibbler(hex[1])};
    Nibbler high = {hexToNibbler(hex[0])<<4};
    return ((high.high<<4)|low.low);
}

byte synta_hexToByte(char* hex){
    return hexToByte(hex);
}
unsigned long synta_hexToLong(char* hex){
    //  char *boo; //waste point for strtol
    //  char str[7]; //Destination of rearranged hex
    //  strncpy(str,&hex[4],2); //Lower Byte
    //  strncpy(str+2,&hex[2],2); //Middle Byte
    //  strncpy(str+4,hex,2); //Upper Byte
    //  str[6] = 0;
    //  return strtol(str,&boo,16); //convert hex to long integer

    Inter inter = Inter(0,hexToByte(hex+4),hexToByte(hex+2),hexToByte(hex)); //create an inter 
    return inter.integer; //and convert it to an integer
}

char synta_command(){
    return _command;
}

byte synta_axis(byte axis){
    if(axis < 2){
        _axis = axis;
    }
    return _axis;
}

ELF          S            "     4     ( . + %RU  $ >   :;I  $ >  $ >  :;  :;   :;I8
  	 :;I8
  
 :;I   I   :;I8
   :;I8
  .?:;<   I4   I  .?:;<   I  :;  I  ! I/  5 I  .?:;    :;I   :;I  /***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\synta.h"

#ifndef synta_h
#define synta_h

#include "AstroEQ.h"
#include "commands.h"

void synta_initialise(unsigned long version, byte gVal);
void synta_assembleResponse(char* dataPacket, char commandOrError, unsigned long responseData);
char synta_recieveCommand(char* dataPacket, char character);
byte synta_axis(byte axis = 2); //make target readonly to outside world.
char synta_command(); //make current command readonly to outside world.
unsigned long synta_hexToLong(char* hex);
byte synta_hexToByte(char* hex);

//Methods for accessing command variables - now in commands.h
//void cmd_setDir(byte target, byte _dir);
//void cmd_updateStepDir(byte target, byte stepSize);
//unsigned int cmd_fVal(byte target);
//void cmd_setStopped(byte target, byte _stopped);
//void cmd_setGotoEn(byte target, byte _gotoEn);
//void cmd_setFVal(byte target, byte _FVal);
//void cmd_setjVal(byte target, unsigned long _jVal);
//void cmd_setIVal(byte target, unsigned int _IVal);
//void cmd_setHVal(byte target, unsigned long _HVal);
//void cmd_setGVal(byte target, byte _GVal);
  
#endif
/***************************************************
 * ! ! ! !        I M P O R T A N T        ! ! ! ! *
 *                                                 *
 * THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD *
 * NOT BE DIRECTLY EDITED. INSTEAD EDIT THE SOURCE *
 * FILE THIS FILE IS GENERATED FROM!!!             *
 ***************************************************/
#line 1 "E:\\Thomas\\Documents\\Arduino\\AstroEQ6\\UnionHelpers.h"

#ifndef __UNION_HELPERS_H__
#define __UNION_HELPERS_H__

#include <inttypes.h>
typedef uint8_t byte;

typedef union {
    uint16_t integer;
    uint8_t array[2];
} TwoBytes;

typedef union {
    uint32_t integer;
    uint16_t array[2];
    uint8_t bytes[4];
} FourBytes;

typedef union{
    byte integer;
    struct {
        byte low:4;
        byte high:4;
    };
} Nibbler;

typedef union{
    unsigned int integer;
    struct {
        byte low;
        byte high;
    };
    struct {
        Nibbler lowNibbler;
        Nibbler highNibbler;
    };
} Byter;

typedef union InterMaker{
    unsigned long integer;
    struct {
        byte low;
        byte mid;
        byte high;
        byte top;
    };
    struct {
        Byter lowByter;
        Byter highByter;
    };
    InterMaker(unsigned long _integer){
        integer = _integer;
    }
    InterMaker(byte _top, byte _high, byte _mid, byte _low){
        low = _low;
        mid = _mid;
        high = _high;
        top = _top;
    }
} Inter;

typedef union{
    unsigned int integer;
    struct {
        unsigned int low:4;
        unsigned int mid:4;
        unsigned int high:4;
        unsigned int:4;
    };
    struct {
        Nibbler lowNibbler;
        Nibbler highNibbler;
    };
} DoubleNibbler;

#endif //__UNION_HELPERS_H__
ELF          S                 4     ( , ) %RU  $ >   :;I  $ >  $ >   I   '  .?:;'@
  	 :;I  
 :;I
  . ?:;'@
  4 :;I  & I  4 :;I  I  ! I/  4 :;I
  5 I                                          z7       int                             A          &            	    &,       	    &       
    &>   de                 
    ,   h                                            ELF          S                 4     ( !  %RU  $ >  $ >  .?:;@I@
   :;I   :;I  .?:;@I@
  4 :;I  	.?:;@@
                                      int     map 6    3               x 63           63           63           63           63            ;    %               w ;%            <    %            
  h <
      l <
               %    3            @      %3            -    3                  -3           -3           23    	                     %         <   `   
    E:\Thomas\Downloads\Programs\EXE\uecide\hardware\cores\arduino\api  WMath.cpp               I                     N                O                8                          @                          1                               /?O_o;L*m~j{			b